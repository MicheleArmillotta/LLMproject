[
  {
    "function_name": "nfs4flexfilelayout_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1520-1525",
    "snippet": "static void __exit nfs4flexfilelayout_exit(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Unregistering...\\n\",\n\t       __func__);\n\tpnfs_unregister_layoutdriver(&flexfilelayout_type);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type flexfilelayout_type = {\n\t.id\t\t\t= LAYOUT_FLEX_FILES,\n\t.name\t\t\t= \"LAYOUT_FLEX_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= ff_layout_alloc_layout_hdr,\n\t.free_layout_hdr\t= ff_layout_free_layout_hdr,\n\t.alloc_lseg\t\t= ff_layout_alloc_lseg,\n\t.free_lseg\t\t= ff_layout_free_lseg,\n\t.pg_read_ops\t\t= &ff_layout_pg_read_ops,\n\t.pg_write_ops\t\t= &ff_layout_pg_write_ops,\n\t.get_ds_info\t\t= ff_layout_get_ds_info,\n\t.free_deviceid_node\t= ff_layout_free_deveiceid_node,\n\t.mark_request_commit\t= pnfs_layout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.commit_pagelist\t= ff_layout_commit_pagelist,\n\t.read_pagelist\t\t= ff_layout_read_pagelist,\n\t.write_pagelist\t\t= ff_layout_write_pagelist,\n\t.alloc_deviceid_node    = ff_layout_alloc_deviceid_node,\n\t.encode_layoutreturn    = ff_layout_encode_layoutreturn,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_unregister_layoutdriver",
          "args": [
            "&flexfilelayout_type"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_unregister_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "184-191",
          "snippet": "void\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nvoid\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Unregistering...\\n\"",
            "__func__"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layoutdriver_type flexfilelayout_type = {\n\t.id\t\t\t= LAYOUT_FLEX_FILES,\n\t.name\t\t\t= \"LAYOUT_FLEX_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= ff_layout_alloc_layout_hdr,\n\t.free_layout_hdr\t= ff_layout_free_layout_hdr,\n\t.alloc_lseg\t\t= ff_layout_alloc_lseg,\n\t.free_lseg\t\t= ff_layout_free_lseg,\n\t.pg_read_ops\t\t= &ff_layout_pg_read_ops,\n\t.pg_write_ops\t\t= &ff_layout_pg_write_ops,\n\t.get_ds_info\t\t= ff_layout_get_ds_info,\n\t.free_deviceid_node\t= ff_layout_free_deveiceid_node,\n\t.mark_request_commit\t= pnfs_layout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.commit_pagelist\t= ff_layout_commit_pagelist,\n\t.read_pagelist\t\t= ff_layout_read_pagelist,\n\t.write_pagelist\t\t= ff_layout_write_pagelist,\n\t.alloc_deviceid_node    = ff_layout_alloc_deviceid_node,\n\t.encode_layoutreturn    = ff_layout_encode_layoutreturn,\n};\n\nstatic void __exit nfs4flexfilelayout_exit(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Unregistering...\\n\",\n\t       __func__);\n\tpnfs_unregister_layoutdriver(&flexfilelayout_type);\n}"
  },
  {
    "function_name": "nfs4flexfilelayout_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1513-1518",
    "snippet": "static int __init nfs4flexfilelayout_init(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Registering...\\n\",\n\t       __func__);\n\treturn pnfs_register_layoutdriver(&flexfilelayout_type);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type flexfilelayout_type = {\n\t.id\t\t\t= LAYOUT_FLEX_FILES,\n\t.name\t\t\t= \"LAYOUT_FLEX_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= ff_layout_alloc_layout_hdr,\n\t.free_layout_hdr\t= ff_layout_free_layout_hdr,\n\t.alloc_lseg\t\t= ff_layout_alloc_lseg,\n\t.free_lseg\t\t= ff_layout_free_lseg,\n\t.pg_read_ops\t\t= &ff_layout_pg_read_ops,\n\t.pg_write_ops\t\t= &ff_layout_pg_write_ops,\n\t.get_ds_info\t\t= ff_layout_get_ds_info,\n\t.free_deviceid_node\t= ff_layout_free_deveiceid_node,\n\t.mark_request_commit\t= pnfs_layout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.commit_pagelist\t= ff_layout_commit_pagelist,\n\t.read_pagelist\t\t= ff_layout_read_pagelist,\n\t.write_pagelist\t\t= ff_layout_write_pagelist,\n\t.alloc_deviceid_node    = ff_layout_alloc_deviceid_node,\n\t.encode_layoutreturn    = ff_layout_encode_layoutreturn,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_register_layoutdriver",
          "args": [
            "&flexfilelayout_type"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_register_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "151-181",
          "snippet": "int\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);",
            "static LIST_HEAD(pnfs_modules_tbl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nint\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Registering...\\n\"",
            "__func__"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layoutdriver_type flexfilelayout_type = {\n\t.id\t\t\t= LAYOUT_FLEX_FILES,\n\t.name\t\t\t= \"LAYOUT_FLEX_FILES\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.alloc_layout_hdr\t= ff_layout_alloc_layout_hdr,\n\t.free_layout_hdr\t= ff_layout_free_layout_hdr,\n\t.alloc_lseg\t\t= ff_layout_alloc_lseg,\n\t.free_lseg\t\t= ff_layout_free_lseg,\n\t.pg_read_ops\t\t= &ff_layout_pg_read_ops,\n\t.pg_write_ops\t\t= &ff_layout_pg_write_ops,\n\t.get_ds_info\t\t= ff_layout_get_ds_info,\n\t.free_deviceid_node\t= ff_layout_free_deveiceid_node,\n\t.mark_request_commit\t= pnfs_layout_mark_request_commit,\n\t.clear_request_commit\t= pnfs_generic_clear_request_commit,\n\t.scan_commit_lists\t= pnfs_generic_scan_commit_lists,\n\t.recover_commit_reqs\t= pnfs_generic_recover_commit_reqs,\n\t.commit_pagelist\t= ff_layout_commit_pagelist,\n\t.read_pagelist\t\t= ff_layout_read_pagelist,\n\t.write_pagelist\t\t= ff_layout_write_pagelist,\n\t.alloc_deviceid_node    = ff_layout_alloc_deviceid_node,\n\t.encode_layoutreturn    = ff_layout_encode_layoutreturn,\n};\n\nstatic int __init nfs4flexfilelayout_init(void)\n{\n\tprintk(KERN_INFO \"%s: NFSv4 Flexfile Layout Driver Registering...\\n\",\n\t       __func__);\n\treturn pnfs_register_layoutdriver(&flexfilelayout_type);\n}"
  },
  {
    "function_name": "ff_layout_encode_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1469-1488",
    "snippet": "static void\nff_layout_encode_layoutreturn(struct pnfs_layout_hdr *lo,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const struct nfs4_layoutreturn_args *args)\n{\n\tstruct nfs4_flexfile_layout *flo = FF_LAYOUT_FROM_HDR(lo);\n\t__be32 *start;\n\n\tdprintk(\"%s: Begin\\n\", __func__);\n\tstart = xdr_reserve_space(xdr, 4);\n\tBUG_ON(!start);\n\n\tif (ff_layout_encode_ioerr(flo, xdr, args))\n\t\tgoto out;\n\n\tff_layout_encode_iostats(flo, xdr, args);\nout:\n\t*start = cpu_to_be32((xdr->p - start - 1) * 4);\n\tdprintk(\"%s: Return\\n\", __func__);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Return\\n\"",
            "__func__"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(xdr->p - start - 1) * 4"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_encode_iostats",
          "args": [
            "flo",
            "xdr",
            "args"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_encode_iostats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "1446-1455",
          "snippet": "static void ff_layout_encode_iostats(struct nfs4_flexfile_layout *flo,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const struct nfs4_layoutreturn_args *args)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (likely(p))\n\t\t*p = cpu_to_be32(0);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_encode_iostats(struct nfs4_flexfile_layout *flo,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const struct nfs4_layoutreturn_args *args)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (likely(p))\n\t\t*p = cpu_to_be32(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_encode_ioerr",
          "args": [
            "flo",
            "xdr",
            "args"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_encode_ioerr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "1423-1443",
          "snippet": "static int ff_layout_encode_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layoutreturn_args *args)\n{\n\tstruct pnfs_layout_hdr *hdr = &flo->generic_hdr;\n\t__be32 *start;\n\tint count = 0, ret = 0;\n\n\tstart = xdr_reserve_space(xdr, 4);\n\tif (unlikely(!start))\n\t\treturn -E2BIG;\n\n\t/* This assume we always return _ALL_ layouts */\n\tspin_lock(&hdr->plh_inode->i_lock);\n\tret = ff_layout_encode_ds_ioerr(flo, xdr, &count, &args->range);\n\tspin_unlock(&hdr->plh_inode->i_lock);\n\n\t*start = cpu_to_be32(count);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_encode_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layoutreturn_args *args)\n{\n\tstruct pnfs_layout_hdr *hdr = &flo->generic_hdr;\n\t__be32 *start;\n\tint count = 0, ret = 0;\n\n\tstart = xdr_reserve_space(xdr, 4);\n\tif (unlikely(!start))\n\t\treturn -E2BIG;\n\n\t/* This assume we always return _ALL_ layouts */\n\tspin_lock(&hdr->plh_inode->i_lock);\n\tret = ff_layout_encode_ds_ioerr(flo, xdr, &count, &args->range);\n\tspin_unlock(&hdr->plh_inode->i_lock);\n\n\t*start = cpu_to_be32(count);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!start"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Begin\\n\"",
            "__func__"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_FROM_HDR",
          "args": [
            "lo"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_encode_layoutreturn(struct pnfs_layout_hdr *lo,\n\t\t\t      struct xdr_stream *xdr,\n\t\t\t      const struct nfs4_layoutreturn_args *args)\n{\n\tstruct nfs4_flexfile_layout *flo = FF_LAYOUT_FROM_HDR(lo);\n\t__be32 *start;\n\n\tdprintk(\"%s: Begin\\n\", __func__);\n\tstart = xdr_reserve_space(xdr, 4);\n\tBUG_ON(!start);\n\n\tif (ff_layout_encode_ioerr(flo, xdr, args))\n\t\tgoto out;\n\n\tff_layout_encode_iostats(flo, xdr, args);\nout:\n\t*start = cpu_to_be32((xdr->p - start - 1) * 4);\n\tdprintk(\"%s: Return\\n\", __func__);\n}"
  },
  {
    "function_name": "ff_layout_alloc_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1457-1467",
    "snippet": "static struct nfs4_deviceid_node *\nff_layout_alloc_deviceid_node(struct nfs_server *server,\n\t\t\t      struct pnfs_device *pdev, gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds *dsaddr;\n\n\tdsaddr = nfs4_ff_alloc_deviceid_node(server, pdev, gfp_flags);\n\tif (!dsaddr)\n\t\treturn NULL;\n\treturn &dsaddr->id_node;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_ff_alloc_deviceid_node",
          "args": [
            "server",
            "pdev",
            "gfp_flags"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_alloc_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "37-173",
          "snippet": "struct nfs4_ff_layout_ds *\nnfs4_ff_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\tstruct nfs4_ff_layout_ds *new_ds = NULL;\n\tstruct nfs4_ff_ds_version *ds_versions = NULL;\n\tu32 mp_count;\n\tu32 version_count;\n\t__be32 *p;\n\tint i, ret = -ENOMEM;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\tnew_ds = kzalloc(sizeof(struct nfs4_ff_layout_ds), gfp_flags);\n\tif (!new_ds)\n\t\tgoto out_scratch;\n\n\tnfs4_init_deviceid_node(&new_ds->id_node,\n\t\t\t\tserver,\n\t\t\t\t&pdev->dev_id);\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* multipath count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tmp_count = be32_to_cpup(p);\n\tdprintk(\"%s: multipath ds count %d\\n\", __func__, mp_count);\n\n\tfor (i = 0; i < mp_count; i++) {\n\t\t/* multipath ds */\n\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t    &stream, gfp_flags);\n\t\tif (da)\n\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t}\n\tif (list_empty(&dsaddrs)) {\n\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t__func__);\n\t\tret = -ENOMEDIUM;\n\t\tgoto out_err_drain_dsaddrs;\n\t}\n\n\t/* version count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tversion_count = be32_to_cpup(p);\n\tdprintk(\"%s: version count %d\\n\", __func__, version_count);\n\n\tds_versions = kzalloc(version_count * sizeof(struct nfs4_ff_ds_version),\n\t\t\t      gfp_flags);\n\tif (!ds_versions)\n\t\tgoto out_scratch;\n\n\tfor (i = 0; i < version_count; i++) {\n\t\t/* 20 = version(4) + minor_version(4) + rsize(4) + wsize(4) +\n\t\t * tightly_coupled(4) */\n\t\tp = xdr_inline_decode(&stream, 20);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\tds_versions[i].version = be32_to_cpup(p++);\n\t\tds_versions[i].minor_version = be32_to_cpup(p++);\n\t\tds_versions[i].rsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].wsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].tightly_coupled = be32_to_cpup(p);\n\n\t\tif (ds_versions[i].rsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].rsize = NFS_MAX_FILE_IO_SIZE;\n\t\tif (ds_versions[i].wsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].wsize = NFS_MAX_FILE_IO_SIZE;\n\n\t\tif (ds_versions[i].version != 3 || ds_versions[i].minor_version != 0) {\n\t\t\tdprintk(\"%s: [%d] unsupported ds version %d-%d\\n\", __func__,\n\t\t\t\ti, ds_versions[i].version,\n\t\t\t\tds_versions[i].minor_version);\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\t}\n\n\t\tdprintk(\"%s: [%d] vers %u minor_ver %u rsize %u wsize %u coupled %d\\n\",\n\t\t\t__func__, i, ds_versions[i].version,\n\t\t\tds_versions[i].minor_version,\n\t\t\tds_versions[i].rsize,\n\t\t\tds_versions[i].wsize,\n\t\t\tds_versions[i].tightly_coupled);\n\t}\n\n\tnew_ds->ds_versions = ds_versions;\n\tnew_ds->ds_versions_cnt = version_count;\n\n\tnew_ds->ds = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\tif (!new_ds->ds)\n\t\tgoto out_err_drain_dsaddrs;\n\n\t/* If DS was already in cache, free ds addrs */\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\t__free_page(scratch);\n\treturn new_ds;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds_versions);\nout_scratch:\n\t__free_page(scratch);\nout_err:\n\tkfree(new_ds);\n\n\tdprintk(\"%s ERROR: returning %d\\n\", __func__, ret);\n\treturn NULL;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs4_ff_layout_ds *\nnfs4_ff_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct list_head dsaddrs;\n\tstruct nfs4_pnfs_ds_addr *da;\n\tstruct nfs4_ff_layout_ds *new_ds = NULL;\n\tstruct nfs4_ff_ds_version *ds_versions = NULL;\n\tu32 mp_count;\n\tu32 version_count;\n\t__be32 *p;\n\tint i, ret = -ENOMEM;\n\n\t/* set up xdr stream */\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\tgoto out_err;\n\n\tnew_ds = kzalloc(sizeof(struct nfs4_ff_layout_ds), gfp_flags);\n\tif (!new_ds)\n\t\tgoto out_scratch;\n\n\tnfs4_init_deviceid_node(&new_ds->id_node,\n\t\t\t\tserver,\n\t\t\t\t&pdev->dev_id);\n\tINIT_LIST_HEAD(&dsaddrs);\n\n\txdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* multipath count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tmp_count = be32_to_cpup(p);\n\tdprintk(\"%s: multipath ds count %d\\n\", __func__, mp_count);\n\n\tfor (i = 0; i < mp_count; i++) {\n\t\t/* multipath ds */\n\t\tda = nfs4_decode_mp_ds_addr(server->nfs_client->cl_net,\n\t\t\t\t\t    &stream, gfp_flags);\n\t\tif (da)\n\t\t\tlist_add_tail(&da->da_node, &dsaddrs);\n\t}\n\tif (list_empty(&dsaddrs)) {\n\t\tdprintk(\"%s: no suitable DS addresses found\\n\",\n\t\t\t__func__);\n\t\tret = -ENOMEDIUM;\n\t\tgoto out_err_drain_dsaddrs;\n\t}\n\n\t/* version count */\n\tp = xdr_inline_decode(&stream, 4);\n\tif (unlikely(!p))\n\t\tgoto out_err_drain_dsaddrs;\n\tversion_count = be32_to_cpup(p);\n\tdprintk(\"%s: version count %d\\n\", __func__, version_count);\n\n\tds_versions = kzalloc(version_count * sizeof(struct nfs4_ff_ds_version),\n\t\t\t      gfp_flags);\n\tif (!ds_versions)\n\t\tgoto out_scratch;\n\n\tfor (i = 0; i < version_count; i++) {\n\t\t/* 20 = version(4) + minor_version(4) + rsize(4) + wsize(4) +\n\t\t * tightly_coupled(4) */\n\t\tp = xdr_inline_decode(&stream, 20);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\tds_versions[i].version = be32_to_cpup(p++);\n\t\tds_versions[i].minor_version = be32_to_cpup(p++);\n\t\tds_versions[i].rsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].wsize = nfs_block_size(be32_to_cpup(p++), NULL);\n\t\tds_versions[i].tightly_coupled = be32_to_cpup(p);\n\n\t\tif (ds_versions[i].rsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].rsize = NFS_MAX_FILE_IO_SIZE;\n\t\tif (ds_versions[i].wsize > NFS_MAX_FILE_IO_SIZE)\n\t\t\tds_versions[i].wsize = NFS_MAX_FILE_IO_SIZE;\n\n\t\tif (ds_versions[i].version != 3 || ds_versions[i].minor_version != 0) {\n\t\t\tdprintk(\"%s: [%d] unsupported ds version %d-%d\\n\", __func__,\n\t\t\t\ti, ds_versions[i].version,\n\t\t\t\tds_versions[i].minor_version);\n\t\t\tret = -EPROTONOSUPPORT;\n\t\t\tgoto out_err_drain_dsaddrs;\n\t\t}\n\n\t\tdprintk(\"%s: [%d] vers %u minor_ver %u rsize %u wsize %u coupled %d\\n\",\n\t\t\t__func__, i, ds_versions[i].version,\n\t\t\tds_versions[i].minor_version,\n\t\t\tds_versions[i].rsize,\n\t\t\tds_versions[i].wsize,\n\t\t\tds_versions[i].tightly_coupled);\n\t}\n\n\tnew_ds->ds_versions = ds_versions;\n\tnew_ds->ds_versions_cnt = version_count;\n\n\tnew_ds->ds = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\n\tif (!new_ds->ds)\n\t\tgoto out_err_drain_dsaddrs;\n\n\t/* If DS was already in cache, free ds addrs */\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs,\n\t\t\t\t      struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\t__free_page(scratch);\n\treturn new_ds;\n\nout_err_drain_dsaddrs:\n\twhile (!list_empty(&dsaddrs)) {\n\t\tda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\n\t\t\t\t      da_node);\n\t\tlist_del_init(&da->da_node);\n\t\tkfree(da->da_remotestr);\n\t\tkfree(da);\n\t}\n\n\tkfree(ds_versions);\nout_scratch:\n\t__free_page(scratch);\nout_err:\n\tkfree(new_ds);\n\n\tdprintk(\"%s ERROR: returning %d\\n\", __func__, ret);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs4_deviceid_node *\nff_layout_alloc_deviceid_node(struct nfs_server *server,\n\t\t\t      struct pnfs_device *pdev, gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds *dsaddr;\n\n\tdsaddr = nfs4_ff_alloc_deviceid_node(server, pdev, gfp_flags);\n\tif (!dsaddr)\n\t\treturn NULL;\n\treturn &dsaddr->id_node;\n}"
  },
  {
    "function_name": "ff_layout_encode_iostats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1446-1455",
    "snippet": "static void ff_layout_encode_iostats(struct nfs4_flexfile_layout *flo,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const struct nfs4_layoutreturn_args *args)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (likely(p))\n\t\t*p = cpu_to_be32(0);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "p"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_encode_iostats(struct nfs4_flexfile_layout *flo,\n\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t     const struct nfs4_layoutreturn_args *args)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (likely(p))\n\t\t*p = cpu_to_be32(0);\n}"
  },
  {
    "function_name": "ff_layout_encode_ioerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1423-1443",
    "snippet": "static int ff_layout_encode_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layoutreturn_args *args)\n{\n\tstruct pnfs_layout_hdr *hdr = &flo->generic_hdr;\n\t__be32 *start;\n\tint count = 0, ret = 0;\n\n\tstart = xdr_reserve_space(xdr, 4);\n\tif (unlikely(!start))\n\t\treturn -E2BIG;\n\n\t/* This assume we always return _ALL_ layouts */\n\tspin_lock(&hdr->plh_inode->i_lock);\n\tret = ff_layout_encode_ds_ioerr(flo, xdr, &count, &args->range);\n\tspin_unlock(&hdr->plh_inode->i_lock);\n\n\t*start = cpu_to_be32(count);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "count"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hdr->plh_inode->i_lock"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_encode_ds_ioerr",
          "args": [
            "flo",
            "xdr",
            "&count",
            "&args->range"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_encode_ds_ioerr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "490-525",
          "snippet": "int ff_layout_encode_ds_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct xdr_stream *xdr, int *count,\n\t\t\t      const struct pnfs_layout_range *range)\n{\n\tstruct nfs4_ff_layout_ds_err *err, *n;\n\t__be32 *p;\n\n\tlist_for_each_entry_safe(err, n, &flo->error_list, list) {\n\t\tif (!is_range_intersecting(err->offset, err->length,\n\t\t\t\t\t   range->offset, range->length))\n\t\t\tcontinue;\n\t\t/* offset(8) + length(8) + stateid(NFS4_STATEID_SIZE)\n\t\t * + deviceid(NFS4_DEVICEID4_SIZE) + status(4) + opnum(4)\n\t\t */\n\t\tp = xdr_reserve_space(xdr,\n\t\t\t\t24 + NFS4_STATEID_SIZE + NFS4_DEVICEID4_SIZE);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOBUFS;\n\t\tp = xdr_encode_hyper(p, err->offset);\n\t\tp = xdr_encode_hyper(p, err->length);\n\t\tp = xdr_encode_opaque_fixed(p, &err->stateid,\n\t\t\t\t\t    NFS4_STATEID_SIZE);\n\t\tp = xdr_encode_opaque_fixed(p, &err->deviceid,\n\t\t\t\t\t    NFS4_DEVICEID4_SIZE);\n\t\t*p++ = cpu_to_be32(err->status);\n\t\t*p++ = cpu_to_be32(err->opnum);\n\t\t*count += 1;\n\t\tlist_del(&err->list);\n\t\tdprintk(\"%s: offset %llu length %llu status %d op %d count %d\\n\",\n\t\t\t__func__, err->offset, err->length, err->status,\n\t\t\terr->opnum, *count);\n\t\tkfree(err);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nint ff_layout_encode_ds_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t      struct xdr_stream *xdr, int *count,\n\t\t\t      const struct pnfs_layout_range *range)\n{\n\tstruct nfs4_ff_layout_ds_err *err, *n;\n\t__be32 *p;\n\n\tlist_for_each_entry_safe(err, n, &flo->error_list, list) {\n\t\tif (!is_range_intersecting(err->offset, err->length,\n\t\t\t\t\t   range->offset, range->length))\n\t\t\tcontinue;\n\t\t/* offset(8) + length(8) + stateid(NFS4_STATEID_SIZE)\n\t\t * + deviceid(NFS4_DEVICEID4_SIZE) + status(4) + opnum(4)\n\t\t */\n\t\tp = xdr_reserve_space(xdr,\n\t\t\t\t24 + NFS4_STATEID_SIZE + NFS4_DEVICEID4_SIZE);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOBUFS;\n\t\tp = xdr_encode_hyper(p, err->offset);\n\t\tp = xdr_encode_hyper(p, err->length);\n\t\tp = xdr_encode_opaque_fixed(p, &err->stateid,\n\t\t\t\t\t    NFS4_STATEID_SIZE);\n\t\tp = xdr_encode_opaque_fixed(p, &err->deviceid,\n\t\t\t\t\t    NFS4_DEVICEID4_SIZE);\n\t\t*p++ = cpu_to_be32(err->status);\n\t\t*p++ = cpu_to_be32(err->opnum);\n\t\t*count += 1;\n\t\tlist_del(&err->list);\n\t\tdprintk(\"%s: offset %llu length %llu status %d op %d count %d\\n\",\n\t\t\t__func__, err->offset, err->length, err->status,\n\t\t\terr->opnum, *count);\n\t\tkfree(err);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hdr->plh_inode->i_lock"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!start"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_encode_ioerr(struct nfs4_flexfile_layout *flo,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layoutreturn_args *args)\n{\n\tstruct pnfs_layout_hdr *hdr = &flo->generic_hdr;\n\t__be32 *start;\n\tint count = 0, ret = 0;\n\n\tstart = xdr_reserve_space(xdr, 4);\n\tif (unlikely(!start))\n\t\treturn -E2BIG;\n\n\t/* This assume we always return _ALL_ layouts */\n\tspin_lock(&hdr->plh_inode->i_lock);\n\tret = ff_layout_encode_ds_ioerr(flo, xdr, &count, &args->range);\n\tspin_unlock(&hdr->plh_inode->i_lock);\n\n\t*start = cpu_to_be32(count);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ff_layout_free_deveiceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1416-1421",
    "snippet": "static void\nff_layout_free_deveiceid_node(struct nfs4_deviceid_node *d)\n{\n\tnfs4_ff_layout_free_deviceid(container_of(d, struct nfs4_ff_layout_ds,\n\t\t\t\t\t\t  id_node));\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_free_deveiceid_node(struct nfs4_deviceid_node *d)\n{\n\tnfs4_ff_layout_free_deviceid(container_of(d, struct nfs4_ff_layout_ds,\n\t\t\t\t\t\t  id_node));\n}"
  },
  {
    "function_name": "ff_layout_get_ds_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1405-1414",
    "snippet": "static struct pnfs_ds_commit_info *\nff_layout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\n\tif (layout == NULL)\n\t\treturn NULL;\n\n\treturn &FF_LAYOUT_FROM_HDR(layout)->commit_info;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FF_LAYOUT_FROM_HDR",
          "args": [
            "layout"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_ds_commit_info *\nff_layout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\n\tif (layout == NULL)\n\t\treturn NULL;\n\n\treturn &FF_LAYOUT_FROM_HDR(layout)->commit_info;\n}"
  },
  {
    "function_name": "ff_layout_commit_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1397-1403",
    "snippet": "static int\nff_layout_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t   int how, struct nfs_commit_info *cinfo)\n{\n\treturn pnfs_generic_commit_pagelist(inode, mds_pages, how, cinfo,\n\t\t\t\t\t    ff_layout_initiate_commit);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_commit_pagelist",
          "args": [
            "inode",
            "mds_pages",
            "how",
            "cinfo",
            "ff_layout_initiate_commit"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_commit_pagelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "233-287",
          "snippet": "int\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t     int how, struct nfs_commit_info *cinfo,\n\t\t\t     int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t    int how))\n{\n\tstruct nfs_commit_data *data, *tmp;\n\tLIST_HEAD(list);\n\tunsigned int nreq = 0;\n\n\tif (!list_empty(mds_pages)) {\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (data != NULL) {\n\t\t\tdata->lseg = NULL;\n\t\t\tlist_add(&data->pages, &list);\n\t\t\tnreq++;\n\t\t} else {\n\t\t\tnfs_retry_commit(mds_pages, NULL, cinfo, 0);\n\t\t\tpnfs_generic_retry_commit(cinfo, 0);\n\t\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tnreq += pnfs_generic_alloc_ds_commits(cinfo, &list);\n\n\tif (nreq == 0) {\n\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\tgoto out;\n\t}\n\n\tatomic_add(nreq, &cinfo->mds->rpcs_out);\n\n\tlist_for_each_entry_safe(data, tmp, &list, pages) {\n\t\tlist_del_init(&data->pages);\n\t\tif (!data->lseg) {\n\t\t\tnfs_init_commit(data, mds_pages, NULL, cinfo);\n\t\t\tnfs_initiate_commit(NFS_CLIENT(inode), data,\n\t\t\t\t\t    NFS_PROTO(data->inode),\n\t\t\t\t\t    data->mds_ops, how, 0);\n\t\t} else {\n\t\t\tstruct pnfs_commit_bucket *buckets;\n\n\t\t\tbuckets = cinfo->ds->buckets;\n\t\t\tnfs_init_commit(data,\n\t\t\t\t\t&buckets[data->ds_commit_index].committing,\n\t\t\t\t\tdata->lseg,\n\t\t\t\t\tcinfo);\n\t\t\tinitiate_commit(data, how);\n\t\t}\n\t}\nout:\n\tcinfo->ds->ncommitting = 0;\n\treturn PNFS_ATTEMPTED;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint\npnfs_generic_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t     int how, struct nfs_commit_info *cinfo,\n\t\t\t     int (*initiate_commit)(struct nfs_commit_data *data,\n\t\t\t\t\t\t    int how))\n{\n\tstruct nfs_commit_data *data, *tmp;\n\tLIST_HEAD(list);\n\tunsigned int nreq = 0;\n\n\tif (!list_empty(mds_pages)) {\n\t\tdata = nfs_commitdata_alloc();\n\t\tif (data != NULL) {\n\t\t\tdata->lseg = NULL;\n\t\t\tlist_add(&data->pages, &list);\n\t\t\tnreq++;\n\t\t} else {\n\t\t\tnfs_retry_commit(mds_pages, NULL, cinfo, 0);\n\t\t\tpnfs_generic_retry_commit(cinfo, 0);\n\t\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tnreq += pnfs_generic_alloc_ds_commits(cinfo, &list);\n\n\tif (nreq == 0) {\n\t\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\t\tgoto out;\n\t}\n\n\tatomic_add(nreq, &cinfo->mds->rpcs_out);\n\n\tlist_for_each_entry_safe(data, tmp, &list, pages) {\n\t\tlist_del_init(&data->pages);\n\t\tif (!data->lseg) {\n\t\t\tnfs_init_commit(data, mds_pages, NULL, cinfo);\n\t\t\tnfs_initiate_commit(NFS_CLIENT(inode), data,\n\t\t\t\t\t    NFS_PROTO(data->inode),\n\t\t\t\t\t    data->mds_ops, how, 0);\n\t\t} else {\n\t\t\tstruct pnfs_commit_bucket *buckets;\n\n\t\t\tbuckets = cinfo->ds->buckets;\n\t\t\tnfs_init_commit(data,\n\t\t\t\t\t&buckets[data->ds_commit_index].committing,\n\t\t\t\t\tdata->lseg,\n\t\t\t\t\tcinfo);\n\t\t\tinitiate_commit(data, how);\n\t\t}\n\t}\nout:\n\tcinfo->ds->ncommitting = 0;\n\treturn PNFS_ATTEMPTED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nff_layout_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\n\t\t\t   int how, struct nfs_commit_info *cinfo)\n{\n\treturn pnfs_generic_commit_pagelist(inode, mds_pages, how, cinfo,\n\t\t\t\t\t    ff_layout_initiate_commit);\n}"
  },
  {
    "function_name": "ff_layout_initiate_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1351-1395",
    "snippet": "static int ff_layout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tu32 idx;\n\tint vers;\n\tstruct nfs_fh *fh;\n\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, true);\n\tif (!ds)\n\t\tgoto out_err;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, data->cred);\n\tif (IS_ERR(ds_cred))\n\t\tgoto out_err;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s ino %lu, how %d cl_count %d vers %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\tdata->commit_done_cb = ff_layout_commit_done_cb;\n\tdata->cred = ds_cred;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\treturn nfs_initiate_commit(ds_clnt, data, ds->ds_clp->rpc_ops,\n\t\t\t\t   vers == 3 ? &ff_layout_commit_call_ops_v3 :\n\t\t\t\t\t       &ff_layout_commit_call_ops_v4,\n\t\t\t\t   how, RPC_TASK_SOFTCONN);\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops ff_layout_commit_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v3,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};",
      "static const struct rpc_call_ops ff_layout_commit_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v4,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_generic_commit_release",
          "args": [
            "data"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_commit_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "51-59",
          "snippet": "void pnfs_generic_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tpnfs_put_lseg(data->lseg);\n\tnfs_put_client(data->ds_clp);\n\tnfs_commitdata_release(data);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tpnfs_put_lseg(data->lseg);\n\tnfs_put_client(data->ds_clp);\n\tnfs_commitdata_release(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_generic_prepare_to_resend_writes",
          "args": [
            "data"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_prepare_to_resend_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "31-39",
          "snippet": "void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_initiate_commit",
          "args": [
            "ds_clnt",
            "data",
            "ds->ds_clp->rpc_ops",
            "vers == 3 ? &ff_layout_commit_call_ops_v3 :\n\t\t\t\t\t       &ff_layout_commit_call_ops_v4",
            "how",
            "RPC_TASK_SOFTCONN"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1533-1570",
          "snippet": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_ds_fh_from_commit",
          "args": [
            "lseg",
            "data->ds_commit_index"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "select_ds_fh_from_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "1340-1349",
          "snippet": "static struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_ff_layout_segment *flseg = FF_LAYOUT_LSEG(lseg);\n\n\t/* FIXME: Assume that there is only one NFS version available\n\t * for the DS.\n\t */\n\treturn &flseg->mirror_array[i]->fh_versions[0];\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_ff_layout_segment *flseg = FF_LAYOUT_LSEG(lseg);\n\n\t/* FIXME: Assume that there is only one NFS version available\n\t * for the DS.\n\t */\n\treturn &flseg->mirror_array[i]->fh_versions[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ino %lu, how %d cl_count %d vers %d\\n\"",
            "__func__",
            "data->inode->i_ino",
            "how",
            "atomic_read(&ds->ds_clp->cl_count)",
            "vers"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_ds_version",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_ds_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "122-126",
          "snippet": "static inline int\nnfs4_ff_layout_ds_version(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\treturn FF_LAYOUT_COMP(lseg, ds_idx)->mirror_ds->ds_versions[0].version;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline int\nnfs4_ff_layout_ds_version(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\treturn FF_LAYOUT_COMP(lseg, ds_idx)->mirror_ds->ds_versions[0].version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_cred"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_get_ds_cred",
          "args": [
            "lseg",
            "idx",
            "data->cred"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_get_ds_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "440-456",
          "snippet": "struct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_clnt"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_find_or_create_ds_client",
          "args": [
            "lseg",
            "idx",
            "ds->ds_clp",
            "data->inode"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_find_or_create_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "462-477",
          "snippet": "struct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_prepare_ds",
          "args": [
            "lseg",
            "idx",
            "true"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "358-438",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_ds_index_from_commit",
          "args": [
            "lseg",
            "data->ds_commit_index"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "calc_ds_index_from_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "1335-1338",
          "snippet": "static u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\treturn i;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic const struct rpc_call_ops ff_layout_commit_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v3,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};\nstatic const struct rpc_call_ops ff_layout_commit_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_commit_prepare_v4,\n\t.rpc_call_done = pnfs_generic_write_commit_done,\n\t.rpc_count_stats = ff_layout_commit_count_stats,\n\t.rpc_release = pnfs_generic_commit_release,\n};\n\nstatic int ff_layout_initiate_commit(struct nfs_commit_data *data, int how)\n{\n\tstruct pnfs_layout_segment *lseg = data->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tu32 idx;\n\tint vers;\n\tstruct nfs_fh *fh;\n\n\tidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, true);\n\tif (!ds)\n\t\tgoto out_err;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   data->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_err;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, data->cred);\n\tif (IS_ERR(ds_cred))\n\t\tgoto out_err;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s ino %lu, how %d cl_count %d vers %d\\n\", __func__,\n\t\tdata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\tdata->commit_done_cb = ff_layout_commit_done_cb;\n\tdata->cred = ds_cred;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\tdata->ds_clp = ds->ds_clp;\n\tfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\n\tif (fh)\n\t\tdata->args.fh = fh;\n\treturn nfs_initiate_commit(ds_clnt, data, ds->ds_clp->rpc_ops,\n\t\t\t\t   vers == 3 ? &ff_layout_commit_call_ops_v3 :\n\t\t\t\t\t       &ff_layout_commit_call_ops_v4,\n\t\t\t\t   how, RPC_TASK_SOFTCONN);\nout_err:\n\tpnfs_generic_prepare_to_resend_writes(data);\n\tpnfs_generic_commit_release(data);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "select_ds_fh_from_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1340-1349",
    "snippet": "static struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_ff_layout_segment *flseg = FF_LAYOUT_LSEG(lseg);\n\n\t/* FIXME: Assume that there is only one NFS version available\n\t * for the DS.\n\t */\n\treturn &flseg->mirror_array[i]->fh_versions[0];\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FF_LAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "78-84",
          "snippet": "static inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs_fh *\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\tstruct nfs4_ff_layout_segment *flseg = FF_LAYOUT_LSEG(lseg);\n\n\t/* FIXME: Assume that there is only one NFS version available\n\t * for the DS.\n\t */\n\treturn &flseg->mirror_array[i]->fh_versions[0];\n}"
  },
  {
    "function_name": "calc_ds_index_from_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1335-1338",
    "snippet": "static u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\treturn i;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\treturn i;\n}"
  },
  {
    "function_name": "ff_layout_write_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1281-1333",
    "snippet": "static enum pnfs_try_status\nff_layout_write_pagelist(struct nfs_pgio_header *hdr, int sync)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tloff_t offset = hdr->args.offset;\n\tint vers;\n\tstruct nfs_fh *fh;\n\tint idx = hdr->pgio_mirror_idx;\n\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, true);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, hdr->cred);\n\tif (IS_ERR(ds_cred))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d vers %d\\n\",\n\t\t__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,\n\t\toffset, ds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\n\thdr->pgio_done_cb = ff_layout_write_done_cb;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_ff_layout_select_ds_fh(lseg, idx);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\n\t/*\n\t * Note that if we ever decide to split across DSes,\n\t * then we may need to handle dense-like offsets.\n\t */\n\thdr->args.offset = offset;\n\n\t/* Perform an asynchronous write */\n\tnfs_initiate_pgio(ds_clnt, hdr, ds_cred, ds->ds_clp->rpc_ops,\n\t\t\t  vers == 3 ? &ff_layout_write_call_ops_v3 :\n\t\t\t\t      &ff_layout_write_call_ops_v4,\n\t\t\t  sync, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops ff_layout_write_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_write_prepare_v3,\n\t.rpc_call_done = ff_layout_write_call_done,\n\t.rpc_count_stats = ff_layout_write_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};",
      "static const struct rpc_call_ops ff_layout_write_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_write_prepare_v4,\n\t.rpc_call_done = ff_layout_write_call_done,\n\t.rpc_count_stats = ff_layout_write_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_initiate_pgio",
          "args": [
            "ds_clnt",
            "hdr",
            "ds_cred",
            "ds->ds_clp->rpc_ops",
            "vers == 3 ? &ff_layout_write_call_ops_v3 :\n\t\t\t\t      &ff_layout_write_call_ops_v4",
            "sync",
            "RPC_TASK_SOFTCONN"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_pgio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "616-660",
          "snippet": "int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_select_ds_fh",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_select_ds_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "333-355",
          "snippet": "struct nfs_fh *\nnfs4_ff_layout_select_ds_fh(struct pnfs_layout_segment *lseg, u32 mirror_idx)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, mirror_idx);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for mirror offset index %d\\n\",\n\t\t\t__func__, mirror_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* FIXME: For now assume there is only 1 version available for the DS */\n\tfh = &mirror->fh_versions[0];\nout:\n\treturn fh;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs_fh *\nnfs4_ff_layout_select_ds_fh(struct pnfs_layout_segment *lseg, u32 mirror_idx)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, mirror_idx);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for mirror offset index %d\\n\",\n\t\t\t__func__, mirror_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* FIXME: For now assume there is only 1 version available for the DS */\n\tfh = &mirror->fh_versions[0];\nout:\n\treturn fh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d vers %d\\n\"",
            "__func__",
            "hdr->inode->i_ino",
            "sync",
            "(size_t) hdr->args.count",
            "offset",
            "ds->ds_remotestr",
            "atomic_read(&ds->ds_clp->cl_count)",
            "vers"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_ds_version",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_ds_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "122-126",
          "snippet": "static inline int\nnfs4_ff_layout_ds_version(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\treturn FF_LAYOUT_COMP(lseg, ds_idx)->mirror_ds->ds_versions[0].version;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline int\nnfs4_ff_layout_ds_version(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\treturn FF_LAYOUT_COMP(lseg, ds_idx)->mirror_ds->ds_versions[0].version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_cred"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_get_ds_cred",
          "args": [
            "lseg",
            "idx",
            "hdr->cred"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_get_ds_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "440-456",
          "snippet": "struct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_clnt"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_find_or_create_ds_client",
          "args": [
            "lseg",
            "idx",
            "ds->ds_clp",
            "hdr->inode"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_find_or_create_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "462-477",
          "snippet": "struct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_prepare_ds",
          "args": [
            "lseg",
            "idx",
            "true"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "358-438",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic const struct rpc_call_ops ff_layout_write_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_write_prepare_v3,\n\t.rpc_call_done = ff_layout_write_call_done,\n\t.rpc_count_stats = ff_layout_write_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\nstatic const struct rpc_call_ops ff_layout_write_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_write_prepare_v4,\n\t.rpc_call_done = ff_layout_write_call_done,\n\t.rpc_count_stats = ff_layout_write_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\n\nstatic enum pnfs_try_status\nff_layout_write_pagelist(struct nfs_pgio_header *hdr, int sync)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tloff_t offset = hdr->args.offset;\n\tint vers;\n\tstruct nfs_fh *fh;\n\tint idx = hdr->pgio_mirror_idx;\n\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, true);\n\tif (!ds)\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, hdr->cred);\n\tif (IS_ERR(ds_cred))\n\t\treturn PNFS_NOT_ATTEMPTED;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d vers %d\\n\",\n\t\t__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,\n\t\toffset, ds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count),\n\t\tvers);\n\n\thdr->pgio_done_cb = ff_layout_write_done_cb;\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\thdr->ds_commit_idx = idx;\n\tfh = nfs4_ff_layout_select_ds_fh(lseg, idx);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\n\t/*\n\t * Note that if we ever decide to split across DSes,\n\t * then we may need to handle dense-like offsets.\n\t */\n\thdr->args.offset = offset;\n\n\t/* Perform an asynchronous write */\n\tnfs_initiate_pgio(ds_clnt, hdr, ds_cred, ds->ds_clp->rpc_ops,\n\t\t\t  vers == 3 ? &ff_layout_write_call_ops_v3 :\n\t\t\t\t      &ff_layout_write_call_ops_v4,\n\t\t\t  sync, RPC_TASK_SOFTCONN);\n\treturn PNFS_ATTEMPTED;\n}"
  },
  {
    "function_name": "ff_layout_read_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1219-1278",
    "snippet": "static enum pnfs_try_status\nff_layout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tloff_t offset = hdr->args.offset;\n\tu32 idx = hdr->pgio_mirror_idx;\n\tint vers;\n\tstruct nfs_fh *fh;\n\n\tdprintk(\"--> %s ino %lu pgbase %u req %Zu@%llu\\n\",\n\t\t__func__, hdr->inode->i_ino,\n\t\thdr->args.pgbase, (size_t)hdr->args.count, offset);\n\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, false);\n\tif (!ds)\n\t\tgoto out_failed;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_failed;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, hdr->cred);\n\tif (IS_ERR(ds_cred))\n\t\tgoto out_failed;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s USE DS: %s cl_count %d vers %d\\n\", __func__,\n\t\tds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count), vers);\n\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\tfh = nfs4_ff_layout_select_ds_fh(lseg, idx);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\n\t/*\n\t * Note that if we ever decide to split across DSes,\n\t * then we may need to handle dense-like offsets.\n\t */\n\thdr->args.offset = offset;\n\thdr->mds_offset = offset;\n\n\t/* Perform an asynchronous read to ds */\n\tnfs_initiate_pgio(ds_clnt, hdr, ds_cred, ds->ds_clp->rpc_ops,\n\t\t\t  vers == 3 ? &ff_layout_read_call_ops_v3 :\n\t\t\t\t      &ff_layout_read_call_ops_v4,\n\t\t\t  0, RPC_TASK_SOFTCONN);\n\n\treturn PNFS_ATTEMPTED;\n\nout_failed:\n\tif (ff_layout_has_available_ds(lseg))\n\t\treturn PNFS_TRY_AGAIN;\n\treturn PNFS_NOT_ATTEMPTED;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops ff_layout_read_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_read_prepare_v3,\n\t.rpc_call_done = ff_layout_read_call_done,\n\t.rpc_count_stats = ff_layout_read_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};",
      "static const struct rpc_call_ops ff_layout_read_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_read_prepare_v4,\n\t.rpc_call_done = ff_layout_read_call_done,\n\t.rpc_count_stats = ff_layout_read_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff_layout_has_available_ds",
          "args": [
            "lseg"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_has_available_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "527-543",
          "snippet": "bool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nbool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_initiate_pgio",
          "args": [
            "ds_clnt",
            "hdr",
            "ds_cred",
            "ds->ds_clp->rpc_ops",
            "vers == 3 ? &ff_layout_read_call_ops_v3 :\n\t\t\t\t      &ff_layout_read_call_ops_v4",
            "0",
            "RPC_TASK_SOFTCONN"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_pgio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "616-660",
          "snippet": "int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &hdr->args,\n\t\t.rpc_resp = &hdr->res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.task = &hdr->task,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = hdr,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t};\n\tint ret = 0;\n\n\thdr->rw_ops->rw_initiate(hdr, &msg, rpc_ops, &task_setup_data, how);\n\n\tdprintk(\"NFS: %5u initiated pgio call \"\n\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\",\n\t\thdr->task.tk_pid,\n\t\thdr->inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\thdr->args.count,\n\t\t(unsigned long long)hdr->args.offset);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tif (how & FLUSH_SYNC) {\n\t\tret = rpc_wait_for_completion_task(task);\n\t\tif (ret == 0)\n\t\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_select_ds_fh",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_select_ds_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "333-355",
          "snippet": "struct nfs_fh *\nnfs4_ff_layout_select_ds_fh(struct pnfs_layout_segment *lseg, u32 mirror_idx)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, mirror_idx);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for mirror offset index %d\\n\",\n\t\t\t__func__, mirror_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* FIXME: For now assume there is only 1 version available for the DS */\n\tfh = &mirror->fh_versions[0];\nout:\n\treturn fh;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct nfs_fh *\nnfs4_ff_layout_select_ds_fh(struct pnfs_layout_segment *lseg, u32 mirror_idx)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, mirror_idx);\n\tstruct nfs_fh *fh = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for mirror offset index %d\\n\",\n\t\t\t__func__, mirror_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* FIXME: For now assume there is only 1 version available for the DS */\n\tfh = &mirror->fh_versions[0];\nout:\n\treturn fh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s USE DS: %s cl_count %d vers %d\\n\"",
            "__func__",
            "ds->ds_remotestr",
            "atomic_read(&ds->ds_clp->cl_count)",
            "vers"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ds->ds_clp->cl_count"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_ds_version",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_ds_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "122-126",
          "snippet": "static inline int\nnfs4_ff_layout_ds_version(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\treturn FF_LAYOUT_COMP(lseg, ds_idx)->mirror_ds->ds_versions[0].version;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline int\nnfs4_ff_layout_ds_version(struct pnfs_layout_segment *lseg, u32 ds_idx)\n{\n\treturn FF_LAYOUT_COMP(lseg, ds_idx)->mirror_ds->ds_versions[0].version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_cred"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_get_ds_cred",
          "args": [
            "lseg",
            "idx",
            "hdr->cred"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_get_ds_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "440-456",
          "snippet": "struct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_cred *\nff_layout_get_ds_cred(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t      struct rpc_cred *mdscred)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct rpc_cred *cred = ERR_PTR(-EINVAL);\n\n\tif (!nfs4_ff_layout_prepare_ds(lseg, ds_idx, true))\n\t\tgoto out;\n\n\tif (mirror && mirror->cred)\n\t\tcred = mirror->cred;\n\telse\n\t\tcred = mdscred;\nout:\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ds_clnt"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_find_or_create_ds_client",
          "args": [
            "lseg",
            "idx",
            "ds->ds_clp",
            "hdr->inode"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_find_or_create_ds_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "462-477",
          "snippet": "struct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstruct rpc_clnt *\nnfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t\t struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\n\tswitch (mirror->mirror_ds->ds_versions[0].version) {\n\tcase 3:\n\t\t/* For NFSv3 DS, flavor is set when creating DS connections */\n\t\treturn ds_clp->cl_rpcclient;\n\tcase 4:\n\t\treturn nfs4_find_or_create_ds_client(ds_clp, inode);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_prepare_ds",
          "args": [
            "lseg",
            "idx",
            "false"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "358-438",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s ino %lu pgbase %u req %Zu@%llu\\n\"",
            "__func__",
            "hdr->inode->i_ino",
            "hdr->args.pgbase",
            "(size_t)hdr->args.count",
            "offset"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic const struct rpc_call_ops ff_layout_read_call_ops_v3 = {\n\t.rpc_call_prepare = ff_layout_read_prepare_v3,\n\t.rpc_call_done = ff_layout_read_call_done,\n\t.rpc_count_stats = ff_layout_read_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\nstatic const struct rpc_call_ops ff_layout_read_call_ops_v4 = {\n\t.rpc_call_prepare = ff_layout_read_prepare_v4,\n\t.rpc_call_done = ff_layout_read_call_done,\n\t.rpc_count_stats = ff_layout_read_count_stats,\n\t.rpc_release = pnfs_generic_rw_release,\n};\n\nstatic enum pnfs_try_status\nff_layout_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct pnfs_layout_segment *lseg = hdr->lseg;\n\tstruct nfs4_pnfs_ds *ds;\n\tstruct rpc_clnt *ds_clnt;\n\tstruct rpc_cred *ds_cred;\n\tloff_t offset = hdr->args.offset;\n\tu32 idx = hdr->pgio_mirror_idx;\n\tint vers;\n\tstruct nfs_fh *fh;\n\n\tdprintk(\"--> %s ino %lu pgbase %u req %Zu@%llu\\n\",\n\t\t__func__, hdr->inode->i_ino,\n\t\thdr->args.pgbase, (size_t)hdr->args.count, offset);\n\n\tds = nfs4_ff_layout_prepare_ds(lseg, idx, false);\n\tif (!ds)\n\t\tgoto out_failed;\n\n\tds_clnt = nfs4_ff_find_or_create_ds_client(lseg, idx, ds->ds_clp,\n\t\t\t\t\t\t   hdr->inode);\n\tif (IS_ERR(ds_clnt))\n\t\tgoto out_failed;\n\n\tds_cred = ff_layout_get_ds_cred(lseg, idx, hdr->cred);\n\tif (IS_ERR(ds_cred))\n\t\tgoto out_failed;\n\n\tvers = nfs4_ff_layout_ds_version(lseg, idx);\n\n\tdprintk(\"%s USE DS: %s cl_count %d vers %d\\n\", __func__,\n\t\tds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count), vers);\n\n\tatomic_inc(&ds->ds_clp->cl_count);\n\thdr->ds_clp = ds->ds_clp;\n\tfh = nfs4_ff_layout_select_ds_fh(lseg, idx);\n\tif (fh)\n\t\thdr->args.fh = fh;\n\n\t/*\n\t * Note that if we ever decide to split across DSes,\n\t * then we may need to handle dense-like offsets.\n\t */\n\thdr->args.offset = offset;\n\thdr->mds_offset = offset;\n\n\t/* Perform an asynchronous read to ds */\n\tnfs_initiate_pgio(ds_clnt, hdr, ds_cred, ds->ds_clp->rpc_ops,\n\t\t\t  vers == 3 ? &ff_layout_read_call_ops_v3 :\n\t\t\t\t      &ff_layout_read_call_ops_v4,\n\t\t\t  0, RPC_TASK_SOFTCONN);\n\n\treturn PNFS_ATTEMPTED;\n\nout_failed:\n\tif (ff_layout_has_available_ds(lseg))\n\t\treturn PNFS_TRY_AGAIN;\n\treturn PNFS_NOT_ATTEMPTED;\n}"
  },
  {
    "function_name": "ff_layout_commit_count_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1169-1175",
    "snippet": "static void ff_layout_commit_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *cdata = data;\n\n\trpc_count_iostats_metrics(task,\n\t    &NFS_CLIENT(cdata->inode)->cl_metrics[NFSPROC4_CLNT_COMMIT]);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_count_iostats_metrics",
          "args": [
            "task",
            "&NFS_CLIENT(cdata->inode)->cl_metrics[NFSPROC4_CLNT_COMMIT]"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "cdata->inode"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_commit_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *cdata = data;\n\n\trpc_count_iostats_metrics(task,\n\t    &NFS_CLIENT(cdata->inode)->cl_metrics[NFSPROC4_CLNT_COMMIT]);\n}"
  },
  {
    "function_name": "ff_layout_commit_prepare_v4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1159-1167",
    "snippet": "static void ff_layout_commit_prepare_v4(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\tff_layout_setup_sequence(wdata->ds_clp,\n\t\t\t\t &wdata->args.seq_args,\n\t\t\t\t &wdata->res.seq_res,\n\t\t\t\t task);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff_layout_setup_sequence",
          "args": [
            "wdata->ds_clp",
            "&wdata->args.seq_args",
            "&wdata->res.seq_res",
            "task"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "944-958",
          "snippet": "static int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_commit_prepare_v4(struct rpc_task *task, void *data)\n{\n\tstruct nfs_commit_data *wdata = data;\n\n\tff_layout_setup_sequence(wdata->ds_clp,\n\t\t\t\t &wdata->args.seq_args,\n\t\t\t\t &wdata->res.seq_res,\n\t\t\t\t task);\n}"
  },
  {
    "function_name": "ff_layout_commit_prepare_v3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1154-1157",
    "snippet": "static void ff_layout_commit_prepare_v3(struct rpc_task *task, void *data)\n{\n\trpc_call_start(task);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_call_start",
          "args": [
            "task"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_commit_prepare_v3(struct rpc_task *task, void *data)\n{\n\trpc_call_start(task);\n}"
  },
  {
    "function_name": "ff_layout_write_count_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1146-1152",
    "snippet": "static void ff_layout_write_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats_metrics(task,\n\t    &NFS_CLIENT(hdr->inode)->cl_metrics[NFSPROC4_CLNT_WRITE]);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_count_iostats_metrics",
          "args": [
            "task",
            "&NFS_CLIENT(hdr->inode)->cl_metrics[NFSPROC4_CLNT_WRITE]"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "hdr->inode"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_write_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats_metrics(task,\n\t    &NFS_CLIENT(hdr->inode)->cl_metrics[NFSPROC4_CLNT_WRITE]);\n}"
  },
  {
    "function_name": "ff_layout_write_call_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1132-1144",
    "snippet": "static void ff_layout_write_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs4_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, hdr);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_call_done",
          "args": [
            "task",
            "hdr"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_sequence_done",
          "args": [
            "task",
            "&hdr->res.seq_res"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_sequence_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "826-830",
          "snippet": "int nfs4_sequence_done(struct rpc_task *task,\n\t\t       struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_sequence_done(struct rpc_task *task,\n\t\t       struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_write_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs4_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, hdr);\n}"
  },
  {
    "function_name": "ff_layout_write_prepare_v4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1114-1130",
    "snippet": "static void ff_layout_write_prepare_v4(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_write_prepare_common(task, hdr))\n\t\treturn;\n\n\tif (ff_layout_setup_sequence(hdr->ds_clp,\n\t\t\t\t     &hdr->args.seq_args,\n\t\t\t\t     &hdr->res.seq_res,\n\t\t\t\t     task))\n\t\treturn;\n\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_WRITE) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_rw_stateid",
          "args": [
            "&hdr->args.stateid",
            "hdr->args.context",
            "hdr->args.lock_context",
            "FMODE_WRITE"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_rw_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "4110-4120",
          "snippet": "int nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_setup_sequence",
          "args": [
            "hdr->ds_clp",
            "&hdr->args.seq_args",
            "&hdr->res.seq_res",
            "task"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "944-958",
          "snippet": "static int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_write_prepare_common",
          "args": [
            "task",
            "hdr"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_write_prepare_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "1082-1102",
          "snippet": "static int ff_layout_write_prepare_common(struct rpc_task *task,\n\t\t\t\t\t  struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tbool retry_pnfs;\n\n\t\tretry_pnfs = ff_layout_has_available_ds(hdr->lseg);\n\t\tdprintk(\"%s task %u reset io to %s\\n\", __func__,\n\t\t\ttask->tk_pid, retry_pnfs ? \"pNFS\" : \"MDS\");\n\t\tff_layout_reset_write(hdr, retry_pnfs);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_write_prepare_common(struct rpc_task *task,\n\t\t\t\t\t  struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tbool retry_pnfs;\n\n\t\tretry_pnfs = ff_layout_has_available_ds(hdr->lseg);\n\t\tdprintk(\"%s task %u reset io to %s\\n\", __func__,\n\t\t\ttask->tk_pid, retry_pnfs ? \"pNFS\" : \"MDS\");\n\t\tff_layout_reset_write(hdr, retry_pnfs);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_write_prepare_v4(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_write_prepare_common(task, hdr))\n\t\treturn;\n\n\tif (ff_layout_setup_sequence(hdr->ds_clp,\n\t\t\t\t     &hdr->args.seq_args,\n\t\t\t\t     &hdr->res.seq_res,\n\t\t\t\t     task))\n\t\treturn;\n\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_WRITE) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}"
  },
  {
    "function_name": "ff_layout_write_prepare_v3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1104-1112",
    "snippet": "static void ff_layout_write_prepare_v3(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_write_prepare_common(task, hdr))\n\t\treturn;\n\n\trpc_call_start(task);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_call_start",
          "args": [
            "task"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_write_prepare_common",
          "args": [
            "task",
            "hdr"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_write_prepare_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "1082-1102",
          "snippet": "static int ff_layout_write_prepare_common(struct rpc_task *task,\n\t\t\t\t\t  struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tbool retry_pnfs;\n\n\t\tretry_pnfs = ff_layout_has_available_ds(hdr->lseg);\n\t\tdprintk(\"%s task %u reset io to %s\\n\", __func__,\n\t\t\ttask->tk_pid, retry_pnfs ? \"pNFS\" : \"MDS\");\n\t\tff_layout_reset_write(hdr, retry_pnfs);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_write_prepare_common(struct rpc_task *task,\n\t\t\t\t\t  struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tbool retry_pnfs;\n\n\t\tretry_pnfs = ff_layout_has_available_ds(hdr->lseg);\n\t\tdprintk(\"%s task %u reset io to %s\\n\", __func__,\n\t\t\ttask->tk_pid, retry_pnfs ? \"pNFS\" : \"MDS\");\n\t\tff_layout_reset_write(hdr, retry_pnfs);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_write_prepare_v3(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_write_prepare_common(task, hdr))\n\t\treturn;\n\n\trpc_call_start(task);\n}"
  },
  {
    "function_name": "ff_layout_write_prepare_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1082-1102",
    "snippet": "static int ff_layout_write_prepare_common(struct rpc_task *task,\n\t\t\t\t\t  struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tbool retry_pnfs;\n\n\t\tretry_pnfs = ff_layout_has_available_ds(hdr->lseg);\n\t\tdprintk(\"%s task %u reset io to %s\\n\", __func__,\n\t\t\ttask->tk_pid, retry_pnfs ? \"pNFS\" : \"MDS\");\n\t\tff_layout_reset_write(hdr, retry_pnfs);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "0"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_reset_write",
          "args": [
            "hdr",
            "retry_pnfs"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_reset_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "609-650",
          "snippet": "static void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (retry_pnfs) {\n\t\tdprintk(\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\tif (!hdr->dreq) {\n\t\t\tstruct nfs_open_context *ctx;\n\n\t\t\tctx = nfs_list_entry(hdr->pages.next)->wb_context;\n\t\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\t\t\thdr->completion_ops->error_cleanup(&hdr->pages);\n\t\t} else {\n\t\t\tnfs_direct_set_resched_writes(hdr->dreq);\n\t\t\t/* fake unstable write to let common nfs resend pages */\n\t\t\thdr->verf.committed = NFS_UNSTABLE;\n\t\t\thdr->good_bytes = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (retry_pnfs) {\n\t\tdprintk(\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\tif (!hdr->dreq) {\n\t\t\tstruct nfs_open_context *ctx;\n\n\t\t\tctx = nfs_list_entry(hdr->pages.next)->wb_context;\n\t\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\t\t\thdr->completion_ops->error_cleanup(&hdr->pages);\n\t\t} else {\n\t\t\tnfs_direct_set_resched_writes(hdr->dreq);\n\t\t\t/* fake unstable write to let common nfs resend pages */\n\t\t\thdr->verf.committed = NFS_UNSTABLE;\n\t\t\thdr->good_bytes = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s task %u reset io to %s\\n\"",
            "__func__",
            "task->tk_pid",
            "retry_pnfs ? \"pNFS\" : \"MDS\""
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_has_available_ds",
          "args": [
            "hdr->lseg"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_has_available_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "527-543",
          "snippet": "bool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nbool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_reset_to_mds",
          "args": [
            "hdr->lseg",
            "hdr->pgio_mirror_idx"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_reset_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "899-906",
          "snippet": "static bool\nff_layout_reset_to_mds(struct pnfs_layout_segment *lseg, int idx)\n{\n\t/* No mirroring for now */\n\tstruct nfs4_deviceid_node *node = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\treturn ff_layout_test_devid_unavailable(node);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nff_layout_reset_to_mds(struct pnfs_layout_segment *lseg, int idx)\n{\n\t/* No mirroring for now */\n\tstruct nfs4_deviceid_node *node = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\treturn ff_layout_test_devid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags)"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_CONTEXT_BAD",
            "&hdr->args.context->flags"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_write_prepare_common(struct rpc_task *task,\n\t\t\t\t\t  struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tbool retry_pnfs;\n\n\t\tretry_pnfs = ff_layout_has_available_ds(hdr->lseg);\n\t\tdprintk(\"%s task %u reset io to %s\\n\", __func__,\n\t\t\ttask->tk_pid, retry_pnfs ? \"pNFS\" : \"MDS\");\n\t\tff_layout_reset_write(hdr, retry_pnfs);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ff_layout_commit_done_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1044-1080",
    "snippet": "static int ff_layout_commit_done_cb(struct rpc_task *task,\n\t\t\t\t     struct nfs_commit_data *data)\n{\n\tstruct inode *inode;\n\tint err;\n\n\ttrace_nfs4_pnfs_commit_ds(data, task->tk_status);\n\tif (task->tk_status == -ETIMEDOUT && !data->res.op_status)\n\t\tdata->res.op_status = NFS4ERR_NXIO;\n\tif (task->tk_status < 0 && data->res.op_status)\n\t\tff_layout_io_track_ds_error(data->lseg, data->ds_commit_index,\n\t\t\t\t\t    data->args.offset, data->args.count,\n\t\t\t\t\t    data->res.op_status, OP_COMMIT);\n\terr = ff_layout_async_handle_error(task, NULL, data->ds_clp,\n\t\t\t\t\t   data->lseg, data->ds_commit_index);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_PNFS:\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tinode = data->lseg->pls_layout->plh_inode;\n\t\tpnfs_error_mark_layout_for_return(inode, data->lseg);\n\t\tif (err == -NFS4ERR_RESET_TO_PNFS)\n\t\t\tpnfs_set_retry_layoutget(data->lseg->pls_layout);\n\t\telse\n\t\t\tpnfs_clear_retry_layoutget(data->lseg->pls_layout);\n\t\tpnfs_generic_prepare_to_resend_writes(data);\n\t\treturn -EAGAIN;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (data->verf.committed == NFS_UNSTABLE)\n\t\tpnfs_commit_set_layoutcommit(data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_commit_set_layoutcommit",
          "args": [
            "data"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_commit_set_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2132-2158",
          "snippet": "void pnfs_commit_set_layoutcommit(struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &data->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(data->lseg);\n\t}\n\tif (data->lwb > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = data->lwb;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, data->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_commit_set_layoutcommit(struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &data->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(data->lseg);\n\t}\n\tif (data->lwb > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = data->lwb;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, data->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_prepare_to_resend_writes",
          "args": [
            "data"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_prepare_to_resend_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_nfs.c",
          "lines": "31-39",
          "snippet": "void pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_generic_prepare_to_resend_writes(struct nfs_commit_data *data)\n{\n\tstruct nfs_page *first = nfs_list_entry(data->pages.next);\n\n\tdata->task.tk_status = 0;\n\tmemcpy(&data->verf.verifier, &first->wb_verf,\n\t       sizeof(data->verf.verifier));\n\tdata->verf.verifier.data[0]++; /* ensure verifier mismatch */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_clear_retry_layoutget",
          "args": [
            "data->lseg->pls_layout"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "370-377",
          "snippet": "static inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_set_retry_layoutget",
          "args": [
            "data->lseg->pls_layout"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "364-368",
          "snippet": "static inline void pnfs_set_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (!test_and_set_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_set_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (!test_and_set_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_error_mark_layout_for_return",
          "args": [
            "inode",
            "data->lseg"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_error_mark_layout_for_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1679-1707",
          "snippet": "void pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_async_handle_error",
          "args": [
            "task",
            "NULL",
            "data->ds_clp",
            "data->lseg",
            "data->ds_commit_index"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_async_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "809-828",
          "snippet": "static int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_io_track_ds_error",
          "args": [
            "data->lseg",
            "data->ds_commit_index",
            "data->args.offset",
            "data->args.count",
            "data->res.op_status",
            "OP_COMMIT"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_io_track_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "830-842",
          "snippet": "static void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_commit_ds",
          "args": [
            "data",
            "task->tk_status"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_commit_done_cb(struct rpc_task *task,\n\t\t\t\t     struct nfs_commit_data *data)\n{\n\tstruct inode *inode;\n\tint err;\n\n\ttrace_nfs4_pnfs_commit_ds(data, task->tk_status);\n\tif (task->tk_status == -ETIMEDOUT && !data->res.op_status)\n\t\tdata->res.op_status = NFS4ERR_NXIO;\n\tif (task->tk_status < 0 && data->res.op_status)\n\t\tff_layout_io_track_ds_error(data->lseg, data->ds_commit_index,\n\t\t\t\t\t    data->args.offset, data->args.count,\n\t\t\t\t\t    data->res.op_status, OP_COMMIT);\n\terr = ff_layout_async_handle_error(task, NULL, data->ds_clp,\n\t\t\t\t\t   data->lseg, data->ds_commit_index);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_PNFS:\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tinode = data->lseg->pls_layout->plh_inode;\n\t\tpnfs_error_mark_layout_for_return(inode, data->lseg);\n\t\tif (err == -NFS4ERR_RESET_TO_PNFS)\n\t\t\tpnfs_set_retry_layoutget(data->lseg->pls_layout);\n\t\telse\n\t\t\tpnfs_clear_retry_layoutget(data->lseg->pls_layout);\n\t\tpnfs_generic_prepare_to_resend_writes(data);\n\t\treturn -EAGAIN;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (data->verf.committed == NFS_UNSTABLE)\n\t\tpnfs_commit_set_layoutcommit(data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ff_layout_write_done_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "1002-1042",
    "snippet": "static int ff_layout_write_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode;\n\tint err;\n\n\ttrace_nfs4_pnfs_write(hdr, task->tk_status);\n\tif (task->tk_status == -ETIMEDOUT && !hdr->res.op_status)\n\t\thdr->res.op_status = NFS4ERR_NXIO;\n\tif (task->tk_status < 0 && hdr->res.op_status)\n\t\tff_layout_io_track_ds_error(hdr->lseg, hdr->pgio_mirror_idx,\n\t\t\t\t\t    hdr->args.offset, hdr->args.count,\n\t\t\t\t\t    hdr->res.op_status, OP_WRITE);\n\terr = ff_layout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t   hdr->ds_clp, hdr->lseg,\n\t\t\t\t\t   hdr->pgio_mirror_idx);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_PNFS:\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tinode = hdr->lseg->pls_layout->plh_inode;\n\t\tpnfs_error_mark_layout_for_return(inode, hdr->lseg);\n\t\tif (err == -NFS4ERR_RESET_TO_PNFS) {\n\t\t\tpnfs_set_retry_layoutget(hdr->lseg->pls_layout);\n\t\t\tff_layout_reset_write(hdr, true);\n\t\t} else {\n\t\t\tpnfs_clear_retry_layoutget(hdr->lseg->pls_layout);\n\t\t\tff_layout_reset_write(hdr, false);\n\t\t}\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (hdr->res.verf->committed == NFS_FILE_SYNC ||\n\t    hdr->res.verf->committed == NFS_DATA_SYNC)\n\t\tff_layout_set_layoutcommit(hdr);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff_layout_set_layoutcommit",
          "args": [
            "hdr"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_set_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "891-897",
          "snippet": "static void\nff_layout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_reset_write",
          "args": [
            "hdr",
            "false"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_reset_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "609-650",
          "snippet": "static void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (retry_pnfs) {\n\t\tdprintk(\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\tif (!hdr->dreq) {\n\t\t\tstruct nfs_open_context *ctx;\n\n\t\t\tctx = nfs_list_entry(hdr->pages.next)->wb_context;\n\t\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\t\t\thdr->completion_ops->error_cleanup(&hdr->pages);\n\t\t} else {\n\t\t\tnfs_direct_set_resched_writes(hdr->dreq);\n\t\t\t/* fake unstable write to let common nfs resend pages */\n\t\t\thdr->verf.committed = NFS_UNSTABLE;\n\t\t\thdr->good_bytes = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (retry_pnfs) {\n\t\tdprintk(\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\tif (!hdr->dreq) {\n\t\t\tstruct nfs_open_context *ctx;\n\n\t\t\tctx = nfs_list_entry(hdr->pages.next)->wb_context;\n\t\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\t\t\thdr->completion_ops->error_cleanup(&hdr->pages);\n\t\t} else {\n\t\t\tnfs_direct_set_resched_writes(hdr->dreq);\n\t\t\t/* fake unstable write to let common nfs resend pages */\n\t\t\thdr->verf.committed = NFS_UNSTABLE;\n\t\t\thdr->good_bytes = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_clear_retry_layoutget",
          "args": [
            "hdr->lseg->pls_layout"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "370-377",
          "snippet": "static inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_clear_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (test_and_clear_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags)) {\n\t\tatomic_dec(&lo->plh_refcount);\n\t\t/* wake up waiters for LAYOUTRETURN as that is not needed */\n\t\twake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_set_retry_layoutget",
          "args": [
            "hdr->lseg->pls_layout"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_retry_layoutget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "364-368",
          "snippet": "static inline void pnfs_set_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (!test_and_set_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_set_retry_layoutget(struct pnfs_layout_hdr *lo)\n{\n\tif (!test_and_set_bit(NFS_LAYOUT_RETRY_LAYOUTGET, &lo->plh_flags))\n\t\tatomic_inc(&lo->plh_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_error_mark_layout_for_return",
          "args": [
            "inode",
            "hdr->lseg"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_error_mark_layout_for_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1679-1707",
          "snippet": "void pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_async_handle_error",
          "args": [
            "task",
            "hdr->args.context->state",
            "hdr->ds_clp",
            "hdr->lseg",
            "hdr->pgio_mirror_idx"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_async_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "809-828",
          "snippet": "static int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_io_track_ds_error",
          "args": [
            "hdr->lseg",
            "hdr->pgio_mirror_idx",
            "hdr->args.offset",
            "hdr->args.count",
            "hdr->res.op_status",
            "OP_WRITE"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_io_track_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "830-842",
          "snippet": "static void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_write",
          "args": [
            "hdr",
            "task->tk_status"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_write_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode;\n\tint err;\n\n\ttrace_nfs4_pnfs_write(hdr, task->tk_status);\n\tif (task->tk_status == -ETIMEDOUT && !hdr->res.op_status)\n\t\thdr->res.op_status = NFS4ERR_NXIO;\n\tif (task->tk_status < 0 && hdr->res.op_status)\n\t\tff_layout_io_track_ds_error(hdr->lseg, hdr->pgio_mirror_idx,\n\t\t\t\t\t    hdr->args.offset, hdr->args.count,\n\t\t\t\t\t    hdr->res.op_status, OP_WRITE);\n\terr = ff_layout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t   hdr->ds_clp, hdr->lseg,\n\t\t\t\t\t   hdr->pgio_mirror_idx);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_PNFS:\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tinode = hdr->lseg->pls_layout->plh_inode;\n\t\tpnfs_error_mark_layout_for_return(inode, hdr->lseg);\n\t\tif (err == -NFS4ERR_RESET_TO_PNFS) {\n\t\t\tpnfs_set_retry_layoutget(hdr->lseg->pls_layout);\n\t\t\tff_layout_reset_write(hdr, true);\n\t\t} else {\n\t\t\tpnfs_clear_retry_layoutget(hdr->lseg->pls_layout);\n\t\t\tff_layout_reset_write(hdr, false);\n\t\t}\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (hdr->res.verf->committed == NFS_FILE_SYNC ||\n\t    hdr->res.verf->committed == NFS_DATA_SYNC)\n\t\tff_layout_set_layoutcommit(hdr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ff_layout_read_count_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "994-1000",
    "snippet": "static void ff_layout_read_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats_metrics(task,\n\t    &NFS_CLIENT(hdr->inode)->cl_metrics[NFSPROC4_CLNT_READ]);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_count_iostats_metrics",
          "args": [
            "task",
            "&NFS_CLIENT(hdr->inode)->cl_metrics[NFSPROC4_CLNT_READ]"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "hdr->inode"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_read_count_stats(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\trpc_count_iostats_metrics(task,\n\t    &NFS_CLIENT(hdr->inode)->cl_metrics[NFSPROC4_CLNT_READ]);\n}"
  },
  {
    "function_name": "ff_layout_read_call_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "978-992",
    "snippet": "static void ff_layout_read_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tdprintk(\"--> %s task->tk_status %d\\n\", __func__, task->tk_status);\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs4_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, hdr);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->mds_ops->rpc_call_done",
          "args": [
            "task",
            "hdr"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_sequence_done",
          "args": [
            "task",
            "&hdr->res.seq_res"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_sequence_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "826-830",
          "snippet": "int nfs4_sequence_done(struct rpc_task *task,\n\t\t       struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_sequence_done(struct rpc_task *task,\n\t\t       struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s task->tk_status %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_read_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tdprintk(\"--> %s task->tk_status %d\\n\", __func__, task->tk_status);\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&\n\t    task->tk_status == 0) {\n\t\tnfs4_sequence_done(task, &hdr->res.seq_res);\n\t\treturn;\n\t}\n\n\t/* Note this may cause RPC to be resent */\n\thdr->mds_ops->rpc_call_done(task, hdr);\n}"
  },
  {
    "function_name": "ff_layout_read_prepare_v4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "960-976",
    "snippet": "static void ff_layout_read_prepare_v4(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_read_prepare_common(task, hdr))\n\t\treturn;\n\n\tif (ff_layout_setup_sequence(hdr->ds_clp,\n\t\t\t\t     &hdr->args.seq_args,\n\t\t\t\t     &hdr->res.seq_res,\n\t\t\t\t     task))\n\t\treturn;\n\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_READ) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_rw_stateid",
          "args": [
            "&hdr->args.stateid",
            "hdr->args.context",
            "hdr->args.lock_context",
            "FMODE_READ"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_rw_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "4110-4120",
          "snippet": "int nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tconst struct nfs_lockowner *lockowner = NULL;\n\n\tif (l_ctx != NULL)\n\t\tlockowner = &l_ctx->lockowner;\n\treturn nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_setup_sequence",
          "args": [
            "hdr->ds_clp",
            "&hdr->args.seq_args",
            "&hdr->res.seq_res",
            "task"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "944-958",
          "snippet": "static int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_read_prepare_common",
          "args": [
            "task",
            "hdr"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_read_prepare_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "908-927",
          "snippet": "static int ff_layout_read_prepare_common(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tif (ff_layout_has_available_ds(hdr->lseg))\n\t\t\tpnfs_read_resend_pnfs(hdr);\n\t\telse\n\t\t\tff_layout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\thdr->pgio_done_cb = ff_layout_read_done_cb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_read_prepare_common(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tif (ff_layout_has_available_ds(hdr->lseg))\n\t\t\tpnfs_read_resend_pnfs(hdr);\n\t\telse\n\t\t\tff_layout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\thdr->pgio_done_cb = ff_layout_read_done_cb;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_read_prepare_v4(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_read_prepare_common(task, hdr))\n\t\treturn;\n\n\tif (ff_layout_setup_sequence(hdr->ds_clp,\n\t\t\t\t     &hdr->args.seq_args,\n\t\t\t\t     &hdr->res.seq_res,\n\t\t\t\t     task))\n\t\treturn;\n\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\thdr->args.lock_context, FMODE_READ) == -EIO)\n\t\trpc_exit(task, -EIO); /* lost lock, terminate I/O */\n}"
  },
  {
    "function_name": "ff_layout_setup_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "944-958",
    "snippet": "static int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs40_setup_sequence",
          "args": [
            "ds_clp->cl_slot_tbl",
            "args",
            "res",
            "task"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "nfs40_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "498-536",
          "snippet": "int nfs40_setup_sequence(struct nfs4_slot_table *tbl,\n\t\t\t struct nfs4_sequence_args *args,\n\t\t\t struct nfs4_sequence_res *res,\n\t\t\t struct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_start;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)\n\t\tgoto out_sleep;\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\tres->sr_slot = slot;\n\nout_start:\n\trpc_call_start(task);\n\treturn 0;\n\nout_sleep:\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs40_setup_sequence(struct nfs4_slot_table *tbl,\n\t\t\t struct nfs4_sequence_args *args,\n\t\t\t struct nfs4_sequence_res *res,\n\t\t\t struct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_start;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)\n\t\tgoto out_sleep;\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\tres->sr_slot = slot;\n\nout_start:\n\trpc_call_start(task);\n\treturn 0;\n\nout_sleep:\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs41_setup_sequence",
          "args": [
            "ds_clp->cl_session",
            "args",
            "res",
            "task"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "nfs41_setup_sequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "707-768",
          "snippet": "int nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs41_setup_sequence(struct nfs4_session *session,\n\t\t\t\tstruct nfs4_sequence_args *args,\n\t\t\t\tstruct nfs4_sequence_res *res,\n\t\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_slot *slot;\n\tstruct nfs4_slot_table *tbl;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_success;\n\n\ttbl = &session->fc_slot_table;\n\n\ttask->tk_timeout = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state) &&\n\t    !args->sa_privileged) {\n\t\t/* The state manager will wait until the slot table is empty */\n\t\tdprintk(\"%s session is draining\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\t/* If out of memory, try again in 1/4 second */\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\ttask->tk_timeout = HZ >> 2;\n\t\tdprintk(\"<-- %s: no free slots\\n\", __func__);\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\targs->sa_slot = slot;\n\n\tdprintk(\"<-- %s slotid=%u seqid=%u\\n\", __func__,\n\t\t\tslot->slot_nr, slot->seq_nr);\n\n\tres->sr_slot = slot;\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\t/*\n\t * sr_status is only set in decode_sequence, and so will remain\n\t * set to 1 if an rpc level failure occurs.\n\t */\n\tres->sr_status = 1;\n\ttrace_nfs4_setup_sequence(session, args);\nout_success:\n\trpc_call_start(task);\n\treturn 0;\nout_sleep:\n\t/* Privileged tasks are queued with top priority */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_setup_sequence(struct nfs_client *ds_clp,\n\t\t\t\t    struct nfs4_sequence_args *args,\n\t\t\t\t    struct nfs4_sequence_res *res,\n\t\t\t\t    struct rpc_task *task)\n{\n\tif (ds_clp->cl_session)\n\t\treturn nfs41_setup_sequence(ds_clp->cl_session,\n\t\t\t\t\t   args,\n\t\t\t\t\t   res,\n\t\t\t\t\t   task);\n\treturn nfs40_setup_sequence(ds_clp->cl_slot_tbl,\n\t\t\t\t   args,\n\t\t\t\t   res,\n\t\t\t\t   task);\n}"
  },
  {
    "function_name": "ff_layout_read_prepare_v3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "934-942",
    "snippet": "static void ff_layout_read_prepare_v3(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_read_prepare_common(task, hdr))\n\t\treturn;\n\n\trpc_call_start(task);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_call_start",
          "args": [
            "task"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_read_prepare_common",
          "args": [
            "task",
            "hdr"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_read_prepare_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "908-927",
          "snippet": "static int ff_layout_read_prepare_common(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tif (ff_layout_has_available_ds(hdr->lseg))\n\t\t\tpnfs_read_resend_pnfs(hdr);\n\t\telse\n\t\t\tff_layout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\thdr->pgio_done_cb = ff_layout_read_done_cb;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_read_prepare_common(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tif (ff_layout_has_available_ds(hdr->lseg))\n\t\t\tpnfs_read_resend_pnfs(hdr);\n\t\telse\n\t\t\tff_layout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\thdr->pgio_done_cb = ff_layout_read_done_cb;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_read_prepare_v3(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\n\tif (ff_layout_read_prepare_common(task, hdr))\n\t\treturn;\n\n\trpc_call_start(task);\n}"
  },
  {
    "function_name": "ff_layout_read_prepare_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "908-927",
    "snippet": "static int ff_layout_read_prepare_common(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tif (ff_layout_has_available_ds(hdr->lseg))\n\t\t\tpnfs_read_resend_pnfs(hdr);\n\t\telse\n\t\t\tff_layout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\thdr->pgio_done_cb = ff_layout_read_done_cb;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "0"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_reset_read",
          "args": [
            "hdr"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_reset_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "652-669",
          "snippet": "static void ff_layout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_read_resend_pnfs",
          "args": [
            "hdr"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_read_resend_pnfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2006-2012",
          "snippet": "int pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_has_available_ds",
          "args": [
            "hdr->lseg"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_has_available_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "527-543",
          "snippet": "bool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nbool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s task %u reset io to MDS\\n\"",
            "__func__",
            "task->tk_pid"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_reset_to_mds",
          "args": [
            "hdr->lseg",
            "hdr->pgio_mirror_idx"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_reset_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "899-906",
          "snippet": "static bool\nff_layout_reset_to_mds(struct pnfs_layout_segment *lseg, int idx)\n{\n\t/* No mirroring for now */\n\tstruct nfs4_deviceid_node *node = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\treturn ff_layout_test_devid_unavailable(node);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nff_layout_reset_to_mds(struct pnfs_layout_segment *lseg, int idx)\n{\n\t/* No mirroring for now */\n\tstruct nfs4_deviceid_node *node = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\treturn ff_layout_test_devid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_exit",
          "args": [
            "task",
            "-EIO"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_CONTEXT_BAD",
            "&hdr->args.context->flags"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_read_prepare_common(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {\n\t\trpc_exit(task, -EIO);\n\t\treturn -EIO;\n\t}\n\tif (ff_layout_reset_to_mds(hdr->lseg, hdr->pgio_mirror_idx)) {\n\t\tdprintk(\"%s task %u reset io to MDS\\n\", __func__, task->tk_pid);\n\t\tif (ff_layout_has_available_ds(hdr->lseg))\n\t\t\tpnfs_read_resend_pnfs(hdr);\n\t\telse\n\t\t\tff_layout_reset_read(hdr);\n\t\trpc_exit(task, 0);\n\t\treturn -EAGAIN;\n\t}\n\thdr->pgio_done_cb = ff_layout_read_done_cb;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ff_layout_reset_to_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "899-906",
    "snippet": "static bool\nff_layout_reset_to_mds(struct pnfs_layout_segment *lseg, int idx)\n{\n\t/* No mirroring for now */\n\tstruct nfs4_deviceid_node *node = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\treturn ff_layout_test_devid_unavailable(node);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ff_layout_test_devid_unavailable",
          "args": [
            "node"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_test_devid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "116-120",
          "snippet": "static inline bool\nff_layout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn nfs4_test_deviceid_unavailable(node);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline bool\nff_layout_test_devid_unavailable(struct nfs4_deviceid_node *node)\n{\n\treturn nfs4_test_deviceid_unavailable(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_DEVID_NODE",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_DEVID_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "86-94",
          "snippet": "static inline struct nfs4_deviceid_node *\nFF_LAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx] == NULL ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds->id_node;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_deviceid_node *\nFF_LAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx] == NULL ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds->id_node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool\nff_layout_reset_to_mds(struct pnfs_layout_segment *lseg, int idx)\n{\n\t/* No mirroring for now */\n\tstruct nfs4_deviceid_node *node = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\treturn ff_layout_test_devid_unavailable(node);\n}"
  },
  {
    "function_name": "ff_layout_set_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "891-897",
    "snippet": "static void\nff_layout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s inode %lu pls_end_pos %lu\\n\"",
            "__func__",
            "hdr->inode->i_ino",
            "(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "hdr->inode"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_set_layoutcommit",
          "args": [
            "hdr"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_set_layoutcommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2101-2129",
          "snippet": "void\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tloff_t end_pos = hdr->mds_offset + hdr->res.count;\n\tbool mark_as_dirty = false;\n\n\tspin_lock(&inode->i_lock);\n\tif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\n\t\tmark_as_dirty = true;\n\t\tdprintk(\"%s: Set layoutcommit for inode %lu \",\n\t\t\t__func__, inode->i_ino);\n\t}\n\tif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\n\t\t/* references matched in nfs4_layoutcommit_release */\n\t\tpnfs_get_lseg(hdr->lseg);\n\t}\n\tif (end_pos > nfsi->layout->plh_lwb)\n\t\tnfsi->layout->plh_lwb = end_pos;\n\tspin_unlock(&inode->i_lock);\n\tdprintk(\"%s: lseg %p end_pos %llu\\n\",\n\t\t__func__, hdr->lseg, nfsi->layout->plh_lwb);\n\n\t/* if pnfs_layoutcommit_inode() runs between inode locks, the next one\n\t * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */\n\tif (mark_as_dirty)\n\t\tmark_inode_dirty_sync(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_set_layoutcommit(struct nfs_pgio_header *hdr)\n{\n\tpnfs_set_layoutcommit(hdr);\n\tdprintk(\"%s inode %lu pls_end_pos %lu\\n\", __func__, hdr->inode->i_ino,\n\t\t(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\n}"
  },
  {
    "function_name": "ff_layout_read_done_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "846-880",
    "snippet": "static int ff_layout_read_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode;\n\tint err;\n\n\ttrace_nfs4_pnfs_read(hdr, task->tk_status);\n\tif (task->tk_status == -ETIMEDOUT && !hdr->res.op_status)\n\t\thdr->res.op_status = NFS4ERR_NXIO;\n\tif (task->tk_status < 0 && hdr->res.op_status)\n\t\tff_layout_io_track_ds_error(hdr->lseg, hdr->pgio_mirror_idx,\n\t\t\t\t\t    hdr->args.offset, hdr->args.count,\n\t\t\t\t\t    hdr->res.op_status, OP_READ);\n\terr = ff_layout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t   hdr->ds_clp, hdr->lseg,\n\t\t\t\t\t   hdr->pgio_mirror_idx);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_PNFS:\n\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t&hdr->lseg->pls_layout->plh_flags);\n\t\tpnfs_read_resend_pnfs(hdr);\n\t\treturn task->tk_status;\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tinode = hdr->lseg->pls_layout->plh_inode;\n\t\tpnfs_error_mark_layout_for_return(inode, hdr->lseg);\n\t\tff_layout_reset_read(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_reset_read",
          "args": [
            "hdr"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_reset_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "652-669",
          "snippet": "static void ff_layout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_error_mark_layout_for_return",
          "args": [
            "inode",
            "hdr->lseg"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_error_mark_layout_for_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1679-1707",
          "snippet": "void pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\n\t\t\t\t       struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\n\tint iomode = pnfs_iomode_to_fail_bit(lseg->pls_range.iomode);\n\tstruct pnfs_layout_range range = {\n\t\t.iomode = lseg->pls_range.iomode,\n\t\t.offset = 0,\n\t\t.length = NFS4_MAX_UINT64,\n\t};\n\tLIST_HEAD(free_me);\n\n\tspin_lock(&inode->i_lock);\n\t/* set failure bit so that pnfs path will be retried later */\n\tpnfs_layout_set_fail_bit(lo, iomode);\n\tset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\n\tif (lo->plh_return_iomode == 0)\n\t\tlo->plh_return_iomode = range.iomode;\n\telse if (lo->plh_return_iomode != range.iomode)\n\t\tlo->plh_return_iomode = IOMODE_ANY;\n\t/*\n\t * mark all matching lsegs so that we are sure to have no live\n\t * segments at hand when sending layoutreturn. See pnfs_put_lseg()\n\t * for how it works.\n\t */\n\tpnfs_mark_matching_lsegs_return(lo, &free_me, &range);\n\tspin_unlock(&inode->i_lock);\n\tpnfs_free_lseg_list(&free_me);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_read_resend_pnfs",
          "args": [
            "hdr"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_read_resend_pnfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "2006-2012",
          "snippet": "int pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\tnfs_pageio_init_read(&pgio, hdr->inode, false, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_LAYOUT_RETURN_BEFORE_CLOSE",
            "&hdr->lseg->pls_layout->plh_flags"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_async_handle_error",
          "args": [
            "task",
            "hdr->args.context->state",
            "hdr->ds_clp",
            "hdr->lseg",
            "hdr->pgio_mirror_idx"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_async_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "809-828",
          "snippet": "static int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_io_track_ds_error",
          "args": [
            "hdr->lseg",
            "hdr->pgio_mirror_idx",
            "hdr->args.offset",
            "hdr->args.count",
            "hdr->res.op_status",
            "OP_READ"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_io_track_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "830-842",
          "snippet": "static void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs4_pnfs_read",
          "args": [
            "hdr",
            "task->tk_status"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_read_done_cb(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode;\n\tint err;\n\n\ttrace_nfs4_pnfs_read(hdr, task->tk_status);\n\tif (task->tk_status == -ETIMEDOUT && !hdr->res.op_status)\n\t\thdr->res.op_status = NFS4ERR_NXIO;\n\tif (task->tk_status < 0 && hdr->res.op_status)\n\t\tff_layout_io_track_ds_error(hdr->lseg, hdr->pgio_mirror_idx,\n\t\t\t\t\t    hdr->args.offset, hdr->args.count,\n\t\t\t\t\t    hdr->res.op_status, OP_READ);\n\terr = ff_layout_async_handle_error(task, hdr->args.context->state,\n\t\t\t\t\t   hdr->ds_clp, hdr->lseg,\n\t\t\t\t\t   hdr->pgio_mirror_idx);\n\n\tswitch (err) {\n\tcase -NFS4ERR_RESET_TO_PNFS:\n\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t&hdr->lseg->pls_layout->plh_flags);\n\t\tpnfs_read_resend_pnfs(hdr);\n\t\treturn task->tk_status;\n\tcase -NFS4ERR_RESET_TO_MDS:\n\t\tinode = hdr->lseg->pls_layout->plh_inode;\n\t\tpnfs_error_mark_layout_for_return(inode, hdr->lseg);\n\t\tff_layout_reset_read(hdr);\n\t\treturn task->tk_status;\n\tcase -EAGAIN:\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ff_layout_io_track_ds_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "830-842",
    "snippet": "static void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: err %d op %d status %u\\n\"",
            "__func__",
            "err",
            "opnum",
            "status"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_track_ds_error",
          "args": [
            "FF_LAYOUT_FROM_HDR(lseg->pls_layout)",
            "mirror",
            "offset",
            "length",
            "status",
            "opnum",
            "GFP_NOIO"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_track_ds_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "254-296",
          "snippet": "int ff_layout_track_ds_error(struct nfs4_flexfile_layout *flo,\n\t\t\t     struct nfs4_ff_layout_mirror *mirror, u64 offset,\n\t\t\t     u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds_err *dserr;\n\tbool needfree;\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tif (mirror->mirror_ds == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (ff_layout_update_ds_error(flo, offset, length, status, opnum,\n\t\t\t\t      &mirror->stateid,\n\t\t\t\t      &mirror->mirror_ds->id_node.deviceid)) {\n\t\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tdserr = kmalloc(sizeof(*dserr), gfp_flags);\n\tif (!dserr)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dserr->list);\n\tdserr->offset = offset;\n\tdserr->length = length;\n\tdserr->status = status;\n\tdserr->opnum = opnum;\n\tnfs4_stateid_copy(&dserr->stateid, &mirror->stateid);\n\tmemcpy(&dserr->deviceid, &mirror->mirror_ds->id_node.deviceid,\n\t       NFS4_DEVICEID4_SIZE);\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tneedfree = ff_layout_add_ds_error_locked(flo, dserr);\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (needfree)\n\t\tkfree(dserr);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nint ff_layout_track_ds_error(struct nfs4_flexfile_layout *flo,\n\t\t\t     struct nfs4_ff_layout_mirror *mirror, u64 offset,\n\t\t\t     u64 length, int status, enum nfs_opnum4 opnum,\n\t\t\t     gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_ds_err *dserr;\n\tbool needfree;\n\n\tif (status == 0)\n\t\treturn 0;\n\n\tif (mirror->mirror_ds == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (ff_layout_update_ds_error(flo, offset, length, status, opnum,\n\t\t\t\t      &mirror->stateid,\n\t\t\t\t      &mirror->mirror_ds->id_node.deviceid)) {\n\t\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tdserr = kmalloc(sizeof(*dserr), gfp_flags);\n\tif (!dserr)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dserr->list);\n\tdserr->offset = offset;\n\tdserr->length = length;\n\tdserr->status = status;\n\tdserr->opnum = opnum;\n\tnfs4_stateid_copy(&dserr->stateid, &mirror->stateid);\n\tmemcpy(&dserr->deviceid, &mirror->mirror_ds->id_node.deviceid,\n\t       NFS4_DEVICEID4_SIZE);\n\n\tspin_lock(&flo->generic_hdr.plh_inode->i_lock);\n\tneedfree = ff_layout_add_ds_error_locked(flo, dserr);\n\tspin_unlock(&flo->generic_hdr.plh_inode->i_lock);\n\tif (needfree)\n\t\tkfree(dserr);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_FROM_HDR",
          "args": [
            "lseg->pls_layout"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx, u64 offset, u64 length,\n\t\t\t\t\tu32 status, int opnum)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tint err;\n\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}"
  },
  {
    "function_name": "ff_layout_async_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "809-828",
    "snippet": "static int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_async_handle_error_v4",
          "args": [
            "task",
            "state",
            "clp",
            "lseg",
            "idx"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_async_handle_error_v4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "671-779",
          "snippet": "static int ff_layout_async_handle_error_v4(struct rpc_task *task,\n\t\t\t\t\t   struct nfs4_state *state,\n\t\t\t\t\t   struct nfs_client *clp,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tnfs_remove_bad_delegation(state->inode);\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FF_LAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [
            "#define FF_LAYOUT_POLL_RETRY_MAX     (15*HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define FF_LAYOUT_POLL_RETRY_MAX     (15*HZ)\n\nstatic int ff_layout_async_handle_error_v4(struct rpc_task *task,\n\t\t\t\t\t   struct nfs4_state *state,\n\t\t\t\t\t   struct nfs_client *clp,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tnfs_remove_bad_delegation(state->inode);\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FF_LAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_async_handle_error_v3",
          "args": [
            "task",
            "lseg",
            "idx"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_async_handle_error_v3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "782-807",
          "snippet": "static int ff_layout_async_handle_error_v3(struct rpc_task *task,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tif (task->tk_status != -EJUKEBOX) {\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\n\t\telse\n\t\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\n\n\tif (task->tk_status == -EJUKEBOX)\n\t\tnfs_inc_stats(lseg->pls_layout->plh_inode, NFSIOS_DELAY);\n\ttask->tk_status = 0;\n\trpc_restart_call(task);\n\trpc_delay(task, NFS_JUKEBOX_RETRY_TIME);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_async_handle_error_v3(struct rpc_task *task,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tif (task->tk_status != -EJUKEBOX) {\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\n\t\telse\n\t\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\n\n\tif (task->tk_status == -EJUKEBOX)\n\t\tnfs_inc_stats(lseg->pls_layout->plh_inode, NFSIOS_DELAY);\n\ttask->tk_status = 0;\n\trpc_restart_call(task);\n\trpc_delay(task, NFS_JUKEBOX_RETRY_TIME);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_async_handle_error(struct rpc_task *task,\n\t\t\t\t\tstruct nfs4_state *state,\n\t\t\t\t\tstruct nfs_client *clp,\n\t\t\t\t\tstruct pnfs_layout_segment *lseg,\n\t\t\t\t\tint idx)\n{\n\tint vers = clp->cl_nfs_mod->rpc_vers->number;\n\n\tswitch (vers) {\n\tcase 3:\n\t\treturn ff_layout_async_handle_error_v3(task, lseg, idx);\n\tcase 4:\n\t\treturn ff_layout_async_handle_error_v4(task, state, clp,\n\t\t\t\t\t\t       lseg, idx);\n\tdefault:\n\t\t/* should never happen */\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "ff_layout_async_handle_error_v3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "782-807",
    "snippet": "static int ff_layout_async_handle_error_v3(struct rpc_task *task,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tif (task->tk_status != -EJUKEBOX) {\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\n\t\telse\n\t\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\n\n\tif (task->tk_status == -EJUKEBOX)\n\t\tnfs_inc_stats(lseg->pls_layout->plh_inode, NFSIOS_DELAY);\n\ttask->tk_status = 0;\n\trpc_restart_call(task);\n\trpc_delay(task, NFS_JUKEBOX_RETRY_TIME);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "NFS_JUKEBOX_RETRY_TIME"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_restart_call",
          "args": [
            "task"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "lseg->pls_layout->plh_inode",
            "NFSIOS_DELAY"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_has_available_ds",
          "args": [
            "lseg"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_has_available_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "527-543",
          "snippet": "bool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nbool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_mark_deviceid_unavailable",
          "args": [
            "devid"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_mark_deviceid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "281-286",
          "snippet": "void\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s DS connection error %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_DEVID_NODE",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_DEVID_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "86-94",
          "snippet": "static inline struct nfs4_deviceid_node *\nFF_LAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx] == NULL ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds->id_node;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_deviceid_node *\nFF_LAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx] == NULL ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds->id_node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_async_handle_error_v3(struct rpc_task *task,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tif (task->tk_status != -EJUKEBOX) {\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\n\t\telse\n\t\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\n\n\tif (task->tk_status == -EJUKEBOX)\n\t\tnfs_inc_stats(lseg->pls_layout->plh_inode, NFSIOS_DELAY);\n\ttask->tk_status = 0;\n\trpc_restart_call(task);\n\trpc_delay(task, NFS_JUKEBOX_RETRY_TIME);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "ff_layout_async_handle_error_v4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "671-779",
    "snippet": "static int ff_layout_async_handle_error_v4(struct rpc_task *task,\n\t\t\t\t\t   struct nfs4_state *state,\n\t\t\t\t\t   struct nfs_client *clp,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tnfs_remove_bad_delegation(state->inode);\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FF_LAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [
      "#define FF_LAYOUT_POLL_RETRY_MAX     (15*HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_wake_up_queued_task",
          "args": [
            "&mds_client->cl_rpcwaitq",
            "task"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS4CLNT_MANAGER_RUNNING",
            "&mds_client->cl_state"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_sleep_on",
          "args": [
            "&mds_client->cl_rpcwaitq",
            "task",
            "NULL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Retry through MDS. Error %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_has_available_ds",
          "args": [
            "lseg"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_has_available_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "527-543",
          "snippet": "bool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nbool ff_layout_has_available_ds(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_deviceid_node *devid;\n\tint idx;\n\n\tfor (idx = 0; idx < FF_LAYOUT_MIRROR_COUNT(lseg); idx++) {\n\t\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tif (!ff_layout_test_devid_unavailable(devid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_wake_up",
          "args": [
            "&tbl->slot_tbl_waitq"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_mark_deviceid_unavailable",
          "args": [
            "devid"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_mark_deviceid_unavailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "281-286",
          "snippet": "void\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_mark_deviceid_unavailable(struct nfs4_deviceid_node *node)\n{\n\tnode->timestamp_unavailable = jiffies;\n\tset_bit(NFS_DEVICEID_UNAVAILABLE, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s DS connection error %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wake_up",
          "args": [
            "&tbl->slot_tbl_waitq"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_destroy_layout",
          "args": [
            "NFS_I(inode)"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_destroy_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "535-537",
          "snippet": "static inline void pnfs_destroy_layout(struct nfs_inode *nfsi)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_destroy_layout(struct nfs_inode *nfsi)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Invalid layout error %d\\n\"",
            "__func__",
            "task->tk_status"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "FF_LAYOUT_POLL_RETRY_MAX"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_session_recovery",
          "args": [
            "clp->cl_session",
            "task->tk_status"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_session_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "2138-2150",
          "snippet": "void nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n\tstruct nfs_client *clp = session->clp;\n\n\tswitch (err) {\n\tdefault:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t}\n\tnfs4_schedule_lease_recovery(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_session_recovery(struct nfs4_session *session, int err)\n{\n\tstruct nfs_client *clp = session->clp;\n\n\tswitch (err) {\n\tdefault:\n\t\tset_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state);\n\t\tbreak;\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tset_bit(NFS4CLNT_BIND_CONN_TO_SESSION, &clp->cl_state);\n\t}\n\tnfs4_schedule_lease_recovery(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\"",
            "__func__",
            "task->tk_status",
            "clp->cl_exchange_flags"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_lease_recovery",
          "args": [
            "mds_client"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_lease_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1177-1186",
          "snippet": "void nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid nfs4_schedule_lease_recovery(struct nfs_client *clp)\n{\n\tif (!clp)\n\t\treturn;\n\tif (!test_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state))\n\t\tset_bit(NFS4CLNT_CHECK_LEASE, &clp->cl_state);\n\tdprintk(\"%s: scheduling lease recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_schedule_stateid_recovery",
          "args": [
            "mds_server",
            "state"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_schedule_stateid_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "1322-1333",
          "snippet": "int nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn -EBADF;\n\tnfs4_state_mark_reclaim_nograce(clp, state);\n\tdprintk(\"%s: scheduling stateid recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint nfs4_schedule_stateid_recovery(const struct nfs_server *server, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_valid_open_stateid(state))\n\t\treturn -EBADF;\n\tnfs4_state_mark_reclaim_nograce(clp, state);\n\tdprintk(\"%s: scheduling stateid recovery for server %s\\n\", __func__,\n\t\t\tclp->cl_hostname);\n\tnfs4_schedule_state_manager(clp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_remove_bad_delegation",
          "args": [
            "state->inode"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_remove_bad_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "655-665",
          "snippet": "void nfs_remove_bad_delegation(struct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\n\tnfs_revoke_delegation(inode);\n\tdelegation = nfs_inode_detach_delegation(inode);\n\tif (delegation) {\n\t\tnfs_inode_find_state_and_recover(inode, &delegation->stateid);\n\t\tnfs_free_delegation(delegation);\n\t}\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nvoid nfs_remove_bad_delegation(struct inode *inode)\n{\n\tstruct nfs_delegation *delegation;\n\n\tnfs_revoke_delegation(inode);\n\tdelegation = nfs_inode_detach_delegation(inode);\n\tif (delegation) {\n\t\tnfs_inode_find_state_and_recover(inode, &delegation->stateid);\n\t\tnfs_free_delegation(delegation);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_DEVID_NODE",
          "args": [
            "lseg",
            "idx"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_DEVID_NODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "86-94",
          "snippet": "static inline struct nfs4_deviceid_node *\nFF_LAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx] == NULL ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds->id_node;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_deviceid_node *\nFF_LAYOUT_DEVID_NODE(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx] == NULL ||\n\t    FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_LSEG(lseg)->mirror_array[idx]->mirror_ds->id_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\n#define FF_LAYOUT_POLL_RETRY_MAX     (15*HZ)\n\nstatic int ff_layout_async_handle_error_v4(struct rpc_task *task,\n\t\t\t\t\t   struct nfs4_state *state,\n\t\t\t\t\t   struct nfs_client *clp,\n\t\t\t\t\t   struct pnfs_layout_segment *lseg,\n\t\t\t\t\t   int idx)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct inode *inode = lo->plh_inode;\n\tstruct nfs_server *mds_server = NFS_SERVER(inode);\n\n\tstruct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);\n\tstruct nfs_client *mds_client = mds_server->nfs_client;\n\tstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\n\tswitch (task->tk_status) {\n\t/* MDS state errors */\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tnfs_remove_bad_delegation(state->inode);\n\tcase -NFS4ERR_OPENMODE:\n\t\tif (state == NULL)\n\t\t\tbreak;\n\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\tgoto out_bad_stateid;\n\t\tgoto wait_on_recovery;\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (state != NULL) {\n\t\t\tif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\n\t\t\t\tgoto out_bad_stateid;\n\t\t}\n\t\tnfs4_schedule_lease_recovery(mds_client);\n\t\tgoto wait_on_recovery;\n\t/* DS session errors */\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tdprintk(\"%s ERROR %d, Reset session. Exchangeid \"\n\t\t\t\"flags 0x%x\\n\", __func__, task->tk_status,\n\t\t\tclp->cl_exchange_flags);\n\t\tnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\trpc_delay(task, FF_LAYOUT_POLL_RETRY_MAX);\n\t\tbreak;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tbreak;\n\t/* Invalidate Layout errors */\n\tcase -NFS4ERR_PNFS_NO_LAYOUT:\n\tcase -ESTALE:           /* mapped NFS4ERR_STALE */\n\tcase -EBADHANDLE:       /* mapped NFS4ERR_BADHANDLE */\n\tcase -EISDIR:           /* mapped NFS4ERR_ISDIR */\n\tcase -NFS4ERR_FHEXPIRED:\n\tcase -NFS4ERR_WRONG_TYPE:\n\t\tdprintk(\"%s Invalid layout error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\t/*\n\t\t * Destroy layout so new i/o will get a new layout.\n\t\t * Layout will not be destroyed until all current lseg\n\t\t * references are put. Mark layout as invalid to resend failed\n\t\t * i/o and all i/o waiting on the slot table to the MDS until\n\t\t * layout is destroyed and a new valid layout is obtained.\n\t\t */\n\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\tgoto reset;\n\t/* RPC connection errors */\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EIO:\n\tcase -ETIMEDOUT:\n\tcase -EPIPE:\n\t\tdprintk(\"%s DS connection error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\tnfs4_mark_deviceid_unavailable(devid);\n\t\trpc_wake_up(&tbl->slot_tbl_waitq);\n\t\t/* fall through */\n\tdefault:\n\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\treturn -NFS4ERR_RESET_TO_PNFS;\nreset:\n\t\tdprintk(\"%s Retry through MDS. Error %d\\n\", __func__,\n\t\t\ttask->tk_status);\n\t\treturn -NFS4ERR_RESET_TO_MDS;\n\t}\nout:\n\ttask->tk_status = 0;\n\treturn -EAGAIN;\nout_bad_stateid:\n\ttask->tk_status = -EIO;\n\treturn 0;\nwait_on_recovery:\n\trpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\n\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\n\t\trpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\n\tgoto out;\n}"
  },
  {
    "function_name": "ff_layout_reset_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "652-669",
    "snippet": "static void ff_layout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_read_done_resend_to_mds",
          "args": [
            "hdr"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_read_done_resend_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1931-1938",
          "snippet": "int pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\"",
            "__func__",
            "hdr->task.tk_pid",
            "hdr->inode->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(hdr->inode)",
            "hdr->args.count",
            "(unsigned long long)hdr->args.offset"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "hdr->inode"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_inode",
          "args": [
            "hdr->inode",
            "false"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "642-645",
          "snippet": "static inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_reset_read(struct nfs_pgio_header *hdr)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_read_done_resend_to_mds(hdr);\n\t}\n}"
  },
  {
    "function_name": "ff_layout_reset_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "609-650",
    "snippet": "static void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (retry_pnfs) {\n\t\tdprintk(\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\tif (!hdr->dreq) {\n\t\t\tstruct nfs_open_context *ctx;\n\n\t\t\tctx = nfs_list_entry(hdr->pages.next)->wb_context;\n\t\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\t\t\thdr->completion_ops->error_cleanup(&hdr->pages);\n\t\t} else {\n\t\t\tnfs_direct_set_resched_writes(hdr->dreq);\n\t\t\t/* fake unstable write to let common nfs resend pages */\n\t\t\thdr->verf.committed = NFS_UNSTABLE;\n\t\t\thdr->good_bytes = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_write_done_resend_to_mds",
          "args": [
            "hdr"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_write_done_resend_to_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1814-1822",
          "snippet": "int pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nint pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\n\t/* Resend all requests through the MDS */\n\tnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\n\t\t\t      hdr->completion_ops);\n\treturn nfs_pageio_resend(&pgio, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\"",
            "__func__",
            "hdr->task.tk_pid",
            "hdr->inode->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(hdr->inode)",
            "hdr->args.count",
            "(unsigned long long)hdr->args.offset"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "hdr->inode"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_IOHDR_REDO",
            "&hdr->flags"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_direct_set_resched_writes",
          "args": [
            "hdr->dreq"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_set_resched_writes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "120-123",
          "snippet": "void nfs_direct_set_resched_writes(struct nfs_direct_req *dreq)\n{\n\tdreq->flags = NFS_ODIRECT_RESCHED_WRITES;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n\nvoid nfs_direct_set_resched_writes(struct nfs_direct_req *dreq)\n{\n\tdreq->flags = NFS_ODIRECT_RESCHED_WRITES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hdr->completion_ops->error_cleanup",
          "args": [
            "&hdr->pages"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_CONTEXT_RESEND_WRITES",
            "&ctx->flags"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "hdr->pages.next"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\"",
            "__func__",
            "hdr->task.tk_pid",
            "hdr->inode->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(hdr->inode)",
            "hdr->args.count",
            "(unsigned long long)hdr->args.offset"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "hdr->inode"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_layoutcommit_inode",
          "args": [
            "hdr->inode",
            "false"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_layoutcommit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "642-645",
          "snippet": "static inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline int pnfs_layoutcommit_inode(struct inode *inode, bool sync)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)\n{\n\tstruct rpc_task *task = &hdr->task;\n\n\tpnfs_layoutcommit_inode(hdr->inode, false);\n\n\tif (retry_pnfs) {\n\t\tdprintk(\"%s Reset task %5u for i/o through pNFS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\tif (!hdr->dreq) {\n\t\t\tstruct nfs_open_context *ctx;\n\n\t\t\tctx = nfs_list_entry(hdr->pages.next)->wb_context;\n\t\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &ctx->flags);\n\t\t\thdr->completion_ops->error_cleanup(&hdr->pages);\n\t\t} else {\n\t\t\tnfs_direct_set_resched_writes(hdr->dreq);\n\t\t\t/* fake unstable write to let common nfs resend pages */\n\t\t\thdr->verf.committed = NFS_UNSTABLE;\n\t\t\thdr->good_bytes = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\n\t\tdprintk(\"%s Reset task %5u for i/o through MDS \"\n\t\t\t\"(req %s/%llu, %u bytes @ offset %llu)\\n\", __func__,\n\t\t\thdr->task.tk_pid,\n\t\t\thdr->inode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(hdr->inode),\n\t\t\thdr->args.count,\n\t\t\t(unsigned long long)hdr->args.offset);\n\n\t\ttask->tk_status = pnfs_write_done_resend_to_mds(hdr);\n\t}\n}"
  },
  {
    "function_name": "ff_layout_pg_get_mirror_count_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "573-592",
    "snippet": "static unsigned int\nff_layout_pg_get_mirror_count_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t\t    struct nfs_page *req)\n{\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\tif (pgio->pg_lseg)\n\t\treturn FF_LAYOUT_MIRROR_COUNT(pgio->pg_lseg);\n\n\t/* no lseg means that pnfs is not in use, so no mirroring here */\n\tpnfs_put_lseg(pgio->pg_lseg);\n\tpgio->pg_lseg = NULL;\n\tnfs_pageio_reset_write_mds(pgio);\n\treturn 1;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_reset_write_mds",
          "args": [
            "pgio"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_write_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1329-1339",
          "snippet": "void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "545-547",
          "snippet": "static inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_MIRROR_COUNT",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_MIRROR_COUNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "110-114",
          "snippet": "static inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_update_layout",
          "args": [
            "pgio->pg_inode",
            "req->wb_context",
            "0",
            "NFS4_MAX_UINT64",
            "IOMODE_RW",
            "GFP_NOFS"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1445-1574",
          "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int\nff_layout_pg_get_mirror_count_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t\t    struct nfs_page *req)\n{\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\tif (pgio->pg_lseg)\n\t\treturn FF_LAYOUT_MIRROR_COUNT(pgio->pg_lseg);\n\n\t/* no lseg means that pnfs is not in use, so no mirroring here */\n\tpnfs_put_lseg(pgio->pg_lseg);\n\tpgio->pg_lseg = NULL;\n\tnfs_pageio_reset_write_mds(pgio);\n\treturn 1;\n}"
  },
  {
    "function_name": "ff_layout_pg_init_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "524-571",
    "snippet": "static void\nff_layout_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs_commit_info cinfo;\n\tstruct nfs4_pnfs_ds *ds;\n\tint i;\n\tint status;\n\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tgoto out_mds;\n\n\tnfs_init_cinfo(&cinfo, pgio->pg_inode, pgio->pg_dreq);\n\tstatus = ff_layout_alloc_commit_info(pgio->pg_lseg, &cinfo, GFP_NOFS);\n\tif (status < 0)\n\t\tgoto out_mds;\n\n\t/* Use a direct mapping of ds_idx to pgio mirror_idx */\n\tif (WARN_ON_ONCE(pgio->pg_mirror_count !=\n\t    FF_LAYOUT_MIRROR_COUNT(pgio->pg_lseg)))\n\t\tgoto out_mds;\n\n\tfor (i = 0; i < pgio->pg_mirror_count; i++) {\n\t\tds = nfs4_ff_layout_prepare_ds(pgio->pg_lseg, i, true);\n\t\tif (!ds)\n\t\t\tgoto out_mds;\n\t\tpgm = &pgio->pg_mirrors[i];\n\t\tmirror = FF_LAYOUT_COMP(pgio->pg_lseg, i);\n\t\tpgm->pg_bsize = mirror->mirror_ds->ds_versions[0].wsize;\n\t}\n\n\treturn;\n\nout_mds:\n\tpnfs_put_lseg(pgio->pg_lseg);\n\tpgio->pg_lseg = NULL;\n\tnfs_pageio_reset_write_mds(pgio);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_reset_write_mds",
          "args": [
            "pgio"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_write_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1329-1339",
          "snippet": "void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "545-547",
          "snippet": "static inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "pgio->pg_lseg",
            "i"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_prepare_ds",
          "args": [
            "pgio->pg_lseg",
            "i",
            "true"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "358-438",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pgio->pg_mirror_count !=\n\t    FF_LAYOUT_MIRROR_COUNT(pgio->pg_lseg)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_MIRROR_COUNT",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_MIRROR_COUNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "110-114",
          "snippet": "static inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_alloc_commit_info",
          "args": [
            "pgio->pg_lseg",
            "&cinfo",
            "GFP_NOFS"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_alloc_commit_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "418-462",
          "snippet": "static int\nff_layout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t    struct nfs_commit_info *cinfo,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_segment *fls = FF_LAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size;\n\n\tif (cinfo->ds->nbuckets != 0) {\n\t\t/* This assumes there is only one RW lseg per file.\n\t\t * To support multiple lseg per file, we need to\n\t\t * change struct pnfs_commit_bucket to allow dynamic\n\t\t * increasing nbuckets.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tsize = ff_layout_get_lseg_count(fls) * FF_LAYOUT_MIRROR_COUNT(lseg);\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\telse {\n\t\tint i;\n\n\t\tspin_lock(cinfo->lock);\n\t\tif (cinfo->ds->nbuckets != 0)\n\t\t\tkfree(buckets);\n\t\telse {\n\t\t\tcinfo->ds->buckets = buckets;\n\t\t\tcinfo->ds->nbuckets = size;\n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t\t\t/* mark direct verifier as unset */\n\t\t\t\tbuckets[i].direct_verf.committed =\n\t\t\t\t\tNFS_INVALID_STABLE_HOW;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(cinfo->lock);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nff_layout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t    struct nfs_commit_info *cinfo,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_segment *fls = FF_LAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size;\n\n\tif (cinfo->ds->nbuckets != 0) {\n\t\t/* This assumes there is only one RW lseg per file.\n\t\t * To support multiple lseg per file, we need to\n\t\t * change struct pnfs_commit_bucket to allow dynamic\n\t\t * increasing nbuckets.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tsize = ff_layout_get_lseg_count(fls) * FF_LAYOUT_MIRROR_COUNT(lseg);\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\telse {\n\t\tint i;\n\n\t\tspin_lock(cinfo->lock);\n\t\tif (cinfo->ds->nbuckets != 0)\n\t\t\tkfree(buckets);\n\t\telse {\n\t\t\tcinfo->ds->buckets = buckets;\n\t\t\tcinfo->ds->nbuckets = size;\n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t\t\t/* mark direct verifier as unset */\n\t\t\t\tbuckets[i].direct_verf.committed =\n\t\t\t\t\tNFS_INVALID_STABLE_HOW;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(cinfo->lock);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo",
          "args": [
            "&cinfo",
            "pgio->pg_inode",
            "pgio->pg_dreq"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "829-837",
          "snippet": "void nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nvoid nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_update_layout",
          "args": [
            "pgio->pg_inode",
            "req->wb_context",
            "0",
            "NFS4_MAX_UINT64",
            "IOMODE_RW",
            "GFP_NOFS"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1445-1574",
          "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs_commit_info cinfo;\n\tstruct nfs4_pnfs_ds *ds;\n\tint i;\n\tint status;\n\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tgoto out_mds;\n\n\tnfs_init_cinfo(&cinfo, pgio->pg_inode, pgio->pg_dreq);\n\tstatus = ff_layout_alloc_commit_info(pgio->pg_lseg, &cinfo, GFP_NOFS);\n\tif (status < 0)\n\t\tgoto out_mds;\n\n\t/* Use a direct mapping of ds_idx to pgio mirror_idx */\n\tif (WARN_ON_ONCE(pgio->pg_mirror_count !=\n\t    FF_LAYOUT_MIRROR_COUNT(pgio->pg_lseg)))\n\t\tgoto out_mds;\n\n\tfor (i = 0; i < pgio->pg_mirror_count; i++) {\n\t\tds = nfs4_ff_layout_prepare_ds(pgio->pg_lseg, i, true);\n\t\tif (!ds)\n\t\t\tgoto out_mds;\n\t\tpgm = &pgio->pg_mirrors[i];\n\t\tmirror = FF_LAYOUT_COMP(pgio->pg_lseg, i);\n\t\tpgm->pg_bsize = mirror->mirror_ds->ds_versions[0].wsize;\n\t}\n\n\treturn;\n\nout_mds:\n\tpnfs_put_lseg(pgio->pg_lseg);\n\tpgio->pg_lseg = NULL;\n\tnfs_pageio_reset_write_mds(pgio);\n}"
  },
  {
    "function_name": "ff_layout_pg_init_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "485-522",
    "snippet": "static void\nff_layout_pg_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_pnfs_ds *ds;\n\tint ds_idx;\n\n\t/* Use full layout for now */\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tgoto out_mds;\n\n\tds = ff_layout_choose_best_ds_for_read(pgio, &ds_idx);\n\tif (!ds)\n\t\tgoto out_mds;\n\tmirror = FF_LAYOUT_COMP(pgio->pg_lseg, ds_idx);\n\n\tpgio->pg_mirror_idx = ds_idx;\n\n\t/* read always uses only one mirror - idx 0 for pgio layer */\n\tpgm = &pgio->pg_mirrors[0];\n\tpgm->pg_bsize = mirror->mirror_ds->ds_versions[0].rsize;\n\n\treturn;\nout_mds:\n\tpnfs_put_lseg(pgio->pg_lseg);\n\tpgio->pg_lseg = NULL;\n\tnfs_pageio_reset_read_mds(pgio);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_reset_read_mds",
          "args": [
            "pgio"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_reset_read_mds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "71-82",
          "snippet": "void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_put_lseg",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_put_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "545-547",
          "snippet": "static inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void pnfs_put_lseg(struct pnfs_layout_segment *lseg)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_COMP",
          "args": [
            "pgio->pg_lseg",
            "ds_idx"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_COMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "102-108",
          "snippet": "static inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_mirror *\nFF_LAYOUT_COMP(struct pnfs_layout_segment *lseg, u32 idx)\n{\n\tif (idx >= FF_LAYOUT_LSEG(lseg)->mirror_array_cnt)\n\t\treturn NULL;\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_choose_best_ds_for_read",
          "args": [
            "pgio",
            "&ds_idx"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_choose_best_ds_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "464-483",
          "snippet": "static struct nfs4_pnfs_ds *\nff_layout_choose_best_ds_for_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t\t  int *best_idx)\n{\n\tstruct nfs4_ff_layout_segment *fls;\n\tstruct nfs4_pnfs_ds *ds;\n\tint idx;\n\n\tfls = FF_LAYOUT_LSEG(pgio->pg_lseg);\n\t/* mirrors are sorted by efficiency */\n\tfor (idx = 0; idx < fls->mirror_array_cnt; idx++) {\n\t\tds = nfs4_ff_layout_prepare_ds(pgio->pg_lseg, idx, false);\n\t\tif (ds) {\n\t\t\t*best_idx = idx;\n\t\t\treturn ds;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs4_pnfs_ds *\nff_layout_choose_best_ds_for_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t\t  int *best_idx)\n{\n\tstruct nfs4_ff_layout_segment *fls;\n\tstruct nfs4_pnfs_ds *ds;\n\tint idx;\n\n\tfls = FF_LAYOUT_LSEG(pgio->pg_lseg);\n\t/* mirrors are sorted by efficiency */\n\tfor (idx = 0; idx < fls->mirror_array_cnt; idx++) {\n\t\tds = nfs4_ff_layout_prepare_ds(pgio->pg_lseg, idx, false);\n\t\tif (ds) {\n\t\t\t*best_idx = idx;\n\t\t\treturn ds;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_update_layout",
          "args": [
            "pgio->pg_inode",
            "req->wb_context",
            "0",
            "NFS4_MAX_UINT64",
            "IOMODE_READ",
            "GFP_KERNEL"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1445-1574",
          "snippet": "struct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstruct pnfs_layout_segment *\npnfs_update_layout(struct inode *ino,\n\t\t   struct nfs_open_context *ctx,\n\t\t   loff_t pos,\n\t\t   u64 count,\n\t\t   enum pnfs_iomode iomode,\n\t\t   gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_range arg = {\n\t\t.iomode = iomode,\n\t\t.offset = pos,\n\t\t.length = count,\n\t};\n\tunsigned pg_offset;\n\tstruct nfs_server *server = NFS_SERVER(ino);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct pnfs_layout_hdr *lo;\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tbool first;\n\n\tif (!pnfs_enabled_sb(NFS_SERVER(ino)))\n\t\tgoto out;\n\n\tif (pnfs_within_mdsthreshold(ctx, ino, iomode))\n\t\tgoto out;\n\nlookup_again:\n\tfirst = false;\n\tspin_lock(&ino->i_lock);\n\tlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\n\tif (lo == NULL) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tgoto out;\n\t}\n\n\t/* Do we even need to bother with this? */\n\tif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\n\t\tdprintk(\"%s matches recall, use MDS\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\t/* if LAYOUTGET already failed once we don't try again */\n\tif (pnfs_layout_io_test_failed(lo, iomode) &&\n\t    !pnfs_should_retry_layoutget(lo))\n\t\tgoto out_unlock;\n\n\tfirst = list_empty(&lo->plh_segs);\n\tif (first) {\n\t\t/* The first layoutget for the file. Need to serialize per\n\t\t * RFC 5661 Errata 3208.\n\t\t */\n\t\tif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t     &lo->plh_flags)) {\n\t\t\tspin_unlock(&ino->i_lock);\n\t\t\twait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tgoto lookup_again;\n\t\t}\n\t} else {\n\t\t/* Check to see if the layout for the given range\n\t\t * already exists\n\t\t */\n\t\tlseg = pnfs_find_lseg(lo, &arg);\n\t\tif (lseg)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Because we free lsegs before sending LAYOUTRETURN, we need to wait\n\t * for LAYOUTRETURN even if first is true.\n\t */\n\tif (!lseg && pnfs_should_retry_layoutget(lo) &&\n\t    test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\n\t\tspin_unlock(&ino->i_lock);\n\t\tdprintk(\"%s wait for layoutreturn\\n\", __func__);\n\t\tif (pnfs_prepare_to_retry_layoutget(lo)) {\n\t\t\tif (first)\n\t\t\t\tpnfs_clear_first_layoutget(lo);\n\t\t\tpnfs_put_layout_hdr(lo);\n\t\t\tdprintk(\"%s retrying\\n\", __func__);\n\t\t\tgoto lookup_again;\n\t\t}\n\t\tgoto out_put_layout_hdr;\n\t}\n\n\tif (pnfs_layoutgets_blocked(lo, &arg, 0))\n\t\tgoto out_unlock;\n\tatomic_inc(&lo->plh_outstanding);\n\tspin_unlock(&ino->i_lock);\n\n\tif (list_empty(&lo->plh_layouts)) {\n\t\t/* The lo must be on the clp list if there is any\n\t\t * chance of a CB_LAYOUTRECALL(FILE) coming in.\n\t\t */\n\t\tspin_lock(&clp->cl_lock);\n\t\tif (list_empty(&lo->plh_layouts))\n\t\t\tlist_add_tail(&lo->plh_layouts, &server->layouts);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n\n\tpg_offset = arg.offset & ~PAGE_CACHE_MASK;\n\tif (pg_offset) {\n\t\targ.offset -= pg_offset;\n\t\targ.length += pg_offset;\n\t}\n\tif (arg.length != NFS4_MAX_UINT64)\n\t\targ.length = PAGE_CACHE_ALIGN(arg.length);\n\n\tlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\n\tpnfs_clear_retry_layoutget(lo);\n\tatomic_dec(&lo->plh_outstanding);\nout_put_layout_hdr:\n\tif (first)\n\t\tpnfs_clear_first_layoutget(lo);\n\tpnfs_put_layout_hdr(lo);\nout:\n\tdprintk(\"%s: inode %s/%llu pNFS layout segment %s for \"\n\t\t\t\"(%s, offset: %llu, length: %llu)\\n\",\n\t\t\t__func__, ino->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(ino),\n\t\t\tlseg == NULL ? \"not found\" : \"found\",\n\t\t\tiomode==IOMODE_RW ?  \"read/write\" : \"read-only\",\n\t\t\t(unsigned long long)pos,\n\t\t\t(unsigned long long)count);\n\treturn lseg;\nout_unlock:\n\tspin_unlock(&ino->i_lock);\n\tgoto out_put_layout_hdr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_pg_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\tstruct nfs_page *req)\n{\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tstruct nfs4_pnfs_ds *ds;\n\tint ds_idx;\n\n\t/* Use full layout for now */\n\tif (!pgio->pg_lseg)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   NFS4_MAX_UINT64,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tgoto out_mds;\n\n\tds = ff_layout_choose_best_ds_for_read(pgio, &ds_idx);\n\tif (!ds)\n\t\tgoto out_mds;\n\tmirror = FF_LAYOUT_COMP(pgio->pg_lseg, ds_idx);\n\n\tpgio->pg_mirror_idx = ds_idx;\n\n\t/* read always uses only one mirror - idx 0 for pgio layer */\n\tpgm = &pgio->pg_mirrors[0];\n\tpgm->pg_bsize = mirror->mirror_ds->ds_versions[0].rsize;\n\n\treturn;\nout_mds:\n\tpnfs_put_lseg(pgio->pg_lseg);\n\tpgio->pg_lseg = NULL;\n\tnfs_pageio_reset_read_mds(pgio);\n}"
  },
  {
    "function_name": "ff_layout_choose_best_ds_for_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "464-483",
    "snippet": "static struct nfs4_pnfs_ds *\nff_layout_choose_best_ds_for_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t\t  int *best_idx)\n{\n\tstruct nfs4_ff_layout_segment *fls;\n\tstruct nfs4_pnfs_ds *ds;\n\tint idx;\n\n\tfls = FF_LAYOUT_LSEG(pgio->pg_lseg);\n\t/* mirrors are sorted by efficiency */\n\tfor (idx = 0; idx < fls->mirror_array_cnt; idx++) {\n\t\tds = nfs4_ff_layout_prepare_ds(pgio->pg_lseg, idx, false);\n\t\tif (ds) {\n\t\t\t*best_idx = idx;\n\t\t\treturn ds;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_ff_layout_prepare_ds",
          "args": [
            "pgio->pg_lseg",
            "idx",
            "false"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_prepare_ds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "358-438",
          "snippet": "struct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;",
            "static unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nstatic unsigned int dataserver_timeo = NFS4_DEF_DS_TIMEO;\nstatic unsigned int dataserver_retrans = NFS4_DEF_DS_RETRANS;\n\nstruct nfs4_pnfs_ds *\nnfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,\n\t\t\t  bool fail_return)\n{\n\tstruct nfs4_ff_layout_mirror *mirror = FF_LAYOUT_COMP(lseg, ds_idx);\n\tstruct nfs4_pnfs_ds *ds = NULL;\n\tstruct nfs4_deviceid_node *devid;\n\tstruct inode *ino = lseg->pls_layout->plh_inode;\n\tstruct nfs_server *s = NFS_SERVER(ino);\n\tunsigned int max_payload;\n\trpc_authflavor_t flavor;\n\n\tif (mirror == NULL || mirror->mirror_ds == NULL ||\n\t    mirror->mirror_ds->ds == NULL) {\n\t\tprintk(KERN_ERR \"NFS: %s: No data server for offset index %d\\n\",\n\t\t\t__func__, ds_idx);\n\t\tif (mirror && mirror->mirror_ds) {\n\t\t\tdevid = &mirror->mirror_ds->id_node;\n\t\t\tpnfs_generic_mark_devid_invalid(devid);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdevid = &mirror->mirror_ds->id_node;\n\tif (ff_layout_test_devid_unavailable(devid))\n\t\tgoto out;\n\n\tds = mirror->mirror_ds->ds;\n\t/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */\n\tsmp_rmb();\n\tif (ds->ds_clp)\n\t\tgoto out;\n\n\tflavor = nfs4_ff_layout_choose_authflavor(mirror);\n\n\t/* FIXME: For now we assume the server sent only one version of NFS\n\t * to use for the DS.\n\t */\n\tnfs4_pnfs_ds_connect(s, ds, devid, dataserver_timeo,\n\t\t\t     dataserver_retrans,\n\t\t\t     mirror->mirror_ds->ds_versions[0].version,\n\t\t\t     mirror->mirror_ds->ds_versions[0].minor_version,\n\t\t\t     flavor);\n\n\t/* connect success, check rsize/wsize limit */\n\tif (ds->ds_clp) {\n\t\tmax_payload =\n\t\t\tnfs_block_size(rpc_max_payload(ds->ds_clp->cl_rpcclient),\n\t\t\t\t       NULL);\n\t\tif (mirror->mirror_ds->ds_versions[0].rsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].rsize = max_payload;\n\t\tif (mirror->mirror_ds->ds_versions[0].wsize > max_payload)\n\t\t\tmirror->mirror_ds->ds_versions[0].wsize = max_payload;\n\t} else {\n\t\tff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t\t mirror, lseg->pls_range.offset,\n\t\t\t\t\t lseg->pls_range.length, NFS4ERR_NXIO,\n\t\t\t\t\t OP_ILLEGAL, GFP_NOIO);\n\t\tif (fail_return) {\n\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tpnfs_set_retry_layoutget(lseg->pls_layout);\n\t\t\telse\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\n\t\t} else {\n\t\t\tif (ff_layout_has_available_ds(lseg))\n\t\t\t\tset_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,\n\t\t\t\t\t&lseg->pls_layout->plh_flags);\n\t\t\telse {\n\t\t\t\tpnfs_error_mark_layout_for_return(ino, lseg);\n\t\t\t\tpnfs_clear_retry_layoutget(lseg->pls_layout);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ff_layout_update_mirror_cred(mirror, ds))\n\t\tds = NULL;\nout:\n\treturn ds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_LSEG",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "78-84",
          "snippet": "static inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct nfs4_pnfs_ds *\nff_layout_choose_best_ds_for_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t\t  int *best_idx)\n{\n\tstruct nfs4_ff_layout_segment *fls;\n\tstruct nfs4_pnfs_ds *ds;\n\tint idx;\n\n\tfls = FF_LAYOUT_LSEG(pgio->pg_lseg);\n\t/* mirrors are sorted by efficiency */\n\tfor (idx = 0; idx < fls->mirror_array_cnt; idx++) {\n\t\tds = nfs4_ff_layout_prepare_ds(pgio->pg_lseg, idx, false);\n\t\tif (ds) {\n\t\t\t*best_idx = idx;\n\t\t\treturn ds;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ff_layout_alloc_commit_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "418-462",
    "snippet": "static int\nff_layout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t    struct nfs_commit_info *cinfo,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_segment *fls = FF_LAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size;\n\n\tif (cinfo->ds->nbuckets != 0) {\n\t\t/* This assumes there is only one RW lseg per file.\n\t\t * To support multiple lseg per file, we need to\n\t\t * change struct pnfs_commit_bucket to allow dynamic\n\t\t * increasing nbuckets.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tsize = ff_layout_get_lseg_count(fls) * FF_LAYOUT_MIRROR_COUNT(lseg);\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\telse {\n\t\tint i;\n\n\t\tspin_lock(cinfo->lock);\n\t\tif (cinfo->ds->nbuckets != 0)\n\t\t\tkfree(buckets);\n\t\telse {\n\t\t\tcinfo->ds->buckets = buckets;\n\t\t\tcinfo->ds->nbuckets = size;\n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t\t\t/* mark direct verifier as unset */\n\t\t\t\tbuckets[i].direct_verf.committed =\n\t\t\t\t\tNFS_INVALID_STABLE_HOW;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(cinfo->lock);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&buckets[i].committing"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&buckets[i].written"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buckets"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "size",
            "sizeof(struct pnfs_commit_bucket)",
            "gfp_flags"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_MIRROR_COUNT",
          "args": [
            "lseg"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_MIRROR_COUNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "110-114",
          "snippet": "static inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline u32\nFF_LAYOUT_MIRROR_COUNT(struct pnfs_layout_segment *lseg)\n{\n\treturn FF_LAYOUT_LSEG(lseg)->mirror_array_cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_get_lseg_count",
          "args": [
            "fls"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_get_lseg_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "412-416",
          "snippet": "static int\nff_layout_get_lseg_count(struct nfs4_ff_layout_segment *fls)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nff_layout_get_lseg_count(struct nfs4_ff_layout_segment *fls)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "78-84",
          "snippet": "static inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nff_layout_alloc_commit_info(struct pnfs_layout_segment *lseg,\n\t\t\t    struct nfs_commit_info *cinfo,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_segment *fls = FF_LAYOUT_LSEG(lseg);\n\tstruct pnfs_commit_bucket *buckets;\n\tint size;\n\n\tif (cinfo->ds->nbuckets != 0) {\n\t\t/* This assumes there is only one RW lseg per file.\n\t\t * To support multiple lseg per file, we need to\n\t\t * change struct pnfs_commit_bucket to allow dynamic\n\t\t * increasing nbuckets.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tsize = ff_layout_get_lseg_count(fls) * FF_LAYOUT_MIRROR_COUNT(lseg);\n\n\tbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\n\t\t\t  gfp_flags);\n\tif (!buckets)\n\t\treturn -ENOMEM;\n\telse {\n\t\tint i;\n\n\t\tspin_lock(cinfo->lock);\n\t\tif (cinfo->ds->nbuckets != 0)\n\t\t\tkfree(buckets);\n\t\telse {\n\t\t\tcinfo->ds->buckets = buckets;\n\t\t\tcinfo->ds->nbuckets = size;\n\t\t\tfor (i = 0; i < size; i++) {\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].written);\n\t\t\t\tINIT_LIST_HEAD(&buckets[i].committing);\n\t\t\t\t/* mark direct verifier as unset */\n\t\t\t\tbuckets[i].direct_verf.committed =\n\t\t\t\t\tNFS_INVALID_STABLE_HOW;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(cinfo->lock);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "ff_layout_get_lseg_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "412-416",
    "snippet": "static int\nff_layout_get_lseg_count(struct nfs4_ff_layout_segment *fls)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\nff_layout_get_lseg_count(struct nfs4_ff_layout_segment *fls)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "ff_layout_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "375-409",
    "snippet": "static void\nff_layout_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_segment *fls = FF_LAYOUT_LSEG(lseg);\n\tint i;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\tif (fls->mirror_array[i]) {\n\t\t\tnfs4_ff_layout_put_deviceid(fls->mirror_array[i]->mirror_ds);\n\t\t\tfls->mirror_array[i]->mirror_ds = NULL;\n\t\t\tif (fls->mirror_array[i]->cred) {\n\t\t\t\tput_rpccred(fls->mirror_array[i]->cred);\n\t\t\t\tfls->mirror_array[i]->cred = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lseg->pls_range.iomode == IOMODE_RW) {\n\t\tstruct nfs4_flexfile_layout *ffl;\n\t\tstruct inode *inode;\n\n\t\tffl = FF_LAYOUT_FROM_HDR(lseg->pls_layout);\n\t\tinode = ffl->generic_hdr.plh_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!ff_layout_has_rw_segments(lseg->pls_layout)) {\n\t\t\tffl->commit_info.nbuckets = 0;\n\t\t\tkfree(ffl->commit_info.buckets);\n\t\t\tffl->commit_info.buckets = NULL;\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\t_ff_layout_free_lseg(fls);\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ff_layout_free_lseg",
          "args": [
            "fls"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "_ff_layout_free_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "175-181",
          "snippet": "static void _ff_layout_free_lseg(struct nfs4_ff_layout_segment *fls)\n{\n\tif (fls) {\n\t\tff_layout_free_mirror_array(fls);\n\t\tkfree(fls);\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void _ff_layout_free_lseg(struct nfs4_ff_layout_segment *fls)\n{\n\tif (fls) {\n\t\tff_layout_free_mirror_array(fls);\n\t\tkfree(fls);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ffl->commit_info.buckets"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_has_rw_segments",
          "args": [
            "lseg->pls_layout"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_has_rw_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "364-373",
          "snippet": "static bool ff_layout_has_rw_segments(struct pnfs_layout_hdr *layout)\n{\n\tstruct pnfs_layout_segment *lseg;\n\n\tlist_for_each_entry(lseg, &layout->plh_segs, pls_list)\n\t\tif (lseg->pls_range.iomode == IOMODE_RW)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool ff_layout_has_rw_segments(struct pnfs_layout_hdr *layout)\n{\n\tstruct pnfs_layout_segment *lseg;\n\n\tlist_for_each_entry(lseg, &layout->plh_segs, pls_list)\n\t\tif (lseg->pls_range.iomode == IOMODE_RW)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_FROM_HDR",
          "args": [
            "lseg->pls_layout"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "fls->mirror_array[i]->cred"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_put_deviceid",
          "args": [
            "fls->mirror_array[i]->mirror_ds"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_put_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "23-27",
          "snippet": "void nfs4_ff_layout_put_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tif (mirror_ds)\n\t\tnfs4_put_deviceid_node(&mirror_ds->id_node);\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid nfs4_ff_layout_put_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tif (mirror_ds)\n\t\tnfs4_put_deviceid_node(&mirror_ds->id_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_LSEG",
          "args": [
            "lseg"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "78-84",
          "snippet": "static inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_segment *\nFF_LAYOUT_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg,\n\t\t\t    struct nfs4_ff_layout_segment,\n\t\t\t    generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tstruct nfs4_ff_layout_segment *fls = FF_LAYOUT_LSEG(lseg);\n\tint i;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\tif (fls->mirror_array[i]) {\n\t\t\tnfs4_ff_layout_put_deviceid(fls->mirror_array[i]->mirror_ds);\n\t\t\tfls->mirror_array[i]->mirror_ds = NULL;\n\t\t\tif (fls->mirror_array[i]->cred) {\n\t\t\t\tput_rpccred(fls->mirror_array[i]->cred);\n\t\t\t\tfls->mirror_array[i]->cred = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lseg->pls_range.iomode == IOMODE_RW) {\n\t\tstruct nfs4_flexfile_layout *ffl;\n\t\tstruct inode *inode;\n\n\t\tffl = FF_LAYOUT_FROM_HDR(lseg->pls_layout);\n\t\tinode = ffl->generic_hdr.plh_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!ff_layout_has_rw_segments(lseg->pls_layout)) {\n\t\t\tffl->commit_info.nbuckets = 0;\n\t\t\tkfree(ffl->commit_info.buckets);\n\t\t\tffl->commit_info.buckets = NULL;\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\t_ff_layout_free_lseg(fls);\n}"
  },
  {
    "function_name": "ff_layout_has_rw_segments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "364-373",
    "snippet": "static bool ff_layout_has_rw_segments(struct pnfs_layout_hdr *layout)\n{\n\tstruct pnfs_layout_segment *lseg;\n\n\tlist_for_each_entry(lseg, &layout->plh_segs, pls_list)\n\t\tif (lseg->pls_range.iomode == IOMODE_RW)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lseg",
            "&layout->plh_segs",
            "pls_list"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic bool ff_layout_has_rw_segments(struct pnfs_layout_hdr *layout)\n{\n\tstruct pnfs_layout_segment *lseg;\n\n\tlist_for_each_entry(lseg, &layout->plh_segs, pls_list)\n\t\tif (lseg->pls_range.iomode == IOMODE_RW)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "ff_layout_alloc_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "199-362",
    "snippet": "static struct pnfs_layout_segment *\nff_layout_alloc_lseg(struct pnfs_layout_hdr *lh,\n\t\t     struct nfs4_layoutget_res *lgr,\n\t\t     gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_segment *ret;\n\tstruct nfs4_ff_layout_segment *fls = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tu64 stripe_unit;\n\tu32 mirror_array_cnt;\n\t__be32 *p;\n\tint i, rc;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages,\n\t\t\t      lgr->layoutp->len);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* stripe unit and mirror_array_cnt */\n\trc = -EIO;\n\tp = xdr_inline_decode(&stream, 8 + 4);\n\tif (!p)\n\t\tgoto out_err_free;\n\n\tp = xdr_decode_hyper(p, &stripe_unit);\n\tmirror_array_cnt = be32_to_cpup(p++);\n\tdprintk(\"%s: stripe_unit=%llu mirror_array_cnt=%u\\n\", __func__,\n\t\tstripe_unit, mirror_array_cnt);\n\n\tif (mirror_array_cnt > NFS4_FLEXFILE_LAYOUT_MAX_MIRROR_CNT ||\n\t    mirror_array_cnt == 0)\n\t\tgoto out_err_free;\n\n\trc = -ENOMEM;\n\tfls = kzalloc(sizeof(*fls), gfp_flags);\n\tif (!fls)\n\t\tgoto out_err_free;\n\n\tfls->mirror_array_cnt = mirror_array_cnt;\n\tfls->stripe_unit = stripe_unit;\n\tfls->mirror_array = kcalloc(fls->mirror_array_cnt,\n\t\t\t\t    sizeof(fls->mirror_array[0]), gfp_flags);\n\tif (fls->mirror_array == NULL)\n\t\tgoto out_err_free;\n\n\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\tstruct nfs4_deviceid devid;\n\t\tstruct nfs4_deviceid_node *idnode;\n\t\tu32 ds_count;\n\t\tu32 fh_count;\n\t\tint j;\n\n\t\trc = -EIO;\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tds_count = be32_to_cpup(p);\n\n\t\t/* FIXME: allow for striping? */\n\t\tif (ds_count != 1)\n\t\t\tgoto out_err_free;\n\n\t\tfls->mirror_array[i] =\n\t\t\tkzalloc(sizeof(struct nfs4_ff_layout_mirror),\n\t\t\t\tgfp_flags);\n\t\tif (fls->mirror_array[i] == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tspin_lock_init(&fls->mirror_array[i]->lock);\n\t\tfls->mirror_array[i]->ds_count = ds_count;\n\n\t\t/* deviceid */\n\t\trc = decode_deviceid(&stream, &devid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\tidnode = nfs4_find_get_deviceid(NFS_SERVER(lh->plh_inode),\n\t\t\t\t\t\t&devid, lh->plh_lc_cred,\n\t\t\t\t\t\tgfp_flags);\n\t\t/*\n\t\t * upon success, mirror_ds is allocated by previous\n\t\t * getdeviceinfo, or newly by .alloc_deviceid_node\n\t\t * nfs4_find_get_deviceid failure is indeed getdeviceinfo falure\n\t\t */\n\t\tif (idnode)\n\t\t\tfls->mirror_array[i]->mirror_ds =\n\t\t\t\tFF_LAYOUT_MIRROR_DS(idnode);\n\t\telse\n\t\t\tgoto out_err_free;\n\n\t\t/* efficiency */\n\t\trc = -EIO;\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tfls->mirror_array[i]->efficiency = be32_to_cpup(p);\n\n\t\t/* stateid */\n\t\trc = decode_stateid(&stream, &fls->mirror_array[i]->stateid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\t/* fh */\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tfh_count = be32_to_cpup(p);\n\n\t\tfls->mirror_array[i]->fh_versions =\n\t\t\tkzalloc(fh_count * sizeof(struct nfs_fh),\n\t\t\t\tgfp_flags);\n\t\tif (fls->mirror_array[i]->fh_versions == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tfor (j = 0; j < fh_count; j++) {\n\t\t\trc = decode_nfs_fh(&stream,\n\t\t\t\t\t   &fls->mirror_array[i]->fh_versions[j]);\n\t\t\tif (rc)\n\t\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tfls->mirror_array[i]->fh_versions_cnt = fh_count;\n\n\t\t/* user */\n\t\trc = decode_name(&stream, &fls->mirror_array[i]->uid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\t/* group */\n\t\trc = decode_name(&stream, &fls->mirror_array[i]->gid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\tdprintk(\"%s: uid %d gid %d\\n\", __func__,\n\t\t\tfls->mirror_array[i]->uid,\n\t\t\tfls->mirror_array[i]->gid);\n\t}\n\n\tff_layout_sort_mirrors(fls);\n\trc = ff_layout_check_layout(lgr);\n\tif (rc)\n\t\tgoto out_err_free;\n\n\tret = &fls->generic_hdr;\n\tdprintk(\"<-- %s (success)\\n\", __func__);\nout_free_page:\n\t__free_page(scratch);\n\treturn ret;\nout_err_free:\n\t_ff_layout_free_lseg(fls);\n\tret = ERR_PTR(rc);\n\tdprintk(\"<-- %s (%d)\\n\", __func__, rc);\n\tgoto out_free_page;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ff_layout_free_lseg",
          "args": [
            "fls"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "_ff_layout_free_lseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "175-181",
          "snippet": "static void _ff_layout_free_lseg(struct nfs4_ff_layout_segment *fls)\n{\n\tif (fls) {\n\t\tff_layout_free_mirror_array(fls);\n\t\tkfree(fls);\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void _ff_layout_free_lseg(struct nfs4_ff_layout_segment *fls)\n{\n\tif (fls) {\n\t\tff_layout_free_mirror_array(fls);\n\t\tkfree(fls);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"<-- %s (success)\\n\"",
            "__func__"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_check_layout",
          "args": [
            "lgr"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_check_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "157-173",
          "snippet": "static int ff_layout_check_layout(struct nfs4_layoutget_res *lgr)\n{\n\tint ret = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tret = -EINVAL;\n\t}\n\n\tdprintk(\"--> %s returns %d\\n\", __func__, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_check_layout(struct nfs4_layoutget_res *lgr)\n{\n\tint ret = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tret = -EINVAL;\n\t}\n\n\tdprintk(\"--> %s returns %d\\n\", __func__, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ff_layout_sort_mirrors",
          "args": [
            "fls"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_sort_mirrors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "183-197",
          "snippet": "static void ff_layout_sort_mirrors(struct nfs4_ff_layout_segment *fls)\n{\n\tstruct nfs4_ff_layout_mirror *tmp;\n\tint i, j;\n\n\tfor (i = 0; i < fls->mirror_array_cnt - 1; i++) {\n\t\tfor (j = i + 1; j < fls->mirror_array_cnt; j++)\n\t\t\tif (fls->mirror_array[i]->efficiency <\n\t\t\t    fls->mirror_array[j]->efficiency) {\n\t\t\t\ttmp = fls->mirror_array[i];\n\t\t\t\tfls->mirror_array[i] = fls->mirror_array[j];\n\t\t\t\tfls->mirror_array[j] = tmp;\n\t\t\t}\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_sort_mirrors(struct nfs4_ff_layout_segment *fls)\n{\n\tstruct nfs4_ff_layout_mirror *tmp;\n\tint i, j;\n\n\tfor (i = 0; i < fls->mirror_array_cnt - 1; i++) {\n\t\tfor (j = i + 1; j < fls->mirror_array_cnt; j++)\n\t\t\tif (fls->mirror_array[i]->efficiency <\n\t\t\t    fls->mirror_array[j]->efficiency) {\n\t\t\t\ttmp = fls->mirror_array[i];\n\t\t\t\tfls->mirror_array[i] = fls->mirror_array[j];\n\t\t\t\tfls->mirror_array[j] = tmp;\n\t\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: uid %d gid %d\\n\"",
            "__func__",
            "fls->mirror_array[i]->uid",
            "fls->mirror_array[i]->gid"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_name",
          "args": [
            "&stream",
            "&fls->mirror_array[i]->gid"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "decode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "110-135",
          "snippet": "static int\ndecode_name(struct xdr_stream *xdr, u32 *id)\n{\n\t__be32 *p;\n\tint len;\n\n\t/* opaque_length(4)*/\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tlen = be32_to_cpup(p++);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tdprintk(\"%s: len %u\\n\", __func__, len);\n\n\t/* opaque body */\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\n\tif (!nfs_map_string_to_numeric((char *)p, len, id))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\ndecode_name(struct xdr_stream *xdr, u32 *id)\n{\n\t__be32 *p;\n\tint len;\n\n\t/* opaque_length(4)*/\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tlen = be32_to_cpup(p++);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tdprintk(\"%s: len %u\\n\", __func__, len);\n\n\t/* opaque body */\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\n\tif (!nfs_map_string_to_numeric((char *)p, len, id))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_nfs_fh",
          "args": [
            "&stream",
            "&fls->mirror_array[i]->fh_versions[j]"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "decode_nfs_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "79-100",
          "snippet": "static int decode_nfs_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tfh->size = be32_to_cpup(p++);\n\tif (fh->size > sizeof(struct nfs_fh)) {\n\t\tprintk(KERN_ERR \"NFS flexfiles: Too big fh received %d\\n\",\n\t\t       fh->size);\n\t\treturn -EOVERFLOW;\n\t}\n\t/* fh.data */\n\tp = xdr_inline_decode(xdr, fh->size);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(&fh->data, p, fh->size);\n\tdprintk(\"%s: fh len %d\\n\", __func__, fh->size);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int decode_nfs_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tfh->size = be32_to_cpup(p++);\n\tif (fh->size > sizeof(struct nfs_fh)) {\n\t\tprintk(KERN_ERR \"NFS flexfiles: Too big fh received %d\\n\",\n\t\t       fh->size);\n\t\treturn -EOVERFLOW;\n\t}\n\t/* fh.data */\n\tp = xdr_inline_decode(xdr, fh->size);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(&fh->data, p, fh->size);\n\tdprintk(\"%s: fh len %d\\n\", __func__, fh->size);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "fh_count * sizeof(struct nfs_fh)",
            "gfp_flags"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_stateid",
          "args": [
            "&stream",
            "&fls->mirror_array[i]->stateid"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "54-65",
          "snippet": "static int decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOBUFS;\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\tdprintk(\"%s: stateid id= [%x%x%x%x]\\n\", __func__,\n\t\tp[0], p[1], p[2], p[3]);\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOBUFS;\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\tdprintk(\"%s: stateid id= [%x%x%x%x]\\n\", __func__,\n\t\tp[0], p[1], p[2], p[3]);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_MIRROR_DS",
          "args": [
            "idnode"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_MIRROR_DS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "96-100",
          "snippet": "static inline struct nfs4_ff_layout_ds *\nFF_LAYOUT_MIRROR_DS(struct nfs4_deviceid_node *node)\n{\n\treturn container_of(node, struct nfs4_ff_layout_ds, id_node);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_ff_layout_ds *\nFF_LAYOUT_MIRROR_DS(struct nfs4_deviceid_node *node)\n{\n\treturn container_of(node, struct nfs4_ff_layout_ds, id_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_find_get_deviceid",
          "args": [
            "NFS_SERVER(lh->plh_inode)",
            "&devid",
            "lh->plh_lc_cred",
            "gfp_flags"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "184-212",
          "snippet": "struct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];",
            "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nstruct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "lh->plh_inode"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_deviceid",
          "args": [
            "&stream",
            "&devid"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "decode_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "67-77",
          "snippet": "static int decode_deviceid(struct xdr_stream *xdr, struct nfs4_deviceid *devid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_DEVICEID4_SIZE);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(devid, p, NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(devid);\n\treturn 0;\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int decode_deviceid(struct xdr_stream *xdr, struct nfs4_deviceid *devid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_DEVICEID4_SIZE);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(devid, p, NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(devid);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fls->mirror_array[i]->lock"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct nfs4_ff_layout_mirror)",
            "gfp_flags"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "4"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "fls->mirror_array_cnt",
            "sizeof(fls->mirror_array[0])",
            "gfp_flags"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fls)",
            "gfp_flags"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: stripe_unit=%llu mirror_array_cnt=%u\\n\"",
            "__func__",
            "stripe_unit",
            "mirror_array_cnt"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&stripe_unit"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&stream",
            "8 + 4"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&stream",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode_pages",
          "args": [
            "&stream",
            "&buf",
            "lgr->layoutp->pages",
            "lgr->layoutp->len"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_flags"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_segment *\nff_layout_alloc_lseg(struct pnfs_layout_hdr *lh,\n\t\t     struct nfs4_layoutget_res *lgr,\n\t\t     gfp_t gfp_flags)\n{\n\tstruct pnfs_layout_segment *ret;\n\tstruct nfs4_ff_layout_segment *fls = NULL;\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tu64 stripe_unit;\n\tu32 mirror_array_cnt;\n\t__be32 *p;\n\tint i, rc;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tscratch = alloc_page(gfp_flags);\n\tif (!scratch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\txdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages,\n\t\t\t      lgr->layoutp->len);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\t/* stripe unit and mirror_array_cnt */\n\trc = -EIO;\n\tp = xdr_inline_decode(&stream, 8 + 4);\n\tif (!p)\n\t\tgoto out_err_free;\n\n\tp = xdr_decode_hyper(p, &stripe_unit);\n\tmirror_array_cnt = be32_to_cpup(p++);\n\tdprintk(\"%s: stripe_unit=%llu mirror_array_cnt=%u\\n\", __func__,\n\t\tstripe_unit, mirror_array_cnt);\n\n\tif (mirror_array_cnt > NFS4_FLEXFILE_LAYOUT_MAX_MIRROR_CNT ||\n\t    mirror_array_cnt == 0)\n\t\tgoto out_err_free;\n\n\trc = -ENOMEM;\n\tfls = kzalloc(sizeof(*fls), gfp_flags);\n\tif (!fls)\n\t\tgoto out_err_free;\n\n\tfls->mirror_array_cnt = mirror_array_cnt;\n\tfls->stripe_unit = stripe_unit;\n\tfls->mirror_array = kcalloc(fls->mirror_array_cnt,\n\t\t\t\t    sizeof(fls->mirror_array[0]), gfp_flags);\n\tif (fls->mirror_array == NULL)\n\t\tgoto out_err_free;\n\n\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\tstruct nfs4_deviceid devid;\n\t\tstruct nfs4_deviceid_node *idnode;\n\t\tu32 ds_count;\n\t\tu32 fh_count;\n\t\tint j;\n\n\t\trc = -EIO;\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tds_count = be32_to_cpup(p);\n\n\t\t/* FIXME: allow for striping? */\n\t\tif (ds_count != 1)\n\t\t\tgoto out_err_free;\n\n\t\tfls->mirror_array[i] =\n\t\t\tkzalloc(sizeof(struct nfs4_ff_layout_mirror),\n\t\t\t\tgfp_flags);\n\t\tif (fls->mirror_array[i] == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tspin_lock_init(&fls->mirror_array[i]->lock);\n\t\tfls->mirror_array[i]->ds_count = ds_count;\n\n\t\t/* deviceid */\n\t\trc = decode_deviceid(&stream, &devid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\tidnode = nfs4_find_get_deviceid(NFS_SERVER(lh->plh_inode),\n\t\t\t\t\t\t&devid, lh->plh_lc_cred,\n\t\t\t\t\t\tgfp_flags);\n\t\t/*\n\t\t * upon success, mirror_ds is allocated by previous\n\t\t * getdeviceinfo, or newly by .alloc_deviceid_node\n\t\t * nfs4_find_get_deviceid failure is indeed getdeviceinfo falure\n\t\t */\n\t\tif (idnode)\n\t\t\tfls->mirror_array[i]->mirror_ds =\n\t\t\t\tFF_LAYOUT_MIRROR_DS(idnode);\n\t\telse\n\t\t\tgoto out_err_free;\n\n\t\t/* efficiency */\n\t\trc = -EIO;\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tfls->mirror_array[i]->efficiency = be32_to_cpup(p);\n\n\t\t/* stateid */\n\t\trc = decode_stateid(&stream, &fls->mirror_array[i]->stateid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\t/* fh */\n\t\tp = xdr_inline_decode(&stream, 4);\n\t\tif (!p)\n\t\t\tgoto out_err_free;\n\t\tfh_count = be32_to_cpup(p);\n\n\t\tfls->mirror_array[i]->fh_versions =\n\t\t\tkzalloc(fh_count * sizeof(struct nfs_fh),\n\t\t\t\tgfp_flags);\n\t\tif (fls->mirror_array[i]->fh_versions == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tfor (j = 0; j < fh_count; j++) {\n\t\t\trc = decode_nfs_fh(&stream,\n\t\t\t\t\t   &fls->mirror_array[i]->fh_versions[j]);\n\t\t\tif (rc)\n\t\t\t\tgoto out_err_free;\n\t\t}\n\n\t\tfls->mirror_array[i]->fh_versions_cnt = fh_count;\n\n\t\t/* user */\n\t\trc = decode_name(&stream, &fls->mirror_array[i]->uid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\t/* group */\n\t\trc = decode_name(&stream, &fls->mirror_array[i]->gid);\n\t\tif (rc)\n\t\t\tgoto out_err_free;\n\n\t\tdprintk(\"%s: uid %d gid %d\\n\", __func__,\n\t\t\tfls->mirror_array[i]->uid,\n\t\t\tfls->mirror_array[i]->gid);\n\t}\n\n\tff_layout_sort_mirrors(fls);\n\trc = ff_layout_check_layout(lgr);\n\tif (rc)\n\t\tgoto out_err_free;\n\n\tret = &fls->generic_hdr;\n\tdprintk(\"<-- %s (success)\\n\", __func__);\nout_free_page:\n\t__free_page(scratch);\n\treturn ret;\nout_err_free:\n\t_ff_layout_free_lseg(fls);\n\tret = ERR_PTR(rc);\n\tdprintk(\"<-- %s (%d)\\n\", __func__, rc);\n\tgoto out_free_page;\n}"
  },
  {
    "function_name": "ff_layout_sort_mirrors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "183-197",
    "snippet": "static void ff_layout_sort_mirrors(struct nfs4_ff_layout_segment *fls)\n{\n\tstruct nfs4_ff_layout_mirror *tmp;\n\tint i, j;\n\n\tfor (i = 0; i < fls->mirror_array_cnt - 1; i++) {\n\t\tfor (j = i + 1; j < fls->mirror_array_cnt; j++)\n\t\t\tif (fls->mirror_array[i]->efficiency <\n\t\t\t    fls->mirror_array[j]->efficiency) {\n\t\t\t\ttmp = fls->mirror_array[i];\n\t\t\t\tfls->mirror_array[i] = fls->mirror_array[j];\n\t\t\t\tfls->mirror_array[j] = tmp;\n\t\t\t}\n\t}\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_sort_mirrors(struct nfs4_ff_layout_segment *fls)\n{\n\tstruct nfs4_ff_layout_mirror *tmp;\n\tint i, j;\n\n\tfor (i = 0; i < fls->mirror_array_cnt - 1; i++) {\n\t\tfor (j = i + 1; j < fls->mirror_array_cnt; j++)\n\t\t\tif (fls->mirror_array[i]->efficiency <\n\t\t\t    fls->mirror_array[j]->efficiency) {\n\t\t\t\ttmp = fls->mirror_array[i];\n\t\t\t\tfls->mirror_array[i] = fls->mirror_array[j];\n\t\t\t\tfls->mirror_array[j] = tmp;\n\t\t\t}\n\t}\n}"
  },
  {
    "function_name": "_ff_layout_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "175-181",
    "snippet": "static void _ff_layout_free_lseg(struct nfs4_ff_layout_segment *fls)\n{\n\tif (fls) {\n\t\tff_layout_free_mirror_array(fls);\n\t\tkfree(fls);\n\t}\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fls"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ff_layout_free_mirror_array",
          "args": [
            "fls"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ff_layout_free_mirror_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
          "lines": "137-155",
          "snippet": "static void ff_layout_free_mirror_array(struct nfs4_ff_layout_segment *fls)\n{\n\tint i;\n\n\tif (fls->mirror_array) {\n\t\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\t\t/* normally mirror_ds is freed in\n\t\t\t * .free_deviceid_node but we still do it here\n\t\t\t * for .alloc_lseg error path */\n\t\t\tif (fls->mirror_array[i]) {\n\t\t\t\tkfree(fls->mirror_array[i]->fh_versions);\n\t\t\t\tnfs4_ff_layout_put_deviceid(fls->mirror_array[i]->mirror_ds);\n\t\t\t\tkfree(fls->mirror_array[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(fls->mirror_array);\n\t\tfls->mirror_array = NULL;\n\t}\n}",
          "includes": [
            "#include \"../nfs.h\"",
            "#include \"../iostat.h\"",
            "#include \"../nfs4trace.h\"",
            "#include \"../delegation.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"flexfilelayout.h\"",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_free_mirror_array(struct nfs4_ff_layout_segment *fls)\n{\n\tint i;\n\n\tif (fls->mirror_array) {\n\t\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\t\t/* normally mirror_ds is freed in\n\t\t\t * .free_deviceid_node but we still do it here\n\t\t\t * for .alloc_lseg error path */\n\t\t\tif (fls->mirror_array[i]) {\n\t\t\t\tkfree(fls->mirror_array[i]->fh_versions);\n\t\t\t\tnfs4_ff_layout_put_deviceid(fls->mirror_array[i]->mirror_ds);\n\t\t\t\tkfree(fls->mirror_array[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(fls->mirror_array);\n\t\tfls->mirror_array = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void _ff_layout_free_lseg(struct nfs4_ff_layout_segment *fls)\n{\n\tif (fls) {\n\t\tff_layout_free_mirror_array(fls);\n\t\tkfree(fls);\n\t}\n}"
  },
  {
    "function_name": "ff_layout_check_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "157-173",
    "snippet": "static int ff_layout_check_layout(struct nfs4_layoutget_res *lgr)\n{\n\tint ret = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tret = -EINVAL;\n\t}\n\n\tdprintk(\"--> %s returns %d\\n\", __func__, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s returns %d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s Only whole file layouts supported. Use MDS i/o\\n\"",
            "__func__"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s\\n\"",
            "__func__"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int ff_layout_check_layout(struct nfs4_layoutget_res *lgr)\n{\n\tint ret = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* FIXME: remove this check when layout segment support is added */\n\tif (lgr->range.offset != 0 ||\n\t    lgr->range.length != NFS4_MAX_UINT64) {\n\t\tdprintk(\"%s Only whole file layouts supported. Use MDS i/o\\n\",\n\t\t\t__func__);\n\t\tret = -EINVAL;\n\t}\n\n\tdprintk(\"--> %s returns %d\\n\", __func__, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ff_layout_free_mirror_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "137-155",
    "snippet": "static void ff_layout_free_mirror_array(struct nfs4_ff_layout_segment *fls)\n{\n\tint i;\n\n\tif (fls->mirror_array) {\n\t\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\t\t/* normally mirror_ds is freed in\n\t\t\t * .free_deviceid_node but we still do it here\n\t\t\t * for .alloc_lseg error path */\n\t\t\tif (fls->mirror_array[i]) {\n\t\t\t\tkfree(fls->mirror_array[i]->fh_versions);\n\t\t\t\tnfs4_ff_layout_put_deviceid(fls->mirror_array[i]->mirror_ds);\n\t\t\t\tkfree(fls->mirror_array[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(fls->mirror_array);\n\t\tfls->mirror_array = NULL;\n\t}\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fls->mirror_array"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fls->mirror_array[i]"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_ff_layout_put_deviceid",
          "args": [
            "fls->mirror_array[i]->mirror_ds"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_ff_layout_put_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayoutdev.c",
          "lines": "23-27",
          "snippet": "void nfs4_ff_layout_put_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tif (mirror_ds)\n\t\tnfs4_put_deviceid_node(&mirror_ds->id_node);\n}",
          "includes": [
            "#include \"flexfilelayout.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../internal.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"flexfilelayout.h\"\n#include \"../nfs4session.h\"\n#include \"../internal.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/nfs_fs.h>\n\nvoid nfs4_ff_layout_put_deviceid(struct nfs4_ff_layout_ds *mirror_ds)\n{\n\tif (mirror_ds)\n\t\tnfs4_put_deviceid_node(&mirror_ds->id_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fls->mirror_array[i]->fh_versions"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void ff_layout_free_mirror_array(struct nfs4_ff_layout_segment *fls)\n{\n\tint i;\n\n\tif (fls->mirror_array) {\n\t\tfor (i = 0; i < fls->mirror_array_cnt; i++) {\n\t\t\t/* normally mirror_ds is freed in\n\t\t\t * .free_deviceid_node but we still do it here\n\t\t\t * for .alloc_lseg error path */\n\t\t\tif (fls->mirror_array[i]) {\n\t\t\t\tkfree(fls->mirror_array[i]->fh_versions);\n\t\t\t\tnfs4_ff_layout_put_deviceid(fls->mirror_array[i]->mirror_ds);\n\t\t\t\tkfree(fls->mirror_array[i]);\n\t\t\t}\n\t\t}\n\t\tkfree(fls->mirror_array);\n\t\tfls->mirror_array = NULL;\n\t}\n}"
  },
  {
    "function_name": "decode_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "110-135",
    "snippet": "static int\ndecode_name(struct xdr_stream *xdr, u32 *id)\n{\n\t__be32 *p;\n\tint len;\n\n\t/* opaque_length(4)*/\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tlen = be32_to_cpup(p++);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tdprintk(\"%s: len %u\\n\", __func__, len);\n\n\t/* opaque body */\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\n\tif (!nfs_map_string_to_numeric((char *)p, len, id))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_map_string_to_numeric",
          "args": [
            "(char *)p",
            "len",
            "id"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_map_string_to_numeric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/idmap.c",
          "lines": "155-168",
          "snippet": "int nfs_map_string_to_numeric(const char *name, size_t namelen, __u32 *res)\n{\n\tunsigned long val;\n\tchar buf[16];\n\n\tif (memchr(name, '@', namelen) != NULL || namelen >= sizeof(buf))\n\t\treturn 0;\n\tmemcpy(buf, name, namelen);\n\tbuf[namelen] = '\\0';\n\tif (kstrtoul(buf, 0, &val) != 0)\n\t\treturn 0;\n\t*res = val;\n\treturn 1;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/fs.h>",
            "#include <linux/parser.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t idmap_pipe_downcall(struct file *, const char __user *,\n\t\t\t\t   size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"netns.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/nfs_idmap.h>\n#include <linux/fs.h>\n#include <linux/parser.h>\n#include <linux/types.h>\n\nstatic ssize_t idmap_pipe_downcall(struct file *, const char __user *,\n\t\t\t\t   size_t);\n\nint nfs_map_string_to_numeric(const char *name, size_t namelen, __u32 *res)\n{\n\tunsigned long val;\n\tchar buf[16];\n\n\tif (memchr(name, '@', namelen) != NULL || namelen >= sizeof(buf))\n\t\treturn 0;\n\tmemcpy(buf, name, namelen);\n\tbuf[namelen] = '\\0';\n\tif (kstrtoul(buf, 0, &val) != 0)\n\t\treturn 0;\n\t*res = val;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "len"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: len %u\\n\"",
            "__func__",
            "len"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int\ndecode_name(struct xdr_stream *xdr, u32 *id)\n{\n\t__be32 *p;\n\tint len;\n\n\t/* opaque_length(4)*/\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tlen = be32_to_cpup(p++);\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tdprintk(\"%s: len %u\\n\", __func__, len);\n\n\t/* opaque body */\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\n\tif (!nfs_map_string_to_numeric((char *)p, len, id))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_nfs_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "79-100",
    "snippet": "static int decode_nfs_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tfh->size = be32_to_cpup(p++);\n\tif (fh->size > sizeof(struct nfs_fh)) {\n\t\tprintk(KERN_ERR \"NFS flexfiles: Too big fh received %d\\n\",\n\t\t       fh->size);\n\t\treturn -EOVERFLOW;\n\t}\n\t/* fh.data */\n\tp = xdr_inline_decode(xdr, fh->size);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(&fh->data, p, fh->size);\n\tdprintk(\"%s: fh len %d\\n\", __func__, fh->size);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: fh len %d\\n\"",
            "__func__",
            "fh->size"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fh->data",
            "p",
            "fh->size"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "fh->size"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFS flexfiles: Too big fh received %d\\n\"",
            "fh->size"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int decode_nfs_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tfh->size = be32_to_cpup(p++);\n\tif (fh->size > sizeof(struct nfs_fh)) {\n\t\tprintk(KERN_ERR \"NFS flexfiles: Too big fh received %d\\n\",\n\t\t       fh->size);\n\t\treturn -EOVERFLOW;\n\t}\n\t/* fh.data */\n\tp = xdr_inline_decode(xdr, fh->size);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(&fh->data, p, fh->size);\n\tdprintk(\"%s: fh len %d\\n\", __func__, fh->size);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "67-77",
    "snippet": "static int decode_deviceid(struct xdr_stream *xdr, struct nfs4_deviceid *devid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_DEVICEID4_SIZE);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(devid, p, NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(devid);\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_print_deviceid",
          "args": [
            "devid"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_print_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "520-522",
          "snippet": "static inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline void nfs4_print_deviceid(const struct nfs4_deviceid *dev_id)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "devid",
            "p",
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int decode_deviceid(struct xdr_stream *xdr, struct nfs4_deviceid *devid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_DEVICEID4_SIZE);\n\tif (unlikely(!p))\n\t\treturn -ENOBUFS;\n\tmemcpy(devid, p, NFS4_DEVICEID4_SIZE);\n\tnfs4_print_deviceid(devid);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "54-65",
    "snippet": "static int decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOBUFS;\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\tdprintk(\"%s: stateid id= [%x%x%x%x]\\n\", __func__,\n\t\tp[0], p[1], p[2], p[3]);\n\treturn 0;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: stateid id= [%x%x%x%x]\\n\"",
            "__func__",
            "p[0]",
            "p[1]",
            "p[2]",
            "p[3]"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stateid",
            "p",
            "NFS4_STATEID_SIZE"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "NFS4_STATEID_SIZE"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic int decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOBUFS;\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\tdprintk(\"%s: stateid id= [%x%x%x%x]\\n\", __func__,\n\t\tp[0], p[1], p[2], p[3]);\n\treturn 0;\n}"
  },
  {
    "function_name": "ff_layout_free_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "41-52",
    "snippet": "static void\nff_layout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs4_ff_layout_ds_err *err, *n;\n\n\tlist_for_each_entry_safe(err, n, &FF_LAYOUT_FROM_HDR(lo)->error_list,\n\t\t\t\t list) {\n\t\tlist_del(&err->list);\n\t\tkfree(err);\n\t}\n\tkfree(FF_LAYOUT_FROM_HDR(lo));\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "FF_LAYOUT_FROM_HDR(lo)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FF_LAYOUT_FROM_HDR",
          "args": [
            "lo"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "err"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&err->list"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "err",
            "n",
            "&FF_LAYOUT_FROM_HDR(lo)->error_list",
            "list"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic void\nff_layout_free_layout_hdr(struct pnfs_layout_hdr *lo)\n{\n\tstruct nfs4_ff_layout_ds_err *err, *n;\n\n\tlist_for_each_entry_safe(err, n, &FF_LAYOUT_FROM_HDR(lo)->error_list,\n\t\t\t\t list) {\n\t\tlist_del(&err->list);\n\t\tkfree(err);\n\t}\n\tkfree(FF_LAYOUT_FROM_HDR(lo));\n}"
  },
  {
    "function_name": "ff_layout_alloc_layout_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.c",
    "lines": "28-39",
    "snippet": "static struct pnfs_layout_hdr *\nff_layout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct nfs4_flexfile_layout *ffl;\n\n\tffl = kzalloc(sizeof(*ffl), gfp_flags);\n\tif (ffl) {\n\t\tINIT_LIST_HEAD(&ffl->error_list);\n\t\treturn &ffl->generic_hdr;\n\t} else\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"../nfs.h\"",
      "#include \"../iostat.h\"",
      "#include \"../nfs4trace.h\"",
      "#include \"../delegation.h\"",
      "#include \"../internal.h\"",
      "#include \"../nfs4session.h\"",
      "#include \"flexfilelayout.h\"",
      "#include <linux/nfs_idmap.h>",
      "#include <linux/sunrpc/metrics.h>",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ffl->error_list"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ffl)",
            "gfp_flags"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../nfs.h\"\n#include \"../iostat.h\"\n#include \"../nfs4trace.h\"\n#include \"../delegation.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"flexfilelayout.h\"\n#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic struct pnfs_layout_hdr *\nff_layout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct nfs4_flexfile_layout *ffl;\n\n\tffl = kzalloc(sizeof(*ffl), gfp_flags);\n\tif (ffl) {\n\t\tINIT_LIST_HEAD(&ffl->error_list);\n\t\treturn &ffl->generic_hdr;\n\t} else\n\t\treturn NULL;\n}"
  }
]