[
  {
    "function_name": "btrfs_extent_item_to_extent_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "879-953",
    "snippet": "void btrfs_extent_item_to_extent_map(struct inode *inode,\n\t\t\t\t     const struct btrfs_path *path,\n\t\t\t\t     struct btrfs_file_extent_item *fi,\n\t\t\t\t     const bool new_inline,\n\t\t\t\t     struct extent_map *em)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tconst int slot = path->slots[0];\n\tstruct btrfs_key key;\n\tu64 extent_start, extent_end;\n\tu64 bytenr;\n\tu8 type = btrfs_file_extent_type(leaf, fi);\n\tint compress_type = btrfs_file_extent_compression(leaf, fi);\n\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\textent_start = key.offset;\n\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\textent_end = extent_start +\n\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize_t size;\n\t\tsize = btrfs_file_extent_inline_len(leaf, slot, fi);\n\t\textent_end = ALIGN(extent_start + size, root->sectorsize);\n\t}\n\n\tem->ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\tem->orig_start = extent_start -\n\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\t\tem->orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tif (bytenr == 0) {\n\t\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\t\treturn;\n\t\t}\n\t\tif (compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->orig_block_len;\n\t\t} else {\n\t\t\tbytenr += btrfs_file_extent_offset(leaf, fi);\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->len;\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC)\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t}\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tem->block_start = EXTENT_MAP_INLINE;\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\t/*\n\t\t * Initialize orig_start and block_len with the same values\n\t\t * as in inode.c:btrfs_get_extent().\n\t\t */\n\t\tem->orig_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = (u64)-1;\n\t\tif (!new_inline && compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t}\n\t} else {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"unknown file extent item type %d, inode %llu, offset %llu, root %llu\",\n\t\t\t  type, btrfs_ino(inode), extent_start,\n\t\t\t  root->root_key.objectid);\n\t}\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"unknown file extent item type %d, inode %llu, offset %llu, root %llu\"",
            "type",
            "btrfs_ino(inode)",
            "extent_start",
            "root->root_key.objectid"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_FLAG_COMPRESSED",
            "&em->flags"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_ram_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "extent_start + size",
            "root->sectorsize"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "leaf",
            "slot",
            "fi"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nvoid btrfs_extent_item_to_extent_map(struct inode *inode,\n\t\t\t\t     const struct btrfs_path *path,\n\t\t\t\t     struct btrfs_file_extent_item *fi,\n\t\t\t\t     const bool new_inline,\n\t\t\t\t     struct extent_map *em)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tconst int slot = path->slots[0];\n\tstruct btrfs_key key;\n\tu64 extent_start, extent_end;\n\tu64 bytenr;\n\tu8 type = btrfs_file_extent_type(leaf, fi);\n\tint compress_type = btrfs_file_extent_compression(leaf, fi);\n\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\textent_start = key.offset;\n\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\textent_end = extent_start +\n\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize_t size;\n\t\tsize = btrfs_file_extent_inline_len(leaf, slot, fi);\n\t\textent_end = ALIGN(extent_start + size, root->sectorsize);\n\t}\n\n\tem->ram_bytes = btrfs_file_extent_ram_bytes(leaf, fi);\n\tif (type == BTRFS_FILE_EXTENT_REG ||\n\t    type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\tem->orig_start = extent_start -\n\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\t\tem->orig_block_len = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tif (bytenr == 0) {\n\t\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\t\treturn;\n\t\t}\n\t\tif (compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->orig_block_len;\n\t\t} else {\n\t\t\tbytenr += btrfs_file_extent_offset(leaf, fi);\n\t\t\tem->block_start = bytenr;\n\t\t\tem->block_len = em->len;\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC)\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t}\n\t} else if (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tem->block_start = EXTENT_MAP_INLINE;\n\t\tem->start = extent_start;\n\t\tem->len = extent_end - extent_start;\n\t\t/*\n\t\t * Initialize orig_start and block_len with the same values\n\t\t * as in inode.c:btrfs_get_extent().\n\t\t */\n\t\tem->orig_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = (u64)-1;\n\t\tif (!new_inline && compress_type != BTRFS_COMPRESS_NONE) {\n\t\t\tset_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\t\tem->compress_type = compress_type;\n\t\t}\n\t} else {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"unknown file extent item type %d, inode %llu, offset %llu, root %llu\",\n\t\t\t  type, btrfs_ino(inode), extent_start,\n\t\t\t  root->root_key.objectid);\n\t}\n}"
  },
  {
    "function_name": "btrfs_csum_file_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "683-877",
    "snippet": "int btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[0]"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "sums->sums + index",
            "(unsigned long)item",
            "ins_size"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "(unsigned long)item_end - (unsigned long)item",
            "ins_size"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sums->len - total_bytes"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_csum_item"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret != 0"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&file_key",
            "ins_size"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "tmp",
            "(u64)MAX_CSUM_ITEMS(root, csum_size)"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_CSUM_ITEMS",
          "args": [
            "root",
            "csum_size"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(u64)1",
            "tmp"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extend_item",
          "args": [
            "root",
            "path",
            "diff"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4634-4697",
          "snippet": "void btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_CSUM_ITEMS",
          "args": [
            "root",
            "csum_size"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "1",
            "(int)tmp"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "tmp < 1"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_CSUM_ITEMS",
          "args": [
            "root",
            "csum_size"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&file_key",
            "path",
            "csum_size",
            "1"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CSUM_ITEMS",
          "args": [
            "root",
            "csum_size"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "item"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_csum_item"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "item"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csum",
          "args": [
            "trans",
            "root",
            "path",
            "bytenr",
            "1"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}"
  },
  {
    "function_name": "btrfs_del_csums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "566-681",
    "snippet": "int btrfs_del_csums(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, u64 bytenr, u64 len)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 end_byte = bytenr + len;\n\tu64 csum_end;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tint blocksize_bits = root->fs_info->sb->s_blocksize_bits;\n\n\troot = root->fs_info->csum_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\t\tkey.offset = end_byte - 1;\n\t\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t} else if (ret < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.offset >= end_byte)\n\t\t\tbreak;\n\n\t\tcsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\n\t\tcsum_end <<= blocksize_bits;\n\t\tcsum_end += key.offset;\n\n\t\t/* this csum ends before we start, we're done */\n\t\tif (csum_end <= bytenr)\n\t\t\tbreak;\n\n\t\t/* delete the entire item, it is inside our range */\n\t\tif (key.offset >= bytenr && csum_end <= end_byte) {\n\t\t\tret = btrfs_del_item(trans, root, path);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (key.offset == bytenr)\n\t\t\t\tbreak;\n\t\t} else if (key.offset < bytenr && csum_end > end_byte) {\n\t\t\tunsigned long offset;\n\t\t\tunsigned long shift_len;\n\t\t\tunsigned long item_offset;\n\t\t\t/*\n\t\t\t *        [ bytenr - len ]\n\t\t\t *     [csum                ]\n\t\t\t *\n\t\t\t * Our bytes are in the middle of the csum,\n\t\t\t * we need to split this item and insert a new one.\n\t\t\t *\n\t\t\t * But we can't drop the path because the\n\t\t\t * csum could change, get removed, extended etc.\n\t\t\t *\n\t\t\t * The trick here is the max size of a csum item leaves\n\t\t\t * enough room in the tree block for a single\n\t\t\t * item header.  So, we split the item in place,\n\t\t\t * adding a new header pointing to the existing\n\t\t\t * bytes.  Then we loop around again and we have\n\t\t\t * a nicely formed csum item that we can neatly\n\t\t\t * truncate.\n\t\t\t */\n\t\t\toffset = (bytenr - key.offset) >> blocksize_bits;\n\t\t\toffset *= csum_size;\n\n\t\t\tshift_len = (len >> blocksize_bits) * csum_size;\n\n\t\t\titem_offset = btrfs_item_ptr_offset(leaf,\n\t\t\t\t\t\t\t    path->slots[0]);\n\n\t\t\tmemset_extent_buffer(leaf, 0, item_offset + offset,\n\t\t\t\t\t     shift_len);\n\t\t\tkey.offset = bytenr;\n\n\t\t\t/*\n\t\t\t * btrfs_split_item returns -EAGAIN when the\n\t\t\t * item changed size or key\n\t\t\t */\n\t\t\tret = btrfs_split_item(trans, root, path, &key, offset);\n\t\t\tif (ret && ret != -EAGAIN) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tkey.offset = end_byte - 1;\n\t\t} else {\n\t\t\ttruncate_one_csum(root, path, &key, bytenr, len);\n\t\t\tif (key.offset < bytenr)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_one_csum",
          "args": [
            "root",
            "path",
            "&key",
            "bytenr",
            "len"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_one_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "516-560",
          "snippet": "static noinline void truncate_one_csum(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       struct btrfs_key *key,\n\t\t\t\t       u64 bytenr, u64 len)\n{\n\tstruct extent_buffer *leaf;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tu64 csum_end;\n\tu64 end_byte = bytenr + len;\n\tu32 blocksize_bits = root->fs_info->sb->s_blocksize_bits;\n\n\tleaf = path->nodes[0];\n\tcsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\n\tcsum_end <<= root->fs_info->sb->s_blocksize_bits;\n\tcsum_end += key->offset;\n\n\tif (key->offset < bytenr && csum_end <= end_byte) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *         [   ]\n\t\t *   [csum     ]\n\t\t *   A simple truncate off the end of the item\n\t\t */\n\t\tu32 new_size = (bytenr - key->offset) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\t\tbtrfs_truncate_item(root, path, new_size, 1);\n\t} else if (key->offset >= bytenr && csum_end > end_byte &&\n\t\t   end_byte > key->offset) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *                 [ ]\n\t\t *                 [csum     ]\n\t\t * we need to truncate from the beginning of the csum\n\t\t */\n\t\tu32 new_size = (csum_end - end_byte) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\n\t\tbtrfs_truncate_item(root, path, new_size, 0);\n\n\t\tkey->offset = end_byte;\n\t\tbtrfs_set_item_key_safe(root, path, key);\n\t} else {\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nstatic noinline void truncate_one_csum(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       struct btrfs_key *key,\n\t\t\t\t       u64 bytenr, u64 len)\n{\n\tstruct extent_buffer *leaf;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tu64 csum_end;\n\tu64 end_byte = bytenr + len;\n\tu32 blocksize_bits = root->fs_info->sb->s_blocksize_bits;\n\n\tleaf = path->nodes[0];\n\tcsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\n\tcsum_end <<= root->fs_info->sb->s_blocksize_bits;\n\tcsum_end += key->offset;\n\n\tif (key->offset < bytenr && csum_end <= end_byte) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *         [   ]\n\t\t *   [csum     ]\n\t\t *   A simple truncate off the end of the item\n\t\t */\n\t\tu32 new_size = (bytenr - key->offset) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\t\tbtrfs_truncate_item(root, path, new_size, 1);\n\t} else if (key->offset >= bytenr && csum_end > end_byte &&\n\t\t   end_byte > key->offset) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *                 [ ]\n\t\t *                 [csum     ]\n\t\t * we need to truncate from the beginning of the csum\n\t\t */\n\t\tu32 new_size = (csum_end - end_byte) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\n\t\tbtrfs_truncate_item(root, path, new_size, 0);\n\n\t\tkey->offset = end_byte;\n\t\tbtrfs_set_item_key_safe(root, path, key);\n\t} else {\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_split_item",
          "args": [
            "trans",
            "root",
            "path",
            "&key",
            "offset"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_split_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4477-4491",
          "snippet": "int btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, root, path, new_key, split_offset);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, root, path, new_key, split_offset);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "leaf",
            "0",
            "item_offset + offset",
            "shift_len"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "root",
            "path"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_del_csums(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, u64 bytenr, u64 len)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tu64 end_byte = bytenr + len;\n\tu64 csum_end;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tint blocksize_bits = root->fs_info->sb->s_blocksize_bits;\n\n\troot = root->fs_info->csum_root;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\t\tkey.offset = end_byte - 1;\n\t\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\t\tpath->leave_spinning = 1;\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t} else if (ret < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.offset >= end_byte)\n\t\t\tbreak;\n\n\t\tcsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\n\t\tcsum_end <<= blocksize_bits;\n\t\tcsum_end += key.offset;\n\n\t\t/* this csum ends before we start, we're done */\n\t\tif (csum_end <= bytenr)\n\t\t\tbreak;\n\n\t\t/* delete the entire item, it is inside our range */\n\t\tif (key.offset >= bytenr && csum_end <= end_byte) {\n\t\t\tret = btrfs_del_item(trans, root, path);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (key.offset == bytenr)\n\t\t\t\tbreak;\n\t\t} else if (key.offset < bytenr && csum_end > end_byte) {\n\t\t\tunsigned long offset;\n\t\t\tunsigned long shift_len;\n\t\t\tunsigned long item_offset;\n\t\t\t/*\n\t\t\t *        [ bytenr - len ]\n\t\t\t *     [csum                ]\n\t\t\t *\n\t\t\t * Our bytes are in the middle of the csum,\n\t\t\t * we need to split this item and insert a new one.\n\t\t\t *\n\t\t\t * But we can't drop the path because the\n\t\t\t * csum could change, get removed, extended etc.\n\t\t\t *\n\t\t\t * The trick here is the max size of a csum item leaves\n\t\t\t * enough room in the tree block for a single\n\t\t\t * item header.  So, we split the item in place,\n\t\t\t * adding a new header pointing to the existing\n\t\t\t * bytes.  Then we loop around again and we have\n\t\t\t * a nicely formed csum item that we can neatly\n\t\t\t * truncate.\n\t\t\t */\n\t\t\toffset = (bytenr - key.offset) >> blocksize_bits;\n\t\t\toffset *= csum_size;\n\n\t\t\tshift_len = (len >> blocksize_bits) * csum_size;\n\n\t\t\titem_offset = btrfs_item_ptr_offset(leaf,\n\t\t\t\t\t\t\t    path->slots[0]);\n\n\t\t\tmemset_extent_buffer(leaf, 0, item_offset + offset,\n\t\t\t\t\t     shift_len);\n\t\t\tkey.offset = bytenr;\n\n\t\t\t/*\n\t\t\t * btrfs_split_item returns -EAGAIN when the\n\t\t\t * item changed size or key\n\t\t\t */\n\t\t\tret = btrfs_split_item(trans, root, path, &key, offset);\n\t\t\tif (ret && ret != -EAGAIN) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tkey.offset = end_byte - 1;\n\t\t} else {\n\t\t\ttruncate_one_csum(root, path, &key, bytenr, len);\n\t\t\tif (key.offset < bytenr)\n\t\t\t\tbreak;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "truncate_one_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "516-560",
    "snippet": "static noinline void truncate_one_csum(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       struct btrfs_key *key,\n\t\t\t\t       u64 bytenr, u64 len)\n{\n\tstruct extent_buffer *leaf;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tu64 csum_end;\n\tu64 end_byte = bytenr + len;\n\tu32 blocksize_bits = root->fs_info->sb->s_blocksize_bits;\n\n\tleaf = path->nodes[0];\n\tcsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\n\tcsum_end <<= root->fs_info->sb->s_blocksize_bits;\n\tcsum_end += key->offset;\n\n\tif (key->offset < bytenr && csum_end <= end_byte) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *         [   ]\n\t\t *   [csum     ]\n\t\t *   A simple truncate off the end of the item\n\t\t */\n\t\tu32 new_size = (bytenr - key->offset) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\t\tbtrfs_truncate_item(root, path, new_size, 1);\n\t} else if (key->offset >= bytenr && csum_end > end_byte &&\n\t\t   end_byte > key->offset) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *                 [ ]\n\t\t *                 [csum     ]\n\t\t * we need to truncate from the beginning of the csum\n\t\t */\n\t\tu32 new_size = (csum_end - end_byte) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\n\t\tbtrfs_truncate_item(root, path, new_size, 0);\n\n\t\tkey->offset = end_byte;\n\t\tbtrfs_set_item_key_safe(root, path, key);\n\t} else {\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key_safe",
          "args": [
            "root",
            "path",
            "key"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_item",
          "args": [
            "root",
            "path",
            "new_size",
            "0"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4535-4629",
          "snippet": "void btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nstatic noinline void truncate_one_csum(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       struct btrfs_key *key,\n\t\t\t\t       u64 bytenr, u64 len)\n{\n\tstruct extent_buffer *leaf;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tu64 csum_end;\n\tu64 end_byte = bytenr + len;\n\tu32 blocksize_bits = root->fs_info->sb->s_blocksize_bits;\n\n\tleaf = path->nodes[0];\n\tcsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\n\tcsum_end <<= root->fs_info->sb->s_blocksize_bits;\n\tcsum_end += key->offset;\n\n\tif (key->offset < bytenr && csum_end <= end_byte) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *         [   ]\n\t\t *   [csum     ]\n\t\t *   A simple truncate off the end of the item\n\t\t */\n\t\tu32 new_size = (bytenr - key->offset) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\t\tbtrfs_truncate_item(root, path, new_size, 1);\n\t} else if (key->offset >= bytenr && csum_end > end_byte &&\n\t\t   end_byte > key->offset) {\n\t\t/*\n\t\t *         [ bytenr - len ]\n\t\t *                 [ ]\n\t\t *                 [csum     ]\n\t\t * we need to truncate from the beginning of the csum\n\t\t */\n\t\tu32 new_size = (csum_end - end_byte) >> blocksize_bits;\n\t\tnew_size *= csum_size;\n\n\t\tbtrfs_truncate_item(root, path, new_size, 0);\n\n\t\tkey->offset = end_byte;\n\t\tbtrfs_set_item_key_safe(root, path, key);\n\t} else {\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "btrfs_csum_one_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "426-503",
    "snippet": "int btrfs_csum_one_bio(struct btrfs_root *root, struct inode *inode,\n\t\t       struct bio *bio, u64 file_start, int contig)\n{\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_ordered_extent *ordered;\n\tchar *data;\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tint bio_index = 0;\n\tint index;\n\tunsigned long total_bytes = 0;\n\tunsigned long this_sum_bytes = 0;\n\tu64 offset;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\tsums = kzalloc(btrfs_ordered_sum_size(root, bio->bi_iter.bi_size),\n\t\t       GFP_NOFS);\n\tif (!sums)\n\t\treturn -ENOMEM;\n\n\tsums->len = bio->bi_iter.bi_size;\n\tINIT_LIST_HEAD(&sums->list);\n\n\tif (contig)\n\t\toffset = file_start;\n\telse\n\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tBUG_ON(!ordered); /* Logic error */\n\tsums->bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tindex = 0;\n\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!contig)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\t\tif (offset >= ordered->file_offset + ordered->len ||\n\t\t    offset < ordered->file_offset) {\n\t\t\tunsigned long bytes_left;\n\t\t\tsums->len = this_sum_bytes;\n\t\t\tthis_sum_bytes = 0;\n\t\t\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\t\tbytes_left = bio->bi_iter.bi_size - total_bytes;\n\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, bytes_left),\n\t\t\t\t       GFP_NOFS);\n\t\t\tBUG_ON(!sums); /* -ENOMEM */\n\t\t\tsums->len = bytes_left;\n\t\t\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\t\t\tBUG_ON(!ordered); /* Logic error */\n\t\t\tsums->bytenr = ((u64)bio->bi_iter.bi_sector << 9) +\n\t\t\t\t       total_bytes;\n\t\t\tindex = 0;\n\t\t}\n\n\t\tdata = kmap_atomic(bvec->bv_page);\n\t\tsums->sums[index] = ~(u32)0;\n\t\tsums->sums[index] = btrfs_csum_data(data + bvec->bv_offset,\n\t\t\t\t\t\t    sums->sums[index],\n\t\t\t\t\t\t    bvec->bv_len);\n\t\tkunmap_atomic(data);\n\t\tbtrfs_csum_final(sums->sums[index],\n\t\t\t\t (char *)(sums->sums + index));\n\n\t\tbio_index++;\n\t\tindex++;\n\t\ttotal_bytes += bvec->bv_len;\n\t\tthis_sum_bytes += bvec->bv_len;\n\t\toffset += bvec->bv_len;\n\t\tbvec++;\n\t}\n\tthis_sum_bytes = 0;\n\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn 0;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_ordered_sum",
          "args": [
            "inode",
            "ordered",
            "sums"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_ordered_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "280-294",
          "snippet": "void btrfs_add_ordered_sum(struct inode *inode,\n\t\t\t   struct btrfs_ordered_extent *entry,\n\t\t\t   struct btrfs_ordered_sum *sum)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tlist_add_tail(&sum->list, &entry->list);\n\tWARN_ON(entry->csum_bytes_left < sum->len);\n\tentry->csum_bytes_left -= sum->len;\n\tif (entry->csum_bytes_left == 0)\n\t\twake_up(&entry->wait);\n\tspin_unlock_irq(&tree->lock);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_add_ordered_sum(struct inode *inode,\n\t\t\t   struct btrfs_ordered_extent *entry,\n\t\t\t   struct btrfs_ordered_sum *sum)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tlist_add_tail(&sum->list, &entry->list);\n\tWARN_ON(entry->csum_bytes_left < sum->len);\n\tentry->csum_bytes_left -= sum->len;\n\tif (entry->csum_bytes_left == 0)\n\t\twake_up(&entry->wait);\n\tspin_unlock_irq(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "sums->sums[index]",
            "(char *)(sums->sums + index)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "data"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "data + bvec->bv_offset",
            "sums->sums[index]",
            "bvec->bv_len"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "bvec->bv_page"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ordered"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_extent",
          "args": [
            "inode",
            "offset"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "777-798",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sums"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "btrfs_ordered_sum_size(root, bytes_left)",
            "GFP_NOFS"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ordered_sum_size",
          "args": [
            "root",
            "bytes_left"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ordered_sum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.h",
          "lines": "149-154",
          "snippet": "static inline int btrfs_ordered_sum_size(struct btrfs_root *root,\n\t\t\t\t\t unsigned long bytes)\n{\n\tint num_sectors = (int)DIV_ROUND_UP(bytes, root->sectorsize);\n\treturn sizeof(struct btrfs_ordered_sum) + num_sectors * sizeof(u32);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int btrfs_ordered_sum_size(struct btrfs_root *root,\n\t\t\t\t\t unsigned long bytes)\n{\n\tint num_sectors = (int)DIV_ROUND_UP(bytes, root->sectorsize);\n\treturn sizeof(struct btrfs_ordered_sum) + num_sectors * sizeof(u32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "bvec->bv_page"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ordered"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "bvec->bv_page"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sums->list"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "btrfs_ordered_sum_size(root, bio->bi_iter.bi_size)",
            "GFP_NOFS"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bio->bi_vcnt <= 0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_csum_one_bio(struct btrfs_root *root, struct inode *inode,\n\t\t       struct bio *bio, u64 file_start, int contig)\n{\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_ordered_extent *ordered;\n\tchar *data;\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tint bio_index = 0;\n\tint index;\n\tunsigned long total_bytes = 0;\n\tunsigned long this_sum_bytes = 0;\n\tu64 offset;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\tsums = kzalloc(btrfs_ordered_sum_size(root, bio->bi_iter.bi_size),\n\t\t       GFP_NOFS);\n\tif (!sums)\n\t\treturn -ENOMEM;\n\n\tsums->len = bio->bi_iter.bi_size;\n\tINIT_LIST_HEAD(&sums->list);\n\n\tif (contig)\n\t\toffset = file_start;\n\telse\n\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tBUG_ON(!ordered); /* Logic error */\n\tsums->bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tindex = 0;\n\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!contig)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\t\tif (offset >= ordered->file_offset + ordered->len ||\n\t\t    offset < ordered->file_offset) {\n\t\t\tunsigned long bytes_left;\n\t\t\tsums->len = this_sum_bytes;\n\t\t\tthis_sum_bytes = 0;\n\t\t\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\t\tbytes_left = bio->bi_iter.bi_size - total_bytes;\n\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, bytes_left),\n\t\t\t\t       GFP_NOFS);\n\t\t\tBUG_ON(!sums); /* -ENOMEM */\n\t\t\tsums->len = bytes_left;\n\t\t\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\t\t\tBUG_ON(!ordered); /* Logic error */\n\t\t\tsums->bytenr = ((u64)bio->bi_iter.bi_sector << 9) +\n\t\t\t\t       total_bytes;\n\t\t\tindex = 0;\n\t\t}\n\n\t\tdata = kmap_atomic(bvec->bv_page);\n\t\tsums->sums[index] = ~(u32)0;\n\t\tsums->sums[index] = btrfs_csum_data(data + bvec->bv_offset,\n\t\t\t\t\t\t    sums->sums[index],\n\t\t\t\t\t\t    bvec->bv_len);\n\t\tkunmap_atomic(data);\n\t\tbtrfs_csum_final(sums->sums[index],\n\t\t\t\t (char *)(sums->sums + index));\n\n\t\tbio_index++;\n\t\tindex++;\n\t\ttotal_bytes += bvec->bv_len;\n\t\tthis_sum_bytes += bvec->bv_len;\n\t\toffset += bvec->bv_len;\n\t\tbvec++;\n\t}\n\tthis_sum_bytes = 0;\n\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_lookup_csums_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "307-424",
    "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&tmplist",
            "list"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sums"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sums->list"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmplist.next",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmplist"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&sums->list",
            "&tmplist"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "path->nodes[0]",
            "sums->sums",
            "((unsigned long)item) + offset",
            "csum_size * size"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "btrfs_ordered_sum_size(root, size)",
            "GFP_NOFS"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ordered_sum_size",
          "args": [
            "root",
            "size"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ordered_sum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.h",
          "lines": "149-154",
          "snippet": "static inline int btrfs_ordered_sum_size(struct btrfs_root *root,\n\t\t\t\t\t unsigned long bytes)\n{\n\tint num_sectors = (int)DIV_ROUND_UP(bytes, root->sectorsize);\n\treturn sizeof(struct btrfs_ordered_sum) + num_sectors * sizeof(u32);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int btrfs_ordered_sum_size(struct btrfs_root *root,\n\t\t\t\t\t unsigned long bytes)\n{\n\tint num_sectors = (int)DIV_ROUND_UP(bytes, root->sectorsize);\n\treturn sizeof(struct btrfs_ordered_sum) + num_sectors * sizeof(u32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "csum_end - start",
            "MAX_ORDERED_SUM_BYTES(root)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_ORDERED_SUM_BYTES",
          "args": [
            "root"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_csum_item"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "csum_end",
            "end + 1"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "end + 1",
            "root->sectorsize"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "start",
            "root->sectorsize"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmplist"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_lookup_bio_sums_dio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "301-305",
    "snippet": "int btrfs_lookup_bio_sums_dio(struct btrfs_root *root, struct inode *inode,\n\t\t\t      struct bio *bio, u64 offset)\n{\n\treturn __btrfs_lookup_bio_sums(root, inode, bio, offset, NULL, 1);\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_lookup_bio_sums",
          "args": [
            "root",
            "inode",
            "bio",
            "offset",
            "NULL",
            "1"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_lookup_bio_sums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "161-293",
          "snippet": "static int __btrfs_lookup_bio_sums(struct btrfs_root *root,\n\t\t\t\t   struct inode *inode, struct bio *bio,\n\t\t\t\t   u64 logical_offset, u32 *dst, int dio)\n{\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_path *path;\n\tu8 *csum;\n\tu64 offset = 0;\n\tu64 item_start_offset = 0;\n\tu64 item_last_offset = 0;\n\tu64 disk_bytenr;\n\tu32 diff;\n\tint nblocks;\n\tint bio_index = 0;\n\tint count;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\n\tif (!dst) {\n\t\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\t\tbtrfs_bio->csum_allocated = kmalloc(nblocks * csum_size,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!btrfs_bio->csum_allocated) {\n\t\t\t\tbtrfs_free_path(path);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_allocated;\n\t\t\tbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\n\t\t} else {\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\t}\n\t\tcsum = btrfs_bio->csum;\n\t} else {\n\t\tcsum = (u8 *)dst;\n\t}\n\n\tif (bio->bi_iter.bi_size > PAGE_CACHE_SIZE * 8)\n\t\tpath->reada = 2;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\n\t/*\n\t * the free space stuff is only read when it hasn't been\n\t * updated in the current transaction.  So, we can safely\n\t * read from the commit root and sidestep a nasty deadlock\n\t * between reading the free space cache and updating the csum tree.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tdisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tif (dio)\n\t\toffset = logical_offset;\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!dio)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\t\tcount = btrfs_find_ordered_sum(inode, offset, disk_bytenr,\n\t\t\t\t\t       (u32 *)csum, nblocks);\n\t\tif (count)\n\t\t\tgoto found;\n\n\t\tif (!item || disk_bytenr < item_start_offset ||\n\t\t    disk_bytenr >= item_last_offset) {\n\t\t\tstruct btrfs_key found_key;\n\t\t\tu32 item_size;\n\n\t\t\tif (item)\n\t\t\t\tbtrfs_release_path(path);\n\t\t\titem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\n\t\t\t\t\t\t path, disk_bytenr, 0);\n\t\t\tif (IS_ERR(item)) {\n\t\t\t\tcount = 1;\n\t\t\t\tmemset(csum, 0, csum_size);\n\t\t\t\tif (BTRFS_I(inode)->root->root_key.objectid ==\n\t\t\t\t    BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\t\t\tset_extent_bits(io_tree, offset,\n\t\t\t\t\t\toffset + bvec->bv_len - 1,\n\t\t\t\t\t\tEXTENT_NODATASUM, GFP_NOFS);\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\t   \"no csum found for inode %llu start %llu\",\n\t\t\t\t\t       btrfs_ino(inode), offset);\n\t\t\t\t}\n\t\t\t\titem = NULL;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\n\t\t\titem_start_offset = found_key.offset;\n\t\t\titem_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0]);\n\t\t\titem_last_offset = item_start_offset +\n\t\t\t\t(item_size / csum_size) *\n\t\t\t\troot->sectorsize;\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_csum_item);\n\t\t}\n\t\t/*\n\t\t * this byte range must be able to fit inside\n\t\t * a single leaf so it will also fit inside a u32\n\t\t */\n\t\tdiff = disk_bytenr - item_start_offset;\n\t\tdiff = diff / root->sectorsize;\n\t\tdiff = diff * csum_size;\n\t\tcount = min_t(int, nblocks, (item_last_offset - disk_bytenr) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\tread_extent_buffer(path->nodes[0], csum,\n\t\t\t\t   ((unsigned long)item) + diff,\n\t\t\t\t   csum_size * count);\nfound:\n\t\tcsum += count * csum_size;\n\t\tnblocks -= count;\n\t\tbio_index += count;\n\t\twhile (count--) {\n\t\t\tdisk_bytenr += bvec->bv_len;\n\t\t\toffset += bvec->bv_len;\n\t\t\tbvec++;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nstatic int __btrfs_lookup_bio_sums(struct btrfs_root *root,\n\t\t\t\t   struct inode *inode, struct bio *bio,\n\t\t\t\t   u64 logical_offset, u32 *dst, int dio)\n{\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_path *path;\n\tu8 *csum;\n\tu64 offset = 0;\n\tu64 item_start_offset = 0;\n\tu64 item_last_offset = 0;\n\tu64 disk_bytenr;\n\tu32 diff;\n\tint nblocks;\n\tint bio_index = 0;\n\tint count;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\n\tif (!dst) {\n\t\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\t\tbtrfs_bio->csum_allocated = kmalloc(nblocks * csum_size,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!btrfs_bio->csum_allocated) {\n\t\t\t\tbtrfs_free_path(path);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_allocated;\n\t\t\tbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\n\t\t} else {\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\t}\n\t\tcsum = btrfs_bio->csum;\n\t} else {\n\t\tcsum = (u8 *)dst;\n\t}\n\n\tif (bio->bi_iter.bi_size > PAGE_CACHE_SIZE * 8)\n\t\tpath->reada = 2;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\n\t/*\n\t * the free space stuff is only read when it hasn't been\n\t * updated in the current transaction.  So, we can safely\n\t * read from the commit root and sidestep a nasty deadlock\n\t * between reading the free space cache and updating the csum tree.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tdisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tif (dio)\n\t\toffset = logical_offset;\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!dio)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\t\tcount = btrfs_find_ordered_sum(inode, offset, disk_bytenr,\n\t\t\t\t\t       (u32 *)csum, nblocks);\n\t\tif (count)\n\t\t\tgoto found;\n\n\t\tif (!item || disk_bytenr < item_start_offset ||\n\t\t    disk_bytenr >= item_last_offset) {\n\t\t\tstruct btrfs_key found_key;\n\t\t\tu32 item_size;\n\n\t\t\tif (item)\n\t\t\t\tbtrfs_release_path(path);\n\t\t\titem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\n\t\t\t\t\t\t path, disk_bytenr, 0);\n\t\t\tif (IS_ERR(item)) {\n\t\t\t\tcount = 1;\n\t\t\t\tmemset(csum, 0, csum_size);\n\t\t\t\tif (BTRFS_I(inode)->root->root_key.objectid ==\n\t\t\t\t    BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\t\t\tset_extent_bits(io_tree, offset,\n\t\t\t\t\t\toffset + bvec->bv_len - 1,\n\t\t\t\t\t\tEXTENT_NODATASUM, GFP_NOFS);\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\t   \"no csum found for inode %llu start %llu\",\n\t\t\t\t\t       btrfs_ino(inode), offset);\n\t\t\t\t}\n\t\t\t\titem = NULL;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\n\t\t\titem_start_offset = found_key.offset;\n\t\t\titem_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0]);\n\t\t\titem_last_offset = item_start_offset +\n\t\t\t\t(item_size / csum_size) *\n\t\t\t\troot->sectorsize;\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_csum_item);\n\t\t}\n\t\t/*\n\t\t * this byte range must be able to fit inside\n\t\t * a single leaf so it will also fit inside a u32\n\t\t */\n\t\tdiff = disk_bytenr - item_start_offset;\n\t\tdiff = diff / root->sectorsize;\n\t\tdiff = diff * csum_size;\n\t\tcount = min_t(int, nblocks, (item_last_offset - disk_bytenr) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\tread_extent_buffer(path->nodes[0], csum,\n\t\t\t\t   ((unsigned long)item) + diff,\n\t\t\t\t   csum_size * count);\nfound:\n\t\tcsum += count * csum_size;\n\t\tnblocks -= count;\n\t\tbio_index += count;\n\t\twhile (count--) {\n\t\t\tdisk_bytenr += bvec->bv_len;\n\t\t\toffset += bvec->bv_len;\n\t\t\tbvec++;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_bio_sums_dio(struct btrfs_root *root, struct inode *inode,\n\t\t\t      struct bio *bio, u64 offset)\n{\n\treturn __btrfs_lookup_bio_sums(root, inode, bio, offset, NULL, 1);\n}"
  },
  {
    "function_name": "btrfs_lookup_bio_sums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "295-299",
    "snippet": "int btrfs_lookup_bio_sums(struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct bio *bio, u32 *dst)\n{\n\treturn __btrfs_lookup_bio_sums(root, inode, bio, 0, dst, 0);\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_lookup_bio_sums",
          "args": [
            "root",
            "inode",
            "bio",
            "0",
            "dst",
            "0"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_lookup_bio_sums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "161-293",
          "snippet": "static int __btrfs_lookup_bio_sums(struct btrfs_root *root,\n\t\t\t\t   struct inode *inode, struct bio *bio,\n\t\t\t\t   u64 logical_offset, u32 *dst, int dio)\n{\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_path *path;\n\tu8 *csum;\n\tu64 offset = 0;\n\tu64 item_start_offset = 0;\n\tu64 item_last_offset = 0;\n\tu64 disk_bytenr;\n\tu32 diff;\n\tint nblocks;\n\tint bio_index = 0;\n\tint count;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\n\tif (!dst) {\n\t\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\t\tbtrfs_bio->csum_allocated = kmalloc(nblocks * csum_size,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!btrfs_bio->csum_allocated) {\n\t\t\t\tbtrfs_free_path(path);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_allocated;\n\t\t\tbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\n\t\t} else {\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\t}\n\t\tcsum = btrfs_bio->csum;\n\t} else {\n\t\tcsum = (u8 *)dst;\n\t}\n\n\tif (bio->bi_iter.bi_size > PAGE_CACHE_SIZE * 8)\n\t\tpath->reada = 2;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\n\t/*\n\t * the free space stuff is only read when it hasn't been\n\t * updated in the current transaction.  So, we can safely\n\t * read from the commit root and sidestep a nasty deadlock\n\t * between reading the free space cache and updating the csum tree.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tdisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tif (dio)\n\t\toffset = logical_offset;\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!dio)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\t\tcount = btrfs_find_ordered_sum(inode, offset, disk_bytenr,\n\t\t\t\t\t       (u32 *)csum, nblocks);\n\t\tif (count)\n\t\t\tgoto found;\n\n\t\tif (!item || disk_bytenr < item_start_offset ||\n\t\t    disk_bytenr >= item_last_offset) {\n\t\t\tstruct btrfs_key found_key;\n\t\t\tu32 item_size;\n\n\t\t\tif (item)\n\t\t\t\tbtrfs_release_path(path);\n\t\t\titem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\n\t\t\t\t\t\t path, disk_bytenr, 0);\n\t\t\tif (IS_ERR(item)) {\n\t\t\t\tcount = 1;\n\t\t\t\tmemset(csum, 0, csum_size);\n\t\t\t\tif (BTRFS_I(inode)->root->root_key.objectid ==\n\t\t\t\t    BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\t\t\tset_extent_bits(io_tree, offset,\n\t\t\t\t\t\toffset + bvec->bv_len - 1,\n\t\t\t\t\t\tEXTENT_NODATASUM, GFP_NOFS);\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\t   \"no csum found for inode %llu start %llu\",\n\t\t\t\t\t       btrfs_ino(inode), offset);\n\t\t\t\t}\n\t\t\t\titem = NULL;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\n\t\t\titem_start_offset = found_key.offset;\n\t\t\titem_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0]);\n\t\t\titem_last_offset = item_start_offset +\n\t\t\t\t(item_size / csum_size) *\n\t\t\t\troot->sectorsize;\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_csum_item);\n\t\t}\n\t\t/*\n\t\t * this byte range must be able to fit inside\n\t\t * a single leaf so it will also fit inside a u32\n\t\t */\n\t\tdiff = disk_bytenr - item_start_offset;\n\t\tdiff = diff / root->sectorsize;\n\t\tdiff = diff * csum_size;\n\t\tcount = min_t(int, nblocks, (item_last_offset - disk_bytenr) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\tread_extent_buffer(path->nodes[0], csum,\n\t\t\t\t   ((unsigned long)item) + diff,\n\t\t\t\t   csum_size * count);\nfound:\n\t\tcsum += count * csum_size;\n\t\tnblocks -= count;\n\t\tbio_index += count;\n\t\twhile (count--) {\n\t\t\tdisk_bytenr += bvec->bv_len;\n\t\t\toffset += bvec->bv_len;\n\t\t\tbvec++;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nstatic int __btrfs_lookup_bio_sums(struct btrfs_root *root,\n\t\t\t\t   struct inode *inode, struct bio *bio,\n\t\t\t\t   u64 logical_offset, u32 *dst, int dio)\n{\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_path *path;\n\tu8 *csum;\n\tu64 offset = 0;\n\tu64 item_start_offset = 0;\n\tu64 item_last_offset = 0;\n\tu64 disk_bytenr;\n\tu32 diff;\n\tint nblocks;\n\tint bio_index = 0;\n\tint count;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\n\tif (!dst) {\n\t\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\t\tbtrfs_bio->csum_allocated = kmalloc(nblocks * csum_size,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!btrfs_bio->csum_allocated) {\n\t\t\t\tbtrfs_free_path(path);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_allocated;\n\t\t\tbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\n\t\t} else {\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\t}\n\t\tcsum = btrfs_bio->csum;\n\t} else {\n\t\tcsum = (u8 *)dst;\n\t}\n\n\tif (bio->bi_iter.bi_size > PAGE_CACHE_SIZE * 8)\n\t\tpath->reada = 2;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\n\t/*\n\t * the free space stuff is only read when it hasn't been\n\t * updated in the current transaction.  So, we can safely\n\t * read from the commit root and sidestep a nasty deadlock\n\t * between reading the free space cache and updating the csum tree.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tdisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tif (dio)\n\t\toffset = logical_offset;\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!dio)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\t\tcount = btrfs_find_ordered_sum(inode, offset, disk_bytenr,\n\t\t\t\t\t       (u32 *)csum, nblocks);\n\t\tif (count)\n\t\t\tgoto found;\n\n\t\tif (!item || disk_bytenr < item_start_offset ||\n\t\t    disk_bytenr >= item_last_offset) {\n\t\t\tstruct btrfs_key found_key;\n\t\t\tu32 item_size;\n\n\t\t\tif (item)\n\t\t\t\tbtrfs_release_path(path);\n\t\t\titem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\n\t\t\t\t\t\t path, disk_bytenr, 0);\n\t\t\tif (IS_ERR(item)) {\n\t\t\t\tcount = 1;\n\t\t\t\tmemset(csum, 0, csum_size);\n\t\t\t\tif (BTRFS_I(inode)->root->root_key.objectid ==\n\t\t\t\t    BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\t\t\tset_extent_bits(io_tree, offset,\n\t\t\t\t\t\toffset + bvec->bv_len - 1,\n\t\t\t\t\t\tEXTENT_NODATASUM, GFP_NOFS);\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\t   \"no csum found for inode %llu start %llu\",\n\t\t\t\t\t       btrfs_ino(inode), offset);\n\t\t\t\t}\n\t\t\t\titem = NULL;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\n\t\t\titem_start_offset = found_key.offset;\n\t\t\titem_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0]);\n\t\t\titem_last_offset = item_start_offset +\n\t\t\t\t(item_size / csum_size) *\n\t\t\t\troot->sectorsize;\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_csum_item);\n\t\t}\n\t\t/*\n\t\t * this byte range must be able to fit inside\n\t\t * a single leaf so it will also fit inside a u32\n\t\t */\n\t\tdiff = disk_bytenr - item_start_offset;\n\t\tdiff = diff / root->sectorsize;\n\t\tdiff = diff * csum_size;\n\t\tcount = min_t(int, nblocks, (item_last_offset - disk_bytenr) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\tread_extent_buffer(path->nodes[0], csum,\n\t\t\t\t   ((unsigned long)item) + diff,\n\t\t\t\t   csum_size * count);\nfound:\n\t\tcsum += count * csum_size;\n\t\tnblocks -= count;\n\t\tbio_index += count;\n\t\twhile (count--) {\n\t\t\tdisk_bytenr += bvec->bv_len;\n\t\t\toffset += bvec->bv_len;\n\t\t\tbvec++;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_bio_sums(struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct bio *bio, u32 *dst)\n{\n\treturn __btrfs_lookup_bio_sums(root, inode, bio, 0, dst, 0);\n}"
  },
  {
    "function_name": "__btrfs_lookup_bio_sums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "161-293",
    "snippet": "static int __btrfs_lookup_bio_sums(struct btrfs_root *root,\n\t\t\t\t   struct inode *inode, struct bio *bio,\n\t\t\t\t   u64 logical_offset, u32 *dst, int dio)\n{\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_path *path;\n\tu8 *csum;\n\tu64 offset = 0;\n\tu64 item_start_offset = 0;\n\tu64 item_last_offset = 0;\n\tu64 disk_bytenr;\n\tu32 diff;\n\tint nblocks;\n\tint bio_index = 0;\n\tint count;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\n\tif (!dst) {\n\t\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\t\tbtrfs_bio->csum_allocated = kmalloc(nblocks * csum_size,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!btrfs_bio->csum_allocated) {\n\t\t\t\tbtrfs_free_path(path);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_allocated;\n\t\t\tbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\n\t\t} else {\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\t}\n\t\tcsum = btrfs_bio->csum;\n\t} else {\n\t\tcsum = (u8 *)dst;\n\t}\n\n\tif (bio->bi_iter.bi_size > PAGE_CACHE_SIZE * 8)\n\t\tpath->reada = 2;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\n\t/*\n\t * the free space stuff is only read when it hasn't been\n\t * updated in the current transaction.  So, we can safely\n\t * read from the commit root and sidestep a nasty deadlock\n\t * between reading the free space cache and updating the csum tree.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tdisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tif (dio)\n\t\toffset = logical_offset;\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!dio)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\t\tcount = btrfs_find_ordered_sum(inode, offset, disk_bytenr,\n\t\t\t\t\t       (u32 *)csum, nblocks);\n\t\tif (count)\n\t\t\tgoto found;\n\n\t\tif (!item || disk_bytenr < item_start_offset ||\n\t\t    disk_bytenr >= item_last_offset) {\n\t\t\tstruct btrfs_key found_key;\n\t\t\tu32 item_size;\n\n\t\t\tif (item)\n\t\t\t\tbtrfs_release_path(path);\n\t\t\titem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\n\t\t\t\t\t\t path, disk_bytenr, 0);\n\t\t\tif (IS_ERR(item)) {\n\t\t\t\tcount = 1;\n\t\t\t\tmemset(csum, 0, csum_size);\n\t\t\t\tif (BTRFS_I(inode)->root->root_key.objectid ==\n\t\t\t\t    BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\t\t\tset_extent_bits(io_tree, offset,\n\t\t\t\t\t\toffset + bvec->bv_len - 1,\n\t\t\t\t\t\tEXTENT_NODATASUM, GFP_NOFS);\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\t   \"no csum found for inode %llu start %llu\",\n\t\t\t\t\t       btrfs_ino(inode), offset);\n\t\t\t\t}\n\t\t\t\titem = NULL;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\n\t\t\titem_start_offset = found_key.offset;\n\t\t\titem_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0]);\n\t\t\titem_last_offset = item_start_offset +\n\t\t\t\t(item_size / csum_size) *\n\t\t\t\troot->sectorsize;\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_csum_item);\n\t\t}\n\t\t/*\n\t\t * this byte range must be able to fit inside\n\t\t * a single leaf so it will also fit inside a u32\n\t\t */\n\t\tdiff = disk_bytenr - item_start_offset;\n\t\tdiff = diff / root->sectorsize;\n\t\tdiff = diff * csum_size;\n\t\tcount = min_t(int, nblocks, (item_last_offset - disk_bytenr) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\tread_extent_buffer(path->nodes[0], csum,\n\t\t\t\t   ((unsigned long)item) + diff,\n\t\t\t\t   csum_size * count);\nfound:\n\t\tcsum += count * csum_size;\n\t\tnblocks -= count;\n\t\tbio_index += count;\n\t\twhile (count--) {\n\t\t\tdisk_bytenr += bvec->bv_len;\n\t\t\toffset += bvec->bv_len;\n\t\t\tbvec++;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "path->nodes[0]",
            "csum",
            "((unsigned long)item) + diff",
            "csum_size * count"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "nblocks",
            "(item_last_offset - disk_bytenr) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_csum_item"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"no csum found for inode %llu start %llu\"",
            "btrfs_ino(inode)",
            "offset"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_extent_bits",
          "args": [
            "io_tree",
            "offset",
            "offset + bvec->bv_len - 1",
            "EXTENT_NODATASUM",
            "GFP_NOFS"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1270-1275",
          "snippet": "int set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "csum",
            "0",
            "csum_size"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "item"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csum",
          "args": [
            "NULL",
            "root->fs_info->csum_root",
            "path",
            "disk_bytenr",
            "0"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_ordered_sum",
          "args": [
            "inode",
            "offset",
            "disk_bytenr",
            "(u32 *)csum",
            "nblocks"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_ordered_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "990-1027",
          "snippet": "int btrfs_find_ordered_sum(struct inode *inode, u64 offset, u64 disk_bytenr,\n\t\t\t   u32 *sum, int len)\n{\n\tstruct btrfs_ordered_sum *ordered_sum;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tunsigned long num_sectors;\n\tunsigned long i;\n\tu32 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tint index = 0;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tif (!ordered)\n\t\treturn 0;\n\n\tspin_lock_irq(&tree->lock);\n\tlist_for_each_entry_reverse(ordered_sum, &ordered->list, list) {\n\t\tif (disk_bytenr >= ordered_sum->bytenr &&\n\t\t    disk_bytenr < ordered_sum->bytenr + ordered_sum->len) {\n\t\t\ti = (disk_bytenr - ordered_sum->bytenr) >>\n\t\t\t    inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = ordered_sum->len >>\n\t\t\t\t      inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = min_t(int, len - index, num_sectors - i);\n\t\t\tmemcpy(sum + index, ordered_sum->sums + i,\n\t\t\t       num_sectors);\n\n\t\t\tindex += (int)num_sectors;\n\t\t\tif (index == len)\n\t\t\t\tgoto out;\n\t\t\tdisk_bytenr += num_sectors * sectorsize;\n\t\t}\n\t}\nout:\n\tspin_unlock_irq(&tree->lock);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn index;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_find_ordered_sum(struct inode *inode, u64 offset, u64 disk_bytenr,\n\t\t\t   u32 *sum, int len)\n{\n\tstruct btrfs_ordered_sum *ordered_sum;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_ordered_inode_tree *tree = &BTRFS_I(inode)->ordered_tree;\n\tunsigned long num_sectors;\n\tunsigned long i;\n\tu32 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tint index = 0;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tif (!ordered)\n\t\treturn 0;\n\n\tspin_lock_irq(&tree->lock);\n\tlist_for_each_entry_reverse(ordered_sum, &ordered->list, list) {\n\t\tif (disk_bytenr >= ordered_sum->bytenr &&\n\t\t    disk_bytenr < ordered_sum->bytenr + ordered_sum->len) {\n\t\t\ti = (disk_bytenr - ordered_sum->bytenr) >>\n\t\t\t    inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = ordered_sum->len >>\n\t\t\t\t      inode->i_sb->s_blocksize_bits;\n\t\t\tnum_sectors = min_t(int, len - index, num_sectors - i);\n\t\t\tmemcpy(sum + index, ordered_sum->sums + i,\n\t\t\t       num_sectors);\n\n\t\t\tindex += (int)num_sectors;\n\t\t\tif (index == len)\n\t\t\t\tgoto out;\n\t\t\tdisk_bytenr += num_sectors * sectorsize;\n\t\t}\n\t}\nout:\n\tspin_unlock_irq(&tree->lock);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "bvec->bv_page"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_is_free_space_inode",
          "args": [
            "inode"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "239-249",
          "snippet": "static inline bool btrfs_is_free_space_inode(struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tif (root == root->fs_info->tree_root &&\n\t    btrfs_ino(inode) != BTRFS_BTREE_INODE_OBJECTID)\n\t\treturn true;\n\tif (BTRFS_I(inode)->location.objectid == BTRFS_FREE_INO_OBJECTID)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline bool btrfs_is_free_space_inode(struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tif (root == root->fs_info->tree_root &&\n\t    btrfs_ino(inode) != BTRFS_BTREE_INODE_OBJECTID)\n\t\treturn true;\n\tif (BTRFS_I(inode)->location.objectid == BTRFS_FREE_INO_OBJECTID)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "bio->bi_vcnt <= 0"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nblocks * csum_size",
            "GFP_NOFS"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nstatic int __btrfs_lookup_bio_sums(struct btrfs_root *root,\n\t\t\t\t   struct inode *inode, struct bio *bio,\n\t\t\t\t   u64 logical_offset, u32 *dst, int dio)\n{\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tstruct btrfs_io_bio *btrfs_bio = btrfs_io_bio(bio);\n\tstruct btrfs_csum_item *item = NULL;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tstruct btrfs_path *path;\n\tu8 *csum;\n\tu64 offset = 0;\n\tu64 item_start_offset = 0;\n\tu64 item_last_offset = 0;\n\tu64 disk_bytenr;\n\tu32 diff;\n\tint nblocks;\n\tint bio_index = 0;\n\tint count;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnblocks = bio->bi_iter.bi_size >> inode->i_sb->s_blocksize_bits;\n\tif (!dst) {\n\t\tif (nblocks * csum_size > BTRFS_BIO_INLINE_CSUM_SIZE) {\n\t\t\tbtrfs_bio->csum_allocated = kmalloc(nblocks * csum_size,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\tif (!btrfs_bio->csum_allocated) {\n\t\t\t\tbtrfs_free_path(path);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_allocated;\n\t\t\tbtrfs_bio->end_io = btrfs_io_bio_endio_readpage;\n\t\t} else {\n\t\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\t}\n\t\tcsum = btrfs_bio->csum;\n\t} else {\n\t\tcsum = (u8 *)dst;\n\t}\n\n\tif (bio->bi_iter.bi_size > PAGE_CACHE_SIZE * 8)\n\t\tpath->reada = 2;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\n\t/*\n\t * the free space stuff is only read when it hasn't been\n\t * updated in the current transaction.  So, we can safely\n\t * read from the commit root and sidestep a nasty deadlock\n\t * between reading the free space cache and updating the csum tree.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t}\n\n\tdisk_bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tif (dio)\n\t\toffset = logical_offset;\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!dio)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\t\tcount = btrfs_find_ordered_sum(inode, offset, disk_bytenr,\n\t\t\t\t\t       (u32 *)csum, nblocks);\n\t\tif (count)\n\t\t\tgoto found;\n\n\t\tif (!item || disk_bytenr < item_start_offset ||\n\t\t    disk_bytenr >= item_last_offset) {\n\t\t\tstruct btrfs_key found_key;\n\t\t\tu32 item_size;\n\n\t\t\tif (item)\n\t\t\t\tbtrfs_release_path(path);\n\t\t\titem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\n\t\t\t\t\t\t path, disk_bytenr, 0);\n\t\t\tif (IS_ERR(item)) {\n\t\t\t\tcount = 1;\n\t\t\t\tmemset(csum, 0, csum_size);\n\t\t\t\tif (BTRFS_I(inode)->root->root_key.objectid ==\n\t\t\t\t    BTRFS_DATA_RELOC_TREE_OBJECTID) {\n\t\t\t\t\tset_extent_bits(io_tree, offset,\n\t\t\t\t\t\toffset + bvec->bv_len - 1,\n\t\t\t\t\t\tEXTENT_NODATASUM, GFP_NOFS);\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\t   \"no csum found for inode %llu start %llu\",\n\t\t\t\t\t       btrfs_ino(inode), offset);\n\t\t\t\t}\n\t\t\t\titem = NULL;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\n\t\t\titem_start_offset = found_key.offset;\n\t\t\titem_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0]);\n\t\t\titem_last_offset = item_start_offset +\n\t\t\t\t(item_size / csum_size) *\n\t\t\t\troot->sectorsize;\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_csum_item);\n\t\t}\n\t\t/*\n\t\t * this byte range must be able to fit inside\n\t\t * a single leaf so it will also fit inside a u32\n\t\t */\n\t\tdiff = disk_bytenr - item_start_offset;\n\t\tdiff = diff / root->sectorsize;\n\t\tdiff = diff * csum_size;\n\t\tcount = min_t(int, nblocks, (item_last_offset - disk_bytenr) >>\n\t\t\t\t\t    inode->i_sb->s_blocksize_bits);\n\t\tread_extent_buffer(path->nodes[0], csum,\n\t\t\t\t   ((unsigned long)item) + diff,\n\t\t\t\t   csum_size * count);\nfound:\n\t\tcsum += count * csum_size;\n\t\tnblocks -= count;\n\t\tbio_index += count;\n\t\twhile (count--) {\n\t\t\tdisk_bytenr += bvec->bv_len;\n\t\t\toffset += bvec->bv_len;\n\t\t\tbvec++;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_io_bio_endio_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "156-159",
    "snippet": "static void btrfs_io_bio_endio_readpage(struct btrfs_io_bio *bio, int err)\n{\n\tkfree(bio->csum_allocated);\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bio->csum_allocated"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nstatic void btrfs_io_bio_endio_readpage(struct btrfs_io_bio *bio, int err)\n{\n\tkfree(bio->csum_allocated);\n}"
  },
  {
    "function_name": "btrfs_lookup_file_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "139-154",
    "snippet": "int btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&file_key",
            "path",
            "ins_len",
            "cow"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_lookup_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "86-137",
    "snippet": "static struct btrfs_csum_item *\nbtrfs_lookup_csum(struct btrfs_trans_handle *trans,\n\t\t  struct btrfs_root *root,\n\t\t  struct btrfs_path *path,\n\t\t  u64 bytenr, int cow)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_csum_item *item;\n\tstruct extent_buffer *leaf;\n\tu64 csum_offset = 0;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tint csums_in_item;\n\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, 0, cow);\n\tif (ret < 0)\n\t\tgoto fail;\n\tleaf = path->nodes[0];\n\tif (ret > 0) {\n\t\tret = 1;\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto fail;\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY)\n\t\t\tgoto fail;\n\n\t\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\tcsums_in_item = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsums_in_item /= csum_size;\n\n\t\tif (csum_offset == csums_in_item) {\n\t\t\tret = -EFBIG;\n\t\t\tgoto fail;\n\t\t} else if (csum_offset > csums_in_item) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\n\treturn item;\nfail:\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_csum_item"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&file_key",
            "path",
            "0",
            "cow"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nstatic struct btrfs_csum_item *\nbtrfs_lookup_csum(struct btrfs_trans_handle *trans,\n\t\t  struct btrfs_root *root,\n\t\t  struct btrfs_path *path,\n\t\t  u64 bytenr, int cow)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_csum_item *item;\n\tstruct extent_buffer *leaf;\n\tu64 csum_offset = 0;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\tint csums_in_item;\n\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, 0, cow);\n\tif (ret < 0)\n\t\tgoto fail;\n\tleaf = path->nodes[0];\n\tif (ret > 0) {\n\t\tret = 1;\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto fail;\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY)\n\t\t\tgoto fail;\n\n\t\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\tcsums_in_item = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsums_in_item /= csum_size;\n\n\t\tif (csum_offset == csums_in_item) {\n\t\t\tret = -EFBIG;\n\t\t\tgoto fail;\n\t\t} else if (csum_offset > csums_in_item) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\n\treturn item;\nfail:\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "btrfs_insert_file_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
    "lines": "40-84",
    "snippet": "int btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     u64 objectid, u64 pos,\n\t\t\t     u64 disk_offset, u64 disk_num_bytes,\n\t\t\t     u64 num_bytes, u64 offset, u64 ram_bytes,\n\t\t\t     u8 compression, u8 encryption, u16 other_encoding)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tfile_key.objectid = objectid;\n\tfile_key.offset = pos;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      sizeof(*item));\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret); /* Can't happen */\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\n\tbtrfs_set_file_extent_offset(leaf, item, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\n\tbtrfs_set_file_extent_generation(leaf, item, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_file_extent_compression(leaf, item, compression);\n\tbtrfs_set_file_extent_encryption(leaf, item, encryption);\n\tbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"print-tree.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_other_encoding",
          "args": [
            "leaf",
            "item",
            "other_encoding"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_encryption",
          "args": [
            "leaf",
            "item",
            "encryption"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_compression",
          "args": [
            "leaf",
            "item",
            "compression"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_type",
          "args": [
            "leaf",
            "item",
            "BTRFS_FILE_EXTENT_REG"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_generation",
          "args": [
            "leaf",
            "item",
            "trans->transid"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_ram_bytes",
          "args": [
            "leaf",
            "item",
            "ram_bytes"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_num_bytes",
          "args": [
            "leaf",
            "item",
            "num_bytes"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_offset",
          "args": [
            "leaf",
            "item",
            "offset"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "item",
            "disk_num_bytes"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "item",
            "disk_offset"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&file_key",
            "sizeof(*item)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     u64 objectid, u64 pos,\n\t\t\t     u64 disk_offset, u64 disk_num_bytes,\n\t\t\t     u64 num_bytes, u64 offset, u64 ram_bytes,\n\t\t\t     u8 compression, u8 encryption, u16 other_encoding)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tfile_key.objectid = objectid;\n\tfile_key.offset = pos;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      sizeof(*item));\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret); /* Can't happen */\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\n\tbtrfs_set_file_extent_offset(leaf, item, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\n\tbtrfs_set_file_extent_generation(leaf, item, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_file_extent_compression(leaf, item, compression);\n\tbtrfs_set_file_extent_encryption(leaf, item, encryption);\n\tbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  }
]