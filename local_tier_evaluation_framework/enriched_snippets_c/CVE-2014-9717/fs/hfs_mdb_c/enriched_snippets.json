[
  {
    "function_name": "hfs_mdb_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/mdb.c",
    "lines": "348-366",
    "snippet": "void hfs_mdb_put(struct super_block *sb)\n{\n\tif (!HFS_SB(sb))\n\t\treturn;\n\t/* free the B-trees */\n\thfs_btree_close(HFS_SB(sb)->ext_tree);\n\thfs_btree_close(HFS_SB(sb)->cat_tree);\n\n\t/* free the buffers holding the primary and alternate MDBs */\n\tbrelse(HFS_SB(sb)->mdb_bh);\n\tbrelse(HFS_SB(sb)->alt_mdb_bh);\n\n\tunload_nls(HFS_SB(sb)->nls_io);\n\tunload_nls(HFS_SB(sb)->nls_disk);\n\n\tfree_pages((unsigned long)HFS_SB(sb)->bitmap, PAGE_SIZE < 8192 ? 1 : 0);\n\tkfree(HFS_SB(sb));\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/nls.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "HFS_SB(sb)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)HFS_SB(sb)->bitmap",
            "PAGE_SIZE < 8192 ? 1 : 0"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unload_nls",
          "args": [
            "HFS_SB(sb)->nls_disk"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "unload_nls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_base.c",
          "lines": "296-300",
          "snippet": "void unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}",
          "includes": [
            "#include <asm/byteorder.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kmod.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/kmod.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid unload_nls(struct nls_table *nls)\n{\n\tif (nls)\n\t\tmodule_put(nls->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "HFS_SB(sb)->alt_mdb_bh"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_btree_close",
          "args": [
            "HFS_SB(sb)->cat_tree"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/btree.c",
          "lines": "136-157",
          "snippet": "void hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_err(\"node %d:%d still has %d user(s)!\\n\",\n\t\t\t\t       node->tree->cnid, node->this,\n\t\t\t\t       atomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_btree_close(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node;\n\tint i;\n\n\tif (!tree)\n\t\treturn;\n\n\tfor (i = 0; i < NODE_HASH_SIZE; i++) {\n\t\twhile ((node = tree->node_hash[i])) {\n\t\t\ttree->node_hash[i] = node->next_hash;\n\t\t\tif (atomic_read(&node->refcnt))\n\t\t\t\tpr_err(\"node %d:%d still has %d user(s)!\\n\",\n\t\t\t\t       node->tree->cnid, node->this,\n\t\t\t\t       atomic_read(&node->refcnt));\n\t\t\thfs_bnode_free(node);\n\t\t\ttree->node_hash_cnt--;\n\t\t}\n\t}\n\tiput(tree->inode);\n\tkfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n\nvoid hfs_mdb_put(struct super_block *sb)\n{\n\tif (!HFS_SB(sb))\n\t\treturn;\n\t/* free the B-trees */\n\thfs_btree_close(HFS_SB(sb)->ext_tree);\n\thfs_btree_close(HFS_SB(sb)->cat_tree);\n\n\t/* free the buffers holding the primary and alternate MDBs */\n\tbrelse(HFS_SB(sb)->mdb_bh);\n\tbrelse(HFS_SB(sb)->alt_mdb_bh);\n\n\tunload_nls(HFS_SB(sb)->nls_io);\n\tunload_nls(HFS_SB(sb)->nls_disk);\n\n\tfree_pages((unsigned long)HFS_SB(sb)->bitmap, PAGE_SIZE < 8192 ? 1 : 0);\n\tkfree(HFS_SB(sb));\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "hfs_mdb_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/mdb.c",
    "lines": "334-342",
    "snippet": "void hfs_mdb_close(struct super_block *sb)\n{\n\t/* update volume attributes */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\tHFS_SB(sb)->mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\n\tHFS_SB(sb)->mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\n\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/nls.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "HFS_SB(sb)->mdb_bh"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "~HFS_SB_ATTRIB_INCNSTNT"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB_ATTRIB_UNMNT"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n\nvoid hfs_mdb_close(struct super_block *sb)\n{\n\t/* update volume attributes */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\tHFS_SB(sb)->mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\n\tHFS_SB(sb)->mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\n\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n}"
  },
  {
    "function_name": "hfs_mdb_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/mdb.c",
    "lines": "258-332",
    "snippet": "void hfs_mdb_commit(struct super_block *sb)\n{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tlock_buffer(HFS_SB(sb)->mdb_bh);\n\tif (test_and_clear_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags)) {\n\t\t/* These parameters may have been modified, so write them back */\n\t\tmdb->drLsMod = hfs_mtime();\n\t\tmdb->drFreeBks = cpu_to_be16(HFS_SB(sb)->free_ablocks);\n\t\tmdb->drNxtCNID = cpu_to_be32(HFS_SB(sb)->next_id);\n\t\tmdb->drNmFls = cpu_to_be16(HFS_SB(sb)->root_files);\n\t\tmdb->drNmRtDirs = cpu_to_be16(HFS_SB(sb)->root_dirs);\n\t\tmdb->drFilCnt = cpu_to_be32(HFS_SB(sb)->file_count);\n\t\tmdb->drDirCnt = cpu_to_be32(HFS_SB(sb)->folder_count);\n\n\t\t/* write MDB to disk */\n\t\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n\t}\n\n\t/* write the backup MDB, not returning until it is written.\n\t * we only do this when either the catalog or extents overflow\n\t * files grow. */\n\tif (test_and_clear_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags) &&\n\t    HFS_SB(sb)->alt_mdb) {\n\t\thfs_inode_write_fork(HFS_SB(sb)->ext_tree->inode, mdb->drXTExtRec,\n\t\t\t\t     &mdb->drXTFlSize, NULL);\n\t\thfs_inode_write_fork(HFS_SB(sb)->cat_tree->inode, mdb->drCTExtRec,\n\t\t\t\t     &mdb->drCTFlSize, NULL);\n\n\t\tlock_buffer(HFS_SB(sb)->alt_mdb_bh);\n\t\tmemcpy(HFS_SB(sb)->alt_mdb, HFS_SB(sb)->mdb, HFS_SECTOR_SIZE);\n\t\tHFS_SB(sb)->alt_mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\n\t\tHFS_SB(sb)->alt_mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\n\t\tunlock_buffer(HFS_SB(sb)->alt_mdb_bh);\n\n\t\tmark_buffer_dirty(HFS_SB(sb)->alt_mdb_bh);\n\t\tsync_dirty_buffer(HFS_SB(sb)->alt_mdb_bh);\n\t}\n\n\tif (test_and_clear_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags)) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t block;\n\t\tchar *ptr;\n\t\tint off, size, len;\n\n\t\tblock = be16_to_cpu(HFS_SB(sb)->mdb->drVBMSt) + HFS_SB(sb)->part_start;\n\t\toff = (block << HFS_SECTOR_SIZE_BITS) & (sb->s_blocksize - 1);\n\t\tblock >>= sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS;\n\t\tsize = (HFS_SB(sb)->fs_ablocks + 7) / 8;\n\t\tptr = (u8 *)HFS_SB(sb)->bitmap;\n\t\twhile (size) {\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"unable to read volume bitmap\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = min((int)sb->s_blocksize - off, size);\n\n\t\t\tlock_buffer(bh);\n\t\t\tmemcpy(bh->b_data + off, ptr, len);\n\t\t\tunlock_buffer(bh);\n\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tblock++;\n\t\t\toff = 0;\n\t\t\tptr += len;\n\t\t\tsize -= len;\n\t\t}\n\t}\n\tunlock_buffer(HFS_SB(sb)->mdb_bh);\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/nls.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "HFS_SB(sb)->mdb_bh"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data + off",
            "ptr",
            "len"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(int)sb->s_blocksize - off",
            "size"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to read volume bitmap\\n\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "HFS_SB(sb)->mdb->drVBMSt"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "HFS_FLG_BITMAP_DIRTY",
            "&HFS_SB(sb)->flags"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "HFS_SB(sb)->alt_mdb_bh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "~HFS_SB_ATTRIB_INCNSTNT"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB_ATTRIB_UNMNT"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "HFS_SB(sb)->alt_mdb",
            "HFS_SB(sb)->mdb",
            "HFS_SECTOR_SIZE"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_inode_write_fork",
          "args": [
            "HFS_SB(sb)->cat_tree->inode",
            "mdb->drCTExtRec",
            "&mdb->drCTFlSize",
            "NULL"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_inode_write_fork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "403-413",
          "snippet": "void hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t  __be32 *log_size, __be32 *phys_size)\n{\n\tmemcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));\n\n\tif (log_size)\n\t\t*log_size = cpu_to_be32(inode->i_size);\n\tif (phys_size)\n\t\t*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_inode_write_fork(struct inode *inode, struct hfs_extent *ext,\n\t\t\t  __be32 *log_size, __be32 *phys_size)\n{\n\tmemcpy(ext, HFS_I(inode)->first_extents, sizeof(hfs_extent_rec));\n\n\tif (log_size)\n\t\t*log_size = cpu_to_be32(inode->i_size);\n\tif (phys_size)\n\t\t*phys_size = cpu_to_be32(HFS_I(inode)->alloc_blocks *\n\t\t\t\t\t HFS_SB(inode->i_sb)->alloc_blksz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFS_SB(sb)->folder_count"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFS_SB(sb)->file_count"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB(sb)->root_dirs"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB(sb)->root_files"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFS_SB(sb)->next_id"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB(sb)->free_ablocks"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_mtime",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n\nvoid hfs_mdb_commit(struct super_block *sb)\n{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tlock_buffer(HFS_SB(sb)->mdb_bh);\n\tif (test_and_clear_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags)) {\n\t\t/* These parameters may have been modified, so write them back */\n\t\tmdb->drLsMod = hfs_mtime();\n\t\tmdb->drFreeBks = cpu_to_be16(HFS_SB(sb)->free_ablocks);\n\t\tmdb->drNxtCNID = cpu_to_be32(HFS_SB(sb)->next_id);\n\t\tmdb->drNmFls = cpu_to_be16(HFS_SB(sb)->root_files);\n\t\tmdb->drNmRtDirs = cpu_to_be16(HFS_SB(sb)->root_dirs);\n\t\tmdb->drFilCnt = cpu_to_be32(HFS_SB(sb)->file_count);\n\t\tmdb->drDirCnt = cpu_to_be32(HFS_SB(sb)->folder_count);\n\n\t\t/* write MDB to disk */\n\t\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n\t}\n\n\t/* write the backup MDB, not returning until it is written.\n\t * we only do this when either the catalog or extents overflow\n\t * files grow. */\n\tif (test_and_clear_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags) &&\n\t    HFS_SB(sb)->alt_mdb) {\n\t\thfs_inode_write_fork(HFS_SB(sb)->ext_tree->inode, mdb->drXTExtRec,\n\t\t\t\t     &mdb->drXTFlSize, NULL);\n\t\thfs_inode_write_fork(HFS_SB(sb)->cat_tree->inode, mdb->drCTExtRec,\n\t\t\t\t     &mdb->drCTFlSize, NULL);\n\n\t\tlock_buffer(HFS_SB(sb)->alt_mdb_bh);\n\t\tmemcpy(HFS_SB(sb)->alt_mdb, HFS_SB(sb)->mdb, HFS_SECTOR_SIZE);\n\t\tHFS_SB(sb)->alt_mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\n\t\tHFS_SB(sb)->alt_mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\n\t\tunlock_buffer(HFS_SB(sb)->alt_mdb_bh);\n\n\t\tmark_buffer_dirty(HFS_SB(sb)->alt_mdb_bh);\n\t\tsync_dirty_buffer(HFS_SB(sb)->alt_mdb_bh);\n\t}\n\n\tif (test_and_clear_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags)) {\n\t\tstruct buffer_head *bh;\n\t\tsector_t block;\n\t\tchar *ptr;\n\t\tint off, size, len;\n\n\t\tblock = be16_to_cpu(HFS_SB(sb)->mdb->drVBMSt) + HFS_SB(sb)->part_start;\n\t\toff = (block << HFS_SECTOR_SIZE_BITS) & (sb->s_blocksize - 1);\n\t\tblock >>= sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS;\n\t\tsize = (HFS_SB(sb)->fs_ablocks + 7) / 8;\n\t\tptr = (u8 *)HFS_SB(sb)->bitmap;\n\t\twhile (size) {\n\t\t\tbh = sb_bread(sb, block);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"unable to read volume bitmap\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = min((int)sb->s_blocksize - off, size);\n\n\t\t\tlock_buffer(bh);\n\t\t\tmemcpy(bh->b_data + off, ptr, len);\n\t\t\tunlock_buffer(bh);\n\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tbrelse(bh);\n\t\t\tblock++;\n\t\t\toff = 0;\n\t\t\tptr += len;\n\t\t\tsize -= len;\n\t\t}\n\t}\n\tunlock_buffer(HFS_SB(sb)->mdb_bh);\n}"
  },
  {
    "function_name": "hfs_mdb_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/mdb.c",
    "lines": "67-232",
    "snippet": "int hfs_mdb_get(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct hfs_mdb *mdb, *mdb2;\n\tunsigned int block;\n\tchar *ptr;\n\tint off2, len, size, sect;\n\tsector_t part_start, part_size;\n\tloff_t off;\n\t__be16 attrib;\n\n\t/* set the device driver to 512-byte blocks */\n\tsize = sb_min_blocksize(sb, HFS_SECTOR_SIZE);\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tif (hfs_get_last_session(sb, &part_start, &part_size))\n\t\treturn -EINVAL;\n\twhile (1) {\n\t\t/* See if this is an HFS filesystem */\n\t\tbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tif (mdb->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC))\n\t\t\tbreak;\n\t\tbrelse(bh);\n\n\t\t/* check for a partition block\n\t\t * (should do this only for cdrom/loop though)\n\t\t */\n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out;\n\t}\n\n\tHFS_SB(sb)->alloc_blksz = size = be32_to_cpu(mdb->drAlBlkSiz);\n\tif (!size || (size & (HFS_SECTOR_SIZE - 1))) {\n\t\tpr_err(\"bad allocation block size %d\\n\", size);\n\t\tgoto out_bh;\n\t}\n\n\tsize = min(HFS_SB(sb)->alloc_blksz, (u32)PAGE_SIZE);\n\t/* size must be a multiple of 512 */\n\twhile (size & (size - 1))\n\t\tsize -= HFS_SECTOR_SIZE;\n\tsect = be16_to_cpu(mdb->drAlBlSt) + part_start;\n\t/* align block size to first sector */\n\twhile (sect & ((size - 1) >> HFS_SECTOR_SIZE_BITS))\n\t\tsize >>= 1;\n\t/* align block size to weird alloc size */\n\twhile (HFS_SB(sb)->alloc_blksz & (size - 1))\n\t\tsize >>= 1;\n\tbrelse(bh);\n\tif (!sb_set_blocksize(sb, size)) {\n\t\tpr_err(\"unable to set blocksize to %u\\n\", size);\n\t\tgoto out;\n\t}\n\n\tbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\n\tif (!bh)\n\t\tgoto out;\n\tif (mdb->drSigWord != cpu_to_be16(HFS_SUPER_MAGIC))\n\t\tgoto out_bh;\n\n\tHFS_SB(sb)->mdb_bh = bh;\n\tHFS_SB(sb)->mdb = mdb;\n\n\t/* These parameters are read from the MDB, and never written */\n\tHFS_SB(sb)->part_start = part_start;\n\tHFS_SB(sb)->fs_ablocks = be16_to_cpu(mdb->drNmAlBlks);\n\tHFS_SB(sb)->fs_div = HFS_SB(sb)->alloc_blksz >> sb->s_blocksize_bits;\n\tHFS_SB(sb)->clumpablks = be32_to_cpu(mdb->drClpSiz) /\n\t\t\t\t HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_SB(sb)->clumpablks)\n\t\tHFS_SB(sb)->clumpablks = 1;\n\tHFS_SB(sb)->fs_start = (be16_to_cpu(mdb->drAlBlSt) + part_start) >>\n\t\t\t       (sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS);\n\n\t/* These parameters are read from and written to the MDB */\n\tHFS_SB(sb)->free_ablocks = be16_to_cpu(mdb->drFreeBks);\n\tHFS_SB(sb)->next_id = be32_to_cpu(mdb->drNxtCNID);\n\tHFS_SB(sb)->root_files = be16_to_cpu(mdb->drNmFls);\n\tHFS_SB(sb)->root_dirs = be16_to_cpu(mdb->drNmRtDirs);\n\tHFS_SB(sb)->file_count = be32_to_cpu(mdb->drFilCnt);\n\tHFS_SB(sb)->folder_count = be32_to_cpu(mdb->drDirCnt);\n\n\t/* TRY to get the alternate (backup) MDB. */\n\tsect = part_start + part_size - 2;\n\tbh = sb_bread512(sb, sect, mdb2);\n\tif (bh) {\n\t\tif (mdb2->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC)) {\n\t\t\tHFS_SB(sb)->alt_mdb_bh = bh;\n\t\t\tHFS_SB(sb)->alt_mdb = mdb2;\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (!HFS_SB(sb)->alt_mdb) {\n\t\tpr_warn(\"unable to locate alternate MDB\\n\");\n\t\tpr_warn(\"continuing without an alternate MDB\\n\");\n\t}\n\n\tHFS_SB(sb)->bitmap = (__be32 *)__get_free_pages(GFP_KERNEL, PAGE_SIZE < 8192 ? 1 : 0);\n\tif (!HFS_SB(sb)->bitmap)\n\t\tgoto out;\n\n\t/* read in the bitmap */\n\tblock = be16_to_cpu(mdb->drVBMSt) + part_start;\n\toff = (loff_t)block << HFS_SECTOR_SIZE_BITS;\n\tsize = (HFS_SB(sb)->fs_ablocks + 8) / 8;\n\tptr = (u8 *)HFS_SB(sb)->bitmap;\n\twhile (size) {\n\t\tbh = sb_bread(sb, off >> sb->s_blocksize_bits);\n\t\tif (!bh) {\n\t\t\tpr_err(\"unable to read volume bitmap\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\toff2 = off & (sb->s_blocksize - 1);\n\t\tlen = min((int)sb->s_blocksize - off2, size);\n\t\tmemcpy(ptr, bh->b_data + off2, len);\n\t\tbrelse(bh);\n\t\tptr += len;\n\t\toff += len;\n\t\tsize -= len;\n\t}\n\n\tHFS_SB(sb)->ext_tree = hfs_btree_open(sb, HFS_EXT_CNID, hfs_ext_keycmp);\n\tif (!HFS_SB(sb)->ext_tree) {\n\t\tpr_err(\"unable to open extent tree\\n\");\n\t\tgoto out;\n\t}\n\tHFS_SB(sb)->cat_tree = hfs_btree_open(sb, HFS_CAT_CNID, hfs_cat_keycmp);\n\tif (!HFS_SB(sb)->cat_tree) {\n\t\tpr_err(\"unable to open catalog tree\\n\");\n\t\tgoto out;\n\t}\n\n\tattrib = mdb->drAtrb;\n\tif (!(attrib & cpu_to_be16(HFS_SB_ATTRIB_UNMNT))) {\n\t\tpr_warn(\"filesystem was not cleanly unmounted, running fsck.hfs is recommended.  mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif ((attrib & cpu_to_be16(HFS_SB_ATTRIB_SLOCK))) {\n\t\tpr_warn(\"filesystem is marked locked, mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/* Mark the volume uncleanly unmounted in case we crash */\n\t\tattrib &= cpu_to_be16(~HFS_SB_ATTRIB_UNMNT);\n\t\tattrib |= cpu_to_be16(HFS_SB_ATTRIB_INCNSTNT);\n\t\tmdb->drAtrb = attrib;\n\t\tbe32_add_cpu(&mdb->drWrCnt, 1);\n\t\tmdb->drLsMod = hfs_mtime();\n\n\t\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n\t\tsync_dirty_buffer(HFS_SB(sb)->mdb_bh);\n\t}\n\n\treturn 0;\n\nout_bh:\n\tbrelse(bh);\nout:\n\thfs_mdb_put(sb);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/nls.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_mdb_put",
          "args": [
            "sb"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_mdb_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/mdb.c",
          "lines": "348-366",
          "snippet": "void hfs_mdb_put(struct super_block *sb)\n{\n\tif (!HFS_SB(sb))\n\t\treturn;\n\t/* free the B-trees */\n\thfs_btree_close(HFS_SB(sb)->ext_tree);\n\thfs_btree_close(HFS_SB(sb)->cat_tree);\n\n\t/* free the buffers holding the primary and alternate MDBs */\n\tbrelse(HFS_SB(sb)->mdb_bh);\n\tbrelse(HFS_SB(sb)->alt_mdb_bh);\n\n\tunload_nls(HFS_SB(sb)->nls_io);\n\tunload_nls(HFS_SB(sb)->nls_disk);\n\n\tfree_pages((unsigned long)HFS_SB(sb)->bitmap, PAGE_SIZE < 8192 ? 1 : 0);\n\tkfree(HFS_SB(sb));\n\tsb->s_fs_info = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/nls.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n\nvoid hfs_mdb_put(struct super_block *sb)\n{\n\tif (!HFS_SB(sb))\n\t\treturn;\n\t/* free the B-trees */\n\thfs_btree_close(HFS_SB(sb)->ext_tree);\n\thfs_btree_close(HFS_SB(sb)->cat_tree);\n\n\t/* free the buffers holding the primary and alternate MDBs */\n\tbrelse(HFS_SB(sb)->mdb_bh);\n\tbrelse(HFS_SB(sb)->alt_mdb_bh);\n\n\tunload_nls(HFS_SB(sb)->nls_io);\n\tunload_nls(HFS_SB(sb)->nls_disk);\n\n\tfree_pages((unsigned long)HFS_SB(sb)->bitmap, PAGE_SIZE < 8192 ? 1 : 0);\n\tkfree(HFS_SB(sb));\n\tsb->s_fs_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "HFS_SB(sb)->mdb_bh"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "HFS_SB(sb)->mdb_bh"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_mtime",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&mdb->drWrCnt",
            "1"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB_ATTRIB_INCNSTNT"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "~HFS_SB_ATTRIB_UNMNT"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"filesystem is marked locked, mounting read-only.\\n\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB_ATTRIB_SLOCK"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"filesystem was not cleanly unmounted, running fsck.hfs is recommended.  mounting read-only.\\n\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SB_ATTRIB_UNMNT"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to open catalog tree\\n\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_btree_open",
          "args": [
            "sb",
            "HFS_CAT_CNID",
            "hfs_cat_keycmp"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/btree.c",
          "lines": "18-133",
          "snippet": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id, btree_keycmp keycmp)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\t/* Set the correct compare function */\n\ttree->sb = sb;\n\ttree->cnid = id;\n\ttree->keycmp = keycmp;\n\n\ttree->inode = iget_locked(sb, id);\n\tif (!tree->inode)\n\t\tgoto free_tree;\n\tBUG_ON(!(tree->inode->i_state & I_NEW));\n\t{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\tHFS_I(tree->inode)->flags = 0;\n\tmutex_init(&HFS_I(tree->inode)->extents_lock);\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drXTExtRec, mdb->drXTFlSize,\n\t\t\t\t    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));\n\t\tif (HFS_I(tree->inode)->alloc_blocks >\n\t\t\t\t\tHFS_I(tree->inode)->first_blocks) {\n\t\t\tpr_err(\"invalid btree extent records\\n\");\n\t\t\tunlock_new_inode(tree->inode);\n\t\t\tgoto free_inode;\n\t\t}\n\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drCTExtRec, mdb->drCTFlSize,\n\t\t\t\t    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));\n\n\t\tif (!HFS_I(tree->inode)->first_blocks) {\n\t\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\t\tunlock_new_inode(tree->inode);\n\t\t\tgoto free_inode;\n\t\t}\n\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t}\n\tunlock_new_inode(tree->inode);\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_EXT_KEYLEN) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t       tree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_CAT_KEYLEN) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t       tree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\ttree->node_size_shift = ffs(size) - 1;\n\ttree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\nfail_page:\n\tpage_cache_release(page);\nfree_inode:\n\ttree->inode->i_mapping->a_ops = &hfs_aops;\n\tiput(tree->inode);\nfree_tree:\n\tkfree(tree);\n\treturn NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nstruct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id, btree_keycmp keycmp)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\t/* Set the correct compare function */\n\ttree->sb = sb;\n\ttree->cnid = id;\n\ttree->keycmp = keycmp;\n\n\ttree->inode = iget_locked(sb, id);\n\tif (!tree->inode)\n\t\tgoto free_tree;\n\tBUG_ON(!(tree->inode->i_state & I_NEW));\n\t{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\tHFS_I(tree->inode)->flags = 0;\n\tmutex_init(&HFS_I(tree->inode)->extents_lock);\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drXTExtRec, mdb->drXTFlSize,\n\t\t\t\t    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));\n\t\tif (HFS_I(tree->inode)->alloc_blocks >\n\t\t\t\t\tHFS_I(tree->inode)->first_blocks) {\n\t\t\tpr_err(\"invalid btree extent records\\n\");\n\t\t\tunlock_new_inode(tree->inode);\n\t\t\tgoto free_inode;\n\t\t}\n\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drCTExtRec, mdb->drCTFlSize,\n\t\t\t\t    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));\n\n\t\tif (!HFS_I(tree->inode)->first_blocks) {\n\t\t\tpr_err(\"invalid btree extent records (0 size)\\n\");\n\t\t\tunlock_new_inode(tree->inode);\n\t\t\tgoto free_inode;\n\t\t}\n\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t}\n\tunlock_new_inode(tree->inode);\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_EXT_KEYLEN) {\n\t\t\tpr_err(\"invalid extent max_key_len %d\\n\",\n\t\t\t       tree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_CAT_KEYLEN) {\n\t\t\tpr_err(\"invalid catalog max_key_len %d\\n\",\n\t\t\t       tree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\ttree->node_size_shift = ffs(size) - 1;\n\ttree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\nfail_page:\n\tpage_cache_release(page);\nfree_inode:\n\ttree->inode->i_mapping->a_ops = &hfs_aops;\n\tiput(tree->inode);\nfree_tree:\n\tkfree(tree);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to open extent tree\\n\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "bh->b_data + off2",
            "len"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(int)sb->s_blocksize - off2",
            "size"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to read volume bitmap\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "off >> sb->s_blocksize_bits"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "mdb->drVBMSt"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL",
            "PAGE_SIZE < 8192 ? 1 : 0"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"continuing without an alternate MDB\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"unable to locate alternate MDB\\n\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SUPER_MAGIC"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread512",
          "args": [
            "sb",
            "sect",
            "mdb2"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "mdb->drDirCnt"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "mdb->drFilCnt"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "mdb->drNmRtDirs"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "mdb->drNmFls"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "mdb->drNxtCNID"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "mdb->drFreeBks"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "mdb->drAlBlSt"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "mdb->drClpSiz"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "mdb->drNmAlBlks"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SUPER_MAGIC"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread512",
          "args": [
            "sb",
            "part_start + HFS_MDB_BLK",
            "mdb"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unable to set blocksize to %u\\n\"",
            "size"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "size"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "mdb->drAlBlSt"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad allocation block size %d\\n\"",
            "size"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "mdb->drAlBlkSiz"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_part_find",
          "args": [
            "sb",
            "&part_start",
            "&part_size"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_part_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/part_tbl.c",
          "lines": "58-117",
          "snippet": "int hfs_part_find(struct super_block *sb,\n\t\t  sector_t *part_start, sector_t *part_size)\n{\n\tstruct buffer_head *bh;\n\t__be16 *data;\n\tint i, size, res;\n\n\tres = -ENOENT;\n\tbh = sb_bread512(sb, *part_start + HFS_PMAP_BLK, data);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tswitch (be16_to_cpu(*data)) {\n\tcase HFS_OLD_PMAP_MAGIC:\n\t  {\n\t\tstruct old_pmap *pm;\n\t\tstruct old_pmap_entry *p;\n\n\t\tpm = (struct old_pmap *)bh->b_data;\n\t\tp = pm->pdEntry;\n\t\tsize = 42;\n\t\tfor (i = 0; i < size; p++, i++) {\n\t\t\tif (p->pdStart && p->pdSize &&\n\t\t\t    p->pdFSID == cpu_to_be32(0x54465331)/*\"TFS1\"*/ &&\n\t\t\t    (HFS_SB(sb)->part < 0 || HFS_SB(sb)->part == i)) {\n\t\t\t\t*part_start += be32_to_cpu(p->pdStart);\n\t\t\t\t*part_size = be32_to_cpu(p->pdSize);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t  }\n\tcase HFS_NEW_PMAP_MAGIC:\n\t  {\n\t\tstruct new_pmap *pm;\n\n\t\tpm = (struct new_pmap *)bh->b_data;\n\t\tsize = be32_to_cpu(pm->pmMapBlkCnt);\n\t\tfor (i = 0; i < size;) {\n\t\t\tif (!memcmp(pm->pmPartType,\"Apple_HFS\", 9) &&\n\t\t\t    (HFS_SB(sb)->part < 0 || HFS_SB(sb)->part == i)) {\n\t\t\t\t*part_start += be32_to_cpu(pm->pmPyPartStart);\n\t\t\t\t*part_size = be32_to_cpu(pm->pmPartBlkCnt);\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tbh = sb_bread512(sb, *part_start + HFS_PMAP_BLK + ++i, pm);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tif (pm->pmSig != cpu_to_be16(HFS_NEW_PMAP_MAGIC))\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t  }\n\t}\n\tbrelse(bh);\n\n\treturn res;\n}",
          "includes": [
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct old_pmap {\n\t__be16\t\tpdSig;\t/* Signature bytes */\n\tstruct \told_pmap_entry {\n\t\t__be32\tpdStart;\n\t\t__be32\tpdSize;\n\t\t__be32\tpdFSID;\n\t}\tpdEntry[42];\n} __packed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfs_fs.h\"\n\nstruct old_pmap {\n\t__be16\t\tpdSig;\t/* Signature bytes */\n\tstruct \told_pmap_entry {\n\t\t__be32\tpdStart;\n\t\t__be32\tpdSize;\n\t\t__be32\tpdFSID;\n\t}\tpdEntry[42];\n} __packed;\n\nint hfs_part_find(struct super_block *sb,\n\t\t  sector_t *part_start, sector_t *part_size)\n{\n\tstruct buffer_head *bh;\n\t__be16 *data;\n\tint i, size, res;\n\n\tres = -ENOENT;\n\tbh = sb_bread512(sb, *part_start + HFS_PMAP_BLK, data);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tswitch (be16_to_cpu(*data)) {\n\tcase HFS_OLD_PMAP_MAGIC:\n\t  {\n\t\tstruct old_pmap *pm;\n\t\tstruct old_pmap_entry *p;\n\n\t\tpm = (struct old_pmap *)bh->b_data;\n\t\tp = pm->pdEntry;\n\t\tsize = 42;\n\t\tfor (i = 0; i < size; p++, i++) {\n\t\t\tif (p->pdStart && p->pdSize &&\n\t\t\t    p->pdFSID == cpu_to_be32(0x54465331)/*\"TFS1\"*/ &&\n\t\t\t    (HFS_SB(sb)->part < 0 || HFS_SB(sb)->part == i)) {\n\t\t\t\t*part_start += be32_to_cpu(p->pdStart);\n\t\t\t\t*part_size = be32_to_cpu(p->pdSize);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t  }\n\tcase HFS_NEW_PMAP_MAGIC:\n\t  {\n\t\tstruct new_pmap *pm;\n\n\t\tpm = (struct new_pmap *)bh->b_data;\n\t\tsize = be32_to_cpu(pm->pmMapBlkCnt);\n\t\tfor (i = 0; i < size;) {\n\t\t\tif (!memcmp(pm->pmPartType,\"Apple_HFS\", 9) &&\n\t\t\t    (HFS_SB(sb)->part < 0 || HFS_SB(sb)->part == i)) {\n\t\t\t\t*part_start += be32_to_cpu(pm->pmPyPartStart);\n\t\t\t\t*part_size = be32_to_cpu(pm->pmPartBlkCnt);\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tbh = sb_bread512(sb, *part_start + HFS_PMAP_BLK + ++i, pm);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tif (pm->pmSig != cpu_to_be16(HFS_NEW_PMAP_MAGIC))\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t  }\n\t}\n\tbrelse(bh);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFS_SUPER_MAGIC"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread512",
          "args": [
            "sb",
            "part_start + HFS_MDB_BLK",
            "mdb"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_get_last_session",
          "args": [
            "sb",
            "&part_start",
            "&part_size"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_get_last_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/mdb.c",
          "lines": "32-59",
          "snippet": "static int hfs_get_last_session(struct super_block *sb,\n\t\t\t\tsector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/nls.h>",
            "#include <linux/genhd.h>",
            "#include <linux/cdrom.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n\nstatic int hfs_get_last_session(struct super_block *sb,\n\t\t\t\tsector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "HFS_SECTOR_SIZE"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n\nint hfs_mdb_get(struct super_block *sb)\n{\n\tstruct buffer_head *bh;\n\tstruct hfs_mdb *mdb, *mdb2;\n\tunsigned int block;\n\tchar *ptr;\n\tint off2, len, size, sect;\n\tsector_t part_start, part_size;\n\tloff_t off;\n\t__be16 attrib;\n\n\t/* set the device driver to 512-byte blocks */\n\tsize = sb_min_blocksize(sb, HFS_SECTOR_SIZE);\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tif (hfs_get_last_session(sb, &part_start, &part_size))\n\t\treturn -EINVAL;\n\twhile (1) {\n\t\t/* See if this is an HFS filesystem */\n\t\tbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tif (mdb->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC))\n\t\t\tbreak;\n\t\tbrelse(bh);\n\n\t\t/* check for a partition block\n\t\t * (should do this only for cdrom/loop though)\n\t\t */\n\t\tif (hfs_part_find(sb, &part_start, &part_size))\n\t\t\tgoto out;\n\t}\n\n\tHFS_SB(sb)->alloc_blksz = size = be32_to_cpu(mdb->drAlBlkSiz);\n\tif (!size || (size & (HFS_SECTOR_SIZE - 1))) {\n\t\tpr_err(\"bad allocation block size %d\\n\", size);\n\t\tgoto out_bh;\n\t}\n\n\tsize = min(HFS_SB(sb)->alloc_blksz, (u32)PAGE_SIZE);\n\t/* size must be a multiple of 512 */\n\twhile (size & (size - 1))\n\t\tsize -= HFS_SECTOR_SIZE;\n\tsect = be16_to_cpu(mdb->drAlBlSt) + part_start;\n\t/* align block size to first sector */\n\twhile (sect & ((size - 1) >> HFS_SECTOR_SIZE_BITS))\n\t\tsize >>= 1;\n\t/* align block size to weird alloc size */\n\twhile (HFS_SB(sb)->alloc_blksz & (size - 1))\n\t\tsize >>= 1;\n\tbrelse(bh);\n\tif (!sb_set_blocksize(sb, size)) {\n\t\tpr_err(\"unable to set blocksize to %u\\n\", size);\n\t\tgoto out;\n\t}\n\n\tbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\n\tif (!bh)\n\t\tgoto out;\n\tif (mdb->drSigWord != cpu_to_be16(HFS_SUPER_MAGIC))\n\t\tgoto out_bh;\n\n\tHFS_SB(sb)->mdb_bh = bh;\n\tHFS_SB(sb)->mdb = mdb;\n\n\t/* These parameters are read from the MDB, and never written */\n\tHFS_SB(sb)->part_start = part_start;\n\tHFS_SB(sb)->fs_ablocks = be16_to_cpu(mdb->drNmAlBlks);\n\tHFS_SB(sb)->fs_div = HFS_SB(sb)->alloc_blksz >> sb->s_blocksize_bits;\n\tHFS_SB(sb)->clumpablks = be32_to_cpu(mdb->drClpSiz) /\n\t\t\t\t HFS_SB(sb)->alloc_blksz;\n\tif (!HFS_SB(sb)->clumpablks)\n\t\tHFS_SB(sb)->clumpablks = 1;\n\tHFS_SB(sb)->fs_start = (be16_to_cpu(mdb->drAlBlSt) + part_start) >>\n\t\t\t       (sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS);\n\n\t/* These parameters are read from and written to the MDB */\n\tHFS_SB(sb)->free_ablocks = be16_to_cpu(mdb->drFreeBks);\n\tHFS_SB(sb)->next_id = be32_to_cpu(mdb->drNxtCNID);\n\tHFS_SB(sb)->root_files = be16_to_cpu(mdb->drNmFls);\n\tHFS_SB(sb)->root_dirs = be16_to_cpu(mdb->drNmRtDirs);\n\tHFS_SB(sb)->file_count = be32_to_cpu(mdb->drFilCnt);\n\tHFS_SB(sb)->folder_count = be32_to_cpu(mdb->drDirCnt);\n\n\t/* TRY to get the alternate (backup) MDB. */\n\tsect = part_start + part_size - 2;\n\tbh = sb_bread512(sb, sect, mdb2);\n\tif (bh) {\n\t\tif (mdb2->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC)) {\n\t\t\tHFS_SB(sb)->alt_mdb_bh = bh;\n\t\t\tHFS_SB(sb)->alt_mdb = mdb2;\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (!HFS_SB(sb)->alt_mdb) {\n\t\tpr_warn(\"unable to locate alternate MDB\\n\");\n\t\tpr_warn(\"continuing without an alternate MDB\\n\");\n\t}\n\n\tHFS_SB(sb)->bitmap = (__be32 *)__get_free_pages(GFP_KERNEL, PAGE_SIZE < 8192 ? 1 : 0);\n\tif (!HFS_SB(sb)->bitmap)\n\t\tgoto out;\n\n\t/* read in the bitmap */\n\tblock = be16_to_cpu(mdb->drVBMSt) + part_start;\n\toff = (loff_t)block << HFS_SECTOR_SIZE_BITS;\n\tsize = (HFS_SB(sb)->fs_ablocks + 8) / 8;\n\tptr = (u8 *)HFS_SB(sb)->bitmap;\n\twhile (size) {\n\t\tbh = sb_bread(sb, off >> sb->s_blocksize_bits);\n\t\tif (!bh) {\n\t\t\tpr_err(\"unable to read volume bitmap\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\toff2 = off & (sb->s_blocksize - 1);\n\t\tlen = min((int)sb->s_blocksize - off2, size);\n\t\tmemcpy(ptr, bh->b_data + off2, len);\n\t\tbrelse(bh);\n\t\tptr += len;\n\t\toff += len;\n\t\tsize -= len;\n\t}\n\n\tHFS_SB(sb)->ext_tree = hfs_btree_open(sb, HFS_EXT_CNID, hfs_ext_keycmp);\n\tif (!HFS_SB(sb)->ext_tree) {\n\t\tpr_err(\"unable to open extent tree\\n\");\n\t\tgoto out;\n\t}\n\tHFS_SB(sb)->cat_tree = hfs_btree_open(sb, HFS_CAT_CNID, hfs_cat_keycmp);\n\tif (!HFS_SB(sb)->cat_tree) {\n\t\tpr_err(\"unable to open catalog tree\\n\");\n\t\tgoto out;\n\t}\n\n\tattrib = mdb->drAtrb;\n\tif (!(attrib & cpu_to_be16(HFS_SB_ATTRIB_UNMNT))) {\n\t\tpr_warn(\"filesystem was not cleanly unmounted, running fsck.hfs is recommended.  mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif ((attrib & cpu_to_be16(HFS_SB_ATTRIB_SLOCK))) {\n\t\tpr_warn(\"filesystem is marked locked, mounting read-only.\\n\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t/* Mark the volume uncleanly unmounted in case we crash */\n\t\tattrib &= cpu_to_be16(~HFS_SB_ATTRIB_UNMNT);\n\t\tattrib |= cpu_to_be16(HFS_SB_ATTRIB_INCNSTNT);\n\t\tmdb->drAtrb = attrib;\n\t\tbe32_add_cpu(&mdb->drWrCnt, 1);\n\t\tmdb->drLsMod = hfs_mtime();\n\n\t\tmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\n\t\tsync_dirty_buffer(HFS_SB(sb)->mdb_bh);\n\t}\n\n\treturn 0;\n\nout_bh:\n\tbrelse(bh);\nout:\n\thfs_mdb_put(sb);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "hfs_get_last_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/mdb.c",
    "lines": "32-59",
    "snippet": "static int hfs_get_last_session(struct super_block *sb,\n\t\t\t\tsector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/nls.h>",
      "#include <linux/genhd.h>",
      "#include <linux/cdrom.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioctl_by_bdev",
          "args": [
            "sb->s_bdev",
            "CDROMMULTISESSION",
            "(unsigned long)&ms_info"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_by_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1677-1685",
          "snippet": "int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid session number or type of track\\n\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/genhd.h>\n#include <linux/cdrom.h>\n\nstatic int hfs_get_last_session(struct super_block *sb,\n\t\t\t\tsector_t *start, sector_t *size)\n{\n\tstruct cdrom_multisession ms_info;\n\tstruct cdrom_tocentry te;\n\tint res;\n\n\t/* default values */\n\t*start = 0;\n\t*size = sb->s_bdev->bd_inode->i_size >> 9;\n\n\tif (HFS_SB(sb)->session >= 0) {\n\t\tte.cdte_track = HFS_SB(sb)->session;\n\t\tte.cdte_format = CDROM_LBA;\n\t\tres = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);\n\t\tif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\n\t\t\t*start = (sector_t)te.cdte_addr.lba << 2;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_err(\"invalid session number or type of track\\n\");\n\t\treturn -EINVAL;\n\t}\n\tms_info.addr_format = CDROM_LBA;\n\tres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);\n\tif (!res && ms_info.xa_flag)\n\t\t*start = (sector_t)ms_info.addr.lba << 2;\n\treturn 0;\n}"
  }
]