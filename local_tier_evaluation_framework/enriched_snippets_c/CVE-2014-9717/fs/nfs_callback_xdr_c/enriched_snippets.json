[
  {
    "function_name": "nfs4_callback_compound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "890-946",
    "snippet": "static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\tstruct cb_compound_hdr_arg hdr_arg = { 0 };\n\tstruct cb_compound_hdr_res hdr_res = { NULL };\n\tstruct xdr_stream xdr_in, xdr_out;\n\t__be32 *p, status;\n\tstruct cb_process_state cps = {\n\t\t.drc_status = 0,\n\t\t.clp = NULL,\n\t\t.slotid = NFS4_NO_SLOT,\n\t\t.net = SVC_NET(rqstp),\n\t};\n\tunsigned int nops = 0;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\n\txdr_init_decode(&xdr_in, &rqstp->rq_arg, rqstp->rq_arg.head[0].iov_base);\n\n\tp = (__be32*)((char *)rqstp->rq_res.head[0].iov_base + rqstp->rq_res.head[0].iov_len);\n\txdr_init_encode(&xdr_out, &rqstp->rq_res, p);\n\n\tstatus = decode_compound_hdr_arg(&xdr_in, &hdr_arg);\n\tif (status == __constant_htonl(NFS4ERR_RESOURCE))\n\t\treturn rpc_garbage_args;\n\n\tif (hdr_arg.minorversion == 0) {\n\t\tcps.clp = nfs4_find_client_ident(SVC_NET(rqstp), hdr_arg.cb_ident);\n\t\tif (!cps.clp || !check_gss_callback_principal(cps.clp, rqstp))\n\t\t\treturn rpc_drop_reply;\n\t}\n\n\tcps.minorversion = hdr_arg.minorversion;\n\thdr_res.taglen = hdr_arg.taglen;\n\thdr_res.tag = hdr_arg.tag;\n\tif (encode_compound_hdr_res(&xdr_out, &hdr_res) != 0)\n\t\treturn rpc_system_err;\n\n\twhile (status == 0 && nops != hdr_arg.nops) {\n\t\tstatus = process_op(nops, rqstp, &xdr_in,\n\t\t\t\t    argp, &xdr_out, resp, &cps);\n\t\tnops++;\n\t}\n\n\t/* Buffer overflow in decode_ops_hdr or encode_ops_hdr. Return\n\t* resource error in cb_compound status without returning op */\n\tif (unlikely(status == htonl(NFS4ERR_RESOURCE_HDR))) {\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\t\tnops--;\n\t}\n\n\t*hdr_res.status = status;\n\t*hdr_res.nops = htonl(nops);\n\tnfs4_cb_free_slot(&cps);\n\tnfs_put_client(cps.clp);\n\tdprintk(\"%s: done, status = %u\\n\", __func__, ntohl(status));\n\treturn rpc_success;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define NFS4ERR_RESOURCE_HDR\t11050"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done, status = %u\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_put_client",
          "args": [
            "cps.clp"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/client.c",
          "lines": "267-286",
          "snippet": "void nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <net/ipv6.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/nfs_xdr.h>\n#include <net/ipv6.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_put_client(struct nfs_client *clp)\n{\n\tstruct nfs_net *nn;\n\n\tif (!clp)\n\t\treturn;\n\n\tdprintk(\"--> nfs_put_client({%d})\\n\", atomic_read(&clp->cl_count));\n\tnn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (atomic_dec_and_lock(&clp->cl_count, &nn->nfs_client_lock)) {\n\t\tlist_del(&clp->cl_share_link);\n\t\tnfs_cb_idr_remove_locked(clp);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tWARN_ON_ONCE(!list_empty(&clp->cl_superblocks));\n\n\t\tclp->rpc_ops->free_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_cb_free_slot",
          "args": [
            "&cps"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_cb_free_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "786-788",
          "snippet": "static void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nops"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status == htonl(NFS4ERR_RESOURCE_HDR)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE_HDR"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_op",
          "args": [
            "nops",
            "rqstp",
            "&xdr_in",
            "argp",
            "&xdr_out",
            "resp",
            "&cps"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "process_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "826-885",
          "snippet": "static __be32 process_op(int nop, struct svc_rqst *rqstp,\n\t\tstruct xdr_stream *xdr_in, void *argp,\n\t\tstruct xdr_stream *xdr_out, void *resp,\n\t\tstruct cb_process_state *cps)\n{\n\tstruct callback_op *op = &callback_ops[0];\n\tunsigned int op_nr;\n\t__be32 status;\n\tlong maxlen;\n\t__be32 res;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\tstatus = decode_op_hdr(xdr_in, &op_nr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tdprintk(\"%s: minorversion=%d nop=%d op_nr=%u\\n\",\n\t\t__func__, cps->minorversion, nop, op_nr);\n\n\tswitch (cps->minorversion) {\n\tcase 0:\n\t\tstatus = preprocess_nfs4_op(op_nr, &op);\n\t\tbreak;\n\tcase 1:\n\t\tstatus = preprocess_nfs41_op(nop, op_nr, &op);\n\t\tbreak;\n\tcase 2:\n\t\tstatus = preprocess_nfs42_op(nop, op_nr, &op);\n\t\tbreak;\n\tdefault:\n\t\tstatus = htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\n\tif (status == htonl(NFS4ERR_OP_ILLEGAL))\n\t\top_nr = OP_CB_ILLEGAL;\n\tif (status)\n\t\tgoto encode_hdr;\n\n\tif (cps->drc_status) {\n\t\tstatus = cps->drc_status;\n\t\tgoto encode_hdr;\n\t}\n\n\tmaxlen = xdr_out->end - xdr_out->p;\n\tif (maxlen > 0 && maxlen < PAGE_SIZE) {\n\t\tstatus = op->decode_args(rqstp, xdr_in, argp);\n\t\tif (likely(status == 0))\n\t\t\tstatus = op->process_op(argp, resp, cps);\n\t} else\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\nencode_hdr:\n\tres = encode_op_hdr(xdr_out, op_nr, status);\n\tif (unlikely(res))\n\t\treturn res;\n\tif (op->encode_res != NULL && status == 0)\n\t\tstatus = op->encode_res(rqstp, xdr_out, resp);\n\tdprintk(\"%s: done, status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_op callback_ops[];",
            "static struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic struct callback_op callback_ops[];\nstatic struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};\n\nstatic __be32 process_op(int nop, struct svc_rqst *rqstp,\n\t\tstruct xdr_stream *xdr_in, void *argp,\n\t\tstruct xdr_stream *xdr_out, void *resp,\n\t\tstruct cb_process_state *cps)\n{\n\tstruct callback_op *op = &callback_ops[0];\n\tunsigned int op_nr;\n\t__be32 status;\n\tlong maxlen;\n\t__be32 res;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\tstatus = decode_op_hdr(xdr_in, &op_nr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tdprintk(\"%s: minorversion=%d nop=%d op_nr=%u\\n\",\n\t\t__func__, cps->minorversion, nop, op_nr);\n\n\tswitch (cps->minorversion) {\n\tcase 0:\n\t\tstatus = preprocess_nfs4_op(op_nr, &op);\n\t\tbreak;\n\tcase 1:\n\t\tstatus = preprocess_nfs41_op(nop, op_nr, &op);\n\t\tbreak;\n\tcase 2:\n\t\tstatus = preprocess_nfs42_op(nop, op_nr, &op);\n\t\tbreak;\n\tdefault:\n\t\tstatus = htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\n\tif (status == htonl(NFS4ERR_OP_ILLEGAL))\n\t\top_nr = OP_CB_ILLEGAL;\n\tif (status)\n\t\tgoto encode_hdr;\n\n\tif (cps->drc_status) {\n\t\tstatus = cps->drc_status;\n\t\tgoto encode_hdr;\n\t}\n\n\tmaxlen = xdr_out->end - xdr_out->p;\n\tif (maxlen > 0 && maxlen < PAGE_SIZE) {\n\t\tstatus = op->decode_args(rqstp, xdr_in, argp);\n\t\tif (likely(status == 0))\n\t\t\tstatus = op->process_op(argp, resp, cps);\n\t} else\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\nencode_hdr:\n\tres = encode_op_hdr(xdr_out, op_nr, status);\n\tif (unlikely(res))\n\t\treturn res;\n\tif (op->encode_res != NULL && status == 0)\n\t\tstatus = op->encode_res(rqstp, xdr_out, resp);\n\tdprintk(\"%s: done, status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_compound_hdr_res",
          "args": [
            "&xdr_out",
            "&hdr_res"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "encode_compound_hdr_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "627-641",
          "snippet": "static __be32 encode_compound_hdr_res(struct xdr_stream *xdr, struct cb_compound_hdr_res *hdr)\n{\n\t__be32 status;\n\n\thdr->status = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->status == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tstatus = encode_string(xdr, hdr->taglen, hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\thdr->nops = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->nops == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_compound_hdr_res(struct xdr_stream *xdr, struct cb_compound_hdr_res *hdr)\n{\n\t__be32 status;\n\n\thdr->status = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->status == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tstatus = encode_string(xdr, hdr->taglen, hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\thdr->nops = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->nops == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_gss_callback_principal",
          "args": [
            "cps.clp",
            "rqstp"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "check_gss_callback_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback.c",
          "lines": "417-455",
          "snippet": "int\ncheck_gss_callback_principal(struct nfs_client *clp, struct svc_rqst *rqstp)\n{\n\tchar *p = rqstp->rq_cred.cr_principal;\n\n\tif (rqstp->rq_authop->flavour != RPC_AUTH_GSS)\n\t\treturn 1;\n\n\t/* No RPC_AUTH_GSS on NFSv4.1 back channel yet */\n\tif (clp->cl_minorversion != 0)\n\t\treturn 0;\n\t/*\n\t * It might just be a normal user principal, in which case\n\t * userspace won't bother to tell us the name at all.\n\t */\n\tif (p == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Did we get the acceptor from userland during the SETCLIENID\n\t * negotiation?\n\t */\n\tif (clp->cl_acceptor)\n\t\treturn !strcmp(p, clp->cl_acceptor);\n\n\t/*\n\t * Otherwise try to verify it using the cl_hostname. Note that this\n\t * doesn't work if a non-canonical hostname was used in the devname.\n\t */\n\n\t/* Expect a GSS_C_NT_HOSTBASED_NAME like \"nfs@serverhostname\" */\n\n\tif (memcmp(p, \"nfs@\", 4) != 0)\n\t\treturn 0;\n\tp += 4;\n\tif (strcmp(p, clp->cl_hostname) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <net/inet_sock.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/errno.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/module.h>",
            "#include <linux/ip.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <net/inet_sock.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/completion.h>\n\nint\ncheck_gss_callback_principal(struct nfs_client *clp, struct svc_rqst *rqstp)\n{\n\tchar *p = rqstp->rq_cred.cr_principal;\n\n\tif (rqstp->rq_authop->flavour != RPC_AUTH_GSS)\n\t\treturn 1;\n\n\t/* No RPC_AUTH_GSS on NFSv4.1 back channel yet */\n\tif (clp->cl_minorversion != 0)\n\t\treturn 0;\n\t/*\n\t * It might just be a normal user principal, in which case\n\t * userspace won't bother to tell us the name at all.\n\t */\n\tif (p == NULL)\n\t\treturn 0;\n\n\t/*\n\t * Did we get the acceptor from userland during the SETCLIENID\n\t * negotiation?\n\t */\n\tif (clp->cl_acceptor)\n\t\treturn !strcmp(p, clp->cl_acceptor);\n\n\t/*\n\t * Otherwise try to verify it using the cl_hostname. Note that this\n\t * doesn't work if a non-canonical hostname was used in the devname.\n\t */\n\n\t/* Expect a GSS_C_NT_HOSTBASED_NAME like \"nfs@serverhostname\" */\n\n\tif (memcmp(p, \"nfs@\", 4) != 0)\n\t\treturn 0;\n\tp += 4;\n\tif (strcmp(p, clp->cl_hostname) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_find_client_ident",
          "args": [
            "SVC_NET(rqstp)",
            "hdr_arg.cb_ident"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_client_ident",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "699-711",
          "snippet": "struct nfs_client *\nnfs4_find_client_ident(struct net *net, int cb_ident)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tclp = idr_find(&nn->cb_ident_idr, cb_ident);\n\tif (clp)\n\t\tatomic_inc(&clp->cl_count);\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn clp;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nstruct nfs_client *\nnfs4_find_client_ident(struct net *net, int cb_ident)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tclp = idr_find(&nn->cb_ident_idr, cb_ident);\n\tif (clp)\n\t\tatomic_inc(&clp->cl_count);\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn clp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__constant_htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_compound_hdr_arg",
          "args": [
            "&xdr_in",
            "&hdr_arg"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "decode_compound_hdr_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "151-182",
          "snippet": "static __be32 decode_compound_hdr_arg(struct xdr_stream *xdr, struct cb_compound_hdr_arg *hdr)\n{\n\t__be32 *p;\n\t__be32 status;\n\n\tstatus = decode_string(xdr, &hdr->taglen, &hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\t/* We do not like overly long tags! */\n\tif (hdr->taglen > CB_OP_TAGLEN_MAXSZ - 12) {\n\t\tprintk(\"NFS: NFSv4 CALLBACK %s: client sent tag of length %u\\n\",\n\t\t\t\t__func__, hdr->taglen);\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t}\n\tp = read_buf(xdr, 12);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\thdr->minorversion = ntohl(*p++);\n\t/* Check for minor version support */\n\tif (hdr->minorversion <= NFS4_MAX_MINOR_VERSION) {\n\t\thdr->cb_ident = ntohl(*p++); /* ignored by v4.1 and v4.2 */\n\t} else {\n\t\tpr_warn_ratelimited(\"NFS: %s: NFSv4 server callback with \"\n\t\t\t\"illegal minor version %u!\\n\",\n\t\t\t__func__, hdr->minorversion);\n\t\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\thdr->nops = ntohl(*p);\n\tdprintk(\"%s: minorversion %d nops %d\\n\", __func__,\n\t\thdr->minorversion, hdr->nops);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define CB_OP_TAGLEN_MAXSZ\t(512)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define CB_OP_TAGLEN_MAXSZ\t(512)\n\nstatic __be32 decode_compound_hdr_arg(struct xdr_stream *xdr, struct cb_compound_hdr_arg *hdr)\n{\n\t__be32 *p;\n\t__be32 status;\n\n\tstatus = decode_string(xdr, &hdr->taglen, &hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\t/* We do not like overly long tags! */\n\tif (hdr->taglen > CB_OP_TAGLEN_MAXSZ - 12) {\n\t\tprintk(\"NFS: NFSv4 CALLBACK %s: client sent tag of length %u\\n\",\n\t\t\t\t__func__, hdr->taglen);\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t}\n\tp = read_buf(xdr, 12);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\thdr->minorversion = ntohl(*p++);\n\t/* Check for minor version support */\n\tif (hdr->minorversion <= NFS4_MAX_MINOR_VERSION) {\n\t\thdr->cb_ident = ntohl(*p++); /* ignored by v4.1 and v4.2 */\n\t} else {\n\t\tpr_warn_ratelimited(\"NFS: %s: NFSv4 server callback with \"\n\t\t\t\"illegal minor version %u!\\n\",\n\t\t\t__func__, hdr->minorversion);\n\t\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\thdr->nops = ntohl(*p);\n\tdprintk(\"%s: minorversion %d nops %d\\n\", __func__,\n\t\thdr->minorversion, hdr->nops);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_init_encode",
          "args": [
            "&xdr_out",
            "&rqstp->rq_res",
            "p"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode",
          "args": [
            "&xdr_in",
            "&rqstp->rq_arg",
            "rqstp->rq_arg.head[0].iov_base"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: start\\n\"",
            "__func__"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define NFS4ERR_RESOURCE_HDR\t11050\n\nstatic __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\tstruct cb_compound_hdr_arg hdr_arg = { 0 };\n\tstruct cb_compound_hdr_res hdr_res = { NULL };\n\tstruct xdr_stream xdr_in, xdr_out;\n\t__be32 *p, status;\n\tstruct cb_process_state cps = {\n\t\t.drc_status = 0,\n\t\t.clp = NULL,\n\t\t.slotid = NFS4_NO_SLOT,\n\t\t.net = SVC_NET(rqstp),\n\t};\n\tunsigned int nops = 0;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\n\txdr_init_decode(&xdr_in, &rqstp->rq_arg, rqstp->rq_arg.head[0].iov_base);\n\n\tp = (__be32*)((char *)rqstp->rq_res.head[0].iov_base + rqstp->rq_res.head[0].iov_len);\n\txdr_init_encode(&xdr_out, &rqstp->rq_res, p);\n\n\tstatus = decode_compound_hdr_arg(&xdr_in, &hdr_arg);\n\tif (status == __constant_htonl(NFS4ERR_RESOURCE))\n\t\treturn rpc_garbage_args;\n\n\tif (hdr_arg.minorversion == 0) {\n\t\tcps.clp = nfs4_find_client_ident(SVC_NET(rqstp), hdr_arg.cb_ident);\n\t\tif (!cps.clp || !check_gss_callback_principal(cps.clp, rqstp))\n\t\t\treturn rpc_drop_reply;\n\t}\n\n\tcps.minorversion = hdr_arg.minorversion;\n\thdr_res.taglen = hdr_arg.taglen;\n\thdr_res.tag = hdr_arg.tag;\n\tif (encode_compound_hdr_res(&xdr_out, &hdr_res) != 0)\n\t\treturn rpc_system_err;\n\n\twhile (status == 0 && nops != hdr_arg.nops) {\n\t\tstatus = process_op(nops, rqstp, &xdr_in,\n\t\t\t\t    argp, &xdr_out, resp, &cps);\n\t\tnops++;\n\t}\n\n\t/* Buffer overflow in decode_ops_hdr or encode_ops_hdr. Return\n\t* resource error in cb_compound status without returning op */\n\tif (unlikely(status == htonl(NFS4ERR_RESOURCE_HDR))) {\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\t\tnops--;\n\t}\n\n\t*hdr_res.status = status;\n\t*hdr_res.nops = htonl(nops);\n\tnfs4_cb_free_slot(&cps);\n\tnfs_put_client(cps.clp);\n\tdprintk(\"%s: done, status = %u\\n\", __func__, ntohl(status));\n\treturn rpc_success;\n}"
  },
  {
    "function_name": "process_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "826-885",
    "snippet": "static __be32 process_op(int nop, struct svc_rqst *rqstp,\n\t\tstruct xdr_stream *xdr_in, void *argp,\n\t\tstruct xdr_stream *xdr_out, void *resp,\n\t\tstruct cb_process_state *cps)\n{\n\tstruct callback_op *op = &callback_ops[0];\n\tunsigned int op_nr;\n\t__be32 status;\n\tlong maxlen;\n\t__be32 res;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\tstatus = decode_op_hdr(xdr_in, &op_nr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tdprintk(\"%s: minorversion=%d nop=%d op_nr=%u\\n\",\n\t\t__func__, cps->minorversion, nop, op_nr);\n\n\tswitch (cps->minorversion) {\n\tcase 0:\n\t\tstatus = preprocess_nfs4_op(op_nr, &op);\n\t\tbreak;\n\tcase 1:\n\t\tstatus = preprocess_nfs41_op(nop, op_nr, &op);\n\t\tbreak;\n\tcase 2:\n\t\tstatus = preprocess_nfs42_op(nop, op_nr, &op);\n\t\tbreak;\n\tdefault:\n\t\tstatus = htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\n\tif (status == htonl(NFS4ERR_OP_ILLEGAL))\n\t\top_nr = OP_CB_ILLEGAL;\n\tif (status)\n\t\tgoto encode_hdr;\n\n\tif (cps->drc_status) {\n\t\tstatus = cps->drc_status;\n\t\tgoto encode_hdr;\n\t}\n\n\tmaxlen = xdr_out->end - xdr_out->p;\n\tif (maxlen > 0 && maxlen < PAGE_SIZE) {\n\t\tstatus = op->decode_args(rqstp, xdr_in, argp);\n\t\tif (likely(status == 0))\n\t\t\tstatus = op->process_op(argp, resp, cps);\n\t} else\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\nencode_hdr:\n\tres = encode_op_hdr(xdr_out, op_nr, status);\n\tif (unlikely(res))\n\t\treturn res;\n\tif (op->encode_res != NULL && status == 0)\n\t\tstatus = op->encode_res(rqstp, xdr_out, resp);\n\tdprintk(\"%s: done, status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callback_op callback_ops[];",
      "static struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done, status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->encode_res",
          "args": [
            "rqstp",
            "xdr_out",
            "resp"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "res"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_op_hdr",
          "args": [
            "xdr_out",
            "op_nr",
            "status"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "encode_op_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "643-653",
          "snippet": "static __be32 encode_op_hdr(struct xdr_stream *xdr, uint32_t op, __be32 res)\n{\n\t__be32 *p;\n\t\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*p++ = htonl(op);\n\t*p = res;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NFS4ERR_RESOURCE_HDR\t11050"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define NFS4ERR_RESOURCE_HDR\t11050\n\nstatic __be32 encode_op_hdr(struct xdr_stream *xdr, uint32_t op, __be32 res)\n{\n\t__be32 *p;\n\t\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*p++ = htonl(op);\n\t*p = res;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->process_op",
          "args": [
            "argp",
            "resp",
            "cps"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "status == 0"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->decode_args",
          "args": [
            "rqstp",
            "xdr_in",
            "argp"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_ILLEGAL"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_MINOR_VERS_MISMATCH"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preprocess_nfs42_op",
          "args": [
            "nop",
            "op_nr",
            "&op"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "preprocess_nfs42_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "804-808",
          "snippet": "static __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preprocess_nfs41_op",
          "args": [
            "nop",
            "op_nr",
            "&op"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "preprocess_nfs41_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "780-784",
          "snippet": "static __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preprocess_nfs4_op",
          "args": [
            "op_nr",
            "&op"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "preprocess_nfs4_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "811-824",
          "snippet": "static __be32\npreprocess_nfs4_op(unsigned int op_nr, struct callback_op **op)\n{\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_op callback_ops[];",
            "static struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic struct callback_op callback_ops[];\nstatic struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};\n\nstatic __be32\npreprocess_nfs4_op(unsigned int op_nr, struct callback_op **op)\n{\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: minorversion=%d nop=%d op_nr=%u\\n\"",
            "__func__",
            "cps->minorversion",
            "nop",
            "op_nr"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_op_hdr",
          "args": [
            "xdr_in",
            "&op_nr"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "decode_op_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "184-192",
          "snippet": "static __be32 decode_op_hdr(struct xdr_stream *xdr, unsigned int *op)\n{\n\t__be32 *p;\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*op = ntohl(*p);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define NFS4ERR_RESOURCE_HDR\t11050"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define NFS4ERR_RESOURCE_HDR\t11050\n\nstatic __be32 decode_op_hdr(struct xdr_stream *xdr, unsigned int *op)\n{\n\t__be32 *p;\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*op = ntohl(*p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: start\\n\"",
            "__func__"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic struct callback_op callback_ops[];\nstatic struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};\n\nstatic __be32 process_op(int nop, struct svc_rqst *rqstp,\n\t\tstruct xdr_stream *xdr_in, void *argp,\n\t\tstruct xdr_stream *xdr_out, void *resp,\n\t\tstruct cb_process_state *cps)\n{\n\tstruct callback_op *op = &callback_ops[0];\n\tunsigned int op_nr;\n\t__be32 status;\n\tlong maxlen;\n\t__be32 res;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\tstatus = decode_op_hdr(xdr_in, &op_nr);\n\tif (unlikely(status))\n\t\treturn status;\n\n\tdprintk(\"%s: minorversion=%d nop=%d op_nr=%u\\n\",\n\t\t__func__, cps->minorversion, nop, op_nr);\n\n\tswitch (cps->minorversion) {\n\tcase 0:\n\t\tstatus = preprocess_nfs4_op(op_nr, &op);\n\t\tbreak;\n\tcase 1:\n\t\tstatus = preprocess_nfs41_op(nop, op_nr, &op);\n\t\tbreak;\n\tcase 2:\n\t\tstatus = preprocess_nfs42_op(nop, op_nr, &op);\n\t\tbreak;\n\tdefault:\n\t\tstatus = htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\n\tif (status == htonl(NFS4ERR_OP_ILLEGAL))\n\t\top_nr = OP_CB_ILLEGAL;\n\tif (status)\n\t\tgoto encode_hdr;\n\n\tif (cps->drc_status) {\n\t\tstatus = cps->drc_status;\n\t\tgoto encode_hdr;\n\t}\n\n\tmaxlen = xdr_out->end - xdr_out->p;\n\tif (maxlen > 0 && maxlen < PAGE_SIZE) {\n\t\tstatus = op->decode_args(rqstp, xdr_in, argp);\n\t\tif (likely(status == 0))\n\t\t\tstatus = op->process_op(argp, resp, cps);\n\t} else\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\nencode_hdr:\n\tres = encode_op_hdr(xdr_out, op_nr, status);\n\tif (unlikely(res))\n\t\treturn res;\n\tif (op->encode_res != NULL && status == 0)\n\t\tstatus = op->encode_res(rqstp, xdr_out, resp);\n\tdprintk(\"%s: done, status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "preprocess_nfs4_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "811-824",
    "snippet": "static __be32\npreprocess_nfs4_op(unsigned int op_nr, struct callback_op **op)\n{\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callback_op callback_ops[];",
      "static struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS_OK"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_ILLEGAL"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic struct callback_op callback_ops[];\nstatic struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};\n\nstatic __be32\npreprocess_nfs4_op(unsigned int op_nr, struct callback_op **op)\n{\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}"
  },
  {
    "function_name": "preprocess_nfs42_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "804-808",
    "snippet": "static __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_MINOR_VERS_MISMATCH"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}"
  },
  {
    "function_name": "preprocess_nfs42_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "792-802",
    "snippet": "static __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\t__be32 status = preprocess_nfs41_op(nop, op_nr, op);\n\tif (status != htonl(NFS4ERR_OP_ILLEGAL))\n\t\treturn status;\n\n\tif (op_nr == OP_CB_OFFLOAD)\n\t\treturn htonl(NFS4ERR_NOTSUPP);\n\treturn htonl(NFS4ERR_OP_ILLEGAL);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_ILLEGAL"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_NOTSUPP"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_ILLEGAL"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preprocess_nfs41_op",
          "args": [
            "nop",
            "op_nr",
            "op"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "preprocess_nfs41_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "780-784",
          "snippet": "static __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32\npreprocess_nfs42_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\t__be32 status = preprocess_nfs41_op(nop, op_nr, op);\n\tif (status != htonl(NFS4ERR_OP_ILLEGAL))\n\t\treturn status;\n\n\tif (op_nr == OP_CB_OFFLOAD)\n\t\treturn htonl(NFS4ERR_NOTSUPP);\n\treturn htonl(NFS4ERR_OP_ILLEGAL);\n}"
  },
  {
    "function_name": "nfs4_cb_free_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "786-788",
    "snippet": "static void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n}"
  },
  {
    "function_name": "preprocess_nfs41_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "780-784",
    "snippet": "static __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_MINOR_VERS_MISMATCH"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n}"
  },
  {
    "function_name": "nfs4_cb_free_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "772-776",
    "snippet": "static void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n\tif (cps->slotid != NFS4_NO_SLOT)\n\t\tnfs4_callback_free_slot(cps->clp->cl_session);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_callback_free_slot",
          "args": [
            "cps->clp->cl_session"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_callback_free_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "758-770",
          "snippet": "static void nfs4_callback_free_slot(struct nfs4_session *session)\n{\n\tstruct nfs4_slot_table *tbl = &session->bc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/*\n\t * Let the state manager know callback processing done.\n\t * A single slot, so highest used slotid is either 0 or -1\n\t */\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tnfs4_slot_tbl_drain_complete(tbl);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_callback_free_slot(struct nfs4_session *session)\n{\n\tstruct nfs4_slot_table *tbl = &session->bc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/*\n\t * Let the state manager know callback processing done.\n\t * A single slot, so highest used slotid is either 0 or -1\n\t */\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tnfs4_slot_tbl_drain_complete(tbl);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_cb_free_slot(struct cb_process_state *cps)\n{\n\tif (cps->slotid != NFS4_NO_SLOT)\n\t\tnfs4_callback_free_slot(cps->clp->cl_session);\n}"
  },
  {
    "function_name": "nfs4_callback_free_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "758-770",
    "snippet": "static void nfs4_callback_free_slot(struct nfs4_session *session)\n{\n\tstruct nfs4_slot_table *tbl = &session->bc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/*\n\t * Let the state manager know callback processing done.\n\t * A single slot, so highest used slotid is either 0 or -1\n\t */\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tnfs4_slot_tbl_drain_complete(tbl);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_slot_tbl_drain_complete",
          "args": [
            "tbl"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_slot_tbl_drain_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4session.c",
          "lines": "60-64",
          "snippet": "void nfs4_slot_tbl_drain_complete(struct nfs4_slot_table *tbl)\n{\n\tif (nfs4_slot_tbl_draining(tbl))\n\t\tcomplete(&tbl->complete);\n}",
          "includes": [
            "#include \"callback.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"callback.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n\nvoid nfs4_slot_tbl_drain_complete(struct nfs4_slot_table *tbl)\n{\n\tif (nfs4_slot_tbl_draining(tbl))\n\t\tcomplete(&tbl->complete);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tbl->slot_tbl_lock"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic void nfs4_callback_free_slot(struct nfs4_session *session)\n{\n\tstruct nfs4_slot_table *tbl = &session->bc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/*\n\t * Let the state manager know callback processing done.\n\t * A single slot, so highest used slotid is either 0 or -1\n\t */\n\ttbl->highest_used_slotid = NFS4_NO_SLOT;\n\tnfs4_slot_tbl_drain_complete(tbl);\n\tspin_unlock(&tbl->slot_tbl_lock);\n}"
  },
  {
    "function_name": "preprocess_nfs41_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "722-756",
    "snippet": "static __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\tif (op_nr == OP_CB_SEQUENCE) {\n\t\tif (nop != 0)\n\t\t\treturn htonl(NFS4ERR_SEQUENCE_POS);\n\t} else {\n\t\tif (nop == 0)\n\t\t\treturn htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\t}\n\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\tcase OP_CB_SEQUENCE:\n\tcase OP_CB_RECALL_ANY:\n\tcase OP_CB_RECALL_SLOT:\n\tcase OP_CB_LAYOUTRECALL:\n\tcase OP_CB_NOTIFY_DEVICEID:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\n\tcase OP_CB_NOTIFY:\n\tcase OP_CB_PUSH_DELEG:\n\tcase OP_CB_RECALLABLE_OBJ_AVAIL:\n\tcase OP_CB_WANTS_CANCELLED:\n\tcase OP_CB_NOTIFY_LOCK:\n\t\treturn htonl(NFS4ERR_NOTSUPP);\n\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct callback_op callback_ops[];",
      "static struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS_OK"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_ILLEGAL"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_NOTSUPP"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_OP_NOT_IN_SESSION"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_SEQUENCE_POS"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic struct callback_op callback_ops[];\nstatic struct callback_op callback_ops[] = {\n\t[0] = {\n\t\t.res_maxsize = CB_OP_HDR_RES_MAXSZ,\n\t},\n\t[OP_CB_GETATTR] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_getattr,\n\t\t.decode_args = (callback_decode_arg_t)decode_getattr_args,\n\t\t.encode_res = (callback_encode_res_t)encode_getattr_res,\n\t\t.res_maxsize = CB_OP_GETATTR_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recall,\n\t\t.decode_args = (callback_decode_arg_t)decode_recall_args,\n\t\t.res_maxsize = CB_OP_RECALL_RES_MAXSZ,\n\t},\n#if defined(CONFIG_NFS_V4_1)\n\t[OP_CB_LAYOUTRECALL] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_layoutrecall,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_layoutrecall_args,\n\t\t.res_maxsize = CB_OP_LAYOUTRECALL_RES_MAXSZ,\n\t},\n\t[OP_CB_NOTIFY_DEVICEID] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_devicenotify,\n\t\t.decode_args =\n\t\t\t(callback_decode_arg_t)decode_devicenotify_args,\n\t\t.res_maxsize = CB_OP_DEVICENOTIFY_RES_MAXSZ,\n\t},\n\t[OP_CB_SEQUENCE] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_sequence,\n\t\t.decode_args = (callback_decode_arg_t)decode_cb_sequence_args,\n\t\t.encode_res = (callback_encode_res_t)encode_cb_sequence_res,\n\t\t.res_maxsize = CB_OP_SEQUENCE_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_ANY] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallany,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallany_args,\n\t\t.res_maxsize = CB_OP_RECALLANY_RES_MAXSZ,\n\t},\n\t[OP_CB_RECALL_SLOT] = {\n\t\t.process_op = (callback_process_op_t)nfs4_callback_recallslot,\n\t\t.decode_args = (callback_decode_arg_t)decode_recallslot_args,\n\t\t.res_maxsize = CB_OP_RECALLSLOT_RES_MAXSZ,\n\t},\n#endif /* CONFIG_NFS_V4_1 */\n};\n\nstatic __be32\npreprocess_nfs41_op(int nop, unsigned int op_nr, struct callback_op **op)\n{\n\tif (op_nr == OP_CB_SEQUENCE) {\n\t\tif (nop != 0)\n\t\t\treturn htonl(NFS4ERR_SEQUENCE_POS);\n\t} else {\n\t\tif (nop == 0)\n\t\t\treturn htonl(NFS4ERR_OP_NOT_IN_SESSION);\n\t}\n\n\tswitch (op_nr) {\n\tcase OP_CB_GETATTR:\n\tcase OP_CB_RECALL:\n\tcase OP_CB_SEQUENCE:\n\tcase OP_CB_RECALL_ANY:\n\tcase OP_CB_RECALL_SLOT:\n\tcase OP_CB_LAYOUTRECALL:\n\tcase OP_CB_NOTIFY_DEVICEID:\n\t\t*op = &callback_ops[op_nr];\n\t\tbreak;\n\n\tcase OP_CB_NOTIFY:\n\tcase OP_CB_PUSH_DELEG:\n\tcase OP_CB_RECALLABLE_OBJ_AVAIL:\n\tcase OP_CB_WANTS_CANCELLED:\n\tcase OP_CB_NOTIFY_LOCK:\n\t\treturn htonl(NFS4ERR_NOTSUPP);\n\n\tdefault:\n\t\treturn htonl(NFS4ERR_OP_ILLEGAL);\n\t}\n\n\treturn htonl(NFS_OK);\n}"
  },
  {
    "function_name": "encode_cb_sequence_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "697-720",
    "snippet": "static __be32 encode_cb_sequence_res(struct svc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       const struct cb_sequenceres *res)\n{\n\t__be32 *p;\n\t__be32 status = res->csr_status;\n\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\n\tencode_sessionid(xdr, &res->csr_sessionid);\n\n\tp = xdr_reserve_space(xdr, 4 * sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\t*p++ = htonl(res->csr_sequenceid);\n\t*p++ = htonl(res->csr_slotid);\n\t*p++ = htonl(res->csr_highestslotid);\n\t*p++ = htonl(res->csr_target_highestslotid);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "res->csr_target_highestslotid"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "res->csr_highestslotid"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "res->csr_slotid"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "res->csr_sequenceid"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 * sizeof(uint32_t)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_sessionid",
          "args": [
            "xdr",
            "&res->csr_sessionid"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "encode_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "683-695",
          "snippet": "static __be32 encode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t const struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = xdr_reserve_space(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(p, sid, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t const struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = xdr_reserve_space(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(p, sid, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_cb_sequence_res(struct svc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       const struct cb_sequenceres *res)\n{\n\t__be32 *p;\n\t__be32 status = res->csr_status;\n\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\n\tencode_sessionid(xdr, &res->csr_sessionid);\n\n\tp = xdr_reserve_space(xdr, 4 * sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\t*p++ = htonl(res->csr_sequenceid);\n\t*p++ = htonl(res->csr_slotid);\n\t*p++ = htonl(res->csr_highestslotid);\n\t*p++ = htonl(res->csr_target_highestslotid);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "encode_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "683-695",
    "snippet": "static __be32 encode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t const struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = xdr_reserve_space(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(p, sid, len);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "sid",
            "len"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t const struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = xdr_reserve_space(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(p, sid, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_getattr_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "655-679",
    "snippet": "static __be32 encode_getattr_res(struct svc_rqst *rqstp, struct xdr_stream *xdr, const struct cb_getattrres *res)\n{\n\t__be32 *savep = NULL;\n\t__be32 status = res->status;\n\t\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_bitmap(xdr, res->bitmap, &savep);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_change(xdr, res->bitmap, res->change_attr);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_size(xdr, res->bitmap, res->size);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_ctime(xdr, res->bitmap, &res->ctime);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_mtime(xdr, res->bitmap, &res->mtime);\n\t*savep = htonl((unsigned int)((char *)xdr->p - (char *)(savep+1)));\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(unsigned int)((char *)xdr->p - (char *)(savep+1))"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_attr_mtime",
          "args": [
            "xdr",
            "res->bitmap",
            "&res->mtime"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attr_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "620-625",
          "snippet": "static __be32 encode_attr_mtime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_MODIFY))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_mtime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_MODIFY))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_attr_ctime",
          "args": [
            "xdr",
            "res->bitmap",
            "&res->ctime"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attr_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "613-618",
          "snippet": "static __be32 encode_attr_ctime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_METADATA))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_ctime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_METADATA))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_attr_size",
          "args": [
            "xdr",
            "res->bitmap",
            "res->size"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "588-599",
          "snippet": "static __be32 encode_attr_size(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t size)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_SIZE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, size);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_size(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t size)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_SIZE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_attr_change",
          "args": [
            "xdr",
            "res->bitmap",
            "res->change_attr"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attr_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "575-586",
          "snippet": "static __be32 encode_attr_change(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t change)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_CHANGE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, change);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_change(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t change)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_CHANGE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, change);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_attr_bitmap",
          "args": [
            "xdr",
            "res->bitmap",
            "&savep"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attr_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "545-573",
          "snippet": "static __be32 encode_attr_bitmap(struct xdr_stream *xdr, const uint32_t *bitmap, __be32 **savep)\n{\n\t__be32 bm[2];\n\t__be32 *p;\n\n\tbm[0] = htonl(bitmap[0] & CB_SUPPORTED_ATTR0);\n\tbm[1] = htonl(bitmap[1] & CB_SUPPORTED_ATTR1);\n\tif (bm[1] != 0) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(2);\n\t\t*p++ = bm[0];\n\t\t*p++ = bm[1];\n\t} else if (bm[0] != 0) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(1);\n\t\t*p++ = bm[0];\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(0);\n\t}\n\t*savep = p;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define CB_SUPPORTED_ATTR1 (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY)",
            "#define CB_SUPPORTED_ATTR0 (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define CB_SUPPORTED_ATTR1 (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY)\n#define CB_SUPPORTED_ATTR0 (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE)\n\nstatic __be32 encode_attr_bitmap(struct xdr_stream *xdr, const uint32_t *bitmap, __be32 **savep)\n{\n\t__be32 bm[2];\n\t__be32 *p;\n\n\tbm[0] = htonl(bitmap[0] & CB_SUPPORTED_ATTR0);\n\tbm[1] = htonl(bitmap[1] & CB_SUPPORTED_ATTR1);\n\tif (bm[1] != 0) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(2);\n\t\t*p++ = bm[0];\n\t\t*p++ = bm[1];\n\t} else if (bm[0] != 0) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(1);\n\t\t*p++ = bm[0];\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(0);\n\t}\n\t*savep = p;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_getattr_res(struct svc_rqst *rqstp, struct xdr_stream *xdr, const struct cb_getattrres *res)\n{\n\t__be32 *savep = NULL;\n\t__be32 status = res->status;\n\t\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_bitmap(xdr, res->bitmap, &savep);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_change(xdr, res->bitmap, res->change_attr);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_size(xdr, res->bitmap, res->size);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_ctime(xdr, res->bitmap, &res->ctime);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tstatus = encode_attr_mtime(xdr, res->bitmap, &res->mtime);\n\t*savep = htonl((unsigned int)((char *)xdr->p - (char *)(savep+1)));\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "encode_op_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "643-653",
    "snippet": "static __be32 encode_op_hdr(struct xdr_stream *xdr, uint32_t op, __be32 res)\n{\n\t__be32 *p;\n\t\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*p++ = htonl(op);\n\t*p = res;\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define NFS4ERR_RESOURCE_HDR\t11050"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "op"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE_HDR"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define NFS4ERR_RESOURCE_HDR\t11050\n\nstatic __be32 encode_op_hdr(struct xdr_stream *xdr, uint32_t op, __be32 res)\n{\n\t__be32 *p;\n\t\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*p++ = htonl(op);\n\t*p = res;\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_compound_hdr_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "627-641",
    "snippet": "static __be32 encode_compound_hdr_res(struct xdr_stream *xdr, struct cb_compound_hdr_res *hdr)\n{\n\t__be32 status;\n\n\thdr->status = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->status == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tstatus = encode_string(xdr, hdr->taglen, hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\thdr->nops = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->nops == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hdr->nops == NULL"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_string",
          "args": [
            "xdr",
            "hdr->taglen",
            "hdr->tag"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "encode_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "532-541",
          "snippet": "static __be32 encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\txdr_encode_opaque(p, str, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\txdr_encode_opaque(p, str, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "hdr->status == NULL"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_compound_hdr_res(struct xdr_stream *xdr, struct cb_compound_hdr_res *hdr)\n{\n\t__be32 status;\n\n\thdr->status = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->status == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tstatus = encode_string(xdr, hdr->taglen, hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\thdr->nops = xdr_reserve_space(xdr, 4);\n\tif (unlikely(hdr->nops == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_attr_mtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "620-625",
    "snippet": "static __be32 encode_attr_mtime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_MODIFY))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_attr_time",
          "args": [
            "xdr",
            "time"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attr_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "601-611",
          "snippet": "static __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec *time)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, time->tv_sec);\n\t*p = htonl(time->tv_nsec);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec *time)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, time->tv_sec);\n\t*p = htonl(time->tv_nsec);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_mtime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_MODIFY))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}"
  },
  {
    "function_name": "encode_attr_ctime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "613-618",
    "snippet": "static __be32 encode_attr_ctime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_METADATA))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_attr_time",
          "args": [
            "xdr",
            "time"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "encode_attr_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "601-611",
          "snippet": "static __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec *time)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, time->tv_sec);\n\t*p = htonl(time->tv_nsec);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec *time)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, time->tv_sec);\n\t*p = htonl(time->tv_nsec);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_ctime(struct xdr_stream *xdr, const uint32_t *bitmap, const struct timespec *time)\n{\n\tif (!(bitmap[1] & FATTR4_WORD1_TIME_METADATA))\n\t\treturn 0;\n\treturn encode_attr_time(xdr,time);\n}"
  },
  {
    "function_name": "encode_attr_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "601-611",
    "snippet": "static __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec *time)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, time->tv_sec);\n\t*p = htonl(time->tv_nsec);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "time->tv_nsec"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "time->tv_sec"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_time(struct xdr_stream *xdr, const struct timespec *time)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 12);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, time->tv_sec);\n\t*p = htonl(time->tv_nsec);\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_attr_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "588-599",
    "snippet": "static __be32 encode_attr_size(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t size)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_SIZE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, size);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "size"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_size(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t size)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_SIZE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, size);\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_attr_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "575-586",
    "snippet": "static __be32 encode_attr_change(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t change)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_CHANGE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, change);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "change"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_attr_change(struct xdr_stream *xdr, const uint32_t *bitmap, uint64_t change)\n{\n\t__be32 *p;\n\n\tif (!(bitmap[0] & FATTR4_WORD0_CHANGE))\n\t\treturn 0;\n\tp = xdr_reserve_space(xdr, 8);\n\tif (unlikely(!p))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tp = xdr_encode_hyper(p, change);\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_attr_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "545-573",
    "snippet": "static __be32 encode_attr_bitmap(struct xdr_stream *xdr, const uint32_t *bitmap, __be32 **savep)\n{\n\t__be32 bm[2];\n\t__be32 *p;\n\n\tbm[0] = htonl(bitmap[0] & CB_SUPPORTED_ATTR0);\n\tbm[1] = htonl(bitmap[1] & CB_SUPPORTED_ATTR1);\n\tif (bm[1] != 0) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(2);\n\t\t*p++ = bm[0];\n\t\t*p++ = bm[1];\n\t} else if (bm[0] != 0) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(1);\n\t\t*p++ = bm[0];\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(0);\n\t}\n\t*savep = p;\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define CB_SUPPORTED_ATTR1 (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY)",
      "#define CB_SUPPORTED_ATTR0 (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "1"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "2"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "bitmap[1] & CB_SUPPORTED_ATTR1"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "bitmap[0] & CB_SUPPORTED_ATTR0"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define CB_SUPPORTED_ATTR1 (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY)\n#define CB_SUPPORTED_ATTR0 (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE)\n\nstatic __be32 encode_attr_bitmap(struct xdr_stream *xdr, const uint32_t *bitmap, __be32 **savep)\n{\n\t__be32 bm[2];\n\t__be32 *p;\n\n\tbm[0] = htonl(bitmap[0] & CB_SUPPORTED_ATTR0);\n\tbm[1] = htonl(bitmap[1] & CB_SUPPORTED_ATTR1);\n\tif (bm[1] != 0) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(2);\n\t\t*p++ = bm[0];\n\t\t*p++ = bm[1];\n\t} else if (bm[0] != 0) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(1);\n\t\t*p++ = bm[0];\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*p++ = htonl(0);\n\t}\n\t*savep = p;\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "532-541",
    "snippet": "static __be32 encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\txdr_encode_opaque(p, str, len);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "str",
            "len"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + len"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 encode_string(struct xdr_stream *xdr, unsigned int len, const char *str)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\txdr_encode_opaque(p, str, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_recallslot_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "516-528",
    "snippet": "static __be32 decode_recallslot_args(struct svc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tstruct cb_recallslotargs *args)\n{\n\t__be32 *p;\n\n\targs->crsa_addr = svc_addr(rqstp);\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\targs->crsa_target_highest_slotid = ntohl(*p++);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "4"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_recallslot_args(struct svc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tstruct cb_recallslotargs *args)\n{\n\t__be32 *p;\n\n\targs->crsa_addr = svc_addr(rqstp);\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\targs->crsa_target_highest_slotid = ntohl(*p++);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_recallany_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "496-514",
    "snippet": "static __be32 decode_recallany_args(struct svc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      struct cb_recallanyargs *args)\n{\n\tuint32_t bitmap[2];\n\t__be32 *p, status;\n\n\targs->craa_addr = svc_addr(rqstp);\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\targs->craa_objs_to_keep = ntohl(*p++);\n\tstatus = decode_bitmap(xdr, bitmap);\n\tif (unlikely(status))\n\t\treturn status;\n\targs->craa_type_mask = bitmap[0];\n\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_bitmap",
          "args": [
            "xdr",
            "bitmap"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "121-138",
          "snippet": "static __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\t__be32 *p;\n\tunsigned int attrlen;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tattrlen = ntohl(*p);\n\tp = read_buf(xdr, attrlen << 2);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tif (likely(attrlen > 0))\n\t\tbitmap[0] = ntohl(*p++);\n\tif (attrlen > 1)\n\t\tbitmap[1] = ntohl(*p);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\t__be32 *p;\n\tunsigned int attrlen;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tattrlen = ntohl(*p);\n\tp = read_buf(xdr, attrlen << 2);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tif (likely(attrlen > 0))\n\t\tbitmap[0] = ntohl(*p++);\n\tif (attrlen > 1)\n\t\tbitmap[1] = ntohl(*p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "4"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_recallany_args(struct svc_rqst *rqstp,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      struct cb_recallanyargs *args)\n{\n\tuint32_t bitmap[2];\n\t__be32 *p, status;\n\n\targs->craa_addr = svc_addr(rqstp);\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_BADXDR);\n\targs->craa_objs_to_keep = ntohl(*p++);\n\tstatus = decode_bitmap(xdr, bitmap);\n\tif (unlikely(status))\n\t\treturn status;\n\targs->craa_type_mask = bitmap[0];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_cb_sequence_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "434-494",
    "snippet": "static __be32 decode_cb_sequence_args(struct svc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tstruct cb_sequenceargs *args)\n{\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &args->csa_sessionid);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = htonl(NFS4ERR_RESOURCE);\n\tp = read_buf(xdr, 5 * sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\tgoto out;\n\n\targs->csa_addr = svc_addr(rqstp);\n\targs->csa_sequenceid = ntohl(*p++);\n\targs->csa_slotid = ntohl(*p++);\n\targs->csa_highestslotid = ntohl(*p++);\n\targs->csa_cachethis = ntohl(*p++);\n\targs->csa_nrclists = ntohl(*p++);\n\targs->csa_rclists = NULL;\n\tif (args->csa_nrclists) {\n\t\targs->csa_rclists = kmalloc_array(args->csa_nrclists,\n\t\t\t\t\t\t  sizeof(*args->csa_rclists),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(args->csa_rclists == NULL))\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < args->csa_nrclists; i++) {\n\t\t\tstatus = decode_rc_list(xdr, &args->csa_rclists[i]);\n\t\t\tif (status) {\n\t\t\t\targs->csa_nrclists = i;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t}\n\tstatus = 0;\n\n\tdprintk(\"%s: sessionid %x:%x:%x:%x sequenceid %u slotid %u \"\n\t\t\"highestslotid %u cachethis %d nrclists %u\\n\",\n\t\t__func__,\n\t\t((u32 *)&args->csa_sessionid)[0],\n\t\t((u32 *)&args->csa_sessionid)[1],\n\t\t((u32 *)&args->csa_sessionid)[2],\n\t\t((u32 *)&args->csa_sessionid)[3],\n\t\targs->csa_sequenceid, args->csa_slotid,\n\t\targs->csa_highestslotid, args->csa_cachethis,\n\t\targs->csa_nrclists);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n\nout_free:\n\tfor (i = 0; i < args->csa_nrclists; i++)\n\t\tkfree(args->csa_rclists[i].rcl_refcalls);\n\tkfree(args->csa_rclists);\n\tgoto out;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->csa_rclists"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->csa_rclists[i].rcl_refcalls"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: sessionid %x:%x:%x:%x sequenceid %u slotid %u \"\n\t\t\"highestslotid %u cachethis %d nrclists %u\\n\"",
            "__func__",
            "((u32 *)&args->csa_sessionid)[0]",
            "((u32 *)&args->csa_sessionid)[1]",
            "((u32 *)&args->csa_sessionid)[2]",
            "((u32 *)&args->csa_sessionid)[3]",
            "args->csa_sequenceid",
            "args->csa_slotid",
            "args->csa_highestslotid",
            "args->csa_cachethis",
            "args->csa_nrclists"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_rc_list",
          "args": [
            "xdr",
            "&args->csa_rclists[i]"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "decode_rc_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "396-432",
          "snippet": "static __be32 decode_rc_list(struct xdr_stream *xdr,\n\t\t\t       struct referring_call_list *rc_list)\n{\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &rc_list->rcl_sessionid);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = htonl(NFS4ERR_RESOURCE);\n\tp = read_buf(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\tgoto out;\n\n\trc_list->rcl_nrefcalls = ntohl(*p++);\n\tif (rc_list->rcl_nrefcalls) {\n\t\tp = read_buf(xdr,\n\t\t\t     rc_list->rcl_nrefcalls * 2 * sizeof(uint32_t));\n\t\tif (unlikely(p == NULL))\n\t\t\tgoto out;\n\t\trc_list->rcl_refcalls = kmalloc_array(rc_list->rcl_nrefcalls,\n\t\t\t\t\t\tsizeof(*rc_list->rcl_refcalls),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (unlikely(rc_list->rcl_refcalls == NULL))\n\t\t\tgoto out;\n\t\tfor (i = 0; i < rc_list->rcl_nrefcalls; i++) {\n\t\t\trc_list->rcl_refcalls[i].rc_sequenceid = ntohl(*p++);\n\t\t\trc_list->rcl_refcalls[i].rc_slotid = ntohl(*p++);\n\t\t}\n\t}\n\tstatus = 0;\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_rc_list(struct xdr_stream *xdr,\n\t\t\t       struct referring_call_list *rc_list)\n{\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &rc_list->rcl_sessionid);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = htonl(NFS4ERR_RESOURCE);\n\tp = read_buf(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\tgoto out;\n\n\trc_list->rcl_nrefcalls = ntohl(*p++);\n\tif (rc_list->rcl_nrefcalls) {\n\t\tp = read_buf(xdr,\n\t\t\t     rc_list->rcl_nrefcalls * 2 * sizeof(uint32_t));\n\t\tif (unlikely(p == NULL))\n\t\t\tgoto out;\n\t\trc_list->rcl_refcalls = kmalloc_array(rc_list->rcl_nrefcalls,\n\t\t\t\t\t\tsizeof(*rc_list->rcl_refcalls),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (unlikely(rc_list->rcl_refcalls == NULL))\n\t\t\tgoto out;\n\t\tfor (i = 0; i < rc_list->rcl_nrefcalls; i++) {\n\t\t\trc_list->rcl_refcalls[i].rc_sequenceid = ntohl(*p++);\n\t\t\trc_list->rcl_refcalls[i].rc_slotid = ntohl(*p++);\n\t\t}\n\t}\n\tstatus = 0;\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "args->csa_rclists == NULL"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "args->csa_nrclists",
            "sizeof(*args->csa_rclists)",
            "GFP_KERNEL"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "5 * sizeof(uint32_t)"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sessionid",
          "args": [
            "xdr",
            "&args->csa_sessionid"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "382-394",
          "snippet": "static __be32 decode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = read_buf(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(sid->data, p, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = read_buf(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(sid->data, p, len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_cb_sequence_args(struct svc_rqst *rqstp,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tstruct cb_sequenceargs *args)\n{\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &args->csa_sessionid);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = htonl(NFS4ERR_RESOURCE);\n\tp = read_buf(xdr, 5 * sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\tgoto out;\n\n\targs->csa_addr = svc_addr(rqstp);\n\targs->csa_sequenceid = ntohl(*p++);\n\targs->csa_slotid = ntohl(*p++);\n\targs->csa_highestslotid = ntohl(*p++);\n\targs->csa_cachethis = ntohl(*p++);\n\targs->csa_nrclists = ntohl(*p++);\n\targs->csa_rclists = NULL;\n\tif (args->csa_nrclists) {\n\t\targs->csa_rclists = kmalloc_array(args->csa_nrclists,\n\t\t\t\t\t\t  sizeof(*args->csa_rclists),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(args->csa_rclists == NULL))\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < args->csa_nrclists; i++) {\n\t\t\tstatus = decode_rc_list(xdr, &args->csa_rclists[i]);\n\t\t\tif (status) {\n\t\t\t\targs->csa_nrclists = i;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t}\n\tstatus = 0;\n\n\tdprintk(\"%s: sessionid %x:%x:%x:%x sequenceid %u slotid %u \"\n\t\t\"highestslotid %u cachethis %d nrclists %u\\n\",\n\t\t__func__,\n\t\t((u32 *)&args->csa_sessionid)[0],\n\t\t((u32 *)&args->csa_sessionid)[1],\n\t\t((u32 *)&args->csa_sessionid)[2],\n\t\t((u32 *)&args->csa_sessionid)[3],\n\t\targs->csa_sequenceid, args->csa_slotid,\n\t\targs->csa_highestslotid, args->csa_cachethis,\n\t\targs->csa_nrclists);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n\nout_free:\n\tfor (i = 0; i < args->csa_nrclists; i++)\n\t\tkfree(args->csa_rclists[i].rcl_refcalls);\n\tkfree(args->csa_rclists);\n\tgoto out;\n}"
  },
  {
    "function_name": "decode_rc_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "396-432",
    "snippet": "static __be32 decode_rc_list(struct xdr_stream *xdr,\n\t\t\t       struct referring_call_list *rc_list)\n{\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &rc_list->rcl_sessionid);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = htonl(NFS4ERR_RESOURCE);\n\tp = read_buf(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\tgoto out;\n\n\trc_list->rcl_nrefcalls = ntohl(*p++);\n\tif (rc_list->rcl_nrefcalls) {\n\t\tp = read_buf(xdr,\n\t\t\t     rc_list->rcl_nrefcalls * 2 * sizeof(uint32_t));\n\t\tif (unlikely(p == NULL))\n\t\t\tgoto out;\n\t\trc_list->rcl_refcalls = kmalloc_array(rc_list->rcl_nrefcalls,\n\t\t\t\t\t\tsizeof(*rc_list->rcl_refcalls),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (unlikely(rc_list->rcl_refcalls == NULL))\n\t\t\tgoto out;\n\t\tfor (i = 0; i < rc_list->rcl_nrefcalls; i++) {\n\t\t\trc_list->rcl_refcalls[i].rc_sequenceid = ntohl(*p++);\n\t\t\trc_list->rcl_refcalls[i].rc_slotid = ntohl(*p++);\n\t\t}\n\t}\n\tstatus = 0;\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc_list->rcl_refcalls == NULL"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "rc_list->rcl_nrefcalls",
            "sizeof(*rc_list->rcl_refcalls)",
            "GFP_KERNEL"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "rc_list->rcl_nrefcalls * 2 * sizeof(uint32_t)"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sessionid",
          "args": [
            "xdr",
            "&rc_list->rcl_sessionid"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "382-394",
          "snippet": "static __be32 decode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = read_buf(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(sid->data, p, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = read_buf(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(sid->data, p, len);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_rc_list(struct xdr_stream *xdr,\n\t\t\t       struct referring_call_list *rc_list)\n{\n\t__be32 *p;\n\tint i;\n\t__be32 status;\n\n\tstatus = decode_sessionid(xdr, &rc_list->rcl_sessionid);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = htonl(NFS4ERR_RESOURCE);\n\tp = read_buf(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL))\n\t\tgoto out;\n\n\trc_list->rcl_nrefcalls = ntohl(*p++);\n\tif (rc_list->rcl_nrefcalls) {\n\t\tp = read_buf(xdr,\n\t\t\t     rc_list->rcl_nrefcalls * 2 * sizeof(uint32_t));\n\t\tif (unlikely(p == NULL))\n\t\t\tgoto out;\n\t\trc_list->rcl_refcalls = kmalloc_array(rc_list->rcl_nrefcalls,\n\t\t\t\t\t\tsizeof(*rc_list->rcl_refcalls),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (unlikely(rc_list->rcl_refcalls == NULL))\n\t\t\tgoto out;\n\t\tfor (i = 0; i < rc_list->rcl_nrefcalls; i++) {\n\t\t\trc_list->rcl_refcalls[i].rc_sequenceid = ntohl(*p++);\n\t\t\trc_list->rcl_refcalls[i].rc_slotid = ntohl(*p++);\n\t\t}\n\t}\n\tstatus = 0;\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "decode_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "382-394",
    "snippet": "static __be32 decode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = read_buf(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(sid->data, p, len);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sid->data",
            "p",
            "len"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "len"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_sessionid(struct xdr_stream *xdr,\n\t\t\t\t struct nfs4_sessionid *sid)\n{\n\t__be32 *p;\n\tint len = NFS4_MAX_SESSIONID_LEN;\n\n\tp = read_buf(xdr, len);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\n\tmemcpy(sid->data, p, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_devicenotify_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "291-380",
    "snippet": "static\n__be32 decode_devicenotify_args(struct svc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tstruct cb_devicenotifyargs *args)\n{\n\t__be32 *p;\n\t__be32 status = 0;\n\tu32 tmp;\n\tint n, i;\n\targs->ndevs = 0;\n\n\t/* Num of device notifications */\n\tp = read_buf(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL)) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\tn = ntohl(*p++);\n\tif (n <= 0)\n\t\tgoto out;\n\tif (n > ULONG_MAX / sizeof(*args->devs)) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\n\targs->devs = kmalloc_array(n, sizeof(*args->devs), GFP_KERNEL);\n\tif (!args->devs) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\tgoto out;\n\t}\n\n\t/* Decode each dev notification */\n\tfor (i = 0; i < n; i++) {\n\t\tstruct cb_devicenotifyitem *dev = &args->devs[i];\n\n\t\tp = read_buf(xdr, (4 * sizeof(uint32_t)) + NFS4_DEVICEID4_SIZE);\n\t\tif (unlikely(p == NULL)) {\n\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttmp = ntohl(*p++);\t/* bitmap size */\n\t\tif (tmp != 1) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tdev->cbd_notify_type = ntohl(*p++);\n\t\tif (dev->cbd_notify_type != NOTIFY_DEVICEID4_CHANGE &&\n\t\t    dev->cbd_notify_type != NOTIFY_DEVICEID4_DELETE) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttmp = ntohl(*p++);\t/* opaque size */\n\t\tif (((dev->cbd_notify_type == NOTIFY_DEVICEID4_CHANGE) &&\n\t\t     (tmp != NFS4_DEVICEID4_SIZE + 8)) ||\n\t\t    ((dev->cbd_notify_type == NOTIFY_DEVICEID4_DELETE) &&\n\t\t     (tmp != NFS4_DEVICEID4_SIZE + 4))) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tdev->cbd_layout_type = ntohl(*p++);\n\t\tmemcpy(dev->cbd_dev_id.data, p, NFS4_DEVICEID4_SIZE);\n\t\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\n\t\tif (dev->cbd_layout_type == NOTIFY_DEVICEID4_CHANGE) {\n\t\t\tp = read_buf(xdr, sizeof(uint32_t));\n\t\t\tif (unlikely(p == NULL)) {\n\t\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdev->cbd_immediate = ntohl(*p++);\n\t\t} else {\n\t\t\tdev->cbd_immediate = 0;\n\t\t}\n\n\t\targs->ndevs++;\n\n\t\tdprintk(\"%s: type %d layout 0x%x immediate %d\\n\",\n\t\t\t__func__, dev->cbd_notify_type, dev->cbd_layout_type,\n\t\t\tdev->cbd_immediate);\n\t}\nout:\n\tdprintk(\"%s: status %d ndevs %d\\n\",\n\t\t__func__, ntohl(status), args->ndevs);\n\treturn status;\nerr:\n\tkfree(args->devs);\n\tgoto out;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->devs"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: status %d ndevs %d\\n\"",
            "__func__",
            "ntohl(status)",
            "args->ndevs"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: type %d layout 0x%x immediate %d\\n\"",
            "__func__",
            "dev->cbd_notify_type",
            "dev->cbd_layout_type",
            "dev->cbd_immediate"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "sizeof(uint32_t)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dev->cbd_dev_id.data",
            "p",
            "NFS4_DEVICEID4_SIZE"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_INVAL"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_INVAL"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_INVAL"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_DELAY"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "n",
            "sizeof(*args->devs)",
            "GFP_KERNEL"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic\n__be32 decode_devicenotify_args(struct svc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tstruct cb_devicenotifyargs *args)\n{\n\t__be32 *p;\n\t__be32 status = 0;\n\tu32 tmp;\n\tint n, i;\n\targs->ndevs = 0;\n\n\t/* Num of device notifications */\n\tp = read_buf(xdr, sizeof(uint32_t));\n\tif (unlikely(p == NULL)) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\tn = ntohl(*p++);\n\tif (n <= 0)\n\t\tgoto out;\n\tif (n > ULONG_MAX / sizeof(*args->devs)) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\n\targs->devs = kmalloc_array(n, sizeof(*args->devs), GFP_KERNEL);\n\tif (!args->devs) {\n\t\tstatus = htonl(NFS4ERR_DELAY);\n\t\tgoto out;\n\t}\n\n\t/* Decode each dev notification */\n\tfor (i = 0; i < n; i++) {\n\t\tstruct cb_devicenotifyitem *dev = &args->devs[i];\n\n\t\tp = read_buf(xdr, (4 * sizeof(uint32_t)) + NFS4_DEVICEID4_SIZE);\n\t\tif (unlikely(p == NULL)) {\n\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttmp = ntohl(*p++);\t/* bitmap size */\n\t\tif (tmp != 1) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tdev->cbd_notify_type = ntohl(*p++);\n\t\tif (dev->cbd_notify_type != NOTIFY_DEVICEID4_CHANGE &&\n\t\t    dev->cbd_notify_type != NOTIFY_DEVICEID4_DELETE) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\n\t\ttmp = ntohl(*p++);\t/* opaque size */\n\t\tif (((dev->cbd_notify_type == NOTIFY_DEVICEID4_CHANGE) &&\n\t\t     (tmp != NFS4_DEVICEID4_SIZE + 8)) ||\n\t\t    ((dev->cbd_notify_type == NOTIFY_DEVICEID4_DELETE) &&\n\t\t     (tmp != NFS4_DEVICEID4_SIZE + 4))) {\n\t\t\tstatus = htonl(NFS4ERR_INVAL);\n\t\t\tgoto err;\n\t\t}\n\t\tdev->cbd_layout_type = ntohl(*p++);\n\t\tmemcpy(dev->cbd_dev_id.data, p, NFS4_DEVICEID4_SIZE);\n\t\tp += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\n\n\t\tif (dev->cbd_layout_type == NOTIFY_DEVICEID4_CHANGE) {\n\t\t\tp = read_buf(xdr, sizeof(uint32_t));\n\t\t\tif (unlikely(p == NULL)) {\n\t\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdev->cbd_immediate = ntohl(*p++);\n\t\t} else {\n\t\t\tdev->cbd_immediate = 0;\n\t\t}\n\n\t\targs->ndevs++;\n\n\t\tdprintk(\"%s: type %d layout 0x%x immediate %d\\n\",\n\t\t\t__func__, dev->cbd_notify_type, dev->cbd_layout_type,\n\t\t\tdev->cbd_immediate);\n\t}\nout:\n\tdprintk(\"%s: status %d ndevs %d\\n\",\n\t\t__func__, ntohl(status), args->ndevs);\n\treturn status;\nerr:\n\tkfree(args->devs);\n\tgoto out;\n}"
  },
  {
    "function_name": "decode_layoutrecall_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "231-289",
    "snippet": "static __be32 decode_layoutrecall_args(struct svc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       struct cb_layoutrecallargs *args)\n{\n\t__be32 *p;\n\t__be32 status = 0;\n\tuint32_t iomode;\n\n\targs->cbl_addr = svc_addr(rqstp);\n\tp = read_buf(xdr, 4 * sizeof(uint32_t));\n\tif (unlikely(p == NULL)) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\n\targs->cbl_layout_type = ntohl(*p++);\n\t/* Depite the spec's xdr, iomode really belongs in the FILE switch,\n\t * as it is unusable and ignored with the other types.\n\t */\n\tiomode = ntohl(*p++);\n\targs->cbl_layoutchanged = ntohl(*p++);\n\targs->cbl_recall_type = ntohl(*p++);\n\n\tif (args->cbl_recall_type == RETURN_FILE) {\n\t\targs->cbl_range.iomode = iomode;\n\t\tstatus = decode_fh(xdr, &args->cbl_fh);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out;\n\n\t\tp = read_buf(xdr, 2 * sizeof(uint64_t));\n\t\tif (unlikely(p == NULL)) {\n\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\tgoto out;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &args->cbl_range.offset);\n\t\tp = xdr_decode_hyper(p, &args->cbl_range.length);\n\t\tstatus = decode_stateid(xdr, &args->cbl_stateid);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out;\n\t} else if (args->cbl_recall_type == RETURN_FSID) {\n\t\tp = read_buf(xdr, 2 * sizeof(uint64_t));\n\t\tif (unlikely(p == NULL)) {\n\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\tgoto out;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &args->cbl_fsid.major);\n\t\tp = xdr_decode_hyper(p, &args->cbl_fsid.minor);\n\t} else if (args->cbl_recall_type != RETURN_ALL) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\tdprintk(\"%s: ltype 0x%x iomode %d changed %d recall_type %d\\n\",\n\t\t__func__,\n\t\targs->cbl_layout_type, iomode,\n\t\targs->cbl_layoutchanged, args->cbl_recall_type);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: ltype 0x%x iomode %d changed %d recall_type %d\\n\"",
            "__func__",
            "args->cbl_layout_type",
            "iomode",
            "args->cbl_layoutchanged",
            "args->cbl_recall_type"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->cbl_fsid.minor"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->cbl_fsid.major"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "2 * sizeof(uint64_t)"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_stateid",
          "args": [
            "xdr",
            "&args->cbl_stateid"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "140-149",
          "snippet": "static __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->cbl_range.length"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->cbl_range.offset"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "xdr",
            "&args->cbl_fh"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "103-119",
          "snippet": "static __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADXDR"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_layoutrecall_args(struct svc_rqst *rqstp,\n\t\t\t\t       struct xdr_stream *xdr,\n\t\t\t\t       struct cb_layoutrecallargs *args)\n{\n\t__be32 *p;\n\t__be32 status = 0;\n\tuint32_t iomode;\n\n\targs->cbl_addr = svc_addr(rqstp);\n\tp = read_buf(xdr, 4 * sizeof(uint32_t));\n\tif (unlikely(p == NULL)) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\n\targs->cbl_layout_type = ntohl(*p++);\n\t/* Depite the spec's xdr, iomode really belongs in the FILE switch,\n\t * as it is unusable and ignored with the other types.\n\t */\n\tiomode = ntohl(*p++);\n\targs->cbl_layoutchanged = ntohl(*p++);\n\targs->cbl_recall_type = ntohl(*p++);\n\n\tif (args->cbl_recall_type == RETURN_FILE) {\n\t\targs->cbl_range.iomode = iomode;\n\t\tstatus = decode_fh(xdr, &args->cbl_fh);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out;\n\n\t\tp = read_buf(xdr, 2 * sizeof(uint64_t));\n\t\tif (unlikely(p == NULL)) {\n\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\tgoto out;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &args->cbl_range.offset);\n\t\tp = xdr_decode_hyper(p, &args->cbl_range.length);\n\t\tstatus = decode_stateid(xdr, &args->cbl_stateid);\n\t\tif (unlikely(status != 0))\n\t\t\tgoto out;\n\t} else if (args->cbl_recall_type == RETURN_FSID) {\n\t\tp = read_buf(xdr, 2 * sizeof(uint64_t));\n\t\tif (unlikely(p == NULL)) {\n\t\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\t\tgoto out;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &args->cbl_fsid.major);\n\t\tp = xdr_decode_hyper(p, &args->cbl_fsid.minor);\n\t} else if (args->cbl_recall_type != RETURN_ALL) {\n\t\tstatus = htonl(NFS4ERR_BADXDR);\n\t\tgoto out;\n\t}\n\tdprintk(\"%s: ltype 0x%x iomode %d changed %d recall_type %d\\n\",\n\t\t__func__,\n\t\targs->cbl_layout_type, iomode,\n\t\targs->cbl_layoutchanged, args->cbl_recall_type);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "decode_recall_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "208-227",
    "snippet": "static __be32 decode_recall_args(struct svc_rqst *rqstp, struct xdr_stream *xdr, struct cb_recallargs *args)\n{\n\t__be32 *p;\n\t__be32 status;\n\n\targs->addr = svc_addr(rqstp);\n\tstatus = decode_stateid(xdr, &args->stateid);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL)) {\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\t\tgoto out;\n\t}\n\targs->truncate = ntohl(*p);\n\tstatus = decode_fh(xdr, &args->fh);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "xdr",
            "&args->fh"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "103-119",
          "snippet": "static __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "4"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_stateid",
          "args": [
            "xdr",
            "&args->stateid"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "140-149",
          "snippet": "static __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_recall_args(struct svc_rqst *rqstp, struct xdr_stream *xdr, struct cb_recallargs *args)\n{\n\t__be32 *p;\n\t__be32 status;\n\n\targs->addr = svc_addr(rqstp);\n\tstatus = decode_stateid(xdr, &args->stateid);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL)) {\n\t\tstatus = htonl(NFS4ERR_RESOURCE);\n\t\tgoto out;\n\t}\n\targs->truncate = ntohl(*p);\n\tstatus = decode_fh(xdr, &args->fh);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "decode_getattr_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "194-206",
    "snippet": "static __be32 decode_getattr_args(struct svc_rqst *rqstp, struct xdr_stream *xdr, struct cb_getattrargs *args)\n{\n\t__be32 status;\n\n\tstatus = decode_fh(xdr, &args->fh);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\targs->addr = svc_addr(rqstp);\n\tstatus = decode_bitmap(xdr, args->bitmap);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: exit with status = %d\\n\"",
            "__func__",
            "ntohl(status)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_bitmap",
          "args": [
            "xdr",
            "args->bitmap"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "121-138",
          "snippet": "static __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\t__be32 *p;\n\tunsigned int attrlen;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tattrlen = ntohl(*p);\n\tp = read_buf(xdr, attrlen << 2);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tif (likely(attrlen > 0))\n\t\tbitmap[0] = ntohl(*p++);\n\tif (attrlen > 1)\n\t\tbitmap[1] = ntohl(*p);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\t__be32 *p;\n\tunsigned int attrlen;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tattrlen = ntohl(*p);\n\tp = read_buf(xdr, attrlen << 2);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tif (likely(attrlen > 0))\n\t\tbitmap[0] = ntohl(*p++);\n\tif (attrlen > 1)\n\t\tbitmap[1] = ntohl(*p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "xdr",
            "&args->fh"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "103-119",
          "snippet": "static __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_getattr_args(struct svc_rqst *rqstp, struct xdr_stream *xdr, struct cb_getattrargs *args)\n{\n\t__be32 status;\n\n\tstatus = decode_fh(xdr, &args->fh);\n\tif (unlikely(status != 0))\n\t\tgoto out;\n\targs->addr = svc_addr(rqstp);\n\tstatus = decode_bitmap(xdr, args->bitmap);\nout:\n\tdprintk(\"%s: exit with status = %d\\n\", __func__, ntohl(status));\n\treturn status;\n}"
  },
  {
    "function_name": "decode_op_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "184-192",
    "snippet": "static __be32 decode_op_hdr(struct xdr_stream *xdr, unsigned int *op)\n{\n\t__be32 *p;\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*op = ntohl(*p);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define NFS4ERR_RESOURCE_HDR\t11050"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE_HDR"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "4"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define NFS4ERR_RESOURCE_HDR\t11050\n\nstatic __be32 decode_op_hdr(struct xdr_stream *xdr, unsigned int *op)\n{\n\t__be32 *p;\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE_HDR);\n\t*op = ntohl(*p);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_compound_hdr_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "151-182",
    "snippet": "static __be32 decode_compound_hdr_arg(struct xdr_stream *xdr, struct cb_compound_hdr_arg *hdr)\n{\n\t__be32 *p;\n\t__be32 status;\n\n\tstatus = decode_string(xdr, &hdr->taglen, &hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\t/* We do not like overly long tags! */\n\tif (hdr->taglen > CB_OP_TAGLEN_MAXSZ - 12) {\n\t\tprintk(\"NFS: NFSv4 CALLBACK %s: client sent tag of length %u\\n\",\n\t\t\t\t__func__, hdr->taglen);\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t}\n\tp = read_buf(xdr, 12);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\thdr->minorversion = ntohl(*p++);\n\t/* Check for minor version support */\n\tif (hdr->minorversion <= NFS4_MAX_MINOR_VERSION) {\n\t\thdr->cb_ident = ntohl(*p++); /* ignored by v4.1 and v4.2 */\n\t} else {\n\t\tpr_warn_ratelimited(\"NFS: %s: NFSv4 server callback with \"\n\t\t\t\"illegal minor version %u!\\n\",\n\t\t\t__func__, hdr->minorversion);\n\t\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\thdr->nops = ntohl(*p);\n\tdprintk(\"%s: minorversion %d nops %d\\n\", __func__,\n\t\thdr->minorversion, hdr->nops);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define CB_OP_TAGLEN_MAXSZ\t(512)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: minorversion %d nops %d\\n\"",
            "__func__",
            "hdr->minorversion",
            "hdr->nops"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_MINOR_VERS_MISMATCH"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"NFS: %s: NFSv4 server callback with \"\n\t\t\t\"illegal minor version %u!\\n\"",
            "__func__",
            "hdr->minorversion"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "12"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NFS: NFSv4 CALLBACK %s: client sent tag of length %u\\n\"",
            "__func__",
            "hdr->taglen"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_string",
          "args": [
            "xdr",
            "&hdr->taglen",
            "&hdr->tag"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "decode_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "83-101",
          "snippet": "static __be32 decode_string(struct xdr_stream *xdr, unsigned int *len, const char **str)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t*len = ntohl(*p);\n\n\tif (*len != 0) {\n\t\tp = read_buf(xdr, *len);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*str = (const char *)p;\n\t} else\n\t\t*str = NULL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_string(struct xdr_stream *xdr, unsigned int *len, const char **str)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t*len = ntohl(*p);\n\n\tif (*len != 0) {\n\t\tp = read_buf(xdr, *len);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*str = (const char *)p;\n\t} else\n\t\t*str = NULL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\n#define CB_OP_TAGLEN_MAXSZ\t(512)\n\nstatic __be32 decode_compound_hdr_arg(struct xdr_stream *xdr, struct cb_compound_hdr_arg *hdr)\n{\n\t__be32 *p;\n\t__be32 status;\n\n\tstatus = decode_string(xdr, &hdr->taglen, &hdr->tag);\n\tif (unlikely(status != 0))\n\t\treturn status;\n\t/* We do not like overly long tags! */\n\tif (hdr->taglen > CB_OP_TAGLEN_MAXSZ - 12) {\n\t\tprintk(\"NFS: NFSv4 CALLBACK %s: client sent tag of length %u\\n\",\n\t\t\t\t__func__, hdr->taglen);\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t}\n\tp = read_buf(xdr, 12);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\thdr->minorversion = ntohl(*p++);\n\t/* Check for minor version support */\n\tif (hdr->minorversion <= NFS4_MAX_MINOR_VERSION) {\n\t\thdr->cb_ident = ntohl(*p++); /* ignored by v4.1 and v4.2 */\n\t} else {\n\t\tpr_warn_ratelimited(\"NFS: %s: NFSv4 server callback with \"\n\t\t\t\"illegal minor version %u!\\n\",\n\t\t\t__func__, hdr->minorversion);\n\t\treturn htonl(NFS4ERR_MINOR_VERS_MISMATCH);\n\t}\n\thdr->nops = ntohl(*p);\n\tdprintk(\"%s: minorversion %d nops %d\\n\", __func__,\n\t\thdr->minorversion, hdr->nops);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "140-149",
    "snippet": "static __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stateid",
            "p",
            "NFS4_STATEID_SIZE"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "NFS4_STATEID_SIZE"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_stateid(struct xdr_stream *xdr, nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, NFS4_STATEID_SIZE);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(stateid, p, NFS4_STATEID_SIZE);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "121-138",
    "snippet": "static __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\t__be32 *p;\n\tunsigned int attrlen;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tattrlen = ntohl(*p);\n\tp = read_buf(xdr, attrlen << 2);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tif (likely(attrlen > 0))\n\t\tbitmap[0] = ntohl(*p++);\n\tif (attrlen > 1)\n\t\tbitmap[1] = ntohl(*p);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "attrlen > 0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "attrlen << 2"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_bitmap(struct xdr_stream *xdr, uint32_t *bitmap)\n{\n\t__be32 *p;\n\tunsigned int attrlen;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tattrlen = ntohl(*p);\n\tp = read_buf(xdr, attrlen << 2);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tif (likely(attrlen > 0))\n\t\tbitmap[0] = ntohl(*p++);\n\tif (attrlen > 1)\n\t\tbitmap[1] = ntohl(*p);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "103-119",
    "snippet": "static __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fh->data[fh->size]",
            "0",
            "sizeof(fh->data) - fh->size"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fh->data[0]",
            "p",
            "fh->size"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "fh->size"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_BADHANDLE"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_fh(struct xdr_stream *xdr, struct nfs_fh *fh)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tfh->size = ntohl(*p);\n\tif (fh->size > NFS4_FHSIZE)\n\t\treturn htonl(NFS4ERR_BADHANDLE);\n\tp = read_buf(xdr, fh->size);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\tmemcpy(&fh->data[0], p, fh->size);\n\tmemset(&fh->data[fh->size], 0, sizeof(fh->data) - fh->size);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "83-101",
    "snippet": "static __be32 decode_string(struct xdr_stream *xdr, unsigned int *len, const char **str)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t*len = ntohl(*p);\n\n\tif (*len != 0) {\n\t\tp = read_buf(xdr, *len);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*str = (const char *)p;\n\t} else\n\t\t*str = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_buf",
          "args": [
            "xdr",
            "*len"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
          "lines": "73-81",
          "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
          "includes": [
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4ERR_RESOURCE"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 decode_string(struct xdr_stream *xdr, unsigned int *len, const char **str)\n{\n\t__be32 *p;\n\n\tp = read_buf(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn htonl(NFS4ERR_RESOURCE);\n\t*len = ntohl(*p);\n\n\tif (*len != 0) {\n\t\tp = read_buf(xdr, *len);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn htonl(NFS4ERR_RESOURCE);\n\t\t*str = (const char *)p;\n\t} else\n\t\t*str = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "read_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "73-81",
    "snippet": "static __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\""
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "nbytes"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 *read_buf(struct xdr_stream *xdr, int nbytes)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, nbytes);\n\tif (unlikely(p == NULL))\n\t\tprintk(KERN_WARNING \"NFS: NFSv4 callback reply buffer overflowed!\\n\");\n\treturn p;\n}"
  },
  {
    "function_name": "nfs4_encode_void",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "68-71",
    "snippet": "static int nfs4_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs4_decode_void",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "63-66",
    "snippet": "static int nfs4_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic int nfs4_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs4_callback_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/callback_xdr.c",
    "lines": "58-61",
    "snippet": "static __be32 nfs4_callback_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn htonl(NFS4_OK);\n}",
    "includes": [
      "#include \"nfs4session.h\"",
      "#include \"internal.h\"",
      "#include \"callback.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/sunrpc/bc_xprt.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/sunrpc/svc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "NFS4_OK"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/kernel.h>\n\nstatic __be32 nfs4_callback_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn htonl(NFS4_OK);\n}"
  }
]