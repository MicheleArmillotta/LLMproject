[
  {
    "function_name": "btrfs_log_new_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "4733-4758",
    "snippet": "int btrfs_log_new_name(struct btrfs_trans_handle *trans,\n\t\t\tstruct inode *inode, struct inode *old_dir,\n\t\t\tstruct dentry *parent)\n{\n\tstruct btrfs_root * root = BTRFS_I(inode)->root;\n\n\t/*\n\t * this will force the logging code to walk the dentry chain\n\t * up for the file\n\t */\n\tif (S_ISREG(inode->i_mode))\n\t\tBTRFS_I(inode)->last_unlink_trans = trans->transid;\n\n\t/*\n\t * if this inode hasn't been logged and directory we're renaming it\n\t * from hasn't been logged, we don't need to log it\n\t */\n\tif (BTRFS_I(inode)->logged_trans <=\n\t    root->fs_info->last_trans_committed &&\n\t    (!old_dir || BTRFS_I(old_dir)->logged_trans <=\n\t\t    root->fs_info->last_trans_committed))\n\t\treturn 0;\n\n\treturn btrfs_log_inode_parent(trans, root, inode, parent, 0,\n\t\t\t\t      LLONG_MAX, 1, NULL);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_log_inode_parent",
          "args": [
            "trans",
            "root",
            "inode",
            "parent",
            "0",
            "LLONG_MAX",
            "1",
            "NULL"
          ],
          "line": 4756
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_log_inode_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "4381-4501",
          "snippet": "static int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t    \t  struct btrfs_root *root, struct inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  const loff_t start,\n\t\t\t\t  const loff_t end,\n\t\t\t\t  int exists_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tint inode_only = exists_only ? LOG_INODE_EXISTS : LOG_INODE_ALL;\n\tstruct super_block *sb;\n\tstruct dentry *old_parent = NULL;\n\tint ret = 0;\n\tu64 last_committed = root->fs_info->last_trans_committed;\n\tconst struct dentry * const first_parent = parent;\n\tconst bool did_unlink = (BTRFS_I(inode)->last_unlink_trans >\n\t\t\t\t last_committed);\n\n\tsb = inode->i_sb;\n\n\tif (btrfs_test_opt(root, NOTREELOG)) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\t/*\n\t * The prev transaction commit doesn't complete, we need do\n\t * full commit by ourselves.\n\t */\n\tif (root->fs_info->last_trans_log_full_commit >\n\t    root->fs_info->last_trans_committed) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (root != BTRFS_I(inode)->root ||\n\t    btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = check_parent_dirs_for_sync(trans, inode, parent,\n\t\t\t\t\t sb, last_committed);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tif (btrfs_inode_in_log(inode, trans->transid)) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, root, inode, inode_only, start, end, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\twhile (1) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tinode = parent->d_inode;\n\t\tif (root != BTRFS_I(inode)->root)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * On unlink we must make sure our immediate parent directory\n\t\t * inode is fully logged. This is to prevent leaving dangling\n\t\t * directory index entries and a wrong directory inode's i_size.\n\t\t * Not doing so can result in a directory being impossible to\n\t\t * delete after log replay (rmdir will always fail with error\n\t\t * -ENOTEMPTY).\n\t\t */\n\t\tif (did_unlink && parent == first_parent)\n\t\t\tinode_only = LOG_INODE_ALL;\n\t\telse\n\t\t\tinode_only = LOG_INODE_EXISTS;\n\n\t\tif (BTRFS_I(inode)->generation >\n\t\t    root->fs_info->last_trans_committed ||\n\t\t    inode_only == LOG_INODE_ALL) {\n\t\t\tret = btrfs_log_inode(trans, root, inode, inode_only,\n\t\t\t\t\t      0, LLONG_MAX, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto end_trans;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tret = 0;\nend_trans:\n\tdput(old_parent);\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define LOG_INODE_EXISTS 1",
            "#define LOG_INODE_ALL 0"
          ],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_INODE_EXISTS 1\n#define LOG_INODE_ALL 0\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t    \t  struct btrfs_root *root, struct inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  const loff_t start,\n\t\t\t\t  const loff_t end,\n\t\t\t\t  int exists_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tint inode_only = exists_only ? LOG_INODE_EXISTS : LOG_INODE_ALL;\n\tstruct super_block *sb;\n\tstruct dentry *old_parent = NULL;\n\tint ret = 0;\n\tu64 last_committed = root->fs_info->last_trans_committed;\n\tconst struct dentry * const first_parent = parent;\n\tconst bool did_unlink = (BTRFS_I(inode)->last_unlink_trans >\n\t\t\t\t last_committed);\n\n\tsb = inode->i_sb;\n\n\tif (btrfs_test_opt(root, NOTREELOG)) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\t/*\n\t * The prev transaction commit doesn't complete, we need do\n\t * full commit by ourselves.\n\t */\n\tif (root->fs_info->last_trans_log_full_commit >\n\t    root->fs_info->last_trans_committed) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (root != BTRFS_I(inode)->root ||\n\t    btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = check_parent_dirs_for_sync(trans, inode, parent,\n\t\t\t\t\t sb, last_committed);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tif (btrfs_inode_in_log(inode, trans->transid)) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, root, inode, inode_only, start, end, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\twhile (1) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tinode = parent->d_inode;\n\t\tif (root != BTRFS_I(inode)->root)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * On unlink we must make sure our immediate parent directory\n\t\t * inode is fully logged. This is to prevent leaving dangling\n\t\t * directory index entries and a wrong directory inode's i_size.\n\t\t * Not doing so can result in a directory being impossible to\n\t\t * delete after log replay (rmdir will always fail with error\n\t\t * -ENOTEMPTY).\n\t\t */\n\t\tif (did_unlink && parent == first_parent)\n\t\t\tinode_only = LOG_INODE_ALL;\n\t\telse\n\t\t\tinode_only = LOG_INODE_EXISTS;\n\n\t\tif (BTRFS_I(inode)->generation >\n\t\t    root->fs_info->last_trans_committed ||\n\t\t    inode_only == LOG_INODE_ALL) {\n\t\t\tret = btrfs_log_inode(trans, root, inode, inode_only,\n\t\t\t\t\t      0, LLONG_MAX, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto end_trans;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tret = 0;\nend_trans:\n\tdput(old_parent);\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "old_dir"
          ],
          "line": 4752
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_log_new_name(struct btrfs_trans_handle *trans,\n\t\t\tstruct inode *inode, struct inode *old_dir,\n\t\t\tstruct dentry *parent)\n{\n\tstruct btrfs_root * root = BTRFS_I(inode)->root;\n\n\t/*\n\t * this will force the logging code to walk the dentry chain\n\t * up for the file\n\t */\n\tif (S_ISREG(inode->i_mode))\n\t\tBTRFS_I(inode)->last_unlink_trans = trans->transid;\n\n\t/*\n\t * if this inode hasn't been logged and directory we're renaming it\n\t * from hasn't been logged, we don't need to log it\n\t */\n\tif (BTRFS_I(inode)->logged_trans <=\n\t    root->fs_info->last_trans_committed &&\n\t    (!old_dir || BTRFS_I(old_dir)->logged_trans <=\n\t\t    root->fs_info->last_trans_committed))\n\t\treturn 0;\n\n\treturn btrfs_log_inode_parent(trans, root, inode, parent, 0,\n\t\t\t\t      LLONG_MAX, 1, NULL);\n}"
  },
  {
    "function_name": "btrfs_record_unlink_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "4677-4724",
    "snippet": "void btrfs_record_unlink_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct inode *dir, struct inode *inode,\n\t\t\t     int for_rename)\n{\n\t/*\n\t * when we're logging a file, if it hasn't been renamed\n\t * or unlinked, and its inode is fully committed on disk,\n\t * we don't have to worry about walking up the directory chain\n\t * to log its parents.\n\t *\n\t * So, we use the last_unlink_trans field to put this transid\n\t * into the file.  When the file is logged we check it and\n\t * don't log the parents if the file is fully on disk.\n\t */\n\tif (S_ISREG(inode->i_mode))\n\t\tBTRFS_I(inode)->last_unlink_trans = trans->transid;\n\n\t/*\n\t * if this directory was already logged any new\n\t * names for this file/dir will get recorded\n\t */\n\tsmp_mb();\n\tif (BTRFS_I(dir)->logged_trans == trans->transid)\n\t\treturn;\n\n\t/*\n\t * if the inode we're about to unlink was logged,\n\t * the log will be properly updated for any new names\n\t */\n\tif (BTRFS_I(inode)->logged_trans == trans->transid)\n\t\treturn;\n\n\t/*\n\t * when renaming files across directories, if the directory\n\t * there we're unlinking from gets fsync'd later on, there's\n\t * no way to find the destination directory later and fsync it\n\t * properly.  So, we have to be conservative and force commits\n\t * so the new name gets discovered.\n\t */\n\tif (for_rename)\n\t\tgoto record;\n\n\t/* we can safely do the unlink without any special recording */\n\treturn;\n\nrecord:\n\tBTRFS_I(dir)->last_unlink_trans = trans->transid;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dir"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_record_unlink_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct inode *dir, struct inode *inode,\n\t\t\t     int for_rename)\n{\n\t/*\n\t * when we're logging a file, if it hasn't been renamed\n\t * or unlinked, and its inode is fully committed on disk,\n\t * we don't have to worry about walking up the directory chain\n\t * to log its parents.\n\t *\n\t * So, we use the last_unlink_trans field to put this transid\n\t * into the file.  When the file is logged we check it and\n\t * don't log the parents if the file is fully on disk.\n\t */\n\tif (S_ISREG(inode->i_mode))\n\t\tBTRFS_I(inode)->last_unlink_trans = trans->transid;\n\n\t/*\n\t * if this directory was already logged any new\n\t * names for this file/dir will get recorded\n\t */\n\tsmp_mb();\n\tif (BTRFS_I(dir)->logged_trans == trans->transid)\n\t\treturn;\n\n\t/*\n\t * if the inode we're about to unlink was logged,\n\t * the log will be properly updated for any new names\n\t */\n\tif (BTRFS_I(inode)->logged_trans == trans->transid)\n\t\treturn;\n\n\t/*\n\t * when renaming files across directories, if the directory\n\t * there we're unlinking from gets fsync'd later on, there's\n\t * no way to find the destination directory later and fsync it\n\t * properly.  So, we have to be conservative and force commits\n\t * so the new name gets discovered.\n\t */\n\tif (for_rename)\n\t\tgoto record;\n\n\t/* we can safely do the unlink without any special recording */\n\treturn;\n\nrecord:\n\tBTRFS_I(dir)->last_unlink_trans = trans->transid;\n}"
  },
  {
    "function_name": "btrfs_recover_log_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "4529-4667",
    "snippet": "int btrfs_recover_log_trees(struct btrfs_root *log_root_tree)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key tmp_key;\n\tstruct btrfs_root *log;\n\tstruct btrfs_fs_info *fs_info = log_root_tree->fs_info;\n\tstruct walk_control wc = {\n\t\t.process_func = process_one_buffer,\n\t\t.stage = 0,\n\t};\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tfs_info->log_root_recovering = 1;\n\n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\twc.trans = trans;\n\twc.pin = 1;\n\n\tret = walk_log_tree(trans, log_root_tree, &wc);\n\tif (ret) {\n\t\tbtrfs_error(fs_info, ret, \"Failed to pin buffers while \"\n\t\t\t    \"recovering log root tree.\");\n\t\tgoto error;\n\t}\n\nagain:\n\tkey.objectid = BTRFS_TREE_LOG_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, log_root_tree, &key, path, 0, 0);\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't find tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tif (found_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\t\tbreak;\n\n\t\tlog = btrfs_read_fs_root(log_root_tree, &found_key);\n\t\tif (IS_ERR(log)) {\n\t\t\tret = PTR_ERR(log);\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't read tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\ttmp_key.objectid = found_key.offset;\n\t\ttmp_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_key.offset = (u64)-1;\n\n\t\twc.replay_dest = btrfs_read_fs_root_no_name(fs_info, &tmp_key);\n\t\tif (IS_ERR(wc.replay_dest)) {\n\t\t\tret = PTR_ERR(wc.replay_dest);\n\t\t\tfree_extent_buffer(log->node);\n\t\t\tfree_extent_buffer(log->commit_root);\n\t\t\tkfree(log);\n\t\t\tbtrfs_error(fs_info, ret, \"Couldn't read target root \"\n\t\t\t\t    \"for tree log recovery.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest->log_root = log;\n\t\tbtrfs_record_root_in_trans(trans, wc.replay_dest);\n\t\tret = walk_log_tree(trans, log, &wc);\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tret = fixup_inode_link_counts(trans, wc.replay_dest,\n\t\t\t\t\t\t      path);\n\t\t}\n\n\t\tkey.offset = found_key.offset - 1;\n\t\twc.replay_dest->log_root = NULL;\n\t\tfree_extent_buffer(log->node);\n\t\tfree_extent_buffer(log->commit_root);\n\t\tkfree(log);\n\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* step one is to pin it all, step two is to replay just inodes */\n\tif (wc.pin) {\n\t\twc.pin = 0;\n\t\twc.process_func = replay_one_buffer;\n\t\twc.stage = LOG_WALK_REPLAY_INODES;\n\t\tgoto again;\n\t}\n\t/* step three is to replay everything */\n\tif (wc.stage < LOG_WALK_REPLAY_ALL) {\n\t\twc.stage++;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/* step 4: commit the transaction, which also unpins the blocks */\n\tret = btrfs_commit_transaction(trans, fs_info->tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tfree_extent_buffer(log_root_tree->node);\n\tlog_root_tree->log_root = NULL;\n\tfs_info->log_root_recovering = 0;\n\tkfree(log_root_tree);\n\n\treturn 0;\nerror:\n\tif (wc.trans)\n\t\tbtrfs_end_transaction(wc.trans, fs_info->tree_root);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define LOG_WALK_REPLAY_ALL 3",
      "#define LOG_WALK_REPLAY_INODES 1"
    ],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4665
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "wc.trans",
            "fs_info->tree_root"
          ],
          "line": 4664
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_root_tree"
          ],
          "line": 4659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "log_root_tree->node"
          ],
          "line": 4656
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "fs_info->tree_root"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 4634
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log"
          ],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_inode_link_counts",
          "args": [
            "trans",
            "wc.replay_dest",
            "path"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_inode_link_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1441-1493",
          "snippet": "static noinline int fixup_inode_link_counts(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret == 1) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_TREE_LOG_FIXUP_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t\tinode = read_one_inode(root, key.offset);\n\t\tif (!inode)\n\t\t\treturn -EIO;\n\n\t\tret = fixup_inode_link_count(trans, root, inode);\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * fixup on a directory may create new entries,\n\t\t * make sure we always look for the highset possible\n\t\t * offset\n\t\t */\n\t\tkey.offset = (u64)-1;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int fixup_inode_link_counts(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret == 1) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_TREE_LOG_FIXUP_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t\tinode = read_one_inode(root, key.offset);\n\t\tif (!inode)\n\t\t\treturn -EIO;\n\n\t\tret = fixup_inode_link_count(trans, root, inode);\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * fixup on a directory may create new entries,\n\t\t * make sure we always look for the highset possible\n\t\t * offset\n\t\t */\n\t\tkey.offset = (u64)-1;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_log_tree",
          "args": [
            "trans",
            "log",
            "&wc"
          ],
          "line": 4615
        },
        "resolved": true,
        "details": {
          "function_name": "walk_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2336-2404",
          "snippet": "static int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\textent_buffer_get(log->node);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* was the root node processed? if not, catch it here */\n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free) {\n\t\t\tstruct extent_buffer *next;\n\n\t\t\tnext = path->nodes[orig_level];\n\n\t\t\tif (trans) {\n\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\tclean_tree_block(trans, log, next);\n\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t}\n\n\t\t\tWARN_ON(log->root_key.objectid !=\n\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\tret = btrfs_free_and_pin_reserved_extent(log, next->start,\n\t\t\t\t\t\t\t next->len);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\textent_buffer_get(log->node);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* was the root node processed? if not, catch it here */\n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free) {\n\t\t\tstruct extent_buffer *next;\n\n\t\t\tnext = path->nodes[orig_level];\n\n\t\t\tif (trans) {\n\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\tclean_tree_block(trans, log, next);\n\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t}\n\n\t\t\tWARN_ON(log->root_key.objectid !=\n\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\tret = btrfs_free_and_pin_reserved_extent(log, next->start,\n\t\t\t\t\t\t\t next->len);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_record_root_in_trans",
          "args": [
            "trans",
            "wc.replay_dest"
          ],
          "line": 4614
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_error",
          "args": [
            "fs_info",
            "ret",
            "\"Couldn't read target root \"\n\t\t\t\t    \"for tree log recovery.\""
          ],
          "line": 4608
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "wc.replay_dest"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "wc.replay_dest"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&tmp_key"
          ],
          "line": 4602
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "log"
          ],
          "line": 4592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "log"
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 4584
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "log_root_tree",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 4572
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "fs_info->tree_root",
            "0"
          ],
          "line": 4550
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4544
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_WALK_REPLAY_ALL 3\n#define LOG_WALK_REPLAY_INODES 1\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nint btrfs_recover_log_trees(struct btrfs_root *log_root_tree)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key tmp_key;\n\tstruct btrfs_root *log;\n\tstruct btrfs_fs_info *fs_info = log_root_tree->fs_info;\n\tstruct walk_control wc = {\n\t\t.process_func = process_one_buffer,\n\t\t.stage = 0,\n\t};\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tfs_info->log_root_recovering = 1;\n\n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\twc.trans = trans;\n\twc.pin = 1;\n\n\tret = walk_log_tree(trans, log_root_tree, &wc);\n\tif (ret) {\n\t\tbtrfs_error(fs_info, ret, \"Failed to pin buffers while \"\n\t\t\t    \"recovering log root tree.\");\n\t\tgoto error;\n\t}\n\nagain:\n\tkey.objectid = BTRFS_TREE_LOG_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, log_root_tree, &key, path, 0, 0);\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't find tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tif (found_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\t\tbreak;\n\n\t\tlog = btrfs_read_fs_root(log_root_tree, &found_key);\n\t\tif (IS_ERR(log)) {\n\t\t\tret = PTR_ERR(log);\n\t\t\tbtrfs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't read tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\ttmp_key.objectid = found_key.offset;\n\t\ttmp_key.type = BTRFS_ROOT_ITEM_KEY;\n\t\ttmp_key.offset = (u64)-1;\n\n\t\twc.replay_dest = btrfs_read_fs_root_no_name(fs_info, &tmp_key);\n\t\tif (IS_ERR(wc.replay_dest)) {\n\t\t\tret = PTR_ERR(wc.replay_dest);\n\t\t\tfree_extent_buffer(log->node);\n\t\t\tfree_extent_buffer(log->commit_root);\n\t\t\tkfree(log);\n\t\t\tbtrfs_error(fs_info, ret, \"Couldn't read target root \"\n\t\t\t\t    \"for tree log recovery.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest->log_root = log;\n\t\tbtrfs_record_root_in_trans(trans, wc.replay_dest);\n\t\tret = walk_log_tree(trans, log, &wc);\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tret = fixup_inode_link_counts(trans, wc.replay_dest,\n\t\t\t\t\t\t      path);\n\t\t}\n\n\t\tkey.offset = found_key.offset - 1;\n\t\twc.replay_dest->log_root = NULL;\n\t\tfree_extent_buffer(log->node);\n\t\tfree_extent_buffer(log->commit_root);\n\t\tkfree(log);\n\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* step one is to pin it all, step two is to replay just inodes */\n\tif (wc.pin) {\n\t\twc.pin = 0;\n\t\twc.process_func = replay_one_buffer;\n\t\twc.stage = LOG_WALK_REPLAY_INODES;\n\t\tgoto again;\n\t}\n\t/* step three is to replay everything */\n\tif (wc.stage < LOG_WALK_REPLAY_ALL) {\n\t\twc.stage++;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/* step 4: commit the transaction, which also unpins the blocks */\n\tret = btrfs_commit_transaction(trans, fs_info->tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tfree_extent_buffer(log_root_tree->node);\n\tlog_root_tree->log_root = NULL;\n\tfs_info->log_root_recovering = 0;\n\tkfree(log_root_tree);\n\n\treturn 0;\nerror:\n\tif (wc.trans)\n\t\tbtrfs_end_transaction(wc.trans, fs_info->tree_root);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_log_dentry_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "4509-4523",
    "snippet": "int btrfs_log_dentry_safe(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct dentry *dentry,\n\t\t\t  const loff_t start,\n\t\t\t  const loff_t end,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tint ret;\n\n\tret = btrfs_log_inode_parent(trans, root, dentry->d_inode, parent,\n\t\t\t\t     start, end, 0, ctx);\n\tdput(parent);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 4520
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_log_inode_parent",
          "args": [
            "trans",
            "root",
            "dentry->d_inode",
            "parent",
            "start",
            "end",
            "0",
            "ctx"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_log_inode_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "4381-4501",
          "snippet": "static int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t    \t  struct btrfs_root *root, struct inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  const loff_t start,\n\t\t\t\t  const loff_t end,\n\t\t\t\t  int exists_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tint inode_only = exists_only ? LOG_INODE_EXISTS : LOG_INODE_ALL;\n\tstruct super_block *sb;\n\tstruct dentry *old_parent = NULL;\n\tint ret = 0;\n\tu64 last_committed = root->fs_info->last_trans_committed;\n\tconst struct dentry * const first_parent = parent;\n\tconst bool did_unlink = (BTRFS_I(inode)->last_unlink_trans >\n\t\t\t\t last_committed);\n\n\tsb = inode->i_sb;\n\n\tif (btrfs_test_opt(root, NOTREELOG)) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\t/*\n\t * The prev transaction commit doesn't complete, we need do\n\t * full commit by ourselves.\n\t */\n\tif (root->fs_info->last_trans_log_full_commit >\n\t    root->fs_info->last_trans_committed) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (root != BTRFS_I(inode)->root ||\n\t    btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = check_parent_dirs_for_sync(trans, inode, parent,\n\t\t\t\t\t sb, last_committed);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tif (btrfs_inode_in_log(inode, trans->transid)) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, root, inode, inode_only, start, end, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\twhile (1) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tinode = parent->d_inode;\n\t\tif (root != BTRFS_I(inode)->root)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * On unlink we must make sure our immediate parent directory\n\t\t * inode is fully logged. This is to prevent leaving dangling\n\t\t * directory index entries and a wrong directory inode's i_size.\n\t\t * Not doing so can result in a directory being impossible to\n\t\t * delete after log replay (rmdir will always fail with error\n\t\t * -ENOTEMPTY).\n\t\t */\n\t\tif (did_unlink && parent == first_parent)\n\t\t\tinode_only = LOG_INODE_ALL;\n\t\telse\n\t\t\tinode_only = LOG_INODE_EXISTS;\n\n\t\tif (BTRFS_I(inode)->generation >\n\t\t    root->fs_info->last_trans_committed ||\n\t\t    inode_only == LOG_INODE_ALL) {\n\t\t\tret = btrfs_log_inode(trans, root, inode, inode_only,\n\t\t\t\t\t      0, LLONG_MAX, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto end_trans;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tret = 0;\nend_trans:\n\tdput(old_parent);\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define LOG_INODE_EXISTS 1",
            "#define LOG_INODE_ALL 0"
          ],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_INODE_EXISTS 1\n#define LOG_INODE_ALL 0\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t    \t  struct btrfs_root *root, struct inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  const loff_t start,\n\t\t\t\t  const loff_t end,\n\t\t\t\t  int exists_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tint inode_only = exists_only ? LOG_INODE_EXISTS : LOG_INODE_ALL;\n\tstruct super_block *sb;\n\tstruct dentry *old_parent = NULL;\n\tint ret = 0;\n\tu64 last_committed = root->fs_info->last_trans_committed;\n\tconst struct dentry * const first_parent = parent;\n\tconst bool did_unlink = (BTRFS_I(inode)->last_unlink_trans >\n\t\t\t\t last_committed);\n\n\tsb = inode->i_sb;\n\n\tif (btrfs_test_opt(root, NOTREELOG)) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\t/*\n\t * The prev transaction commit doesn't complete, we need do\n\t * full commit by ourselves.\n\t */\n\tif (root->fs_info->last_trans_log_full_commit >\n\t    root->fs_info->last_trans_committed) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (root != BTRFS_I(inode)->root ||\n\t    btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = check_parent_dirs_for_sync(trans, inode, parent,\n\t\t\t\t\t sb, last_committed);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tif (btrfs_inode_in_log(inode, trans->transid)) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, root, inode, inode_only, start, end, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\twhile (1) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tinode = parent->d_inode;\n\t\tif (root != BTRFS_I(inode)->root)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * On unlink we must make sure our immediate parent directory\n\t\t * inode is fully logged. This is to prevent leaving dangling\n\t\t * directory index entries and a wrong directory inode's i_size.\n\t\t * Not doing so can result in a directory being impossible to\n\t\t * delete after log replay (rmdir will always fail with error\n\t\t * -ENOTEMPTY).\n\t\t */\n\t\tif (did_unlink && parent == first_parent)\n\t\t\tinode_only = LOG_INODE_ALL;\n\t\telse\n\t\t\tinode_only = LOG_INODE_EXISTS;\n\n\t\tif (BTRFS_I(inode)->generation >\n\t\t    root->fs_info->last_trans_committed ||\n\t\t    inode_only == LOG_INODE_ALL) {\n\t\t\tret = btrfs_log_inode(trans, root, inode, inode_only,\n\t\t\t\t\t      0, LLONG_MAX, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto end_trans;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tret = 0;\nend_trans:\n\tdput(old_parent);\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 4515
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nint btrfs_log_dentry_safe(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct dentry *dentry,\n\t\t\t  const loff_t start,\n\t\t\t  const loff_t end,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tint ret;\n\n\tret = btrfs_log_inode_parent(trans, root, dentry->d_inode, parent,\n\t\t\t\t     start, end, 0, ctx);\n\tdput(parent);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_log_inode_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "4381-4501",
    "snippet": "static int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t    \t  struct btrfs_root *root, struct inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  const loff_t start,\n\t\t\t\t  const loff_t end,\n\t\t\t\t  int exists_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tint inode_only = exists_only ? LOG_INODE_EXISTS : LOG_INODE_ALL;\n\tstruct super_block *sb;\n\tstruct dentry *old_parent = NULL;\n\tint ret = 0;\n\tu64 last_committed = root->fs_info->last_trans_committed;\n\tconst struct dentry * const first_parent = parent;\n\tconst bool did_unlink = (BTRFS_I(inode)->last_unlink_trans >\n\t\t\t\t last_committed);\n\n\tsb = inode->i_sb;\n\n\tif (btrfs_test_opt(root, NOTREELOG)) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\t/*\n\t * The prev transaction commit doesn't complete, we need do\n\t * full commit by ourselves.\n\t */\n\tif (root->fs_info->last_trans_log_full_commit >\n\t    root->fs_info->last_trans_committed) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (root != BTRFS_I(inode)->root ||\n\t    btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = check_parent_dirs_for_sync(trans, inode, parent,\n\t\t\t\t\t sb, last_committed);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tif (btrfs_inode_in_log(inode, trans->transid)) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, root, inode, inode_only, start, end, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\twhile (1) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tinode = parent->d_inode;\n\t\tif (root != BTRFS_I(inode)->root)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * On unlink we must make sure our immediate parent directory\n\t\t * inode is fully logged. This is to prevent leaving dangling\n\t\t * directory index entries and a wrong directory inode's i_size.\n\t\t * Not doing so can result in a directory being impossible to\n\t\t * delete after log replay (rmdir will always fail with error\n\t\t * -ENOTEMPTY).\n\t\t */\n\t\tif (did_unlink && parent == first_parent)\n\t\t\tinode_only = LOG_INODE_ALL;\n\t\telse\n\t\t\tinode_only = LOG_INODE_EXISTS;\n\n\t\tif (BTRFS_I(inode)->generation >\n\t\t    root->fs_info->last_trans_committed ||\n\t\t    inode_only == LOG_INODE_ALL) {\n\t\t\tret = btrfs_log_inode(trans, root, inode, inode_only,\n\t\t\t\t\t      0, LLONG_MAX, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto end_trans;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tret = 0;\nend_trans:\n\tdput(old_parent);\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define LOG_INODE_EXISTS 1",
      "#define LOG_INODE_ALL 0"
    ],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_log_trans",
          "args": [
            "root"
          ],
          "line": 4498
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_log_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "238-245",
          "snippet": "void btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_remove_log_ctx",
          "args": [
            "root",
            "ctx"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_log_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2468-2477",
          "snippet": "static inline void btrfs_remove_log_ctx(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tmutex_lock(&root->log_mutex);\n\tlist_del_init(&ctx->list);\n\tmutex_unlock(&root->log_mutex);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic inline void btrfs_remove_log_ctx(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tmutex_lock(&root->log_mutex);\n\tlist_del_init(&ctx->list);\n\tmutex_unlock(&root->log_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_log_full_commit",
          "args": [
            "root->fs_info",
            "trans"
          ],
          "line": 4492
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_log_full_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "43-47",
          "snippet": "static inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "old_parent"
          ],
          "line": 4490
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "parent"
          ],
          "line": 4484
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "parent"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_log_inode",
          "args": [
            "trans",
            "root",
            "inode",
            "inode_only",
            "0",
            "LLONG_MAX",
            "ctx"
          ],
          "line": 4476
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3993-4299",
          "snippet": "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_path *dst_path;\n\tstruct btrfs_key min_key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src = NULL;\n\tLIST_HEAD(logged_list);\n\tu64 last_extent = 0;\n\tint err = 0;\n\tint ret;\n\tint nritems;\n\tint ins_start_slot = 0;\n\tint ins_nr;\n\tbool fast_search = false;\n\tu64 ino = btrfs_ino(inode);\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 logged_isize = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tdst_path = btrfs_alloc_path();\n\tif (!dst_path) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_INODE_ITEM_KEY;\n\tmin_key.offset = 0;\n\n\tmax_key.objectid = ino;\n\n\n\t/* today the code can only do partial logging of directories */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    (!test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t       &BTRFS_I(inode)->runtime_flags) &&\n\t     inode_only == LOG_INODE_EXISTS))\n\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\telse\n\t\tmax_key.type = (u8)-1;\n\tmax_key.offset = (u64)-1;\n\n\t/*\n\t * Only run delayed items if we are a dir or a new file.\n\t * Otherwise commit the delayed inode only, which is needed in\n\t * order for the log replay code to mark inodes for link count\n\t * fixup (create temporary BTRFS_TREE_LOG_FIXUP_OBJECTID items).\n\t */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    BTRFS_I(inode)->generation > root->fs_info->last_trans_committed)\n\t\tret = btrfs_commit_inode_delayed_items(trans, inode);\n\telse\n\t\tret = btrfs_commit_inode_delayed_inode(inode);\n\n\tif (ret) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_free_path(dst_path);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_get_logged_extents(inode, &logged_list, start, end);\n\n\t/*\n\t * a brute force approach to making sure we get the most uptodate\n\t * copies of everything.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tint max_key_type = BTRFS_DIR_LOG_INDEX_KEY;\n\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\tmax_key_type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tmax_key.type = max_key_type;\n\t\t}\n\t\tret = drop_objectid_items(trans, log, path, ino, max_key_type);\n\t} else {\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t/*\n\t\t\t * Make sure the new inode item we write to the log has\n\t\t\t * the same isize as the current one (if it exists).\n\t\t\t * This is necessary to prevent data loss after log\n\t\t\t * replay, and also to prevent doing a wrong expanding\n\t\t\t * truncate - for e.g. create file, write 4K into offset\n\t\t\t * 0, fsync, write 4K into offset 4096, add hard link,\n\t\t\t * fsync some other file (to sync log), power fail - if\n\t\t\t * we use the inode's current i_size, after log replay\n\t\t\t * we get a 8Kb file, with the last 4Kb extent as a hole\n\t\t\t * (zeroes), as if an expanding truncate happened,\n\t\t\t * instead of getting a file of 4Kb only.\n\t\t\t */\n\t\t\terr = logged_inode_size(log, inode, path,\n\t\t\t\t\t\t&logged_isize);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t\t  max_key.type);\n\t\t\t} else {\n\t\t\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tret = btrfs_truncate_inode_items(trans, log,\n\t\t\t\t\t\t\t\t inode, 0, 0);\n\t\t\t}\n\t\t} else if (test_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t    &BTRFS_I(inode)->runtime_flags) ||\n\t\t\t   inode_only == LOG_INODE_EXISTS) {\n\t\t\tif (inode_only == LOG_INODE_ALL) {\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tfast_search = true;\n\t\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\t} else {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t}\n\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t  max_key.type);\n\t\t} else {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tret = log_inode_item(trans, log, dst_path, inode);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tgoto log_extents;\n\t\t}\n\n\t}\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (1) {\n\t\tins_nr = 0;\n\t\tret = btrfs_search_forward(root, &min_key,\n\t\t\t\t\t   path, trans->transid);\n\t\tif (ret != 0)\n\t\t\tbreak;\nagain:\n\t\t/* note, ins_nr might be > 0 here, cleanup outside the loop */\n\t\tif (min_key.objectid != ino)\n\t\t\tbreak;\n\t\tif (min_key.type > max_key.type)\n\t\t\tbreak;\n\n\t\tsrc = path->nodes[0];\n\t\tif (ins_nr && ins_start_slot + ins_nr == path->slots[0]) {\n\t\t\tins_nr++;\n\t\t\tgoto next_slot;\n\t\t} else if (!ins_nr) {\n\t\t\tins_start_slot = path->slots[0];\n\t\t\tins_nr = 1;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (ret) {\n\t\t\tins_nr = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tins_nr = 1;\n\t\tins_start_slot = path->slots[0];\nnext_slot:\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < nritems) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &min_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ins_nr) {\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t &last_extent, ins_start_slot,\n\t\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tins_nr = 0;\n\t\t}\n\t\tbtrfs_release_path(path);\n\n\t\tif (min_key.offset < (u64)-1) {\n\t\t\tmin_key.offset++;\n\t\t} else if (min_key.type < max_key.type) {\n\t\t\tmin_key.type++;\n\t\t\tmin_key.offset = 0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ins_nr) {\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = 0;\n\t\tins_nr = 0;\n\t}\n\nlog_extents:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\tif (fast_search) {\n\t\t/*\n\t\t * Some ordered extents started by fsync might have completed\n\t\t * before we collected the ordered extents in logged_list, which\n\t\t * means they're gone, not in our logged_list nor in the inode's\n\t\t * ordered tree. We want the application/user space to know an\n\t\t * error happened while attempting to persist file data so that\n\t\t * it can take proper action. If such error happened, we leave\n\t\t * without writing to the log tree and the fsync must report the\n\t\t * file data write error and not commit the current transaction.\n\t\t */\n\t\terr = btrfs_inode_check_errors(inode);\n\t\tif (err) {\n\t\t\tctx->io_err = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = btrfs_log_changed_extents(trans, root, inode, dst_path,\n\t\t\t\t\t\t&logged_list, ctx);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (inode_only == LOG_INODE_ALL) {\n\t\tstruct extent_map *em, *n;\n\n\t\twrite_lock(&em_tree->lock);\n\t\t/*\n\t\t * We can't just remove every em if we're called for a ranged\n\t\t * fsync - that is, one that doesn't cover the whole possible\n\t\t * file range (0 to LLONG_MAX). This is because we can have\n\t\t * em's that fall outside the range we're logging and therefore\n\t\t * their ordered operations haven't completed yet\n\t\t * (btrfs_finish_ordered_io() not invoked yet). This means we\n\t\t * didn't get their respective file extent item in the fs/subvol\n\t\t * tree yet, and need to let the next fast fsync (one which\n\t\t * consults the list of modified extent maps) find the em so\n\t\t * that it logs a matching file extent item and waits for the\n\t\t * respective ordered operation to complete (if it's still\n\t\t * running).\n\t\t *\n\t\t * Removing every em outside the range we're logging would make\n\t\t * the next fast fsync not log their matching file extent items,\n\t\t * therefore making us lose data after a log replay.\n\t\t */\n\t\tlist_for_each_entry_safe(em, n, &em_tree->modified_extents,\n\t\t\t\t\t list) {\n\t\t\tconst u64 mod_end = em->mod_start + em->mod_len - 1;\n\n\t\t\tif (em->mod_start >= start && mod_end <= end)\n\t\t\t\tlist_del_init(&em->list);\n\t\t}\n\t\twrite_unlock(&em_tree->lock);\n\t}\n\n\tif (inode_only == LOG_INODE_ALL && S_ISDIR(inode->i_mode)) {\n\t\tret = log_directory_changes(trans, root, inode, path, dst_path);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->logged_trans = trans->transid;\n\tBTRFS_I(inode)->last_log_commit = BTRFS_I(inode)->last_sub_trans;\nout_unlock:\n\tif (unlikely(err))\n\t\tbtrfs_put_logged_extents(&logged_list);\n\telse\n\t\tbtrfs_submit_logged_extents(&logged_list, log);\n\tmutex_unlock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(dst_path);\n\treturn err;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define LOG_INODE_EXISTS 1",
            "#define LOG_INODE_ALL 0"
          ],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_INODE_EXISTS 1\n#define LOG_INODE_ALL 0\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_path *dst_path;\n\tstruct btrfs_key min_key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src = NULL;\n\tLIST_HEAD(logged_list);\n\tu64 last_extent = 0;\n\tint err = 0;\n\tint ret;\n\tint nritems;\n\tint ins_start_slot = 0;\n\tint ins_nr;\n\tbool fast_search = false;\n\tu64 ino = btrfs_ino(inode);\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 logged_isize = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tdst_path = btrfs_alloc_path();\n\tif (!dst_path) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_INODE_ITEM_KEY;\n\tmin_key.offset = 0;\n\n\tmax_key.objectid = ino;\n\n\n\t/* today the code can only do partial logging of directories */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    (!test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t       &BTRFS_I(inode)->runtime_flags) &&\n\t     inode_only == LOG_INODE_EXISTS))\n\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\telse\n\t\tmax_key.type = (u8)-1;\n\tmax_key.offset = (u64)-1;\n\n\t/*\n\t * Only run delayed items if we are a dir or a new file.\n\t * Otherwise commit the delayed inode only, which is needed in\n\t * order for the log replay code to mark inodes for link count\n\t * fixup (create temporary BTRFS_TREE_LOG_FIXUP_OBJECTID items).\n\t */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    BTRFS_I(inode)->generation > root->fs_info->last_trans_committed)\n\t\tret = btrfs_commit_inode_delayed_items(trans, inode);\n\telse\n\t\tret = btrfs_commit_inode_delayed_inode(inode);\n\n\tif (ret) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_free_path(dst_path);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_get_logged_extents(inode, &logged_list, start, end);\n\n\t/*\n\t * a brute force approach to making sure we get the most uptodate\n\t * copies of everything.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tint max_key_type = BTRFS_DIR_LOG_INDEX_KEY;\n\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\tmax_key_type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tmax_key.type = max_key_type;\n\t\t}\n\t\tret = drop_objectid_items(trans, log, path, ino, max_key_type);\n\t} else {\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t/*\n\t\t\t * Make sure the new inode item we write to the log has\n\t\t\t * the same isize as the current one (if it exists).\n\t\t\t * This is necessary to prevent data loss after log\n\t\t\t * replay, and also to prevent doing a wrong expanding\n\t\t\t * truncate - for e.g. create file, write 4K into offset\n\t\t\t * 0, fsync, write 4K into offset 4096, add hard link,\n\t\t\t * fsync some other file (to sync log), power fail - if\n\t\t\t * we use the inode's current i_size, after log replay\n\t\t\t * we get a 8Kb file, with the last 4Kb extent as a hole\n\t\t\t * (zeroes), as if an expanding truncate happened,\n\t\t\t * instead of getting a file of 4Kb only.\n\t\t\t */\n\t\t\terr = logged_inode_size(log, inode, path,\n\t\t\t\t\t\t&logged_isize);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t\t  max_key.type);\n\t\t\t} else {\n\t\t\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tret = btrfs_truncate_inode_items(trans, log,\n\t\t\t\t\t\t\t\t inode, 0, 0);\n\t\t\t}\n\t\t} else if (test_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t    &BTRFS_I(inode)->runtime_flags) ||\n\t\t\t   inode_only == LOG_INODE_EXISTS) {\n\t\t\tif (inode_only == LOG_INODE_ALL) {\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tfast_search = true;\n\t\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\t} else {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t}\n\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t  max_key.type);\n\t\t} else {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tret = log_inode_item(trans, log, dst_path, inode);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tgoto log_extents;\n\t\t}\n\n\t}\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (1) {\n\t\tins_nr = 0;\n\t\tret = btrfs_search_forward(root, &min_key,\n\t\t\t\t\t   path, trans->transid);\n\t\tif (ret != 0)\n\t\t\tbreak;\nagain:\n\t\t/* note, ins_nr might be > 0 here, cleanup outside the loop */\n\t\tif (min_key.objectid != ino)\n\t\t\tbreak;\n\t\tif (min_key.type > max_key.type)\n\t\t\tbreak;\n\n\t\tsrc = path->nodes[0];\n\t\tif (ins_nr && ins_start_slot + ins_nr == path->slots[0]) {\n\t\t\tins_nr++;\n\t\t\tgoto next_slot;\n\t\t} else if (!ins_nr) {\n\t\t\tins_start_slot = path->slots[0];\n\t\t\tins_nr = 1;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (ret) {\n\t\t\tins_nr = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tins_nr = 1;\n\t\tins_start_slot = path->slots[0];\nnext_slot:\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < nritems) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &min_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ins_nr) {\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t &last_extent, ins_start_slot,\n\t\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tins_nr = 0;\n\t\t}\n\t\tbtrfs_release_path(path);\n\n\t\tif (min_key.offset < (u64)-1) {\n\t\t\tmin_key.offset++;\n\t\t} else if (min_key.type < max_key.type) {\n\t\t\tmin_key.type++;\n\t\t\tmin_key.offset = 0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ins_nr) {\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = 0;\n\t\tins_nr = 0;\n\t}\n\nlog_extents:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\tif (fast_search) {\n\t\t/*\n\t\t * Some ordered extents started by fsync might have completed\n\t\t * before we collected the ordered extents in logged_list, which\n\t\t * means they're gone, not in our logged_list nor in the inode's\n\t\t * ordered tree. We want the application/user space to know an\n\t\t * error happened while attempting to persist file data so that\n\t\t * it can take proper action. If such error happened, we leave\n\t\t * without writing to the log tree and the fsync must report the\n\t\t * file data write error and not commit the current transaction.\n\t\t */\n\t\terr = btrfs_inode_check_errors(inode);\n\t\tif (err) {\n\t\t\tctx->io_err = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = btrfs_log_changed_extents(trans, root, inode, dst_path,\n\t\t\t\t\t\t&logged_list, ctx);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (inode_only == LOG_INODE_ALL) {\n\t\tstruct extent_map *em, *n;\n\n\t\twrite_lock(&em_tree->lock);\n\t\t/*\n\t\t * We can't just remove every em if we're called for a ranged\n\t\t * fsync - that is, one that doesn't cover the whole possible\n\t\t * file range (0 to LLONG_MAX). This is because we can have\n\t\t * em's that fall outside the range we're logging and therefore\n\t\t * their ordered operations haven't completed yet\n\t\t * (btrfs_finish_ordered_io() not invoked yet). This means we\n\t\t * didn't get their respective file extent item in the fs/subvol\n\t\t * tree yet, and need to let the next fast fsync (one which\n\t\t * consults the list of modified extent maps) find the em so\n\t\t * that it logs a matching file extent item and waits for the\n\t\t * respective ordered operation to complete (if it's still\n\t\t * running).\n\t\t *\n\t\t * Removing every em outside the range we're logging would make\n\t\t * the next fast fsync not log their matching file extent items,\n\t\t * therefore making us lose data after a log replay.\n\t\t */\n\t\tlist_for_each_entry_safe(em, n, &em_tree->modified_extents,\n\t\t\t\t\t list) {\n\t\t\tconst u64 mod_end = em->mod_start + em->mod_len - 1;\n\n\t\t\tif (em->mod_start >= start && mod_end <= end)\n\t\t\t\tlist_del_init(&em->list);\n\t\t}\n\t\twrite_unlock(&em_tree->lock);\n\t}\n\n\tif (inode_only == LOG_INODE_ALL && S_ISDIR(inode->i_mode)) {\n\t\tret = log_directory_changes(trans, root, inode, path, dst_path);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->logged_trans = trans->transid;\n\tBTRFS_I(inode)->last_log_commit = BTRFS_I(inode)->last_sub_trans;\nout_unlock:\n\tif (unlikely(err))\n\t\tbtrfs_put_logged_extents(&logged_list);\n\telse\n\t\tbtrfs_submit_logged_extents(&logged_list, log);\n\tmutex_unlock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(dst_path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4473
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_log_trans",
          "args": [
            "trans",
            "root",
            "ctx"
          ],
          "line": 4431
        },
        "resolved": true,
        "details": {
          "function_name": "start_log_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "139-195",
          "snippet": "static int start_log_trans(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tint index;\n\tint ret;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!root->log_start_pid) {\n\t\t\troot->log_start_pid = current->pid;\n\t\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t} else if (root->log_start_pid != current->pid) {\n\t\t\tset_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t}\n\n\t\tatomic_inc(&root->log_batch);\n\t\tatomic_inc(&root->log_writers);\n\t\tif (ctx) {\n\t\t\tindex = root->log_transid % 2;\n\t\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\t\tctx->log_transid = root->log_transid;\n\t\t}\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\tif (!root->fs_info->log_root_tree)\n\t\tret = btrfs_init_log_root_tree(trans, root->fs_info);\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!root->log_root) {\n\t\tret = btrfs_add_log_tree(trans, root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\troot->log_start_pid = current->pid;\n\tatomic_inc(&root->log_batch);\n\tatomic_inc(&root->log_writers);\n\tif (ctx) {\n\t\tindex = root->log_transid % 2;\n\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\tctx->log_transid = root->log_transid;\n\t}\nout:\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic int start_log_trans(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tint index;\n\tint ret;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!root->log_start_pid) {\n\t\t\troot->log_start_pid = current->pid;\n\t\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t} else if (root->log_start_pid != current->pid) {\n\t\t\tset_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t}\n\n\t\tatomic_inc(&root->log_batch);\n\t\tatomic_inc(&root->log_writers);\n\t\tif (ctx) {\n\t\t\tindex = root->log_transid % 2;\n\t\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\t\tctx->log_transid = root->log_transid;\n\t\t}\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\tif (!root->fs_info->log_root_tree)\n\t\tret = btrfs_init_log_root_tree(trans, root->fs_info);\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!root->log_root) {\n\t\tret = btrfs_add_log_tree(trans, root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\troot->log_start_pid = current->pid;\n\tatomic_inc(&root->log_batch);\n\tatomic_inc(&root->log_writers);\n\tif (ctx) {\n\t\tindex = root->log_transid % 2;\n\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\tctx->log_transid = root->log_transid;\n\t}\nout:\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_in_log",
          "args": [
            "inode",
            "trans->transid"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_in_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "251-269",
          "snippet": "static inline int btrfs_inode_in_log(struct inode *inode, u64 generation)\n{\n\tif (BTRFS_I(inode)->logged_trans == generation &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->last_log_commit &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->root->last_log_commit) {\n\t\t/*\n\t\t * After a ranged fsync we might have left some extent maps\n\t\t * (that fall outside the fsync's range). So return false\n\t\t * here if the list isn't empty, to make sure btrfs_log_inode()\n\t\t * will be called and process those extent maps.\n\t\t */\n\t\tsmp_mb();\n\t\tif (list_empty(&BTRFS_I(inode)->extent_tree.modified_extents))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline int btrfs_inode_in_log(struct inode *inode, u64 generation)\n{\n\tif (BTRFS_I(inode)->logged_trans == generation &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->last_log_commit &&\n\t    BTRFS_I(inode)->last_sub_trans <=\n\t    BTRFS_I(inode)->root->last_log_commit) {\n\t\t/*\n\t\t * After a ranged fsync we might have left some extent maps\n\t\t * (that fall outside the fsync's range). So return false\n\t\t * here if the list isn't empty, to make sure btrfs_log_inode()\n\t\t * will be called and process those extent maps.\n\t\t */\n\t\tsmp_mb();\n\t\tif (list_empty(&BTRFS_I(inode)->extent_tree.modified_extents))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_parent_dirs_for_sync",
          "args": [
            "trans",
            "inode",
            "parent",
            "sb",
            "last_committed"
          ],
          "line": 4421
        },
        "resolved": true,
        "details": {
          "function_name": "check_parent_dirs_for_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "4307-4373",
          "snippet": "static noinline int check_parent_dirs_for_sync(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct inode *inode,\n\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t       u64 last_committed)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root;\n\tstruct dentry *old_parent = NULL;\n\tstruct inode *orig_inode = inode;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed)\n\t\t\tgoto out;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tgoto out;\n\t\tinode = parent->d_inode;\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * If we are logging a directory then we start with our inode,\n\t\t * not our parents inode, so we need to skipp setting the\n\t\t * logged_trans so that further down in the log code we don't\n\t\t * think this inode has already been logged.\n\t\t */\n\t\tif (inode != orig_inode)\n\t\t\tBTRFS_I(inode)->logged_trans = trans->transid;\n\t\tsmp_mb();\n\n\t\tif (BTRFS_I(inode)->last_unlink_trans > last_committed) {\n\t\t\troot = BTRFS_I(inode)->root;\n\n\t\t\t/*\n\t\t\t * make sure any commits to the log are forced\n\t\t\t * to be full commits\n\t\t\t */\n\t\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t\tinode = parent->d_inode;\n\n\t}\n\tdput(old_parent);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int check_parent_dirs_for_sync(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct inode *inode,\n\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t       u64 last_committed)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root;\n\tstruct dentry *old_parent = NULL;\n\tstruct inode *orig_inode = inode;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed)\n\t\t\tgoto out;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tgoto out;\n\t\tinode = parent->d_inode;\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * If we are logging a directory then we start with our inode,\n\t\t * not our parents inode, so we need to skipp setting the\n\t\t * logged_trans so that further down in the log code we don't\n\t\t * think this inode has already been logged.\n\t\t */\n\t\tif (inode != orig_inode)\n\t\t\tBTRFS_I(inode)->logged_trans = trans->transid;\n\t\tsmp_mb();\n\n\t\tif (BTRFS_I(inode)->last_unlink_trans > last_committed) {\n\t\t\troot = BTRFS_I(inode)->root;\n\n\t\t\t/*\n\t\t\t * make sure any commits to the log are forced\n\t\t\t * to be full commits\n\t\t\t */\n\t\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t\tinode = parent->d_inode;\n\n\t}\n\tdput(old_parent);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&root->root_item"
          ],
          "line": 4416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NOTREELOG"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_INODE_EXISTS 1\n#define LOG_INODE_ALL 0\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t    \t  struct btrfs_root *root, struct inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  const loff_t start,\n\t\t\t\t  const loff_t end,\n\t\t\t\t  int exists_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tint inode_only = exists_only ? LOG_INODE_EXISTS : LOG_INODE_ALL;\n\tstruct super_block *sb;\n\tstruct dentry *old_parent = NULL;\n\tint ret = 0;\n\tu64 last_committed = root->fs_info->last_trans_committed;\n\tconst struct dentry * const first_parent = parent;\n\tconst bool did_unlink = (BTRFS_I(inode)->last_unlink_trans >\n\t\t\t\t last_committed);\n\n\tsb = inode->i_sb;\n\n\tif (btrfs_test_opt(root, NOTREELOG)) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\t/*\n\t * The prev transaction commit doesn't complete, we need do\n\t * full commit by ourselves.\n\t */\n\tif (root->fs_info->last_trans_log_full_commit >\n\t    root->fs_info->last_trans_committed) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (root != BTRFS_I(inode)->root ||\n\t    btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = check_parent_dirs_for_sync(trans, inode, parent,\n\t\t\t\t\t sb, last_committed);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tif (btrfs_inode_in_log(inode, trans->transid)) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, root, inode, inode_only, start, end, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\twhile (1) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tinode = parent->d_inode;\n\t\tif (root != BTRFS_I(inode)->root)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * On unlink we must make sure our immediate parent directory\n\t\t * inode is fully logged. This is to prevent leaving dangling\n\t\t * directory index entries and a wrong directory inode's i_size.\n\t\t * Not doing so can result in a directory being impossible to\n\t\t * delete after log replay (rmdir will always fail with error\n\t\t * -ENOTEMPTY).\n\t\t */\n\t\tif (did_unlink && parent == first_parent)\n\t\t\tinode_only = LOG_INODE_ALL;\n\t\telse\n\t\t\tinode_only = LOG_INODE_EXISTS;\n\n\t\tif (BTRFS_I(inode)->generation >\n\t\t    root->fs_info->last_trans_committed ||\n\t\t    inode_only == LOG_INODE_ALL) {\n\t\t\tret = btrfs_log_inode(trans, root, inode, inode_only,\n\t\t\t\t\t      0, LLONG_MAX, ctx);\n\t\t\tif (ret)\n\t\t\t\tgoto end_trans;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tret = 0;\nend_trans:\n\tdput(old_parent);\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}"
  },
  {
    "function_name": "check_parent_dirs_for_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "4307-4373",
    "snippet": "static noinline int check_parent_dirs_for_sync(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct inode *inode,\n\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t       u64 last_committed)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root;\n\tstruct dentry *old_parent = NULL;\n\tstruct inode *orig_inode = inode;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed)\n\t\t\tgoto out;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tgoto out;\n\t\tinode = parent->d_inode;\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * If we are logging a directory then we start with our inode,\n\t\t * not our parents inode, so we need to skipp setting the\n\t\t * logged_trans so that further down in the log code we don't\n\t\t * think this inode has already been logged.\n\t\t */\n\t\tif (inode != orig_inode)\n\t\t\tBTRFS_I(inode)->logged_trans = trans->transid;\n\t\tsmp_mb();\n\n\t\tif (BTRFS_I(inode)->last_unlink_trans > last_committed) {\n\t\t\troot = BTRFS_I(inode)->root;\n\n\t\t\t/*\n\t\t\t * make sure any commits to the log are forced\n\t\t\t * to be full commits\n\t\t\t */\n\t\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t\tinode = parent->d_inode;\n\n\t}\n\tdput(old_parent);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "old_parent"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "parent"
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "parent"
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_log_full_commit",
          "args": [
            "root->fs_info",
            "trans"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_log_full_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "43-47",
          "snippet": "static inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4347
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int check_parent_dirs_for_sync(struct btrfs_trans_handle *trans,\n\t\t\t\t\t       struct inode *inode,\n\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t       struct super_block *sb,\n\t\t\t\t\t       u64 last_committed)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root;\n\tstruct dentry *old_parent = NULL;\n\tstruct inode *orig_inode = inode;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->i_mode) &&\n\t    BTRFS_I(inode)->generation <= last_committed &&\n\t    BTRFS_I(inode)->last_unlink_trans <= last_committed)\n\t\t\tgoto out;\n\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tgoto out;\n\t\tinode = parent->d_inode;\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * If we are logging a directory then we start with our inode,\n\t\t * not our parents inode, so we need to skipp setting the\n\t\t * logged_trans so that further down in the log code we don't\n\t\t * think this inode has already been logged.\n\t\t */\n\t\tif (inode != orig_inode)\n\t\t\tBTRFS_I(inode)->logged_trans = trans->transid;\n\t\tsmp_mb();\n\n\t\tif (BTRFS_I(inode)->last_unlink_trans > last_committed) {\n\t\t\troot = BTRFS_I(inode)->root;\n\n\t\t\t/*\n\t\t\t * make sure any commits to the log are forced\n\t\t\t * to be full commits\n\t\t\t */\n\t\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)\n\t\t\tbreak;\n\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t\tinode = parent->d_inode;\n\n\t}\n\tdput(old_parent);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_log_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3993-4299",
    "snippet": "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_path *dst_path;\n\tstruct btrfs_key min_key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src = NULL;\n\tLIST_HEAD(logged_list);\n\tu64 last_extent = 0;\n\tint err = 0;\n\tint ret;\n\tint nritems;\n\tint ins_start_slot = 0;\n\tint ins_nr;\n\tbool fast_search = false;\n\tu64 ino = btrfs_ino(inode);\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 logged_isize = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tdst_path = btrfs_alloc_path();\n\tif (!dst_path) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_INODE_ITEM_KEY;\n\tmin_key.offset = 0;\n\n\tmax_key.objectid = ino;\n\n\n\t/* today the code can only do partial logging of directories */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    (!test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t       &BTRFS_I(inode)->runtime_flags) &&\n\t     inode_only == LOG_INODE_EXISTS))\n\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\telse\n\t\tmax_key.type = (u8)-1;\n\tmax_key.offset = (u64)-1;\n\n\t/*\n\t * Only run delayed items if we are a dir or a new file.\n\t * Otherwise commit the delayed inode only, which is needed in\n\t * order for the log replay code to mark inodes for link count\n\t * fixup (create temporary BTRFS_TREE_LOG_FIXUP_OBJECTID items).\n\t */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    BTRFS_I(inode)->generation > root->fs_info->last_trans_committed)\n\t\tret = btrfs_commit_inode_delayed_items(trans, inode);\n\telse\n\t\tret = btrfs_commit_inode_delayed_inode(inode);\n\n\tif (ret) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_free_path(dst_path);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_get_logged_extents(inode, &logged_list, start, end);\n\n\t/*\n\t * a brute force approach to making sure we get the most uptodate\n\t * copies of everything.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tint max_key_type = BTRFS_DIR_LOG_INDEX_KEY;\n\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\tmax_key_type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tmax_key.type = max_key_type;\n\t\t}\n\t\tret = drop_objectid_items(trans, log, path, ino, max_key_type);\n\t} else {\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t/*\n\t\t\t * Make sure the new inode item we write to the log has\n\t\t\t * the same isize as the current one (if it exists).\n\t\t\t * This is necessary to prevent data loss after log\n\t\t\t * replay, and also to prevent doing a wrong expanding\n\t\t\t * truncate - for e.g. create file, write 4K into offset\n\t\t\t * 0, fsync, write 4K into offset 4096, add hard link,\n\t\t\t * fsync some other file (to sync log), power fail - if\n\t\t\t * we use the inode's current i_size, after log replay\n\t\t\t * we get a 8Kb file, with the last 4Kb extent as a hole\n\t\t\t * (zeroes), as if an expanding truncate happened,\n\t\t\t * instead of getting a file of 4Kb only.\n\t\t\t */\n\t\t\terr = logged_inode_size(log, inode, path,\n\t\t\t\t\t\t&logged_isize);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t\t  max_key.type);\n\t\t\t} else {\n\t\t\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tret = btrfs_truncate_inode_items(trans, log,\n\t\t\t\t\t\t\t\t inode, 0, 0);\n\t\t\t}\n\t\t} else if (test_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t    &BTRFS_I(inode)->runtime_flags) ||\n\t\t\t   inode_only == LOG_INODE_EXISTS) {\n\t\t\tif (inode_only == LOG_INODE_ALL) {\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tfast_search = true;\n\t\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\t} else {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t}\n\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t  max_key.type);\n\t\t} else {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tret = log_inode_item(trans, log, dst_path, inode);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tgoto log_extents;\n\t\t}\n\n\t}\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (1) {\n\t\tins_nr = 0;\n\t\tret = btrfs_search_forward(root, &min_key,\n\t\t\t\t\t   path, trans->transid);\n\t\tif (ret != 0)\n\t\t\tbreak;\nagain:\n\t\t/* note, ins_nr might be > 0 here, cleanup outside the loop */\n\t\tif (min_key.objectid != ino)\n\t\t\tbreak;\n\t\tif (min_key.type > max_key.type)\n\t\t\tbreak;\n\n\t\tsrc = path->nodes[0];\n\t\tif (ins_nr && ins_start_slot + ins_nr == path->slots[0]) {\n\t\t\tins_nr++;\n\t\t\tgoto next_slot;\n\t\t} else if (!ins_nr) {\n\t\t\tins_start_slot = path->slots[0];\n\t\t\tins_nr = 1;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (ret) {\n\t\t\tins_nr = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tins_nr = 1;\n\t\tins_start_slot = path->slots[0];\nnext_slot:\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < nritems) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &min_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ins_nr) {\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t &last_extent, ins_start_slot,\n\t\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tins_nr = 0;\n\t\t}\n\t\tbtrfs_release_path(path);\n\n\t\tif (min_key.offset < (u64)-1) {\n\t\t\tmin_key.offset++;\n\t\t} else if (min_key.type < max_key.type) {\n\t\t\tmin_key.type++;\n\t\t\tmin_key.offset = 0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ins_nr) {\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = 0;\n\t\tins_nr = 0;\n\t}\n\nlog_extents:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\tif (fast_search) {\n\t\t/*\n\t\t * Some ordered extents started by fsync might have completed\n\t\t * before we collected the ordered extents in logged_list, which\n\t\t * means they're gone, not in our logged_list nor in the inode's\n\t\t * ordered tree. We want the application/user space to know an\n\t\t * error happened while attempting to persist file data so that\n\t\t * it can take proper action. If such error happened, we leave\n\t\t * without writing to the log tree and the fsync must report the\n\t\t * file data write error and not commit the current transaction.\n\t\t */\n\t\terr = btrfs_inode_check_errors(inode);\n\t\tif (err) {\n\t\t\tctx->io_err = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = btrfs_log_changed_extents(trans, root, inode, dst_path,\n\t\t\t\t\t\t&logged_list, ctx);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (inode_only == LOG_INODE_ALL) {\n\t\tstruct extent_map *em, *n;\n\n\t\twrite_lock(&em_tree->lock);\n\t\t/*\n\t\t * We can't just remove every em if we're called for a ranged\n\t\t * fsync - that is, one that doesn't cover the whole possible\n\t\t * file range (0 to LLONG_MAX). This is because we can have\n\t\t * em's that fall outside the range we're logging and therefore\n\t\t * their ordered operations haven't completed yet\n\t\t * (btrfs_finish_ordered_io() not invoked yet). This means we\n\t\t * didn't get their respective file extent item in the fs/subvol\n\t\t * tree yet, and need to let the next fast fsync (one which\n\t\t * consults the list of modified extent maps) find the em so\n\t\t * that it logs a matching file extent item and waits for the\n\t\t * respective ordered operation to complete (if it's still\n\t\t * running).\n\t\t *\n\t\t * Removing every em outside the range we're logging would make\n\t\t * the next fast fsync not log their matching file extent items,\n\t\t * therefore making us lose data after a log replay.\n\t\t */\n\t\tlist_for_each_entry_safe(em, n, &em_tree->modified_extents,\n\t\t\t\t\t list) {\n\t\t\tconst u64 mod_end = em->mod_start + em->mod_len - 1;\n\n\t\t\tif (em->mod_start >= start && mod_end <= end)\n\t\t\t\tlist_del_init(&em->list);\n\t\t}\n\t\twrite_unlock(&em_tree->lock);\n\t}\n\n\tif (inode_only == LOG_INODE_ALL && S_ISDIR(inode->i_mode)) {\n\t\tret = log_directory_changes(trans, root, inode, path, dst_path);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->logged_trans = trans->transid;\n\tBTRFS_I(inode)->last_log_commit = BTRFS_I(inode)->last_sub_trans;\nout_unlock:\n\tif (unlikely(err))\n\t\tbtrfs_put_logged_extents(&logged_list);\n\telse\n\t\tbtrfs_submit_logged_extents(&logged_list, log);\n\tmutex_unlock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(dst_path);\n\treturn err;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define LOG_INODE_EXISTS 1",
      "#define LOG_INODE_ALL 0"
    ],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "dst_path"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&BTRFS_I(inode)->log_mutex"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_submit_logged_extents",
          "args": [
            "&logged_list",
            "log"
          ],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_submit_logged_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "476-484",
          "snippet": "void btrfs_submit_logged_extents(struct list_head *logged_list,\n\t\t\t\t struct btrfs_root *log)\n{\n\tint index = log->log_transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\tlist_splice_tail(logged_list, &log->logged_list[index]);\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_submit_logged_extents(struct list_head *logged_list,\n\t\t\t\t struct btrfs_root *log)\n{\n\tint index = log->log_transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\tlist_splice_tail(logged_list, &log->logged_list[index]);\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_logged_extents",
          "args": [
            "&logged_list"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_logged_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "463-474",
          "snippet": "void btrfs_put_logged_extents(struct list_head *logged_list)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\twhile (!list_empty(logged_list)) {\n\t\tordered = list_first_entry(logged_list,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_put_logged_extents(struct list_head *logged_list)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\n\twhile (!list_empty(logged_list)) {\n\t\tordered = list_first_entry(logged_list,\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 4290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_directory_changes",
          "args": [
            "trans",
            "root",
            "inode",
            "path",
            "dst_path"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "log_directory_changes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3175-3204",
          "snippet": "static noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\tint key_type = BTRFS_DIR_ITEM_KEY;\n\nagain:\n\tmin_key = 0;\n\tmax_key = 0;\n\twhile (1) {\n\t\tret = log_dir_items(trans, root, inode, path,\n\t\t\t\t    dst_path, key_type, min_key,\n\t\t\t\t    &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\tif (key_type == BTRFS_DIR_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_INDEX_KEY;\n\t\tgoto again;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\tint key_type = BTRFS_DIR_ITEM_KEY;\n\nagain:\n\tmin_key = 0;\n\tmax_key = 0;\n\twhile (1) {\n\t\tret = log_dir_items(trans, root, inode, path,\n\t\t\t\t    dst_path, key_type, min_key,\n\t\t\t\t    &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\tif (key_type == BTRFS_DIR_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_INDEX_KEY;\n\t\tgoto again;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4276
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&em->list"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "em",
            "n",
            "&em_tree->modified_extents",
            "list"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 4250
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_log_changed_extents",
          "args": [
            "trans",
            "root",
            "inode",
            "dst_path",
            "&logged_list",
            "ctx"
          ],
          "line": 4241
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_log_changed_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3876-3950",
          "snippet": "static int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct list_head *logged_list,\n\t\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct extent_map *em, *n;\n\tstruct list_head extents;\n\tstruct extent_map_tree *tree = &BTRFS_I(inode)->extent_tree;\n\tu64 test_gen;\n\tint ret = 0;\n\tint num = 0;\n\n\tINIT_LIST_HEAD(&extents);\n\n\twrite_lock(&tree->lock);\n\ttest_gen = root->fs_info->last_trans_committed;\n\n\tlist_for_each_entry_safe(em, n, &tree->modified_extents, list) {\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * Just an arbitrary number, this can be really CPU intensive\n\t\t * once we start getting a lot of extents, and really once we\n\t\t * have a bunch of extents we just want to commit since it will\n\t\t * be faster.\n\t\t */\n\t\tif (++num > 32768) {\n\t\t\tlist_del_init(&tree->modified_extents);\n\t\t\tret = -EFBIG;\n\t\t\tgoto process;\n\t\t}\n\n\t\tif (em->generation <= test_gen)\n\t\t\tcontinue;\n\t\t/* Need a ref to keep it from getting evicted from cache */\n\t\tatomic_inc(&em->refs);\n\t\tset_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\t\tlist_add_tail(&em->list, &extents);\n\t\tnum++;\n\t}\n\n\tlist_sort(NULL, &extents, extent_cmp);\n\nprocess:\n\twhile (!list_empty(&extents)) {\n\t\tem = list_entry(extents.next, struct extent_map, list);\n\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * If we had an error we just need to delete everybody from our\n\t\t * private list.\n\t\t */\n\t\tif (ret) {\n\t\t\tclear_em_logging(tree, em);\n\t\t\tfree_extent_map(em);\n\t\t\tcontinue;\n\t\t}\n\n\t\twrite_unlock(&tree->lock);\n\n\t\tret = log_one_extent(trans, inode, root, em, path, logged_list,\n\t\t\t\t     ctx);\n\t\twrite_lock(&tree->lock);\n\t\tclear_em_logging(tree, em);\n\t\tfree_extent_map(em);\n\t}\n\tWARN_ON(!list_empty(&extents));\n\twrite_unlock(&tree->lock);\n\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct list_head *logged_list,\n\t\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct extent_map *em, *n;\n\tstruct list_head extents;\n\tstruct extent_map_tree *tree = &BTRFS_I(inode)->extent_tree;\n\tu64 test_gen;\n\tint ret = 0;\n\tint num = 0;\n\n\tINIT_LIST_HEAD(&extents);\n\n\twrite_lock(&tree->lock);\n\ttest_gen = root->fs_info->last_trans_committed;\n\n\tlist_for_each_entry_safe(em, n, &tree->modified_extents, list) {\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * Just an arbitrary number, this can be really CPU intensive\n\t\t * once we start getting a lot of extents, and really once we\n\t\t * have a bunch of extents we just want to commit since it will\n\t\t * be faster.\n\t\t */\n\t\tif (++num > 32768) {\n\t\t\tlist_del_init(&tree->modified_extents);\n\t\t\tret = -EFBIG;\n\t\t\tgoto process;\n\t\t}\n\n\t\tif (em->generation <= test_gen)\n\t\t\tcontinue;\n\t\t/* Need a ref to keep it from getting evicted from cache */\n\t\tatomic_inc(&em->refs);\n\t\tset_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\t\tlist_add_tail(&em->list, &extents);\n\t\tnum++;\n\t}\n\n\tlist_sort(NULL, &extents, extent_cmp);\n\nprocess:\n\twhile (!list_empty(&extents)) {\n\t\tem = list_entry(extents.next, struct extent_map, list);\n\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * If we had an error we just need to delete everybody from our\n\t\t * private list.\n\t\t */\n\t\tif (ret) {\n\t\t\tclear_em_logging(tree, em);\n\t\t\tfree_extent_map(em);\n\t\t\tcontinue;\n\t\t}\n\n\t\twrite_unlock(&tree->lock);\n\n\t\tret = log_one_extent(trans, inode, root, em, path, logged_list,\n\t\t\t\t     ctx);\n\t\twrite_lock(&tree->lock);\n\t\tclear_em_logging(tree, em);\n\t\tfree_extent_map(em);\n\t}\n\tWARN_ON(!list_empty(&extents));\n\twrite_unlock(&tree->lock);\n\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_check_errors",
          "args": [
            "inode"
          ],
          "line": 4236
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_check_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9630-9642",
          "snippet": "int btrfs_inode_check_errors(struct inode *inode)\n{\n\tint ret = 0;\n\n\tif (test_bit(AS_ENOSPC, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &inode->i_mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &inode->i_mapping->flags))\n\t\tret = -EIO;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_inode_check_errors(struct inode *inode)\n{\n\tint ret = 0;\n\n\tif (test_bit(AS_ENOSPC, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &inode->i_mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &inode->i_mapping->flags))\n\t\tret = -EIO;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "dst_path"
          ],
          "line": 4224
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_items",
          "args": [
            "trans",
            "inode",
            "dst_path",
            "path",
            "&last_extent",
            "ins_start_slot",
            "ins_nr",
            "inode_only",
            "logged_isize"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "copy_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3337-3617",
          "snippet": "static noinline int copy_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct inode *inode,\n\t\t\t       struct btrfs_path *dst_path,\n\t\t\t       struct btrfs_path *src_path, u64 *last_extent,\n\t\t\t       int start_slot, int nr, int inode_only,\n\t\t\t       u64 logged_isize)\n{\n\tunsigned long src_offset;\n\tunsigned long dst_offset;\n\tstruct btrfs_root *log = BTRFS_I(inode)->root->log_root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *src = src_path->nodes[0];\n\tstruct btrfs_key first_key, last_key, key;\n\tint ret;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tchar *ins_data;\n\tint i;\n\tstruct list_head ordered_sums;\n\tint skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tbool has_extents = false;\n\tbool need_find_last_extent = true;\n\tbool done = false;\n\n\tINIT_LIST_HEAD(&ordered_sums);\n\n\tins_data = kmalloc(nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\n\tfirst_key.objectid = (u64)-1;\n\n\tins_sizes = (u32 *)ins_data;\n\tins_keys = (struct btrfs_key *)(ins_data + nr * sizeof(u32));\n\n\tfor (i = 0; i < nr; i++) {\n\t\tins_sizes[i] = btrfs_item_size_nr(src, i + start_slot);\n\t\tbtrfs_item_key_to_cpu(src, ins_keys + i, i + start_slot);\n\t}\n\tret = btrfs_insert_empty_items(trans, log, dst_path,\n\t\t\t\t       ins_keys, ins_sizes, nr);\n\tif (ret) {\n\t\tkfree(ins_data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr; i++, dst_path->slots[0]++) {\n\t\tdst_offset = btrfs_item_ptr_offset(dst_path->nodes[0],\n\t\t\t\t\t\t   dst_path->slots[0]);\n\n\t\tsrc_offset = btrfs_item_ptr_offset(src, start_slot + i);\n\n\t\tif ((i == (nr - 1)))\n\t\t\tlast_key = ins_keys[i];\n\n\t\tif (ins_keys[i].type == BTRFS_INODE_ITEM_KEY) {\n\t\t\tinode_item = btrfs_item_ptr(dst_path->nodes[0],\n\t\t\t\t\t\t    dst_path->slots[0],\n\t\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tfill_inode_item(trans, dst_path->nodes[0], inode_item,\n\t\t\t\t\tinode, inode_only == LOG_INODE_EXISTS,\n\t\t\t\t\tlogged_isize);\n\t\t} else {\n\t\t\tcopy_extent_buffer(dst_path->nodes[0], src, dst_offset,\n\t\t\t\t\t   src_offset, ins_sizes[i]);\n\t\t}\n\n\t\t/*\n\t\t * We set need_find_last_extent here in case we know we were\n\t\t * processing other items and then walk into the first extent in\n\t\t * the inode.  If we don't hit an extent then nothing changes,\n\t\t * we'll do the last search the next time around.\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\thas_extents = true;\n\t\t\tif (first_key.objectid == (u64)-1)\n\t\t\t\tfirst_key = ins_keys[i];\n\t\t} else {\n\t\t\tneed_find_last_extent = false;\n\t\t}\n\n\t\t/* take a reference on file data extents so that truncates\n\t\t * or deletes of this inode don't have to relog the inode\n\t\t * again\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY &&\n\t\t    !skip_csum) {\n\t\t\tint found_type;\n\t\t\textent = btrfs_item_ptr(src, start_slot + i,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\tif (btrfs_file_extent_generation(src, extent) < trans->transid)\n\t\t\t\tcontinue;\n\n\t\t\tfound_type = btrfs_file_extent_type(src, extent);\n\t\t\tif (found_type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t\tu64 ds, dl, cs, cl;\n\t\t\t\tds = btrfs_file_extent_disk_bytenr(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\t/* ds == 0 is a hole */\n\t\t\t\tif (ds == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdl = btrfs_file_extent_disk_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tcs = btrfs_file_extent_offset(src, extent);\n\t\t\t\tcl = btrfs_file_extent_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tif (btrfs_file_extent_compression(src,\n\t\t\t\t\t\t\t\t  extent)) {\n\t\t\t\t\tcs = 0;\n\t\t\t\t\tcl = dl;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_lookup_csums_range(\n\t\t\t\t\t\tlog->fs_info->csum_root,\n\t\t\t\t\t\tds + cs, ds + cs + cl - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_release_path(dst_path);\n\t\t\t\t\tkfree(ins_data);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbtrfs_mark_buffer_dirty(dst_path->nodes[0]);\n\tbtrfs_release_path(dst_path);\n\tkfree(ins_data);\n\n\t/*\n\t * we have to do this after the loop above to avoid changing the\n\t * log tree while trying to change the log tree.\n\t */\n\tret = 0;\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\tif (!has_extents)\n\t\treturn ret;\n\n\tif (need_find_last_extent && *last_extent == first_key.offset) {\n\t\t/*\n\t\t * We don't have any leafs between our current one and the one\n\t\t * we processed before that can have file extent items for our\n\t\t * inode (and have a generation number smaller than our current\n\t\t * transaction id).\n\t\t */\n\t\tneed_find_last_extent = false;\n\t}\n\n\t/*\n\t * Because we use btrfs_search_forward we could skip leaves that were\n\t * not modified and then assume *last_extent is valid when it really\n\t * isn't.  So back up to the previous leaf and read the end of the last\n\t * extent before we go and fill in holes.\n\t */\n\tif (need_find_last_extent) {\n\t\tu64 len;\n\n\t\tret = btrfs_prev_leaf(BTRFS_I(inode)->root, src_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\tgoto fill_holes;\n\t\tif (src_path->slots[0])\n\t\t\tsrc_path->slots[0]--;\n\t\tsrc = src_path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(src, &key, src_path->slots[0]);\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto fill_holes;\n\t\textent = btrfs_item_ptr(src, src_path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src,\n\t\t\t\t\t\t\t   src_path->slots[0],\n\t\t\t\t\t\t\t   extent);\n\t\t\t*last_extent = ALIGN(key.offset + len,\n\t\t\t\t\t     log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\t*last_extent = key.offset + len;\n\t\t}\n\t}\nfill_holes:\n\t/* So we did prev_leaf, now we need to move to the next leaf, but a few\n\t * things could have happened\n\t *\n\t * 1) A merge could have happened, so we could currently be on a leaf\n\t * that holds what we were copying in the first place.\n\t * 2) A split could have happened, and now not all of the items we want\n\t * are on the same leaf.\n\t *\n\t * So we need to adjust how we search for holes, we need to drop the\n\t * path and re-search for the first extent key we found, and then walk\n\t * forward until we hit the last one we copied.\n\t */\n\tif (need_find_last_extent) {\n\t\t/* btrfs_prev_leaf could return 1 without releasing the path */\n\t\tbtrfs_release_path(src_path);\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(inode)->root, &first_key,\n\t\t\t\t\tsrc_path, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tASSERT(ret == 0);\n\t\tsrc = src_path->nodes[0];\n\t\ti = src_path->slots[0];\n\t} else {\n\t\ti = start_slot;\n\t}\n\n\t/*\n\t * Ok so here we need to go through and fill in any holes we may have\n\t * to make sure that holes are punched for those areas in case they had\n\t * extents previously.\n\t */\n\twhile (!done) {\n\t\tu64 offset, len;\n\t\tu64 extent_end;\n\n\t\tif (i >= btrfs_header_nritems(src_path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(inode)->root, src_path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tASSERT(ret == 0);\n\t\t\tsrc = src_path->nodes[0];\n\t\t\ti = 0;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(src, &key, i);\n\t\tif (!btrfs_comp_cpu_keys(&key, &last_key))\n\t\t\tdone = true;\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\textent = btrfs_item_ptr(src, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src, i, extent);\n\t\t\textent_end = ALIGN(key.offset + len, log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\textent_end = key.offset + len;\n\t\t}\n\t\ti++;\n\n\t\tif (*last_extent == key.offset) {\n\t\t\t*last_extent = extent_end;\n\t\t\tcontinue;\n\t\t}\n\t\toffset = *last_extent;\n\t\tlen = key.offset - *last_extent;\n\t\tret = btrfs_insert_file_extent(trans, log, btrfs_ino(inode),\n\t\t\t\t\t       offset, 0, 0, len, 0, len, 0,\n\t\t\t\t\t       0, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t*last_extent = extent_end;\n\t}\n\t/*\n\t * Need to let the callers know we dropped the path so they should\n\t * re-search.\n\t */\n\tif (!ret && need_find_last_extent)\n\t\tret = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define LOG_INODE_EXISTS 1"
          ],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_INODE_EXISTS 1\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int copy_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct inode *inode,\n\t\t\t       struct btrfs_path *dst_path,\n\t\t\t       struct btrfs_path *src_path, u64 *last_extent,\n\t\t\t       int start_slot, int nr, int inode_only,\n\t\t\t       u64 logged_isize)\n{\n\tunsigned long src_offset;\n\tunsigned long dst_offset;\n\tstruct btrfs_root *log = BTRFS_I(inode)->root->log_root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *src = src_path->nodes[0];\n\tstruct btrfs_key first_key, last_key, key;\n\tint ret;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tchar *ins_data;\n\tint i;\n\tstruct list_head ordered_sums;\n\tint skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tbool has_extents = false;\n\tbool need_find_last_extent = true;\n\tbool done = false;\n\n\tINIT_LIST_HEAD(&ordered_sums);\n\n\tins_data = kmalloc(nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\n\tfirst_key.objectid = (u64)-1;\n\n\tins_sizes = (u32 *)ins_data;\n\tins_keys = (struct btrfs_key *)(ins_data + nr * sizeof(u32));\n\n\tfor (i = 0; i < nr; i++) {\n\t\tins_sizes[i] = btrfs_item_size_nr(src, i + start_slot);\n\t\tbtrfs_item_key_to_cpu(src, ins_keys + i, i + start_slot);\n\t}\n\tret = btrfs_insert_empty_items(trans, log, dst_path,\n\t\t\t\t       ins_keys, ins_sizes, nr);\n\tif (ret) {\n\t\tkfree(ins_data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr; i++, dst_path->slots[0]++) {\n\t\tdst_offset = btrfs_item_ptr_offset(dst_path->nodes[0],\n\t\t\t\t\t\t   dst_path->slots[0]);\n\n\t\tsrc_offset = btrfs_item_ptr_offset(src, start_slot + i);\n\n\t\tif ((i == (nr - 1)))\n\t\t\tlast_key = ins_keys[i];\n\n\t\tif (ins_keys[i].type == BTRFS_INODE_ITEM_KEY) {\n\t\t\tinode_item = btrfs_item_ptr(dst_path->nodes[0],\n\t\t\t\t\t\t    dst_path->slots[0],\n\t\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tfill_inode_item(trans, dst_path->nodes[0], inode_item,\n\t\t\t\t\tinode, inode_only == LOG_INODE_EXISTS,\n\t\t\t\t\tlogged_isize);\n\t\t} else {\n\t\t\tcopy_extent_buffer(dst_path->nodes[0], src, dst_offset,\n\t\t\t\t\t   src_offset, ins_sizes[i]);\n\t\t}\n\n\t\t/*\n\t\t * We set need_find_last_extent here in case we know we were\n\t\t * processing other items and then walk into the first extent in\n\t\t * the inode.  If we don't hit an extent then nothing changes,\n\t\t * we'll do the last search the next time around.\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\thas_extents = true;\n\t\t\tif (first_key.objectid == (u64)-1)\n\t\t\t\tfirst_key = ins_keys[i];\n\t\t} else {\n\t\t\tneed_find_last_extent = false;\n\t\t}\n\n\t\t/* take a reference on file data extents so that truncates\n\t\t * or deletes of this inode don't have to relog the inode\n\t\t * again\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY &&\n\t\t    !skip_csum) {\n\t\t\tint found_type;\n\t\t\textent = btrfs_item_ptr(src, start_slot + i,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\tif (btrfs_file_extent_generation(src, extent) < trans->transid)\n\t\t\t\tcontinue;\n\n\t\t\tfound_type = btrfs_file_extent_type(src, extent);\n\t\t\tif (found_type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t\tu64 ds, dl, cs, cl;\n\t\t\t\tds = btrfs_file_extent_disk_bytenr(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\t/* ds == 0 is a hole */\n\t\t\t\tif (ds == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdl = btrfs_file_extent_disk_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tcs = btrfs_file_extent_offset(src, extent);\n\t\t\t\tcl = btrfs_file_extent_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tif (btrfs_file_extent_compression(src,\n\t\t\t\t\t\t\t\t  extent)) {\n\t\t\t\t\tcs = 0;\n\t\t\t\t\tcl = dl;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_lookup_csums_range(\n\t\t\t\t\t\tlog->fs_info->csum_root,\n\t\t\t\t\t\tds + cs, ds + cs + cl - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_release_path(dst_path);\n\t\t\t\t\tkfree(ins_data);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbtrfs_mark_buffer_dirty(dst_path->nodes[0]);\n\tbtrfs_release_path(dst_path);\n\tkfree(ins_data);\n\n\t/*\n\t * we have to do this after the loop above to avoid changing the\n\t * log tree while trying to change the log tree.\n\t */\n\tret = 0;\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\tif (!has_extents)\n\t\treturn ret;\n\n\tif (need_find_last_extent && *last_extent == first_key.offset) {\n\t\t/*\n\t\t * We don't have any leafs between our current one and the one\n\t\t * we processed before that can have file extent items for our\n\t\t * inode (and have a generation number smaller than our current\n\t\t * transaction id).\n\t\t */\n\t\tneed_find_last_extent = false;\n\t}\n\n\t/*\n\t * Because we use btrfs_search_forward we could skip leaves that were\n\t * not modified and then assume *last_extent is valid when it really\n\t * isn't.  So back up to the previous leaf and read the end of the last\n\t * extent before we go and fill in holes.\n\t */\n\tif (need_find_last_extent) {\n\t\tu64 len;\n\n\t\tret = btrfs_prev_leaf(BTRFS_I(inode)->root, src_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\tgoto fill_holes;\n\t\tif (src_path->slots[0])\n\t\t\tsrc_path->slots[0]--;\n\t\tsrc = src_path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(src, &key, src_path->slots[0]);\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto fill_holes;\n\t\textent = btrfs_item_ptr(src, src_path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src,\n\t\t\t\t\t\t\t   src_path->slots[0],\n\t\t\t\t\t\t\t   extent);\n\t\t\t*last_extent = ALIGN(key.offset + len,\n\t\t\t\t\t     log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\t*last_extent = key.offset + len;\n\t\t}\n\t}\nfill_holes:\n\t/* So we did prev_leaf, now we need to move to the next leaf, but a few\n\t * things could have happened\n\t *\n\t * 1) A merge could have happened, so we could currently be on a leaf\n\t * that holds what we were copying in the first place.\n\t * 2) A split could have happened, and now not all of the items we want\n\t * are on the same leaf.\n\t *\n\t * So we need to adjust how we search for holes, we need to drop the\n\t * path and re-search for the first extent key we found, and then walk\n\t * forward until we hit the last one we copied.\n\t */\n\tif (need_find_last_extent) {\n\t\t/* btrfs_prev_leaf could return 1 without releasing the path */\n\t\tbtrfs_release_path(src_path);\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(inode)->root, &first_key,\n\t\t\t\t\tsrc_path, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tASSERT(ret == 0);\n\t\tsrc = src_path->nodes[0];\n\t\ti = src_path->slots[0];\n\t} else {\n\t\ti = start_slot;\n\t}\n\n\t/*\n\t * Ok so here we need to go through and fill in any holes we may have\n\t * to make sure that holes are punched for those areas in case they had\n\t * extents previously.\n\t */\n\twhile (!done) {\n\t\tu64 offset, len;\n\t\tu64 extent_end;\n\n\t\tif (i >= btrfs_header_nritems(src_path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(inode)->root, src_path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tASSERT(ret == 0);\n\t\t\tsrc = src_path->nodes[0];\n\t\t\ti = 0;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(src, &key, i);\n\t\tif (!btrfs_comp_cpu_keys(&key, &last_key))\n\t\t\tdone = true;\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\textent = btrfs_item_ptr(src, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src, i, extent);\n\t\t\textent_end = ALIGN(key.offset + len, log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\textent_end = key.offset + len;\n\t\t}\n\t\ti++;\n\n\t\tif (*last_extent == key.offset) {\n\t\t\t*last_extent = extent_end;\n\t\t\tcontinue;\n\t\t}\n\t\toffset = *last_extent;\n\t\tlen = key.offset - *last_extent;\n\t\tret = btrfs_insert_file_extent(trans, log, btrfs_ino(inode),\n\t\t\t\t\t       offset, 0, 0, len, 0, len, 0,\n\t\t\t\t\t       0, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t*last_extent = extent_end;\n\t}\n\t/*\n\t * Need to let the callers know we dropped the path so they should\n\t * re-search.\n\t */\n\tif (!ret && need_find_last_extent)\n\t\tret = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&min_key",
            "path->slots[0]"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_forward",
          "args": [
            "root",
            "&min_key",
            "path",
            "trans->transid"
          ],
          "line": 4144
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5113-5211",
          "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_inode_item",
          "args": [
            "trans",
            "log",
            "dst_path",
            "inode"
          ],
          "line": 4128
        },
        "resolved": true,
        "details": {
          "function_name": "log_inode_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3318-3335",
          "snippet": "static int log_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log, struct btrfs_path *path,\n\t\t\t  struct inode *inode)\n{\n\tstruct btrfs_inode_item *inode_item;\n\tint ret;\n\n\tret = btrfs_insert_empty_item(trans, log, path,\n\t\t\t\t      &BTRFS_I(inode)->location,\n\t\t\t\t      sizeof(*inode_item));\n\tif (ret && ret != -EEXIST)\n\t\treturn ret;\n\tinode_item = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tfill_inode_item(trans, path->nodes[0], inode_item, inode, 0, 0);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int log_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log, struct btrfs_path *path,\n\t\t\t  struct inode *inode)\n{\n\tstruct btrfs_inode_item *inode_item;\n\tint ret;\n\n\tret = btrfs_insert_empty_item(trans, log, path,\n\t\t\t\t      &BTRFS_I(inode)->location,\n\t\t\t\t      sizeof(*inode_item));\n\tif (ret && ret != -EEXIST)\n\t\treturn ret;\n\tinode_item = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tfill_inode_item(trans, path->nodes[0], inode_item, inode, 0, 0);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_objectid_items",
          "args": [
            "trans",
            "log",
            "path",
            "ino",
            "max_key.type"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "drop_objectid_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3212-3261",
          "snippet": "static int drop_objectid_items(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  u64 objectid, int max_key_type)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint start_slot;\n\n\tkey.objectid = objectid;\n\tkey.type = max_key_type;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, log, &key, path, -1, 1);\n\t\tBUG_ON(ret == 0); /* Logic error */\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0)\n\t\t\tbreak;\n\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\n\t\tif (found_key.objectid != objectid)\n\t\t\tbreak;\n\n\t\tfound_key.offset = 0;\n\t\tfound_key.type = 0;\n\t\tret = btrfs_bin_search(path->nodes[0], &found_key, 0,\n\t\t\t\t       &start_slot);\n\n\t\tret = btrfs_del_items(trans, log, path, start_slot,\n\t\t\t\t      path->slots[0] - start_slot + 1);\n\t\t/*\n\t\t * If start slot isn't 0 then we don't need to re-search, we've\n\t\t * found the last guy with the objectid in this tree.\n\t\t */\n\t\tif (ret || start_slot != 0)\n\t\t\tbreak;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int drop_objectid_items(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  u64 objectid, int max_key_type)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint start_slot;\n\n\tkey.objectid = objectid;\n\tkey.type = max_key_type;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, log, &key, path, -1, 1);\n\t\tBUG_ON(ret == 0); /* Logic error */\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0)\n\t\t\tbreak;\n\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\n\t\tif (found_key.objectid != objectid)\n\t\t\tbreak;\n\n\t\tfound_key.offset = 0;\n\t\tfound_key.type = 0;\n\t\tret = btrfs_bin_search(path->nodes[0], &found_key, 0,\n\t\t\t\t       &start_slot);\n\n\t\tret = btrfs_del_items(trans, log, path, start_slot,\n\t\t\t\t      path->slots[0] - start_slot + 1);\n\t\t/*\n\t\t * If start slot isn't 0 then we don't need to re-search, we've\n\t\t * found the last guy with the objectid in this tree.\n\t\t */\n\t\tif (ret || start_slot != 0)\n\t\t\tbreak;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_INODE_COPY_EVERYTHING",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_INODE_COPY_EVERYTHING",
            "&BTRFS_I(inode)->runtime_flags"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_inode_items",
          "args": [
            "trans",
            "log",
            "inode",
            "0",
            "0"
          ],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_inode_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "4176-4420",
          "snippet": "int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct inode *inode,\n\t\t\t       u64 new_size, u32 min_type)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 extent_start = 0;\n\tu64 extent_num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 item_end = 0;\n\tu64 last_size = (u64)-1;\n\tu32 found_type = (u8)-1;\n\tint found_extent;\n\tint del_item;\n\tint pending_del_nr = 0;\n\tint pending_del_slot = 0;\n\tint extent_type = -1;\n\tint ret;\n\tint err = 0;\n\tu64 ino = btrfs_ino(inode);\n\n\tBUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\t/*\n\t * We want to drop from the next block forward in case this new size is\n\t * not block aligned since we will be keeping the last block of the\n\t * extent just the way it is.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root == root->fs_info->tree_root)\n\t\tbtrfs_drop_extent_cache(inode, ALIGN(new_size,\n\t\t\t\t\troot->sectorsize), (u64)-1, 0);\n\n\t/*\n\t * This function is also used to drop the items in the log tree before\n\t * we relog the inode, so if root != BTRFS_I(inode)->root, it means\n\t * it is used to drop the loged items. So we shouldn't kill the delayed\n\t * items.\n\t */\n\tif (min_type == 0 && root == BTRFS_I(inode)->root)\n\t\tbtrfs_kill_delayed_inode_items(inode);\n\n\tkey.objectid = ino;\n\tkey.offset = (u64)-1;\n\tkey.type = (u8)-1;\n\nsearch_again:\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tif (ret > 0) {\n\t\t/* there are no items in the tree for us to truncate, we're\n\t\t * done\n\t\t */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (1) {\n\t\tfi = NULL;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tfound_type = found_key.type;\n\n\t\tif (found_key.objectid != ino)\n\t\t\tbreak;\n\n\t\tif (found_type < min_type)\n\t\t\tbreak;\n\n\t\titem_end = found_key.offset;\n\t\tif (found_type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end +=\n\t\t\t\t    btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end += btrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t\t path->slots[0], fi);\n\t\t\t}\n\t\t\titem_end--;\n\t\t}\n\t\tif (found_type > min_type) {\n\t\t\tdel_item = 1;\n\t\t} else {\n\t\t\tif (item_end < new_size)\n\t\t\t\tbreak;\n\t\t\tif (found_key.offset >= new_size)\n\t\t\t\tdel_item = 1;\n\t\t\telse\n\t\t\t\tdel_item = 0;\n\t\t}\n\t\tfound_extent = 0;\n\t\t/* FIXME, shrink the extent if the ref count is only 1 */\n\t\tif (found_type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto delete;\n\n\t\tif (del_item)\n\t\t\tlast_size = found_key.offset;\n\t\telse\n\t\t\tlast_size = new_size;\n\n\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tu64 num_dec;\n\t\t\textent_start = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tif (!del_item) {\n\t\t\t\tu64 orig_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\textent_num_bytes = ALIGN(new_size -\n\t\t\t\t\t\tfound_key.offset,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\t extent_num_bytes);\n\t\t\t\tnum_dec = (orig_num_bytes -\n\t\t\t\t\t   extent_num_bytes);\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t     &root->state) &&\n\t\t\t\t    extent_start != 0)\n\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t} else {\n\t\t\t\textent_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t\t fi);\n\t\t\t\textent_offset = found_key.offset -\n\t\t\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\n\t\t\t\t/* FIXME blocksize != 4096 */\n\t\t\t\tnum_dec = btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tif (extent_start != 0) {\n\t\t\t\t\tfound_extent = 1;\n\t\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t\t     &root->state))\n\t\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t/*\n\t\t\t * we can't truncate inline items that have had\n\t\t\t * special encodings\n\t\t\t */\n\t\t\tif (!del_item &&\n\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0) {\n\t\t\t\tu32 size = new_size - found_key.offset;\n\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\t\tnew_size);\n\n\t\t\t\t/*\n\t\t\t\t * update the ram bytes to properly reflect\n\t\t\t\t * the new size of our item\n\t\t\t\t */\n\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\t\t\t\tsize =\n\t\t\t\t    btrfs_file_extent_calc_inline_size(size);\n\t\t\t\tbtrfs_truncate_item(root, path, size, 1);\n\t\t\t} else if (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t    &root->state)) {\n\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\tfound_key.offset);\n\t\t\t}\n\t\t}\ndelete:\n\t\tif (del_item) {\n\t\t\tif (!pending_del_nr) {\n\t\t\t\t/* no pending yet, add ourselves */\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t\tpending_del_nr = 1;\n\t\t\t} else if (pending_del_nr &&\n\t\t\t\t   path->slots[0] + 1 == pending_del_slot) {\n\t\t\t\t/* hop on the pending chunk */\n\t\t\t\tpending_del_nr++;\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tif (found_extent &&\n\t\t    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t     root == root->fs_info->tree_root)) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_free_extent(trans, root, extent_start,\n\t\t\t\t\t\textent_num_bytes, 0,\n\t\t\t\t\t\tbtrfs_header_owner(leaf),\n\t\t\t\t\t\tino, extent_offset, 0);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_type == BTRFS_INODE_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0 ||\n\t\t    path->slots[0] != pending_del_slot) {\n\t\t\tif (pending_del_nr) {\n\t\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\tpending_del_slot,\n\t\t\t\t\t\tpending_del_nr);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tpending_del_nr = 0;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto search_again;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t}\nout:\n\tif (pending_del_nr) {\n\t\tret = btrfs_del_items(trans, root, path, pending_del_slot,\n\t\t\t\t      pending_del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\nerror:\n\tif (last_size != (u64)-1 &&\n\t    root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\tbtrfs_ordered_update_i_size(inode, last_size, NULL);\n\tbtrfs_free_path(path);\n\treturn err;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct inode *inode,\n\t\t\t       u64 new_size, u32 min_type)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 extent_start = 0;\n\tu64 extent_num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 item_end = 0;\n\tu64 last_size = (u64)-1;\n\tu32 found_type = (u8)-1;\n\tint found_extent;\n\tint del_item;\n\tint pending_del_nr = 0;\n\tint pending_del_slot = 0;\n\tint extent_type = -1;\n\tint ret;\n\tint err = 0;\n\tu64 ino = btrfs_ino(inode);\n\n\tBUG_ON(new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\t/*\n\t * We want to drop from the next block forward in case this new size is\n\t * not block aligned since we will be keeping the last block of the\n\t * extent just the way it is.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t    root == root->fs_info->tree_root)\n\t\tbtrfs_drop_extent_cache(inode, ALIGN(new_size,\n\t\t\t\t\troot->sectorsize), (u64)-1, 0);\n\n\t/*\n\t * This function is also used to drop the items in the log tree before\n\t * we relog the inode, so if root != BTRFS_I(inode)->root, it means\n\t * it is used to drop the loged items. So we shouldn't kill the delayed\n\t * items.\n\t */\n\tif (min_type == 0 && root == BTRFS_I(inode)->root)\n\t\tbtrfs_kill_delayed_inode_items(inode);\n\n\tkey.objectid = ino;\n\tkey.offset = (u64)-1;\n\tkey.type = (u8)-1;\n\nsearch_again:\n\tpath->leave_spinning = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tif (ret > 0) {\n\t\t/* there are no items in the tree for us to truncate, we're\n\t\t * done\n\t\t */\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\n\twhile (1) {\n\t\tfi = NULL;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tfound_type = found_key.type;\n\n\t\tif (found_key.objectid != ino)\n\t\t\tbreak;\n\n\t\tif (found_type < min_type)\n\t\t\tbreak;\n\n\t\titem_end = found_key.offset;\n\t\tif (found_type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\t\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end +=\n\t\t\t\t    btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\titem_end += btrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t\t path->slots[0], fi);\n\t\t\t}\n\t\t\titem_end--;\n\t\t}\n\t\tif (found_type > min_type) {\n\t\t\tdel_item = 1;\n\t\t} else {\n\t\t\tif (item_end < new_size)\n\t\t\t\tbreak;\n\t\t\tif (found_key.offset >= new_size)\n\t\t\t\tdel_item = 1;\n\t\t\telse\n\t\t\t\tdel_item = 0;\n\t\t}\n\t\tfound_extent = 0;\n\t\t/* FIXME, shrink the extent if the ref count is only 1 */\n\t\tif (found_type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto delete;\n\n\t\tif (del_item)\n\t\t\tlast_size = found_key.offset;\n\t\telse\n\t\t\tlast_size = new_size;\n\n\t\tif (extent_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tu64 num_dec;\n\t\t\textent_start = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tif (!del_item) {\n\t\t\t\tu64 orig_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\textent_num_bytes = ALIGN(new_size -\n\t\t\t\t\t\tfound_key.offset,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\t extent_num_bytes);\n\t\t\t\tnum_dec = (orig_num_bytes -\n\t\t\t\t\t   extent_num_bytes);\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t     &root->state) &&\n\t\t\t\t    extent_start != 0)\n\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t} else {\n\t\t\t\textent_num_bytes =\n\t\t\t\t\tbtrfs_file_extent_disk_num_bytes(leaf,\n\t\t\t\t\t\t\t\t\t fi);\n\t\t\t\textent_offset = found_key.offset -\n\t\t\t\t\tbtrfs_file_extent_offset(leaf, fi);\n\n\t\t\t\t/* FIXME blocksize != 4096 */\n\t\t\t\tnum_dec = btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tif (extent_start != 0) {\n\t\t\t\t\tfound_extent = 1;\n\t\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t\t     &root->state))\n\t\t\t\t\t\tinode_sub_bytes(inode, num_dec);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t/*\n\t\t\t * we can't truncate inline items that have had\n\t\t\t * special encodings\n\t\t\t */\n\t\t\tif (!del_item &&\n\t\t\t    btrfs_file_extent_compression(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_encryption(leaf, fi) == 0 &&\n\t\t\t    btrfs_file_extent_other_encoding(leaf, fi) == 0) {\n\t\t\t\tu32 size = new_size - found_key.offset;\n\n\t\t\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\t\tnew_size);\n\n\t\t\t\t/*\n\t\t\t\t * update the ram bytes to properly reflect\n\t\t\t\t * the new size of our item\n\t\t\t\t */\n\t\t\t\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\t\t\t\tsize =\n\t\t\t\t    btrfs_file_extent_calc_inline_size(size);\n\t\t\t\tbtrfs_truncate_item(root, path, size, 1);\n\t\t\t} else if (test_bit(BTRFS_ROOT_REF_COWS,\n\t\t\t\t\t    &root->state)) {\n\t\t\t\tinode_sub_bytes(inode, item_end + 1 -\n\t\t\t\t\t\tfound_key.offset);\n\t\t\t}\n\t\t}\ndelete:\n\t\tif (del_item) {\n\t\t\tif (!pending_del_nr) {\n\t\t\t\t/* no pending yet, add ourselves */\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t\tpending_del_nr = 1;\n\t\t\t} else if (pending_del_nr &&\n\t\t\t\t   path->slots[0] + 1 == pending_del_slot) {\n\t\t\t\t/* hop on the pending chunk */\n\t\t\t\tpending_del_nr++;\n\t\t\t\tpending_del_slot = path->slots[0];\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tif (found_extent &&\n\t\t    (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t     root == root->fs_info->tree_root)) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_free_extent(trans, root, extent_start,\n\t\t\t\t\t\textent_num_bytes, 0,\n\t\t\t\t\t\tbtrfs_header_owner(leaf),\n\t\t\t\t\t\tino, extent_offset, 0);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tif (found_type == BTRFS_INODE_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0 ||\n\t\t    path->slots[0] != pending_del_slot) {\n\t\t\tif (pending_del_nr) {\n\t\t\t\tret = btrfs_del_items(trans, root, path,\n\t\t\t\t\t\tpending_del_slot,\n\t\t\t\t\t\tpending_del_nr);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_abort_transaction(trans,\n\t\t\t\t\t\t\t\troot, ret);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tpending_del_nr = 0;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto search_again;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t}\nout:\n\tif (pending_del_nr) {\n\t\tret = btrfs_del_items(trans, root, path, pending_del_slot,\n\t\t\t\t      pending_del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\nerror:\n\tif (last_size != (u64)-1 &&\n\t    root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\tbtrfs_ordered_update_i_size(inode, last_size, NULL);\n\tbtrfs_free_path(path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logged_inode_size",
          "args": [
            "log",
            "inode",
            "path",
            "&logged_isize"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "logged_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3952-3977",
          "snippet": "static int logged_inode_size(struct btrfs_root *log, struct inode *inode,\n\t\t\t     struct btrfs_path *path, u64 *size_ret)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, log, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t*size_ret = i_size_read(inode);\n\t} else {\n\t\tstruct btrfs_inode_item *item;\n\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_item);\n\t\t*size_ret = btrfs_inode_size(path->nodes[0], item);\n\t}\n\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int logged_inode_size(struct btrfs_root *log, struct inode *inode,\n\t\t\t     struct btrfs_path *path, u64 *size_ret)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, log, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t*size_ret = i_size_read(inode);\n\t} else {\n\t\tstruct btrfs_inode_item *item;\n\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_item);\n\t\t*size_ret = btrfs_inode_size(path->nodes[0], item);\n\t}\n\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_logged_extents",
          "args": [
            "inode",
            "&logged_list",
            "start",
            "end"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_logged_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "434-461",
          "snippet": "void btrfs_get_logged_extents(struct inode *inode,\n\t\t\t      struct list_head *logged_list,\n\t\t\t      const loff_t start,\n\t\t\t      const loff_t end)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct rb_node *n;\n\tstruct rb_node *prev;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tn = __tree_search(&tree->tree, end, &prev);\n\tif (!n)\n\t\tn = prev;\n\tfor (; n; n = rb_prev(n)) {\n\t\tordered = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tif (ordered->file_offset > end)\n\t\t\tcontinue;\n\t\tif (entry_end(ordered) <= start)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED, &ordered->flags))\n\t\t\tcontinue;\n\t\tlist_add(&ordered->log_list, logged_list);\n\t\tatomic_inc(&ordered->refs);\n\t}\n\tspin_unlock_irq(&tree->lock);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_get_logged_extents(struct inode *inode,\n\t\t\t      struct list_head *logged_list,\n\t\t\t      const loff_t start,\n\t\t\t      const loff_t end)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct rb_node *n;\n\tstruct rb_node *prev;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tn = __tree_search(&tree->tree, end, &prev);\n\tif (!n)\n\t\tn = prev;\n\tfor (; n; n = rb_prev(n)) {\n\t\tordered = rb_entry(n, struct btrfs_ordered_extent, rb_node);\n\t\tif (ordered->file_offset > end)\n\t\t\tcontinue;\n\t\tif (entry_end(ordered) <= start)\n\t\t\tbreak;\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED, &ordered->flags))\n\t\t\tcontinue;\n\t\tlist_add(&ordered->log_list, logged_list);\n\t\tatomic_inc(&ordered->refs);\n\t}\n\tspin_unlock_irq(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&BTRFS_I(inode)->log_mutex"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_inode_delayed_inode",
          "args": [
            "inode"
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_inode_delayed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1255-1307",
          "snippet": "int btrfs_commit_inode_delayed_inode(struct inode *inode)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\ttrans = btrfs_join_transaction(delayed_node->root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto trans_out;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags))\n\t\tret = __btrfs_update_delayed_inode(trans, delayed_node->root,\n\t\t\t\t\t\t   path, delayed_node);\n\telse\n\t\tret = 0;\n\tmutex_unlock(&delayed_node->mutex);\n\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\ntrans_out:\n\tbtrfs_end_transaction(trans, delayed_node->root);\n\tbtrfs_btree_balance_dirty(delayed_node->root);\nout:\n\tbtrfs_release_delayed_node(delayed_node);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_commit_inode_delayed_inode(struct inode *inode)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags)) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\ttrans = btrfs_join_transaction(delayed_node->root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto trans_out;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (test_bit(BTRFS_DELAYED_NODE_INODE_DIRTY, &delayed_node->flags))\n\t\tret = __btrfs_update_delayed_inode(trans, delayed_node->root,\n\t\t\t\t\t\t   path, delayed_node);\n\telse\n\t\tret = 0;\n\tmutex_unlock(&delayed_node->mutex);\n\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\ntrans_out:\n\tbtrfs_end_transaction(trans, delayed_node->root);\n\tbtrfs_btree_balance_dirty(delayed_node->root);\nout:\n\tbtrfs_release_delayed_node(delayed_node);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_inode_delayed_items",
          "args": [
            "trans",
            "inode"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_inode_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1217-1253",
          "snippet": "int btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!delayed_node->count) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tret = __btrfs_commit_inode_delayed_items(trans, path, delayed_node);\n\n\tbtrfs_release_delayed_node(delayed_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_commit_inode_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode)\n{\n\tstruct btrfs_delayed_node *delayed_node = btrfs_get_delayed_node(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_rsv *block_rsv;\n\tint ret;\n\n\tif (!delayed_node)\n\t\treturn 0;\n\n\tmutex_lock(&delayed_node->mutex);\n\tif (!delayed_node->count) {\n\t\tmutex_unlock(&delayed_node->mutex);\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&delayed_node->mutex);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tbtrfs_release_delayed_node(delayed_node);\n\t\treturn -ENOMEM;\n\t}\n\tpath->leave_spinning = 1;\n\n\tblock_rsv = trans->block_rsv;\n\ttrans->block_rsv = &delayed_node->root->fs_info->delayed_block_rsv;\n\n\tret = __btrfs_commit_inode_delayed_items(trans, path, delayed_node);\n\n\tbtrfs_release_delayed_node(delayed_node);\n\tbtrfs_free_path(path);\n\ttrans->block_rsv = block_rsv;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "logged_list"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_INODE_EXISTS 1\n#define LOG_INODE_ALL 0\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_path *dst_path;\n\tstruct btrfs_key min_key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src = NULL;\n\tLIST_HEAD(logged_list);\n\tu64 last_extent = 0;\n\tint err = 0;\n\tint ret;\n\tint nritems;\n\tint ins_start_slot = 0;\n\tint ins_nr;\n\tbool fast_search = false;\n\tu64 ino = btrfs_ino(inode);\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 logged_isize = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tdst_path = btrfs_alloc_path();\n\tif (!dst_path) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_INODE_ITEM_KEY;\n\tmin_key.offset = 0;\n\n\tmax_key.objectid = ino;\n\n\n\t/* today the code can only do partial logging of directories */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    (!test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t       &BTRFS_I(inode)->runtime_flags) &&\n\t     inode_only == LOG_INODE_EXISTS))\n\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\telse\n\t\tmax_key.type = (u8)-1;\n\tmax_key.offset = (u64)-1;\n\n\t/*\n\t * Only run delayed items if we are a dir or a new file.\n\t * Otherwise commit the delayed inode only, which is needed in\n\t * order for the log replay code to mark inodes for link count\n\t * fixup (create temporary BTRFS_TREE_LOG_FIXUP_OBJECTID items).\n\t */\n\tif (S_ISDIR(inode->i_mode) ||\n\t    BTRFS_I(inode)->generation > root->fs_info->last_trans_committed)\n\t\tret = btrfs_commit_inode_delayed_items(trans, inode);\n\telse\n\t\tret = btrfs_commit_inode_delayed_inode(inode);\n\n\tif (ret) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_free_path(dst_path);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_get_logged_extents(inode, &logged_list, start, end);\n\n\t/*\n\t * a brute force approach to making sure we get the most uptodate\n\t * copies of everything.\n\t */\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tint max_key_type = BTRFS_DIR_LOG_INDEX_KEY;\n\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\tmax_key_type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tmax_key.type = max_key_type;\n\t\t}\n\t\tret = drop_objectid_items(trans, log, path, ino, max_key_type);\n\t} else {\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t/*\n\t\t\t * Make sure the new inode item we write to the log has\n\t\t\t * the same isize as the current one (if it exists).\n\t\t\t * This is necessary to prevent data loss after log\n\t\t\t * replay, and also to prevent doing a wrong expanding\n\t\t\t * truncate - for e.g. create file, write 4K into offset\n\t\t\t * 0, fsync, write 4K into offset 4096, add hard link,\n\t\t\t * fsync some other file (to sync log), power fail - if\n\t\t\t * we use the inode's current i_size, after log replay\n\t\t\t * we get a 8Kb file, with the last 4Kb extent as a hole\n\t\t\t * (zeroes), as if an expanding truncate happened,\n\t\t\t * instead of getting a file of 4Kb only.\n\t\t\t */\n\t\t\terr = logged_inode_size(log, inode, path,\n\t\t\t\t\t\t&logged_isize);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &BTRFS_I(inode)->runtime_flags)) {\n\t\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t\t  max_key.type);\n\t\t\t} else {\n\t\t\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tret = btrfs_truncate_inode_items(trans, log,\n\t\t\t\t\t\t\t\t inode, 0, 0);\n\t\t\t}\n\t\t} else if (test_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t    &BTRFS_I(inode)->runtime_flags) ||\n\t\t\t   inode_only == LOG_INODE_EXISTS) {\n\t\t\tif (inode_only == LOG_INODE_ALL) {\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tfast_search = true;\n\t\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\t} else {\n\t\t\t\tmax_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\t}\n\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t  max_key.type);\n\t\t} else {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tret = log_inode_item(trans, log, dst_path, inode);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tgoto log_extents;\n\t\t}\n\n\t}\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (1) {\n\t\tins_nr = 0;\n\t\tret = btrfs_search_forward(root, &min_key,\n\t\t\t\t\t   path, trans->transid);\n\t\tif (ret != 0)\n\t\t\tbreak;\nagain:\n\t\t/* note, ins_nr might be > 0 here, cleanup outside the loop */\n\t\tif (min_key.objectid != ino)\n\t\t\tbreak;\n\t\tif (min_key.type > max_key.type)\n\t\t\tbreak;\n\n\t\tsrc = path->nodes[0];\n\t\tif (ins_nr && ins_start_slot + ins_nr == path->slots[0]) {\n\t\t\tins_nr++;\n\t\t\tgoto next_slot;\n\t\t} else if (!ins_nr) {\n\t\t\tins_start_slot = path->slots[0];\n\t\t\tins_nr = 1;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (ret) {\n\t\t\tins_nr = 0;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tins_nr = 1;\n\t\tins_start_slot = path->slots[0];\nnext_slot:\n\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < nritems) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &min_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ins_nr) {\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t &last_extent, ins_start_slot,\n\t\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tret = 0;\n\t\t\tins_nr = 0;\n\t\t}\n\t\tbtrfs_release_path(path);\n\n\t\tif (min_key.offset < (u64)-1) {\n\t\t\tmin_key.offset++;\n\t\t} else if (min_key.type < max_key.type) {\n\t\t\tmin_key.type++;\n\t\t\tmin_key.offset = 0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ins_nr) {\n\t\tret = copy_items(trans, inode, dst_path, path, &last_extent,\n\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t logged_isize);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = 0;\n\t\tins_nr = 0;\n\t}\n\nlog_extents:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\tif (fast_search) {\n\t\t/*\n\t\t * Some ordered extents started by fsync might have completed\n\t\t * before we collected the ordered extents in logged_list, which\n\t\t * means they're gone, not in our logged_list nor in the inode's\n\t\t * ordered tree. We want the application/user space to know an\n\t\t * error happened while attempting to persist file data so that\n\t\t * it can take proper action. If such error happened, we leave\n\t\t * without writing to the log tree and the fsync must report the\n\t\t * file data write error and not commit the current transaction.\n\t\t */\n\t\terr = btrfs_inode_check_errors(inode);\n\t\tif (err) {\n\t\t\tctx->io_err = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = btrfs_log_changed_extents(trans, root, inode, dst_path,\n\t\t\t\t\t\t&logged_list, ctx);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (inode_only == LOG_INODE_ALL) {\n\t\tstruct extent_map *em, *n;\n\n\t\twrite_lock(&em_tree->lock);\n\t\t/*\n\t\t * We can't just remove every em if we're called for a ranged\n\t\t * fsync - that is, one that doesn't cover the whole possible\n\t\t * file range (0 to LLONG_MAX). This is because we can have\n\t\t * em's that fall outside the range we're logging and therefore\n\t\t * their ordered operations haven't completed yet\n\t\t * (btrfs_finish_ordered_io() not invoked yet). This means we\n\t\t * didn't get their respective file extent item in the fs/subvol\n\t\t * tree yet, and need to let the next fast fsync (one which\n\t\t * consults the list of modified extent maps) find the em so\n\t\t * that it logs a matching file extent item and waits for the\n\t\t * respective ordered operation to complete (if it's still\n\t\t * running).\n\t\t *\n\t\t * Removing every em outside the range we're logging would make\n\t\t * the next fast fsync not log their matching file extent items,\n\t\t * therefore making us lose data after a log replay.\n\t\t */\n\t\tlist_for_each_entry_safe(em, n, &em_tree->modified_extents,\n\t\t\t\t\t list) {\n\t\t\tconst u64 mod_end = em->mod_start + em->mod_len - 1;\n\n\t\t\tif (em->mod_start >= start && mod_end <= end)\n\t\t\t\tlist_del_init(&em->list);\n\t\t}\n\t\twrite_unlock(&em_tree->lock);\n\t}\n\n\tif (inode_only == LOG_INODE_ALL && S_ISDIR(inode->i_mode)) {\n\t\tret = log_directory_changes(trans, root, inode, path, dst_path);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tBTRFS_I(inode)->logged_trans = trans->transid;\n\tBTRFS_I(inode)->last_log_commit = BTRFS_I(inode)->last_sub_trans;\nout_unlock:\n\tif (unlikely(err))\n\t\tbtrfs_put_logged_extents(&logged_list);\n\telse\n\t\tbtrfs_submit_logged_extents(&logged_list, log);\n\tmutex_unlock(&BTRFS_I(inode)->log_mutex);\n\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(dst_path);\n\treturn err;\n}"
  },
  {
    "function_name": "logged_inode_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3952-3977",
    "snippet": "static int logged_inode_size(struct btrfs_root *log, struct inode *inode,\n\t\t\t     struct btrfs_path *path, u64 *size_ret)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, log, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t*size_ret = i_size_read(inode);\n\t} else {\n\t\tstruct btrfs_inode_item *item;\n\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_item);\n\t\t*size_ret = btrfs_inode_size(path->nodes[0], item);\n\t}\n\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "path->nodes[0]",
            "item"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "log",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 3958
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int logged_inode_size(struct btrfs_root *log, struct inode *inode,\n\t\t\t     struct btrfs_path *path, u64 *size_ret)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, log, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t*size_ret = i_size_read(inode);\n\t} else {\n\t\tstruct btrfs_inode_item *item;\n\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_item);\n\t\t*size_ret = btrfs_inode_size(path->nodes[0], item);\n\t}\n\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_log_changed_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3876-3950",
    "snippet": "static int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct list_head *logged_list,\n\t\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct extent_map *em, *n;\n\tstruct list_head extents;\n\tstruct extent_map_tree *tree = &BTRFS_I(inode)->extent_tree;\n\tu64 test_gen;\n\tint ret = 0;\n\tint num = 0;\n\n\tINIT_LIST_HEAD(&extents);\n\n\twrite_lock(&tree->lock);\n\ttest_gen = root->fs_info->last_trans_committed;\n\n\tlist_for_each_entry_safe(em, n, &tree->modified_extents, list) {\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * Just an arbitrary number, this can be really CPU intensive\n\t\t * once we start getting a lot of extents, and really once we\n\t\t * have a bunch of extents we just want to commit since it will\n\t\t * be faster.\n\t\t */\n\t\tif (++num > 32768) {\n\t\t\tlist_del_init(&tree->modified_extents);\n\t\t\tret = -EFBIG;\n\t\t\tgoto process;\n\t\t}\n\n\t\tif (em->generation <= test_gen)\n\t\t\tcontinue;\n\t\t/* Need a ref to keep it from getting evicted from cache */\n\t\tatomic_inc(&em->refs);\n\t\tset_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\t\tlist_add_tail(&em->list, &extents);\n\t\tnum++;\n\t}\n\n\tlist_sort(NULL, &extents, extent_cmp);\n\nprocess:\n\twhile (!list_empty(&extents)) {\n\t\tem = list_entry(extents.next, struct extent_map, list);\n\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * If we had an error we just need to delete everybody from our\n\t\t * private list.\n\t\t */\n\t\tif (ret) {\n\t\t\tclear_em_logging(tree, em);\n\t\t\tfree_extent_map(em);\n\t\t\tcontinue;\n\t\t}\n\n\t\twrite_unlock(&tree->lock);\n\n\t\tret = log_one_extent(trans, inode, root, em, path, logged_list,\n\t\t\t\t     ctx);\n\t\twrite_lock(&tree->lock);\n\t\tclear_em_logging(tree, em);\n\t\tfree_extent_map(em);\n\t}\n\tWARN_ON(!list_empty(&extents));\n\twrite_unlock(&tree->lock);\n\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&extents)"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&extents"
          ],
          "line": 3945
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3943
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_em_logging",
          "args": [
            "tree",
            "em"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "clear_em_logging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "314-319",
          "snippet": "void clear_em_logging(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tclear_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\tif (extent_map_in_tree(em))\n\t\ttry_merge_map(tree, em);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nvoid clear_em_logging(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tclear_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\tif (extent_map_in_tree(em))\n\t\ttry_merge_map(tree, em);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 3941
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_one_extent",
          "args": [
            "trans",
            "inode",
            "root",
            "em",
            "path",
            "logged_list",
            "ctx"
          ],
          "line": 3939
        },
        "resolved": true,
        "details": {
          "function_name": "log_one_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3782-3874",
          "snippet": "static int log_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct inode *inode, struct btrfs_root *root,\n\t\t\t  const struct extent_map *em,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  const struct list_head *logged_list,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_map_token token;\n\tstruct btrfs_key key;\n\tu64 extent_offset = em->start - em->orig_start;\n\tu64 block_len;\n\tint ret;\n\tint extent_inserted = 0;\n\tbool ordered_io_err = false;\n\n\tret = wait_ordered_extents(trans, inode, root, em, logged_list,\n\t\t\t\t   &ordered_io_err);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ordered_io_err) {\n\t\tctx->io_err = -EIO;\n\t\treturn 0;\n\t}\n\n\tbtrfs_init_map_token(&token);\n\n\tret = __btrfs_drop_extents(trans, log, inode, path, em->start,\n\t\t\t\t   em->start + em->len, NULL, 0, 1,\n\t\t\t\t   sizeof(*fi), &extent_inserted);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!extent_inserted) {\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = em->start;\n\n\t\tret = btrfs_insert_empty_item(trans, log, path, &key,\n\t\t\t\t\t      sizeof(*fi));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tbtrfs_set_token_file_extent_generation(leaf, fi, trans->transid,\n\t\t\t\t\t       &token);\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_PREALLOC,\n\t\t\t\t\t\t &token);\n\telse\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_REG,\n\t\t\t\t\t\t &token);\n\n\tblock_len = max(em->block_len, em->orig_block_len);\n\tif (em->compress_type != BTRFS_COMPRESS_NONE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start,\n\t\t\t\t\t\t\t&token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else if (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start -\n\t\t\t\t\t\t\textent_offset, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi, 0, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, 0,\n\t\t\t\t\t\t\t   &token);\n\t}\n\n\tbtrfs_set_token_file_extent_offset(leaf, fi, extent_offset, &token);\n\tbtrfs_set_token_file_extent_num_bytes(leaf, fi, em->len, &token);\n\tbtrfs_set_token_file_extent_ram_bytes(leaf, fi, em->ram_bytes, &token);\n\tbtrfs_set_token_file_extent_compression(leaf, fi, em->compress_type,\n\t\t\t\t\t\t&token);\n\tbtrfs_set_token_file_extent_encryption(leaf, fi, 0, &token);\n\tbtrfs_set_token_file_extent_other_encoding(leaf, fi, 0, &token);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int log_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct inode *inode, struct btrfs_root *root,\n\t\t\t  const struct extent_map *em,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  const struct list_head *logged_list,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_map_token token;\n\tstruct btrfs_key key;\n\tu64 extent_offset = em->start - em->orig_start;\n\tu64 block_len;\n\tint ret;\n\tint extent_inserted = 0;\n\tbool ordered_io_err = false;\n\n\tret = wait_ordered_extents(trans, inode, root, em, logged_list,\n\t\t\t\t   &ordered_io_err);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ordered_io_err) {\n\t\tctx->io_err = -EIO;\n\t\treturn 0;\n\t}\n\n\tbtrfs_init_map_token(&token);\n\n\tret = __btrfs_drop_extents(trans, log, inode, path, em->start,\n\t\t\t\t   em->start + em->len, NULL, 0, 1,\n\t\t\t\t   sizeof(*fi), &extent_inserted);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!extent_inserted) {\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = em->start;\n\n\t\tret = btrfs_insert_empty_item(trans, log, path, &key,\n\t\t\t\t\t      sizeof(*fi));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tbtrfs_set_token_file_extent_generation(leaf, fi, trans->transid,\n\t\t\t\t\t       &token);\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_PREALLOC,\n\t\t\t\t\t\t &token);\n\telse\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_REG,\n\t\t\t\t\t\t &token);\n\n\tblock_len = max(em->block_len, em->orig_block_len);\n\tif (em->compress_type != BTRFS_COMPRESS_NONE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start,\n\t\t\t\t\t\t\t&token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else if (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start -\n\t\t\t\t\t\t\textent_offset, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi, 0, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, 0,\n\t\t\t\t\t\t\t   &token);\n\t}\n\n\tbtrfs_set_token_file_extent_offset(leaf, fi, extent_offset, &token);\n\tbtrfs_set_token_file_extent_num_bytes(leaf, fi, em->len, &token);\n\tbtrfs_set_token_file_extent_ram_bytes(leaf, fi, em->ram_bytes, &token);\n\tbtrfs_set_token_file_extent_compression(leaf, fi, em->compress_type,\n\t\t\t\t\t\t&token);\n\tbtrfs_set_token_file_extent_encryption(leaf, fi, 0, &token);\n\tbtrfs_set_token_file_extent_other_encoding(leaf, fi, 0, &token);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&em->list"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "extents.next",
            "structextent_map",
            "list"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_sort",
          "args": [
            "NULL",
            "&extents",
            "extent_cmp"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&em->list",
            "&extents"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_FLAG_LOGGING",
            "&em->flags"
          ],
          "line": 3914
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&em->refs"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&tree->modified_extents"
          ],
          "line": 3905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&em->list"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "em",
            "n",
            "&tree->modified_extents",
            "list"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&extents"
          ],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3885
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct list_head *logged_list,\n\t\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct extent_map *em, *n;\n\tstruct list_head extents;\n\tstruct extent_map_tree *tree = &BTRFS_I(inode)->extent_tree;\n\tu64 test_gen;\n\tint ret = 0;\n\tint num = 0;\n\n\tINIT_LIST_HEAD(&extents);\n\n\twrite_lock(&tree->lock);\n\ttest_gen = root->fs_info->last_trans_committed;\n\n\tlist_for_each_entry_safe(em, n, &tree->modified_extents, list) {\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * Just an arbitrary number, this can be really CPU intensive\n\t\t * once we start getting a lot of extents, and really once we\n\t\t * have a bunch of extents we just want to commit since it will\n\t\t * be faster.\n\t\t */\n\t\tif (++num > 32768) {\n\t\t\tlist_del_init(&tree->modified_extents);\n\t\t\tret = -EFBIG;\n\t\t\tgoto process;\n\t\t}\n\n\t\tif (em->generation <= test_gen)\n\t\t\tcontinue;\n\t\t/* Need a ref to keep it from getting evicted from cache */\n\t\tatomic_inc(&em->refs);\n\t\tset_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\t\tlist_add_tail(&em->list, &extents);\n\t\tnum++;\n\t}\n\n\tlist_sort(NULL, &extents, extent_cmp);\n\nprocess:\n\twhile (!list_empty(&extents)) {\n\t\tem = list_entry(extents.next, struct extent_map, list);\n\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * If we had an error we just need to delete everybody from our\n\t\t * private list.\n\t\t */\n\t\tif (ret) {\n\t\t\tclear_em_logging(tree, em);\n\t\t\tfree_extent_map(em);\n\t\t\tcontinue;\n\t\t}\n\n\t\twrite_unlock(&tree->lock);\n\n\t\tret = log_one_extent(trans, inode, root, em, path, logged_list,\n\t\t\t\t     ctx);\n\t\twrite_lock(&tree->lock);\n\t\tclear_em_logging(tree, em);\n\t\tfree_extent_map(em);\n\t}\n\tWARN_ON(!list_empty(&extents));\n\twrite_unlock(&tree->lock);\n\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "log_one_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3782-3874",
    "snippet": "static int log_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct inode *inode, struct btrfs_root *root,\n\t\t\t  const struct extent_map *em,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  const struct list_head *logged_list,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_map_token token;\n\tstruct btrfs_key key;\n\tu64 extent_offset = em->start - em->orig_start;\n\tu64 block_len;\n\tint ret;\n\tint extent_inserted = 0;\n\tbool ordered_io_err = false;\n\n\tret = wait_ordered_extents(trans, inode, root, em, logged_list,\n\t\t\t\t   &ordered_io_err);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ordered_io_err) {\n\t\tctx->io_err = -EIO;\n\t\treturn 0;\n\t}\n\n\tbtrfs_init_map_token(&token);\n\n\tret = __btrfs_drop_extents(trans, log, inode, path, em->start,\n\t\t\t\t   em->start + em->len, NULL, 0, 1,\n\t\t\t\t   sizeof(*fi), &extent_inserted);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!extent_inserted) {\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = em->start;\n\n\t\tret = btrfs_insert_empty_item(trans, log, path, &key,\n\t\t\t\t\t      sizeof(*fi));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tbtrfs_set_token_file_extent_generation(leaf, fi, trans->transid,\n\t\t\t\t\t       &token);\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_PREALLOC,\n\t\t\t\t\t\t &token);\n\telse\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_REG,\n\t\t\t\t\t\t &token);\n\n\tblock_len = max(em->block_len, em->orig_block_len);\n\tif (em->compress_type != BTRFS_COMPRESS_NONE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start,\n\t\t\t\t\t\t\t&token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else if (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start -\n\t\t\t\t\t\t\textent_offset, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi, 0, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, 0,\n\t\t\t\t\t\t\t   &token);\n\t}\n\n\tbtrfs_set_token_file_extent_offset(leaf, fi, extent_offset, &token);\n\tbtrfs_set_token_file_extent_num_bytes(leaf, fi, em->len, &token);\n\tbtrfs_set_token_file_extent_ram_bytes(leaf, fi, em->ram_bytes, &token);\n\tbtrfs_set_token_file_extent_compression(leaf, fi, em->compress_type,\n\t\t\t\t\t\t&token);\n\tbtrfs_set_token_file_extent_encryption(leaf, fi, 0, &token);\n\tbtrfs_set_token_file_extent_other_encoding(leaf, fi, 0, &token);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3871
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 3869
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_other_encoding",
          "args": [
            "leaf",
            "fi",
            "0",
            "&token"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_encryption",
          "args": [
            "leaf",
            "fi",
            "0",
            "&token"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_compression",
          "args": [
            "leaf",
            "fi",
            "em->compress_type",
            "&token"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_ram_bytes",
          "args": [
            "leaf",
            "fi",
            "em->ram_bytes",
            "&token"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi",
            "em->len",
            "&token"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_offset",
          "args": [
            "leaf",
            "fi",
            "extent_offset",
            "&token"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi",
            "0",
            "&token"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi",
            "0",
            "&token"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi",
            "block_len",
            "&token"
          ],
          "line": 3854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi",
            "em->block_start -\n\t\t\t\t\t\t\textent_offset",
            "&token"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi",
            "block_len",
            "&token"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi",
            "em->block_start",
            "&token"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "em->block_len",
            "em->orig_block_len"
          ],
          "line": 3843
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_type",
          "args": [
            "leaf",
            "fi",
            "BTRFS_FILE_EXTENT_REG",
            "&token"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_type",
          "args": [
            "leaf",
            "fi",
            "BTRFS_FILE_EXTENT_PREALLOC",
            "&token"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_PREALLOC",
            "&em->flags"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_file_extent_generation",
          "args": [
            "leaf",
            "fi",
            "trans->transid",
            "&token"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "log",
            "path",
            "&key",
            "sizeof(*fi)"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_drop_extents",
          "args": [
            "trans",
            "log",
            "inode",
            "path",
            "em->start",
            "em->start + em->len",
            "NULL",
            "0",
            "1",
            "sizeof(*fi)",
            "&extent_inserted"
          ],
          "line": 3812
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_drop_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "695-1011",
          "snippet": "int __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint __btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root, struct inode *inode,\n\t\t\t struct btrfs_path *path, u64 start, u64 end,\n\t\t\t u64 *drop_end, int drop_cache,\n\t\t\t int replace_extent,\n\t\t\t u32 extent_item_size,\n\t\t\t int *key_inserted)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_key key;\n\tstruct btrfs_key new_key;\n\tu64 ino = btrfs_ino(inode);\n\tu64 search_start = start;\n\tu64 disk_bytenr = 0;\n\tu64 num_bytes = 0;\n\tu64 extent_offset = 0;\n\tu64 extent_end = 0;\n\tint del_nr = 0;\n\tint del_slot = 0;\n\tint extent_type;\n\tint recow;\n\tint ret;\n\tint modify_tree = -1;\n\tint update_refs;\n\tint found = 0;\n\tint leafs_visited = 0;\n\n\tif (drop_cache)\n\t\tbtrfs_drop_extent_cache(inode, start, end - 1, 0);\n\n\tif (start >= BTRFS_I(inode)->disk_i_size && !replace_extent)\n\t\tmodify_tree = 0;\n\n\tupdate_refs = (test_bit(BTRFS_ROOT_REF_COWS, &root->state) ||\n\t\t       root == root->fs_info->tree_root);\n\twhile (1) {\n\t\trecow = 0;\n\t\tret = btrfs_lookup_file_extent(trans, root, path, ino,\n\t\t\t\t\t       search_start, modify_tree);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0 && path->slots[0] > 0 && search_start == start) {\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\t\tif (key.objectid == ino &&\n\t\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t\tret = 0;\n\t\tleafs_visited++;\nnext_slot:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleafs_visited++;\n\t\t\tleaf = path->nodes[0];\n\t\t\trecow = 1;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid > ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY || key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(leaf, fi);\n\n\t\tif (extent_type == BTRFS_FILE_EXTENT_REG ||\n\t\t    extent_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tdisk_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\t\textent_offset = btrfs_file_extent_offset(leaf, fi);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, fi);\n\t\t} else if (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_inline_len(leaf,\n\t\t\t\t\t\t     path->slots[0], fi);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t\textent_end = search_start;\n\t\t}\n\n\t\t/*\n\t\t * Don't skip extent items representing 0 byte lengths. They\n\t\t * used to be created (bug) if while punching holes we hit\n\t\t * -ENOSPC condition. So if we find one here, just ensure we\n\t\t * delete it, otherwise we would insert a new file extent item\n\t\t * with the same key (offset) as that 0 bytes length file\n\t\t * extent item in the call to setup_items_for_insert() later\n\t\t * in this function.\n\t\t */\n\t\tif (extent_end == key.offset && extent_end >= search_start)\n\t\t\tgoto delete_extent_item;\n\n\t\tif (extent_end <= search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tfound = 1;\n\t\tsearch_start = max(key.offset, start);\n\t\tif (recow || !modify_tree) {\n\t\t\tmodify_tree = -1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t *     | - range to drop - |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end < extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = start;\n\t\t\tret = btrfs_duplicate_item(trans, root, path,\n\t\t\t\t\t\t   &new_key);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0] - 1,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\n\t\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\t\textent_offset += start - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - start);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\n\t\t\tif (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tnew_key.objectid,\n\t\t\t\t\t\tstart - extent_offset, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tkey.offset = start;\n\t\t}\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *      | -------- extent -------- |\n\t\t */\n\t\tif (start <= key.offset && end < extent_end) {\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(&new_key, &key, sizeof(new_key));\n\t\t\tnew_key.offset = end;\n\t\t\tbtrfs_set_item_key_safe(root, path, &new_key);\n\n\t\t\textent_offset += end - key.offset;\n\t\t\tbtrfs_set_file_extent_offset(leaf, fi, extent_offset);\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\textent_end - end);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, end - key.offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_start = extent_end;\n\t\t/*\n\t\t *       | ---- range to drop ----- |\n\t\t *  | -------- extent -------- |\n\t\t */\n\t\tif (start > key.offset && end >= extent_end) {\n\t\t\tBUG_ON(del_nr > 0);\n\t\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbtrfs_set_file_extent_num_bytes(leaf, fi,\n\t\t\t\t\t\t\tstart - key.offset);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\tif (update_refs && disk_bytenr > 0)\n\t\t\t\tinode_sub_bytes(inode, extent_end - start);\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\t/*\n\t\t *  | ---- range to drop ----- |\n\t\t *    | ------ extent ------ |\n\t\t */\n\t\tif (start <= key.offset && end >= extent_end) {\ndelete_extent_item:\n\t\t\tif (del_nr == 0) {\n\t\t\t\tdel_slot = path->slots[0];\n\t\t\t\tdel_nr = 1;\n\t\t\t} else {\n\t\t\t\tBUG_ON(del_slot + del_nr != path->slots[0]);\n\t\t\t\tdel_nr++;\n\t\t\t}\n\n\t\t\tif (update_refs &&\n\t\t\t    extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t\textent_end = ALIGN(extent_end,\n\t\t\t\t\t\t   root->sectorsize);\n\t\t\t} else if (update_refs && disk_bytenr > 0) {\n\t\t\t\tret = btrfs_free_extent(trans, root,\n\t\t\t\t\t\tdisk_bytenr, num_bytes, 0,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey.objectid, key.offset -\n\t\t\t\t\t\textent_offset, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\textent_end - key.offset);\n\t\t\t}\n\n\t\t\tif (end == extent_end)\n\t\t\t\tbreak;\n\n\t\t\tif (path->slots[0] + 1 < btrfs_header_nritems(leaf)) {\n\t\t\t\tpath->slots[0]++;\n\t\t\t\tgoto next_slot;\n\t\t\t}\n\n\t\t\tret = btrfs_del_items(trans, root, path, del_slot,\n\t\t\t\t\t      del_nr);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdel_nr = 0;\n\t\t\tdel_slot = 0;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(1);\n\t}\n\n\tif (!ret && del_nr > 0) {\n\t\t/*\n\t\t * Set path->slots[0] to first slot, so that after the delete\n\t\t * if items are move off from our leaf to its immediate left or\n\t\t * right neighbor leafs, we end up with a correct and adjusted\n\t\t * path->slots[0] for our insertion (if replace_extent != 0).\n\t\t */\n\t\tpath->slots[0] = del_slot;\n\t\tret = btrfs_del_items(trans, root, path, del_slot, del_nr);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t}\n\n\tleaf = path->nodes[0];\n\t/*\n\t * If btrfs_del_items() was called, it might have deleted a leaf, in\n\t * which case it unlocked our path, so check path->locks[0] matches a\n\t * write lock.\n\t */\n\tif (!ret && replace_extent && leafs_visited == 1 &&\n\t    (path->locks[0] == BTRFS_WRITE_LOCK_BLOCKING ||\n\t     path->locks[0] == BTRFS_WRITE_LOCK) &&\n\t    btrfs_leaf_free_space(root, leaf) >=\n\t    sizeof(struct btrfs_item) + extent_item_size) {\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = start;\n\t\tif (!del_nr && path->slots[0] < btrfs_header_nritems(leaf)) {\n\t\t\tstruct btrfs_key slot_key;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &slot_key, path->slots[0]);\n\t\t\tif (btrfs_comp_cpu_keys(&key, &slot_key) > 0)\n\t\t\t\tpath->slots[0]++;\n\t\t}\n\t\tsetup_items_for_insert(root, path, &key,\n\t\t\t\t       &extent_item_size,\n\t\t\t\t       extent_item_size,\n\t\t\t\t       sizeof(struct btrfs_item) +\n\t\t\t\t       extent_item_size, 1);\n\t\t*key_inserted = 1;\n\t}\n\n\tif (!replace_extent || !(*key_inserted))\n\t\tbtrfs_release_path(path);\n\tif (drop_end)\n\t\t*drop_end = found ? min(end, extent_end) : end;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_ordered_extents",
          "args": [
            "trans",
            "inode",
            "root",
            "em",
            "logged_list",
            "&ordered_io_err"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "wait_ordered_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3633-3780",
          "snippet": "static int wait_ordered_extents(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tconst struct extent_map *em,\n\t\t\t\tconst struct list_head *logged_list,\n\t\t\t\tbool *ordered_io_error)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_root *log = root->log_root;\n\tu64 mod_start = em->mod_start;\n\tu64 mod_len = em->mod_len;\n\tconst bool skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tu64 csum_offset;\n\tu64 csum_len;\n\tLIST_HEAD(ordered_sums);\n\tint ret = 0;\n\n\t*ordered_io_error = false;\n\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) ||\n\t    em->block_start == EXTENT_MAP_HOLE)\n\t\treturn 0;\n\n\t/*\n\t * Wait far any ordered extent that covers our extent map. If it\n\t * finishes without an error, first check and see if our csums are on\n\t * our outstanding ordered extents.\n\t */\n\tlist_for_each_entry(ordered, logged_list, log_list) {\n\t\tstruct btrfs_ordered_sum *sum;\n\n\t\tif (!mod_len)\n\t\t\tbreak;\n\n\t\tif (ordered->file_offset + ordered->len <= mod_start ||\n\t\t    mod_start + mod_len <= ordered->file_offset)\n\t\t\tcontinue;\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_IOERR, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tconst u64 start = ordered->file_offset;\n\t\t\tconst u64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(ordered->inode != inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\n\t\twait_event(ordered->wait,\n\t\t\t   (test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) ||\n\t\t\t    test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)));\n\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)) {\n\t\t\t/*\n\t\t\t * Clear the AS_EIO/AS_ENOSPC flags from the inode's\n\t\t\t * i_mapping flags, so that the next fsync won't get\n\t\t\t * an outdated io error too.\n\t\t\t */\n\t\t\tbtrfs_inode_check_errors(inode);\n\t\t\t*ordered_io_error = true;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We are going to copy all the csums on this ordered extent, so\n\t\t * go ahead and adjust mod_start and mod_len in case this\n\t\t * ordered extent has already been logged.\n\t\t */\n\t\tif (ordered->file_offset > mod_start) {\n\t\t\tif (ordered->file_offset + ordered->len >=\n\t\t\t    mod_start + mod_len)\n\t\t\t\tmod_len = ordered->file_offset - mod_start;\n\t\t\t/*\n\t\t\t * If we have this case\n\t\t\t *\n\t\t\t * |--------- logged extent ---------|\n\t\t\t *       |----- ordered extent ----|\n\t\t\t *\n\t\t\t * Just don't mess with mod_start and mod_len, we'll\n\t\t\t * just end up logging more csums than we need and it\n\t\t\t * will be ok.\n\t\t\t */\n\t\t} else {\n\t\t\tif (ordered->file_offset + ordered->len <\n\t\t\t    mod_start + mod_len) {\n\t\t\t\tmod_len = (mod_start + mod_len) -\n\t\t\t\t\t(ordered->file_offset + ordered->len);\n\t\t\t\tmod_start = ordered->file_offset +\n\t\t\t\t\tordered->len;\n\t\t\t} else {\n\t\t\t\tmod_len = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_csum)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * To keep us from looping for the above case of an ordered\n\t\t * extent that falls inside of the logged extent.\n\t\t */\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED_CSUM,\n\t\t\t\t     &ordered->flags))\n\t\t\tcontinue;\n\n\t\tif (ordered->csum_bytes_left) {\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 0);\n\t\t\twait_event(ordered->wait,\n\t\t\t\t   ordered->csum_bytes_left == 0);\n\t\t}\n\n\t\tlist_for_each_entry(sum, &ordered->list, list) {\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sum);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*ordered_io_error || !mod_len || ret || skip_csum)\n\t\treturn ret;\n\n\tif (em->compress_type) {\n\t\tcsum_offset = 0;\n\t\tcsum_len = max(em->block_len, em->orig_block_len);\n\t} else {\n\t\tcsum_offset = mod_start - em->start;\n\t\tcsum_len = mod_len;\n\t}\n\n\t/* block start is already adjusted for the file extent offset. */\n\tret = btrfs_lookup_csums_range(log->fs_info->csum_root,\n\t\t\t\t       em->block_start + csum_offset,\n\t\t\t\t       em->block_start + csum_offset +\n\t\t\t\t       csum_len - 1, &ordered_sums, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int wait_ordered_extents(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tconst struct extent_map *em,\n\t\t\t\tconst struct list_head *logged_list,\n\t\t\t\tbool *ordered_io_error)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_root *log = root->log_root;\n\tu64 mod_start = em->mod_start;\n\tu64 mod_len = em->mod_len;\n\tconst bool skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tu64 csum_offset;\n\tu64 csum_len;\n\tLIST_HEAD(ordered_sums);\n\tint ret = 0;\n\n\t*ordered_io_error = false;\n\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) ||\n\t    em->block_start == EXTENT_MAP_HOLE)\n\t\treturn 0;\n\n\t/*\n\t * Wait far any ordered extent that covers our extent map. If it\n\t * finishes without an error, first check and see if our csums are on\n\t * our outstanding ordered extents.\n\t */\n\tlist_for_each_entry(ordered, logged_list, log_list) {\n\t\tstruct btrfs_ordered_sum *sum;\n\n\t\tif (!mod_len)\n\t\t\tbreak;\n\n\t\tif (ordered->file_offset + ordered->len <= mod_start ||\n\t\t    mod_start + mod_len <= ordered->file_offset)\n\t\t\tcontinue;\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_IOERR, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tconst u64 start = ordered->file_offset;\n\t\t\tconst u64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(ordered->inode != inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\n\t\twait_event(ordered->wait,\n\t\t\t   (test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) ||\n\t\t\t    test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)));\n\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)) {\n\t\t\t/*\n\t\t\t * Clear the AS_EIO/AS_ENOSPC flags from the inode's\n\t\t\t * i_mapping flags, so that the next fsync won't get\n\t\t\t * an outdated io error too.\n\t\t\t */\n\t\t\tbtrfs_inode_check_errors(inode);\n\t\t\t*ordered_io_error = true;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We are going to copy all the csums on this ordered extent, so\n\t\t * go ahead and adjust mod_start and mod_len in case this\n\t\t * ordered extent has already been logged.\n\t\t */\n\t\tif (ordered->file_offset > mod_start) {\n\t\t\tif (ordered->file_offset + ordered->len >=\n\t\t\t    mod_start + mod_len)\n\t\t\t\tmod_len = ordered->file_offset - mod_start;\n\t\t\t/*\n\t\t\t * If we have this case\n\t\t\t *\n\t\t\t * |--------- logged extent ---------|\n\t\t\t *       |----- ordered extent ----|\n\t\t\t *\n\t\t\t * Just don't mess with mod_start and mod_len, we'll\n\t\t\t * just end up logging more csums than we need and it\n\t\t\t * will be ok.\n\t\t\t */\n\t\t} else {\n\t\t\tif (ordered->file_offset + ordered->len <\n\t\t\t    mod_start + mod_len) {\n\t\t\t\tmod_len = (mod_start + mod_len) -\n\t\t\t\t\t(ordered->file_offset + ordered->len);\n\t\t\t\tmod_start = ordered->file_offset +\n\t\t\t\t\tordered->len;\n\t\t\t} else {\n\t\t\t\tmod_len = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_csum)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * To keep us from looping for the above case of an ordered\n\t\t * extent that falls inside of the logged extent.\n\t\t */\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED_CSUM,\n\t\t\t\t     &ordered->flags))\n\t\t\tcontinue;\n\n\t\tif (ordered->csum_bytes_left) {\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 0);\n\t\t\twait_event(ordered->wait,\n\t\t\t\t   ordered->csum_bytes_left == 0);\n\t\t}\n\n\t\tlist_for_each_entry(sum, &ordered->list, list) {\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sum);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*ordered_io_error || !mod_len || ret || skip_csum)\n\t\treturn ret;\n\n\tif (em->compress_type) {\n\t\tcsum_offset = 0;\n\t\tcsum_len = max(em->block_len, em->orig_block_len);\n\t} else {\n\t\tcsum_offset = mod_start - em->start;\n\t\tcsum_len = mod_len;\n\t}\n\n\t/* block start is already adjusted for the file extent offset. */\n\tret = btrfs_lookup_csums_range(log->fs_info->csum_root,\n\t\t\t\t       em->block_start + csum_offset,\n\t\t\t\t       em->block_start + csum_offset +\n\t\t\t\t       csum_len - 1, &ordered_sums, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int log_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct inode *inode, struct btrfs_root *root,\n\t\t\t  const struct extent_map *em,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  const struct list_head *logged_list,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_map_token token;\n\tstruct btrfs_key key;\n\tu64 extent_offset = em->start - em->orig_start;\n\tu64 block_len;\n\tint ret;\n\tint extent_inserted = 0;\n\tbool ordered_io_err = false;\n\n\tret = wait_ordered_extents(trans, inode, root, em, logged_list,\n\t\t\t\t   &ordered_io_err);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ordered_io_err) {\n\t\tctx->io_err = -EIO;\n\t\treturn 0;\n\t}\n\n\tbtrfs_init_map_token(&token);\n\n\tret = __btrfs_drop_extents(trans, log, inode, path, em->start,\n\t\t\t\t   em->start + em->len, NULL, 0, 1,\n\t\t\t\t   sizeof(*fi), &extent_inserted);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!extent_inserted) {\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = em->start;\n\n\t\tret = btrfs_insert_empty_item(trans, log, path, &key,\n\t\t\t\t\t      sizeof(*fi));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tbtrfs_set_token_file_extent_generation(leaf, fi, trans->transid,\n\t\t\t\t\t       &token);\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_PREALLOC,\n\t\t\t\t\t\t &token);\n\telse\n\t\tbtrfs_set_token_file_extent_type(leaf, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_REG,\n\t\t\t\t\t\t &token);\n\n\tblock_len = max(em->block_len, em->orig_block_len);\n\tif (em->compress_type != BTRFS_COMPRESS_NONE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start,\n\t\t\t\t\t\t\t&token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else if (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi,\n\t\t\t\t\t\t\tem->block_start -\n\t\t\t\t\t\t\textent_offset, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, block_len,\n\t\t\t\t\t\t\t   &token);\n\t} else {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(leaf, fi, 0, &token);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(leaf, fi, 0,\n\t\t\t\t\t\t\t   &token);\n\t}\n\n\tbtrfs_set_token_file_extent_offset(leaf, fi, extent_offset, &token);\n\tbtrfs_set_token_file_extent_num_bytes(leaf, fi, em->len, &token);\n\tbtrfs_set_token_file_extent_ram_bytes(leaf, fi, em->ram_bytes, &token);\n\tbtrfs_set_token_file_extent_compression(leaf, fi, em->compress_type,\n\t\t\t\t\t\t&token);\n\tbtrfs_set_token_file_extent_encryption(leaf, fi, 0, &token);\n\tbtrfs_set_token_file_extent_other_encoding(leaf, fi, 0, &token);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wait_ordered_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3633-3780",
    "snippet": "static int wait_ordered_extents(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tconst struct extent_map *em,\n\t\t\t\tconst struct list_head *logged_list,\n\t\t\t\tbool *ordered_io_error)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_root *log = root->log_root;\n\tu64 mod_start = em->mod_start;\n\tu64 mod_len = em->mod_len;\n\tconst bool skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tu64 csum_offset;\n\tu64 csum_len;\n\tLIST_HEAD(ordered_sums);\n\tint ret = 0;\n\n\t*ordered_io_error = false;\n\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) ||\n\t    em->block_start == EXTENT_MAP_HOLE)\n\t\treturn 0;\n\n\t/*\n\t * Wait far any ordered extent that covers our extent map. If it\n\t * finishes without an error, first check and see if our csums are on\n\t * our outstanding ordered extents.\n\t */\n\tlist_for_each_entry(ordered, logged_list, log_list) {\n\t\tstruct btrfs_ordered_sum *sum;\n\n\t\tif (!mod_len)\n\t\t\tbreak;\n\n\t\tif (ordered->file_offset + ordered->len <= mod_start ||\n\t\t    mod_start + mod_len <= ordered->file_offset)\n\t\t\tcontinue;\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_IOERR, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tconst u64 start = ordered->file_offset;\n\t\t\tconst u64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(ordered->inode != inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\n\t\twait_event(ordered->wait,\n\t\t\t   (test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) ||\n\t\t\t    test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)));\n\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)) {\n\t\t\t/*\n\t\t\t * Clear the AS_EIO/AS_ENOSPC flags from the inode's\n\t\t\t * i_mapping flags, so that the next fsync won't get\n\t\t\t * an outdated io error too.\n\t\t\t */\n\t\t\tbtrfs_inode_check_errors(inode);\n\t\t\t*ordered_io_error = true;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We are going to copy all the csums on this ordered extent, so\n\t\t * go ahead and adjust mod_start and mod_len in case this\n\t\t * ordered extent has already been logged.\n\t\t */\n\t\tif (ordered->file_offset > mod_start) {\n\t\t\tif (ordered->file_offset + ordered->len >=\n\t\t\t    mod_start + mod_len)\n\t\t\t\tmod_len = ordered->file_offset - mod_start;\n\t\t\t/*\n\t\t\t * If we have this case\n\t\t\t *\n\t\t\t * |--------- logged extent ---------|\n\t\t\t *       |----- ordered extent ----|\n\t\t\t *\n\t\t\t * Just don't mess with mod_start and mod_len, we'll\n\t\t\t * just end up logging more csums than we need and it\n\t\t\t * will be ok.\n\t\t\t */\n\t\t} else {\n\t\t\tif (ordered->file_offset + ordered->len <\n\t\t\t    mod_start + mod_len) {\n\t\t\t\tmod_len = (mod_start + mod_len) -\n\t\t\t\t\t(ordered->file_offset + ordered->len);\n\t\t\t\tmod_start = ordered->file_offset +\n\t\t\t\t\tordered->len;\n\t\t\t} else {\n\t\t\t\tmod_len = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_csum)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * To keep us from looping for the above case of an ordered\n\t\t * extent that falls inside of the logged extent.\n\t\t */\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED_CSUM,\n\t\t\t\t     &ordered->flags))\n\t\t\tcontinue;\n\n\t\tif (ordered->csum_bytes_left) {\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 0);\n\t\t\twait_event(ordered->wait,\n\t\t\t\t   ordered->csum_bytes_left == 0);\n\t\t}\n\n\t\tlist_for_each_entry(sum, &ordered->list, list) {\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sum);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*ordered_io_error || !mod_len || ret || skip_csum)\n\t\treturn ret;\n\n\tif (em->compress_type) {\n\t\tcsum_offset = 0;\n\t\tcsum_len = max(em->block_len, em->orig_block_len);\n\t} else {\n\t\tcsum_offset = mod_start - em->start;\n\t\tcsum_len = mod_len;\n\t}\n\n\t/* block start is already adjusted for the file extent offset. */\n\tret = btrfs_lookup_csums_range(log->fs_info->csum_root,\n\t\t\t\t       em->block_start + csum_offset,\n\t\t\t\t       em->block_start + csum_offset +\n\t\t\t\t       csum_len - 1, &ordered_sums, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sums"
          ],
          "line": 3776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sums->list"
          ],
          "line": 3775
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_file_blocks",
          "args": [
            "trans",
            "log",
            "sums"
          ],
          "line": 3774
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_file_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "683-877",
          "snippet": "int btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ordered_sums.next",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ordered_sums"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csums_range",
          "args": [
            "log->fs_info->csum_root",
            "em->block_start + csum_offset",
            "em->block_start + csum_offset +\n\t\t\t\t       csum_len - 1",
            "&ordered_sums",
            "0"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "em->block_len",
            "em->orig_block_len"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sum",
            "&ordered->list",
            "list"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "ordered->wait",
            "ordered->csum_bytes_left == 0"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "inode",
            "ordered",
            "0"
          ],
          "line": 3738
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_ORDERED_LOGGED_CSUM",
            "&ordered->flags"
          ],
          "line": 3733
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_check_errors",
          "args": [
            "inode"
          ],
          "line": 3691
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_check_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9630-9642",
          "snippet": "int btrfs_inode_check_errors(struct inode *inode)\n{\n\tint ret = 0;\n\n\tif (test_bit(AS_ENOSPC, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &inode->i_mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &inode->i_mapping->flags))\n\t\tret = -EIO;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_inode_check_errors(struct inode *inode)\n{\n\tint ret = 0;\n\n\tif (test_bit(AS_ENOSPC, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_ENOSPC, &inode->i_mapping->flags))\n\t\tret = -ENOSPC;\n\tif (test_bit(AS_EIO, &inode->i_mapping->flags) &&\n\t    test_and_clear_bit(AS_EIO, &inode->i_mapping->flags))\n\t\tret = -EIO;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ORDERED_IOERR",
            "&ordered->flags"
          ],
          "line": 3685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "ordered->wait",
            "(test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) ||\n\t\t\t    test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ordered->inode != inode"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ordered",
            "logged_list",
            "log_list"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "ordered_sums"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int wait_ordered_extents(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tconst struct extent_map *em,\n\t\t\t\tconst struct list_head *logged_list,\n\t\t\t\tbool *ordered_io_error)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_root *log = root->log_root;\n\tu64 mod_start = em->mod_start;\n\tu64 mod_len = em->mod_len;\n\tconst bool skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tu64 csum_offset;\n\tu64 csum_len;\n\tLIST_HEAD(ordered_sums);\n\tint ret = 0;\n\n\t*ordered_io_error = false;\n\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) ||\n\t    em->block_start == EXTENT_MAP_HOLE)\n\t\treturn 0;\n\n\t/*\n\t * Wait far any ordered extent that covers our extent map. If it\n\t * finishes without an error, first check and see if our csums are on\n\t * our outstanding ordered extents.\n\t */\n\tlist_for_each_entry(ordered, logged_list, log_list) {\n\t\tstruct btrfs_ordered_sum *sum;\n\n\t\tif (!mod_len)\n\t\t\tbreak;\n\n\t\tif (ordered->file_offset + ordered->len <= mod_start ||\n\t\t    mod_start + mod_len <= ordered->file_offset)\n\t\t\tcontinue;\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_IOERR, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tconst u64 start = ordered->file_offset;\n\t\t\tconst u64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(ordered->inode != inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\n\t\twait_event(ordered->wait,\n\t\t\t   (test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) ||\n\t\t\t    test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)));\n\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags)) {\n\t\t\t/*\n\t\t\t * Clear the AS_EIO/AS_ENOSPC flags from the inode's\n\t\t\t * i_mapping flags, so that the next fsync won't get\n\t\t\t * an outdated io error too.\n\t\t\t */\n\t\t\tbtrfs_inode_check_errors(inode);\n\t\t\t*ordered_io_error = true;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We are going to copy all the csums on this ordered extent, so\n\t\t * go ahead and adjust mod_start and mod_len in case this\n\t\t * ordered extent has already been logged.\n\t\t */\n\t\tif (ordered->file_offset > mod_start) {\n\t\t\tif (ordered->file_offset + ordered->len >=\n\t\t\t    mod_start + mod_len)\n\t\t\t\tmod_len = ordered->file_offset - mod_start;\n\t\t\t/*\n\t\t\t * If we have this case\n\t\t\t *\n\t\t\t * |--------- logged extent ---------|\n\t\t\t *       |----- ordered extent ----|\n\t\t\t *\n\t\t\t * Just don't mess with mod_start and mod_len, we'll\n\t\t\t * just end up logging more csums than we need and it\n\t\t\t * will be ok.\n\t\t\t */\n\t\t} else {\n\t\t\tif (ordered->file_offset + ordered->len <\n\t\t\t    mod_start + mod_len) {\n\t\t\t\tmod_len = (mod_start + mod_len) -\n\t\t\t\t\t(ordered->file_offset + ordered->len);\n\t\t\t\tmod_start = ordered->file_offset +\n\t\t\t\t\tordered->len;\n\t\t\t} else {\n\t\t\t\tmod_len = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_csum)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * To keep us from looping for the above case of an ordered\n\t\t * extent that falls inside of the logged extent.\n\t\t */\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED_CSUM,\n\t\t\t\t     &ordered->flags))\n\t\t\tcontinue;\n\n\t\tif (ordered->csum_bytes_left) {\n\t\t\tbtrfs_start_ordered_extent(inode, ordered, 0);\n\t\t\twait_event(ordered->wait,\n\t\t\t\t   ordered->csum_bytes_left == 0);\n\t\t}\n\n\t\tlist_for_each_entry(sum, &ordered->list, list) {\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sum);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*ordered_io_error || !mod_len || ret || skip_csum)\n\t\treturn ret;\n\n\tif (em->compress_type) {\n\t\tcsum_offset = 0;\n\t\tcsum_len = max(em->block_len, em->orig_block_len);\n\t} else {\n\t\tcsum_offset = mod_start - em->start;\n\t\tcsum_len = mod_len;\n\t}\n\n\t/* block start is already adjusted for the file extent offset. */\n\tret = btrfs_lookup_csums_range(log->fs_info->csum_root,\n\t\t\t\t       em->block_start + csum_offset,\n\t\t\t\t       em->block_start + csum_offset +\n\t\t\t\t       csum_len - 1, &ordered_sums, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "extent_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3619-3631",
    "snippet": "static int extent_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct extent_map *em1, *em2;\n\n\tem1 = list_entry(a, struct extent_map, list);\n\tem2 = list_entry(b, struct extent_map, list);\n\n\tif (em1->start < em2->start)\n\t\treturn -1;\n\telse if (em1->start > em2->start)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "b",
            "structextent_map",
            "list"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "a",
            "structextent_map",
            "list"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int extent_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct extent_map *em1, *em2;\n\n\tem1 = list_entry(a, struct extent_map, list);\n\tem2 = list_entry(b, struct extent_map, list);\n\n\tif (em1->start < em2->start)\n\t\treturn -1;\n\telse if (em1->start > em2->start)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3337-3617",
    "snippet": "static noinline int copy_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct inode *inode,\n\t\t\t       struct btrfs_path *dst_path,\n\t\t\t       struct btrfs_path *src_path, u64 *last_extent,\n\t\t\t       int start_slot, int nr, int inode_only,\n\t\t\t       u64 logged_isize)\n{\n\tunsigned long src_offset;\n\tunsigned long dst_offset;\n\tstruct btrfs_root *log = BTRFS_I(inode)->root->log_root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *src = src_path->nodes[0];\n\tstruct btrfs_key first_key, last_key, key;\n\tint ret;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tchar *ins_data;\n\tint i;\n\tstruct list_head ordered_sums;\n\tint skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tbool has_extents = false;\n\tbool need_find_last_extent = true;\n\tbool done = false;\n\n\tINIT_LIST_HEAD(&ordered_sums);\n\n\tins_data = kmalloc(nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\n\tfirst_key.objectid = (u64)-1;\n\n\tins_sizes = (u32 *)ins_data;\n\tins_keys = (struct btrfs_key *)(ins_data + nr * sizeof(u32));\n\n\tfor (i = 0; i < nr; i++) {\n\t\tins_sizes[i] = btrfs_item_size_nr(src, i + start_slot);\n\t\tbtrfs_item_key_to_cpu(src, ins_keys + i, i + start_slot);\n\t}\n\tret = btrfs_insert_empty_items(trans, log, dst_path,\n\t\t\t\t       ins_keys, ins_sizes, nr);\n\tif (ret) {\n\t\tkfree(ins_data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr; i++, dst_path->slots[0]++) {\n\t\tdst_offset = btrfs_item_ptr_offset(dst_path->nodes[0],\n\t\t\t\t\t\t   dst_path->slots[0]);\n\n\t\tsrc_offset = btrfs_item_ptr_offset(src, start_slot + i);\n\n\t\tif ((i == (nr - 1)))\n\t\t\tlast_key = ins_keys[i];\n\n\t\tif (ins_keys[i].type == BTRFS_INODE_ITEM_KEY) {\n\t\t\tinode_item = btrfs_item_ptr(dst_path->nodes[0],\n\t\t\t\t\t\t    dst_path->slots[0],\n\t\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tfill_inode_item(trans, dst_path->nodes[0], inode_item,\n\t\t\t\t\tinode, inode_only == LOG_INODE_EXISTS,\n\t\t\t\t\tlogged_isize);\n\t\t} else {\n\t\t\tcopy_extent_buffer(dst_path->nodes[0], src, dst_offset,\n\t\t\t\t\t   src_offset, ins_sizes[i]);\n\t\t}\n\n\t\t/*\n\t\t * We set need_find_last_extent here in case we know we were\n\t\t * processing other items and then walk into the first extent in\n\t\t * the inode.  If we don't hit an extent then nothing changes,\n\t\t * we'll do the last search the next time around.\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\thas_extents = true;\n\t\t\tif (first_key.objectid == (u64)-1)\n\t\t\t\tfirst_key = ins_keys[i];\n\t\t} else {\n\t\t\tneed_find_last_extent = false;\n\t\t}\n\n\t\t/* take a reference on file data extents so that truncates\n\t\t * or deletes of this inode don't have to relog the inode\n\t\t * again\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY &&\n\t\t    !skip_csum) {\n\t\t\tint found_type;\n\t\t\textent = btrfs_item_ptr(src, start_slot + i,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\tif (btrfs_file_extent_generation(src, extent) < trans->transid)\n\t\t\t\tcontinue;\n\n\t\t\tfound_type = btrfs_file_extent_type(src, extent);\n\t\t\tif (found_type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t\tu64 ds, dl, cs, cl;\n\t\t\t\tds = btrfs_file_extent_disk_bytenr(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\t/* ds == 0 is a hole */\n\t\t\t\tif (ds == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdl = btrfs_file_extent_disk_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tcs = btrfs_file_extent_offset(src, extent);\n\t\t\t\tcl = btrfs_file_extent_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tif (btrfs_file_extent_compression(src,\n\t\t\t\t\t\t\t\t  extent)) {\n\t\t\t\t\tcs = 0;\n\t\t\t\t\tcl = dl;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_lookup_csums_range(\n\t\t\t\t\t\tlog->fs_info->csum_root,\n\t\t\t\t\t\tds + cs, ds + cs + cl - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_release_path(dst_path);\n\t\t\t\t\tkfree(ins_data);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbtrfs_mark_buffer_dirty(dst_path->nodes[0]);\n\tbtrfs_release_path(dst_path);\n\tkfree(ins_data);\n\n\t/*\n\t * we have to do this after the loop above to avoid changing the\n\t * log tree while trying to change the log tree.\n\t */\n\tret = 0;\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\tif (!has_extents)\n\t\treturn ret;\n\n\tif (need_find_last_extent && *last_extent == first_key.offset) {\n\t\t/*\n\t\t * We don't have any leafs between our current one and the one\n\t\t * we processed before that can have file extent items for our\n\t\t * inode (and have a generation number smaller than our current\n\t\t * transaction id).\n\t\t */\n\t\tneed_find_last_extent = false;\n\t}\n\n\t/*\n\t * Because we use btrfs_search_forward we could skip leaves that were\n\t * not modified and then assume *last_extent is valid when it really\n\t * isn't.  So back up to the previous leaf and read the end of the last\n\t * extent before we go and fill in holes.\n\t */\n\tif (need_find_last_extent) {\n\t\tu64 len;\n\n\t\tret = btrfs_prev_leaf(BTRFS_I(inode)->root, src_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\tgoto fill_holes;\n\t\tif (src_path->slots[0])\n\t\t\tsrc_path->slots[0]--;\n\t\tsrc = src_path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(src, &key, src_path->slots[0]);\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto fill_holes;\n\t\textent = btrfs_item_ptr(src, src_path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src,\n\t\t\t\t\t\t\t   src_path->slots[0],\n\t\t\t\t\t\t\t   extent);\n\t\t\t*last_extent = ALIGN(key.offset + len,\n\t\t\t\t\t     log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\t*last_extent = key.offset + len;\n\t\t}\n\t}\nfill_holes:\n\t/* So we did prev_leaf, now we need to move to the next leaf, but a few\n\t * things could have happened\n\t *\n\t * 1) A merge could have happened, so we could currently be on a leaf\n\t * that holds what we were copying in the first place.\n\t * 2) A split could have happened, and now not all of the items we want\n\t * are on the same leaf.\n\t *\n\t * So we need to adjust how we search for holes, we need to drop the\n\t * path and re-search for the first extent key we found, and then walk\n\t * forward until we hit the last one we copied.\n\t */\n\tif (need_find_last_extent) {\n\t\t/* btrfs_prev_leaf could return 1 without releasing the path */\n\t\tbtrfs_release_path(src_path);\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(inode)->root, &first_key,\n\t\t\t\t\tsrc_path, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tASSERT(ret == 0);\n\t\tsrc = src_path->nodes[0];\n\t\ti = src_path->slots[0];\n\t} else {\n\t\ti = start_slot;\n\t}\n\n\t/*\n\t * Ok so here we need to go through and fill in any holes we may have\n\t * to make sure that holes are punched for those areas in case they had\n\t * extents previously.\n\t */\n\twhile (!done) {\n\t\tu64 offset, len;\n\t\tu64 extent_end;\n\n\t\tif (i >= btrfs_header_nritems(src_path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(inode)->root, src_path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tASSERT(ret == 0);\n\t\t\tsrc = src_path->nodes[0];\n\t\t\ti = 0;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(src, &key, i);\n\t\tif (!btrfs_comp_cpu_keys(&key, &last_key))\n\t\t\tdone = true;\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\textent = btrfs_item_ptr(src, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src, i, extent);\n\t\t\textent_end = ALIGN(key.offset + len, log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\textent_end = key.offset + len;\n\t\t}\n\t\ti++;\n\n\t\tif (*last_extent == key.offset) {\n\t\t\t*last_extent = extent_end;\n\t\t\tcontinue;\n\t\t}\n\t\toffset = *last_extent;\n\t\tlen = key.offset - *last_extent;\n\t\tret = btrfs_insert_file_extent(trans, log, btrfs_ino(inode),\n\t\t\t\t\t       offset, 0, 0, len, 0, len, 0,\n\t\t\t\t\t       0, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t*last_extent = extent_end;\n\t}\n\t/*\n\t * Need to let the callers know we dropped the path so they should\n\t * re-search.\n\t */\n\tif (!ret && need_find_last_extent)\n\t\tret = 1;\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define LOG_INODE_EXISTS 1"
    ],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_insert_file_extent",
          "args": [
            "trans",
            "log",
            "btrfs_ino(inode)",
            "offset",
            "0",
            "0",
            "len",
            "0",
            "len",
            "0",
            "0",
            "0"
          ],
          "line": 3603
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_file_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "40-84",
          "snippet": "int btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     u64 objectid, u64 pos,\n\t\t\t     u64 disk_offset, u64 disk_num_bytes,\n\t\t\t     u64 num_bytes, u64 offset, u64 ram_bytes,\n\t\t\t     u8 compression, u8 encryption, u16 other_encoding)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tfile_key.objectid = objectid;\n\tfile_key.offset = pos;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      sizeof(*item));\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret); /* Can't happen */\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\n\tbtrfs_set_file_extent_offset(leaf, item, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\n\tbtrfs_set_file_extent_generation(leaf, item, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_file_extent_compression(leaf, item, compression);\n\tbtrfs_set_file_extent_encryption(leaf, item, encryption);\n\tbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     u64 objectid, u64 pos,\n\t\t\t     u64 disk_offset, u64 disk_num_bytes,\n\t\t\t     u64 num_bytes, u64 offset, u64 ram_bytes,\n\t\t\t     u8 compression, u8 encryption, u16 other_encoding)\n{\n\tint ret = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key file_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tfile_key.objectid = objectid;\n\tfile_key.offset = pos;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      sizeof(*item));\n\tif (ret < 0)\n\t\tgoto out;\n\tBUG_ON(ret); /* Can't happen */\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t      struct btrfs_file_extent_item);\n\tbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\n\tbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\n\tbtrfs_set_file_extent_offset(leaf, item, offset);\n\tbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\n\tbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\n\tbtrfs_set_file_extent_generation(leaf, item, trans->transid);\n\tbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\n\tbtrfs_set_file_extent_compression(leaf, item, compression);\n\tbtrfs_set_file_extent_encryption(leaf, item, encryption);\n\tbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\n\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 3603
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "src",
            "extent"
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "key.offset + len",
            "log->sectorsize"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "src",
            "i",
            "extent"
          ],
          "line": 3589
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "src",
            "extent"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "src",
            "i",
            "structbtrfs_file_extent_item"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&key",
            "&last_key"
          ],
          "line": 3579
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "src",
            "&key",
            "i"
          ],
          "line": 3578
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret == 0"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "BTRFS_I(inode)->root",
            "src_path"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "src_path->nodes[0]"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret == 0"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "BTRFS_I(inode)->root",
            "&first_key",
            "src_path",
            "0",
            "0"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "src_path"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "src",
            "extent"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "key.offset + len",
            "log->sectorsize"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "src",
            "extent"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "src",
            "src_path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_prev_leaf",
          "args": [
            "BTRFS_I(inode)->root",
            "src_path"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prev_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5049-5089",
          "snippet": "int btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sums"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sums->list"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_file_blocks",
          "args": [
            "trans",
            "log",
            "sums"
          ],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_file_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "683-877",
          "snippet": "int btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ordered_sums.next",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ordered_sums"
          ],
          "line": 3475
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ins_data"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "dst_path->nodes[0]"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ins_data"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csums_range",
          "args": [
            "log->fs_info->csum_root",
            "ds + cs",
            "ds + cs + cl - 1",
            "&ordered_sums",
            "0"
          ],
          "line": 3453
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "src",
            "extent"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "src",
            "extent"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "src",
            "extent"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "src",
            "extent"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "src",
            "extent"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "src",
            "extent"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_generation",
          "args": [
            "src",
            "extent"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "src",
            "start_slot + i",
            "structbtrfs_file_extent_item"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "dst_path->nodes[0]",
            "src",
            "dst_offset",
            "src_offset",
            "ins_sizes[i]"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_inode_item",
          "args": [
            "trans",
            "dst_path->nodes[0]",
            "inode_item",
            "inode",
            "inode_only == LOG_INODE_EXISTS",
            "logged_isize"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "fill_inode_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3263-3316",
          "snippet": "static void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "dst_path->nodes[0]",
            "dst_path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "src",
            "start_slot + i"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "dst_path->nodes[0]",
            "dst_path->slots[0]"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ins_data"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_items",
          "args": [
            "trans",
            "log",
            "dst_path",
            "ins_keys",
            "ins_sizes",
            "nr"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4795-4823",
          "snippet": "int btrfs_insert_empty_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    int nr)\n{\n\tint ret = 0;\n\tint slot;\n\tint i;\n\tu32 total_size = 0;\n\tu32 total_data = 0;\n\n\tfor (i = 0; i < nr; i++)\n\t\ttotal_data += data_size[i];\n\n\ttotal_size = total_data + (nr * sizeof(struct btrfs_item));\n\tret = btrfs_search_slot(trans, root, cpu_key, path, total_size, 1);\n\tif (ret == 0)\n\t\treturn -EEXIST;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tslot = path->slots[0];\n\tBUG_ON(slot < 0);\n\n\tsetup_items_for_insert(root, path, cpu_key, data_size,\n\t\t\t       total_data, total_size, nr);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_insert_empty_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    int nr)\n{\n\tint ret = 0;\n\tint slot;\n\tint i;\n\tu32 total_size = 0;\n\tu32 total_data = 0;\n\n\tfor (i = 0; i < nr; i++)\n\t\ttotal_data += data_size[i];\n\n\ttotal_size = total_data + (nr * sizeof(struct btrfs_item));\n\tret = btrfs_search_slot(trans, root, cpu_key, path, total_size, 1);\n\tif (ret == 0)\n\t\treturn -EEXIST;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tslot = path->slots[0];\n\tBUG_ON(slot < 0);\n\n\tsetup_items_for_insert(root, path, cpu_key, data_size,\n\t\t\t       total_data, total_size, nr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "src",
            "i + start_slot"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32)",
            "GFP_NOFS"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ordered_sums"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_INODE_EXISTS 1\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int copy_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct inode *inode,\n\t\t\t       struct btrfs_path *dst_path,\n\t\t\t       struct btrfs_path *src_path, u64 *last_extent,\n\t\t\t       int start_slot, int nr, int inode_only,\n\t\t\t       u64 logged_isize)\n{\n\tunsigned long src_offset;\n\tunsigned long dst_offset;\n\tstruct btrfs_root *log = BTRFS_I(inode)->root->log_root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *src = src_path->nodes[0];\n\tstruct btrfs_key first_key, last_key, key;\n\tint ret;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tchar *ins_data;\n\tint i;\n\tstruct list_head ordered_sums;\n\tint skip_csum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\tbool has_extents = false;\n\tbool need_find_last_extent = true;\n\tbool done = false;\n\n\tINIT_LIST_HEAD(&ordered_sums);\n\n\tins_data = kmalloc(nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\n\tfirst_key.objectid = (u64)-1;\n\n\tins_sizes = (u32 *)ins_data;\n\tins_keys = (struct btrfs_key *)(ins_data + nr * sizeof(u32));\n\n\tfor (i = 0; i < nr; i++) {\n\t\tins_sizes[i] = btrfs_item_size_nr(src, i + start_slot);\n\t\tbtrfs_item_key_to_cpu(src, ins_keys + i, i + start_slot);\n\t}\n\tret = btrfs_insert_empty_items(trans, log, dst_path,\n\t\t\t\t       ins_keys, ins_sizes, nr);\n\tif (ret) {\n\t\tkfree(ins_data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr; i++, dst_path->slots[0]++) {\n\t\tdst_offset = btrfs_item_ptr_offset(dst_path->nodes[0],\n\t\t\t\t\t\t   dst_path->slots[0]);\n\n\t\tsrc_offset = btrfs_item_ptr_offset(src, start_slot + i);\n\n\t\tif ((i == (nr - 1)))\n\t\t\tlast_key = ins_keys[i];\n\n\t\tif (ins_keys[i].type == BTRFS_INODE_ITEM_KEY) {\n\t\t\tinode_item = btrfs_item_ptr(dst_path->nodes[0],\n\t\t\t\t\t\t    dst_path->slots[0],\n\t\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tfill_inode_item(trans, dst_path->nodes[0], inode_item,\n\t\t\t\t\tinode, inode_only == LOG_INODE_EXISTS,\n\t\t\t\t\tlogged_isize);\n\t\t} else {\n\t\t\tcopy_extent_buffer(dst_path->nodes[0], src, dst_offset,\n\t\t\t\t\t   src_offset, ins_sizes[i]);\n\t\t}\n\n\t\t/*\n\t\t * We set need_find_last_extent here in case we know we were\n\t\t * processing other items and then walk into the first extent in\n\t\t * the inode.  If we don't hit an extent then nothing changes,\n\t\t * we'll do the last search the next time around.\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\thas_extents = true;\n\t\t\tif (first_key.objectid == (u64)-1)\n\t\t\t\tfirst_key = ins_keys[i];\n\t\t} else {\n\t\t\tneed_find_last_extent = false;\n\t\t}\n\n\t\t/* take a reference on file data extents so that truncates\n\t\t * or deletes of this inode don't have to relog the inode\n\t\t * again\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY &&\n\t\t    !skip_csum) {\n\t\t\tint found_type;\n\t\t\textent = btrfs_item_ptr(src, start_slot + i,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\tif (btrfs_file_extent_generation(src, extent) < trans->transid)\n\t\t\t\tcontinue;\n\n\t\t\tfound_type = btrfs_file_extent_type(src, extent);\n\t\t\tif (found_type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t\tu64 ds, dl, cs, cl;\n\t\t\t\tds = btrfs_file_extent_disk_bytenr(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\t/* ds == 0 is a hole */\n\t\t\t\tif (ds == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdl = btrfs_file_extent_disk_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tcs = btrfs_file_extent_offset(src, extent);\n\t\t\t\tcl = btrfs_file_extent_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tif (btrfs_file_extent_compression(src,\n\t\t\t\t\t\t\t\t  extent)) {\n\t\t\t\t\tcs = 0;\n\t\t\t\t\tcl = dl;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_lookup_csums_range(\n\t\t\t\t\t\tlog->fs_info->csum_root,\n\t\t\t\t\t\tds + cs, ds + cs + cl - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tbtrfs_release_path(dst_path);\n\t\t\t\t\tkfree(ins_data);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbtrfs_mark_buffer_dirty(dst_path->nodes[0]);\n\tbtrfs_release_path(dst_path);\n\tkfree(ins_data);\n\n\t/*\n\t * we have to do this after the loop above to avoid changing the\n\t * log tree while trying to change the log tree.\n\t */\n\tret = 0;\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = btrfs_csum_file_blocks(trans, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\tif (!has_extents)\n\t\treturn ret;\n\n\tif (need_find_last_extent && *last_extent == first_key.offset) {\n\t\t/*\n\t\t * We don't have any leafs between our current one and the one\n\t\t * we processed before that can have file extent items for our\n\t\t * inode (and have a generation number smaller than our current\n\t\t * transaction id).\n\t\t */\n\t\tneed_find_last_extent = false;\n\t}\n\n\t/*\n\t * Because we use btrfs_search_forward we could skip leaves that were\n\t * not modified and then assume *last_extent is valid when it really\n\t * isn't.  So back up to the previous leaf and read the end of the last\n\t * extent before we go and fill in holes.\n\t */\n\tif (need_find_last_extent) {\n\t\tu64 len;\n\n\t\tret = btrfs_prev_leaf(BTRFS_I(inode)->root, src_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\tgoto fill_holes;\n\t\tif (src_path->slots[0])\n\t\t\tsrc_path->slots[0]--;\n\t\tsrc = src_path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(src, &key, src_path->slots[0]);\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto fill_holes;\n\t\textent = btrfs_item_ptr(src, src_path->slots[0],\n\t\t\t\t\tstruct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src,\n\t\t\t\t\t\t\t   src_path->slots[0],\n\t\t\t\t\t\t\t   extent);\n\t\t\t*last_extent = ALIGN(key.offset + len,\n\t\t\t\t\t     log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\t*last_extent = key.offset + len;\n\t\t}\n\t}\nfill_holes:\n\t/* So we did prev_leaf, now we need to move to the next leaf, but a few\n\t * things could have happened\n\t *\n\t * 1) A merge could have happened, so we could currently be on a leaf\n\t * that holds what we were copying in the first place.\n\t * 2) A split could have happened, and now not all of the items we want\n\t * are on the same leaf.\n\t *\n\t * So we need to adjust how we search for holes, we need to drop the\n\t * path and re-search for the first extent key we found, and then walk\n\t * forward until we hit the last one we copied.\n\t */\n\tif (need_find_last_extent) {\n\t\t/* btrfs_prev_leaf could return 1 without releasing the path */\n\t\tbtrfs_release_path(src_path);\n\t\tret = btrfs_search_slot(NULL, BTRFS_I(inode)->root, &first_key,\n\t\t\t\t\tsrc_path, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tASSERT(ret == 0);\n\t\tsrc = src_path->nodes[0];\n\t\ti = src_path->slots[0];\n\t} else {\n\t\ti = start_slot;\n\t}\n\n\t/*\n\t * Ok so here we need to go through and fill in any holes we may have\n\t * to make sure that holes are punched for those areas in case they had\n\t * extents previously.\n\t */\n\twhile (!done) {\n\t\tu64 offset, len;\n\t\tu64 extent_end;\n\n\t\tif (i >= btrfs_header_nritems(src_path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(BTRFS_I(inode)->root, src_path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tASSERT(ret == 0);\n\t\t\tsrc = src_path->nodes[0];\n\t\t\ti = 0;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(src, &key, i);\n\t\tif (!btrfs_comp_cpu_keys(&key, &last_key))\n\t\t\tdone = true;\n\t\tif (key.objectid != btrfs_ino(inode) ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\textent = btrfs_item_ptr(src, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(src, extent) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tlen = btrfs_file_extent_inline_len(src, i, extent);\n\t\t\textent_end = ALIGN(key.offset + len, log->sectorsize);\n\t\t} else {\n\t\t\tlen = btrfs_file_extent_num_bytes(src, extent);\n\t\t\textent_end = key.offset + len;\n\t\t}\n\t\ti++;\n\n\t\tif (*last_extent == key.offset) {\n\t\t\t*last_extent = extent_end;\n\t\t\tcontinue;\n\t\t}\n\t\toffset = *last_extent;\n\t\tlen = key.offset - *last_extent;\n\t\tret = btrfs_insert_file_extent(trans, log, btrfs_ino(inode),\n\t\t\t\t\t       offset, 0, 0, len, 0, len, 0,\n\t\t\t\t\t       0, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t*last_extent = extent_end;\n\t}\n\t/*\n\t * Need to let the callers know we dropped the path so they should\n\t * re-search.\n\t */\n\tif (!ret && need_find_last_extent)\n\t\tret = 1;\n\treturn ret;\n}"
  },
  {
    "function_name": "log_inode_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3318-3335",
    "snippet": "static int log_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log, struct btrfs_path *path,\n\t\t\t  struct inode *inode)\n{\n\tstruct btrfs_inode_item *inode_item;\n\tint ret;\n\n\tret = btrfs_insert_empty_item(trans, log, path,\n\t\t\t\t      &BTRFS_I(inode)->location,\n\t\t\t\t      sizeof(*inode_item));\n\tif (ret && ret != -EEXIST)\n\t\treturn ret;\n\tinode_item = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tfill_inode_item(trans, path->nodes[0], inode_item, inode, 0, 0);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_inode_item",
          "args": [
            "trans",
            "path->nodes[0]",
            "inode_item",
            "inode",
            "0",
            "0"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "fill_inode_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3263-3316",
          "snippet": "static void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "log",
            "path",
            "&BTRFS_I(inode)->location",
            "sizeof(*inode_item)"
          ],
          "line": 3325
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int log_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log, struct btrfs_path *path,\n\t\t\t  struct inode *inode)\n{\n\tstruct btrfs_inode_item *inode_item;\n\tint ret;\n\n\tret = btrfs_insert_empty_item(trans, log, path,\n\t\t\t\t      &BTRFS_I(inode)->location,\n\t\t\t\t      sizeof(*inode_item));\n\tif (ret && ret != -EEXIST)\n\t\treturn ret;\n\tinode_item = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tfill_inode_item(trans, path->nodes[0], inode_item, inode, 0, 0);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_inode_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3263-3316",
    "snippet": "static void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_block_group",
          "args": [
            "leaf",
            "item",
            "0",
            "&token"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_flags",
          "args": [
            "leaf",
            "item",
            "BTRFS_I(inode)->flags",
            "&token"
          ],
          "line": 3314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3314
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_rdev",
          "args": [
            "leaf",
            "item",
            "inode->i_rdev",
            "&token"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_transid",
          "args": [
            "leaf",
            "item",
            "trans->transid",
            "&token"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_sequence",
          "args": [
            "leaf",
            "item",
            "inode->i_version",
            "&token"
          ],
          "line": 3311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_nbytes",
          "args": [
            "leaf",
            "item",
            "inode_get_bytes(inode)",
            "&token"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_get_bytes",
          "args": [
            "inode"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "inode_get_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "491-499",
          "snippet": "loff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nloff_t inode_get_bytes(struct inode *inode)\n{\n\tloff_t ret;\n\n\tspin_lock(&inode->i_lock);\n\tret = (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_timespec_nsec",
          "args": [
            "leaf",
            "&item->ctime",
            "inode->i_ctime.tv_nsec",
            "&token"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_timespec_sec",
          "args": [
            "leaf",
            "&item->ctime",
            "inode->i_ctime.tv_sec",
            "&token"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_timespec_nsec",
          "args": [
            "leaf",
            "&item->mtime",
            "inode->i_mtime.tv_nsec",
            "&token"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_timespec_sec",
          "args": [
            "leaf",
            "&item->mtime",
            "inode->i_mtime.tv_sec",
            "&token"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_timespec_nsec",
          "args": [
            "leaf",
            "&item->atime",
            "inode->i_atime.tv_nsec",
            "&token"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_timespec_sec",
          "args": [
            "leaf",
            "&item->atime",
            "inode->i_atime.tv_sec",
            "&token"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_nlink",
          "args": [
            "leaf",
            "item",
            "inode->i_nlink",
            "&token"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_mode",
          "args": [
            "leaf",
            "item",
            "inode->i_mode",
            "&token"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_gid",
          "args": [
            "leaf",
            "item",
            "i_gid_read(inode)",
            "&token"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_uid",
          "args": [
            "leaf",
            "item",
            "i_uid_read(inode)",
            "&token"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 3288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_size",
          "args": [
            "leaf",
            "item",
            "inode->i_size",
            "&token"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_generation",
          "args": [
            "leaf",
            "item",
            "BTRFS_I(inode)->generation",
            "&token"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_size",
          "args": [
            "leaf",
            "item",
            "logged_isize",
            "&token"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_generation",
          "args": [
            "leaf",
            "item",
            "0",
            "&token"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}"
  },
  {
    "function_name": "drop_objectid_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3212-3261",
    "snippet": "static int drop_objectid_items(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  u64 objectid, int max_key_type)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint start_slot;\n\n\tkey.objectid = objectid;\n\tkey.type = max_key_type;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, log, &key, path, -1, 1);\n\t\tBUG_ON(ret == 0); /* Logic error */\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0)\n\t\t\tbreak;\n\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\n\t\tif (found_key.objectid != objectid)\n\t\t\tbreak;\n\n\t\tfound_key.offset = 0;\n\t\tfound_key.type = 0;\n\t\tret = btrfs_bin_search(path->nodes[0], &found_key, 0,\n\t\t\t\t       &start_slot);\n\n\t\tret = btrfs_del_items(trans, log, path, start_slot,\n\t\t\t\t      path->slots[0] - start_slot + 1);\n\t\t/*\n\t\t * If start slot isn't 0 then we don't need to re-search, we've\n\t\t * found the last guy with the objectid in this tree.\n\t\t */\n\t\tif (ret || start_slot != 0)\n\t\t\tbreak;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_items",
          "args": [
            "trans",
            "log",
            "path",
            "start_slot",
            "path->slots[0] - start_slot + 1"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4930-5039",
          "snippet": "int btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_bin_search",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "0",
            "&start_slot"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1827-1831",
          "snippet": "int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == 0"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "log",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int drop_objectid_items(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  u64 objectid, int max_key_type)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint start_slot;\n\n\tkey.objectid = objectid;\n\tkey.type = max_key_type;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, log, &key, path, -1, 1);\n\t\tBUG_ON(ret == 0); /* Logic error */\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0)\n\t\t\tbreak;\n\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\n\t\tif (found_key.objectid != objectid)\n\t\t\tbreak;\n\n\t\tfound_key.offset = 0;\n\t\tfound_key.type = 0;\n\t\tret = btrfs_bin_search(path->nodes[0], &found_key, 0,\n\t\t\t\t       &start_slot);\n\n\t\tret = btrfs_del_items(trans, log, path, start_slot,\n\t\t\t\t      path->slots[0] - start_slot + 1);\n\t\t/*\n\t\t * If start slot isn't 0 then we don't need to re-search, we've\n\t\t * found the last guy with the objectid in this tree.\n\t\t */\n\t\tif (ret || start_slot != 0)\n\t\t\tbreak;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "log_directory_changes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3175-3204",
    "snippet": "static noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\tint key_type = BTRFS_DIR_ITEM_KEY;\n\nagain:\n\tmin_key = 0;\n\tmax_key = 0;\n\twhile (1) {\n\t\tret = log_dir_items(trans, root, inode, path,\n\t\t\t\t    dst_path, key_type, min_key,\n\t\t\t\t    &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\tif (key_type == BTRFS_DIR_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_INDEX_KEY;\n\t\tgoto again;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_dir_items",
          "args": [
            "trans",
            "root",
            "inode",
            "path",
            "dst_path",
            "key_type",
            "min_key",
            "&max_key"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "log_dir_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3019-3161",
          "snippet": "static noinline int log_dir_items(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path, int key_type,\n\t\t\t  u64 min_offset, u64 *last_offset_ret)\n{\n\tstruct btrfs_key min_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src;\n\tint err = 0;\n\tint ret;\n\tint i;\n\tint nritems;\n\tu64 first_offset = min_offset;\n\tu64 last_offset = (u64)-1;\n\tu64 ino = btrfs_ino(inode);\n\n\tlog = root->log_root;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = key_type;\n\tmin_key.offset = min_offset;\n\n\tret = btrfs_search_forward(root, &min_key, path, trans->transid);\n\n\t/*\n\t * we didn't find anything from this transaction, see if there\n\t * is anything at all\n\t */\n\tif (ret != 0 || min_key.objectid != ino || min_key.type != key_type) {\n\t\tmin_key.objectid = ino;\n\t\tmin_key.type = key_type;\n\t\tmin_key.offset = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn ret;\n\t\t}\n\t\tret = btrfs_previous_item(root, path, ino, key_type);\n\n\t\t/* if ret == 0 there are items for this type,\n\t\t * create a range to tell us the last key of this type.\n\t\t * otherwise, there are no items in this directory after\n\t\t * *min_offset, and we create a range to indicate that.\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_key tmp;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key_type == tmp.type)\n\t\t\t\tfirst_offset = max(min_offset, tmp.offset) + 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* go backward to find any previous key */\n\tret = btrfs_previous_item(root, path, ino, key_type);\n\tif (ret == 0) {\n\t\tstruct btrfs_key tmp;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (key_type == tmp.type) {\n\t\t\tfirst_offset = tmp.offset;\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* find the first key from this transaction again */\n\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\tif (WARN_ON(ret != 0))\n\t\tgoto done;\n\n\t/*\n\t * we have a block from this transaction, log every item in it\n\t * from our directory\n\t */\n\twhile (1) {\n\t\tstruct btrfs_key tmp;\n\t\tsrc = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(src);\n\t\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\t\tbtrfs_item_key_to_cpu(src, &min_key, i);\n\n\t\t\tif (min_key.objectid != ino || min_key.type != key_type)\n\t\t\t\tgoto done;\n\t\t\tret = overwrite_item(trans, log, dst_path, src, i,\n\t\t\t\t\t     &min_key);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tpath->slots[0] = nritems;\n\n\t\t/*\n\t\t * look ahead to the next item and see if it is also\n\t\t * from this directory and from this transaction\n\t\t */\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret == 1) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (tmp.objectid != ino || tmp.type != key_type) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (btrfs_header_generation(path->nodes[0]) != trans->transid) {\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tlast_offset = tmp.offset;\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\n\tif (err == 0) {\n\t\t*last_offset_ret = last_offset;\n\t\t/*\n\t\t * insert the log range keys to indicate where the log\n\t\t * is valid\n\t\t */\n\t\tret = insert_dir_log_key(trans, log, path, key_type,\n\t\t\t\t\t ino, first_offset, last_offset);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int log_dir_items(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path, int key_type,\n\t\t\t  u64 min_offset, u64 *last_offset_ret)\n{\n\tstruct btrfs_key min_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src;\n\tint err = 0;\n\tint ret;\n\tint i;\n\tint nritems;\n\tu64 first_offset = min_offset;\n\tu64 last_offset = (u64)-1;\n\tu64 ino = btrfs_ino(inode);\n\n\tlog = root->log_root;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = key_type;\n\tmin_key.offset = min_offset;\n\n\tret = btrfs_search_forward(root, &min_key, path, trans->transid);\n\n\t/*\n\t * we didn't find anything from this transaction, see if there\n\t * is anything at all\n\t */\n\tif (ret != 0 || min_key.objectid != ino || min_key.type != key_type) {\n\t\tmin_key.objectid = ino;\n\t\tmin_key.type = key_type;\n\t\tmin_key.offset = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn ret;\n\t\t}\n\t\tret = btrfs_previous_item(root, path, ino, key_type);\n\n\t\t/* if ret == 0 there are items for this type,\n\t\t * create a range to tell us the last key of this type.\n\t\t * otherwise, there are no items in this directory after\n\t\t * *min_offset, and we create a range to indicate that.\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_key tmp;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key_type == tmp.type)\n\t\t\t\tfirst_offset = max(min_offset, tmp.offset) + 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* go backward to find any previous key */\n\tret = btrfs_previous_item(root, path, ino, key_type);\n\tif (ret == 0) {\n\t\tstruct btrfs_key tmp;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (key_type == tmp.type) {\n\t\t\tfirst_offset = tmp.offset;\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* find the first key from this transaction again */\n\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\tif (WARN_ON(ret != 0))\n\t\tgoto done;\n\n\t/*\n\t * we have a block from this transaction, log every item in it\n\t * from our directory\n\t */\n\twhile (1) {\n\t\tstruct btrfs_key tmp;\n\t\tsrc = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(src);\n\t\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\t\tbtrfs_item_key_to_cpu(src, &min_key, i);\n\n\t\t\tif (min_key.objectid != ino || min_key.type != key_type)\n\t\t\t\tgoto done;\n\t\t\tret = overwrite_item(trans, log, dst_path, src, i,\n\t\t\t\t\t     &min_key);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tpath->slots[0] = nritems;\n\n\t\t/*\n\t\t * look ahead to the next item and see if it is also\n\t\t * from this directory and from this transaction\n\t\t */\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret == 1) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (tmp.objectid != ino || tmp.type != key_type) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (btrfs_header_generation(path->nodes[0]) != trans->transid) {\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tlast_offset = tmp.offset;\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\n\tif (err == 0) {\n\t\t*last_offset_ret = last_offset;\n\t\t/*\n\t\t * insert the log range keys to indicate where the log\n\t\t * is valid\n\t\t */\n\t\tret = insert_dir_log_key(trans, log, path, key_type,\n\t\t\t\t\t ino, first_offset, last_offset);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\tint key_type = BTRFS_DIR_ITEM_KEY;\n\nagain:\n\tmin_key = 0;\n\tmax_key = 0;\n\twhile (1) {\n\t\tret = log_dir_items(trans, root, inode, path,\n\t\t\t\t    dst_path, key_type, min_key,\n\t\t\t\t    &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\tif (key_type == BTRFS_DIR_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_INDEX_KEY;\n\t\tgoto again;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "log_dir_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "3019-3161",
    "snippet": "static noinline int log_dir_items(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path, int key_type,\n\t\t\t  u64 min_offset, u64 *last_offset_ret)\n{\n\tstruct btrfs_key min_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src;\n\tint err = 0;\n\tint ret;\n\tint i;\n\tint nritems;\n\tu64 first_offset = min_offset;\n\tu64 last_offset = (u64)-1;\n\tu64 ino = btrfs_ino(inode);\n\n\tlog = root->log_root;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = key_type;\n\tmin_key.offset = min_offset;\n\n\tret = btrfs_search_forward(root, &min_key, path, trans->transid);\n\n\t/*\n\t * we didn't find anything from this transaction, see if there\n\t * is anything at all\n\t */\n\tif (ret != 0 || min_key.objectid != ino || min_key.type != key_type) {\n\t\tmin_key.objectid = ino;\n\t\tmin_key.type = key_type;\n\t\tmin_key.offset = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn ret;\n\t\t}\n\t\tret = btrfs_previous_item(root, path, ino, key_type);\n\n\t\t/* if ret == 0 there are items for this type,\n\t\t * create a range to tell us the last key of this type.\n\t\t * otherwise, there are no items in this directory after\n\t\t * *min_offset, and we create a range to indicate that.\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_key tmp;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key_type == tmp.type)\n\t\t\t\tfirst_offset = max(min_offset, tmp.offset) + 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* go backward to find any previous key */\n\tret = btrfs_previous_item(root, path, ino, key_type);\n\tif (ret == 0) {\n\t\tstruct btrfs_key tmp;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (key_type == tmp.type) {\n\t\t\tfirst_offset = tmp.offset;\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* find the first key from this transaction again */\n\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\tif (WARN_ON(ret != 0))\n\t\tgoto done;\n\n\t/*\n\t * we have a block from this transaction, log every item in it\n\t * from our directory\n\t */\n\twhile (1) {\n\t\tstruct btrfs_key tmp;\n\t\tsrc = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(src);\n\t\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\t\tbtrfs_item_key_to_cpu(src, &min_key, i);\n\n\t\t\tif (min_key.objectid != ino || min_key.type != key_type)\n\t\t\t\tgoto done;\n\t\t\tret = overwrite_item(trans, log, dst_path, src, i,\n\t\t\t\t\t     &min_key);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tpath->slots[0] = nritems;\n\n\t\t/*\n\t\t * look ahead to the next item and see if it is also\n\t\t * from this directory and from this transaction\n\t\t */\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret == 1) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (tmp.objectid != ino || tmp.type != key_type) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (btrfs_header_generation(path->nodes[0]) != trans->transid) {\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tlast_offset = tmp.offset;\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\n\tif (err == 0) {\n\t\t*last_offset_ret = last_offset;\n\t\t/*\n\t\t * insert the log range keys to indicate where the log\n\t\t * is valid\n\t\t */\n\t\tret = insert_dir_log_key(trans, log, path, key_type,\n\t\t\t\t\t ino, first_offset, last_offset);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_dir_log_key",
          "args": [
            "trans",
            "log",
            "path",
            "key_type",
            "ino",
            "first_offset",
            "last_offset"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "insert_dir_log_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2986-3012",
          "snippet": "static noinline int insert_dir_log_key(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       int key_type, u64 dirid,\n\t\t\t\t       u64 first_offset, u64 last_offset)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_log_item *item;\n\n\tkey.objectid = dirid;\n\tkey.offset = first_offset;\n\tif (key_type == BTRFS_DIR_ITEM_KEY)\n\t\tkey.type = BTRFS_DIR_LOG_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_DIR_LOG_INDEX_KEY;\n\tret = btrfs_insert_empty_item(trans, log, path, &key, sizeof(*item));\n\tif (ret)\n\t\treturn ret;\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tbtrfs_set_dir_log_end(path->nodes[0], item, last_offset);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int insert_dir_log_key(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       int key_type, u64 dirid,\n\t\t\t\t       u64 first_offset, u64 last_offset)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_log_item *item;\n\n\tkey.objectid = dirid;\n\tkey.offset = first_offset;\n\tif (key_type == BTRFS_DIR_ITEM_KEY)\n\t\tkey.type = BTRFS_DIR_LOG_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_DIR_LOG_INDEX_KEY;\n\tret = btrfs_insert_empty_item(trans, log, path, &key, sizeof(*item));\n\tif (ret)\n\t\treturn ret;\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tbtrfs_set_dir_log_end(path->nodes[0], item, last_offset);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "dst_path"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "overwrite_item",
          "args": [
            "trans",
            "log",
            "dst_path",
            "path->nodes[0]",
            "path->slots[0]",
            "&tmp"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "overwrite_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "341-539",
          "snippet": "static noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "path->nodes[0]"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&tmp",
            "path->slots[0]"
          ],
          "line": 3129
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "src"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret != 0"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&min_key",
            "path",
            "0",
            "0"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_item",
          "args": [
            "root",
            "path",
            "ino",
            "key_type"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5830-5865",
          "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "min_offset",
            "tmp.offset"
          ],
          "line": 3070
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_forward",
          "args": [
            "root",
            "&min_key",
            "path",
            "trans->transid"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5113-5211",
          "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int log_dir_items(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path, int key_type,\n\t\t\t  u64 min_offset, u64 *last_offset_ret)\n{\n\tstruct btrfs_key min_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src;\n\tint err = 0;\n\tint ret;\n\tint i;\n\tint nritems;\n\tu64 first_offset = min_offset;\n\tu64 last_offset = (u64)-1;\n\tu64 ino = btrfs_ino(inode);\n\n\tlog = root->log_root;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = key_type;\n\tmin_key.offset = min_offset;\n\n\tret = btrfs_search_forward(root, &min_key, path, trans->transid);\n\n\t/*\n\t * we didn't find anything from this transaction, see if there\n\t * is anything at all\n\t */\n\tif (ret != 0 || min_key.objectid != ino || min_key.type != key_type) {\n\t\tmin_key.objectid = ino;\n\t\tmin_key.type = key_type;\n\t\tmin_key.offset = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn ret;\n\t\t}\n\t\tret = btrfs_previous_item(root, path, ino, key_type);\n\n\t\t/* if ret == 0 there are items for this type,\n\t\t * create a range to tell us the last key of this type.\n\t\t * otherwise, there are no items in this directory after\n\t\t * *min_offset, and we create a range to indicate that.\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_key tmp;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key_type == tmp.type)\n\t\t\t\tfirst_offset = max(min_offset, tmp.offset) + 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* go backward to find any previous key */\n\tret = btrfs_previous_item(root, path, ino, key_type);\n\tif (ret == 0) {\n\t\tstruct btrfs_key tmp;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (key_type == tmp.type) {\n\t\t\tfirst_offset = tmp.offset;\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* find the first key from this transaction again */\n\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\tif (WARN_ON(ret != 0))\n\t\tgoto done;\n\n\t/*\n\t * we have a block from this transaction, log every item in it\n\t * from our directory\n\t */\n\twhile (1) {\n\t\tstruct btrfs_key tmp;\n\t\tsrc = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(src);\n\t\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\t\tbtrfs_item_key_to_cpu(src, &min_key, i);\n\n\t\t\tif (min_key.objectid != ino || min_key.type != key_type)\n\t\t\t\tgoto done;\n\t\t\tret = overwrite_item(trans, log, dst_path, src, i,\n\t\t\t\t\t     &min_key);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tpath->slots[0] = nritems;\n\n\t\t/*\n\t\t * look ahead to the next item and see if it is also\n\t\t * from this directory and from this transaction\n\t\t */\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret == 1) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (tmp.objectid != ino || tmp.type != key_type) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (btrfs_header_generation(path->nodes[0]) != trans->transid) {\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tlast_offset = tmp.offset;\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\n\tif (err == 0) {\n\t\t*last_offset_ret = last_offset;\n\t\t/*\n\t\t * insert the log range keys to indicate where the log\n\t\t * is valid\n\t\t */\n\t\tret = insert_dir_log_key(trans, log, path, key_type,\n\t\t\t\t\t ino, first_offset, last_offset);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "insert_dir_log_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2986-3012",
    "snippet": "static noinline int insert_dir_log_key(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       int key_type, u64 dirid,\n\t\t\t\t       u64 first_offset, u64 last_offset)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_log_item *item;\n\n\tkey.objectid = dirid;\n\tkey.offset = first_offset;\n\tif (key_type == BTRFS_DIR_ITEM_KEY)\n\t\tkey.type = BTRFS_DIR_LOG_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_DIR_LOG_INDEX_KEY;\n\tret = btrfs_insert_empty_item(trans, log, path, &key, sizeof(*item));\n\tif (ret)\n\t\treturn ret;\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tbtrfs_set_dir_log_end(path->nodes[0], item, last_offset);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[0]"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_dir_log_end",
          "args": [
            "path->nodes[0]",
            "item",
            "last_offset"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_dir_log_item"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "log",
            "path",
            "&key",
            "sizeof(*item)"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int insert_dir_log_key(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       int key_type, u64 dirid,\n\t\t\t\t       u64 first_offset, u64 last_offset)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_log_item *item;\n\n\tkey.objectid = dirid;\n\tkey.offset = first_offset;\n\tif (key_type == BTRFS_DIR_ITEM_KEY)\n\t\tkey.type = BTRFS_DIR_LOG_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_DIR_LOG_INDEX_KEY;\n\tret = btrfs_insert_empty_item(trans, log, path, &key, sizeof(*item));\n\tif (ret)\n\t\treturn ret;\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tbtrfs_set_dir_log_end(path->nodes[0], item, last_offset);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_del_inode_ref_in_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2950-2979",
    "snippet": "int btrfs_del_inode_ref_in_log(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       const char *name, int name_len,\n\t\t\t       struct inode *inode, u64 dirid)\n{\n\tstruct btrfs_root *log;\n\tu64 index;\n\tint ret;\n\n\tif (BTRFS_I(inode)->logged_trans < trans->transid)\n\t\treturn 0;\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn 0;\n\tlog = root->log_root;\n\tmutex_lock(&BTRFS_I(inode)->log_mutex);\n\n\tret = btrfs_del_inode_ref(trans, log, name, name_len, btrfs_ino(inode),\n\t\t\t\t  dirid, &index);\n\tmutex_unlock(&BTRFS_I(inode)->log_mutex);\n\tif (ret == -ENOSPC) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 0;\n\t} else if (ret < 0 && ret != -ENOENT)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\tbtrfs_end_log_trans(root);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_log_trans",
          "args": [
            "root"
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_log_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "238-245",
          "snippet": "void btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_log_full_commit",
          "args": [
            "root->fs_info",
            "trans"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_log_full_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "43-47",
          "snippet": "static inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&BTRFS_I(inode)->log_mutex"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_inode_ref",
          "args": [
            "trans",
            "log",
            "name",
            "name_len",
            "btrfs_ino(inode)",
            "dirid",
            "&index"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-item.c",
          "lines": "193-263",
          "snippet": "int btrfs_del_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root,\n\t\t\tconst char *name, int name_len,\n\t\t\tu64 inode_objectid, u64 ref_objectid, u64 *index)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\tunsigned long item_start;\n\tu32 item_size;\n\tu32 sub_item_len;\n\tint ret;\n\tint search_ext_refs = 0;\n\tint del_len = name_len + sizeof(*ref);\n\n\tkey.objectid = inode_objectid;\n\tkey.offset = ref_objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t} else if (ret < 0) {\n\t\tgoto out;\n\t}\n\tif (!find_name_in_backref(path, name, name_len, &ref)) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\n\tif (index)\n\t\t*index = btrfs_inode_ref_index(leaf, ref);\n\n\tif (del_len == item_size) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tgoto out;\n\t}\n\tptr = (unsigned long)ref;\n\tsub_item_len = name_len + sizeof(*ref);\n\titem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\t      item_size - (ptr + sub_item_len - item_start));\n\tbtrfs_truncate_item(root, path, item_size - sub_item_len, 1);\nout:\n\tbtrfs_free_path(path);\n\n\tif (search_ext_refs) {\n\t\t/*\n\t\t * No refs were found, or we could not find the\n\t\t * name in our ref array. Find and remove the extended\n\t\t * inode ref then.\n\t\t */\n\t\treturn btrfs_del_inode_extref(trans, root, name, name_len,\n\t\t\t\t\t      inode_objectid, ref_objectid, index);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_del_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root,\n\t\t\tconst char *name, int name_len,\n\t\t\tu64 inode_objectid, u64 ref_objectid, u64 *index)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_ref *ref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\tunsigned long item_start;\n\tu32 item_size;\n\tu32 sub_item_len;\n\tint ret;\n\tint search_ext_refs = 0;\n\tint del_len = name_len + sizeof(*ref);\n\n\tkey.objectid = inode_objectid;\n\tkey.offset = ref_objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->leave_spinning = 1;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t} else if (ret < 0) {\n\t\tgoto out;\n\t}\n\tif (!find_name_in_backref(path, name, name_len, &ref)) {\n\t\tret = -ENOENT;\n\t\tsearch_ext_refs = 1;\n\t\tgoto out;\n\t}\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\n\tif (index)\n\t\t*index = btrfs_inode_ref_index(leaf, ref);\n\n\tif (del_len == item_size) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tgoto out;\n\t}\n\tptr = (unsigned long)ref;\n\tsub_item_len = name_len + sizeof(*ref);\n\titem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\t      item_size - (ptr + sub_item_len - item_start));\n\tbtrfs_truncate_item(root, path, item_size - sub_item_len, 1);\nout:\n\tbtrfs_free_path(path);\n\n\tif (search_ext_refs) {\n\t\t/*\n\t\t * No refs were found, or we could not find the\n\t\t * name in our ref array. Find and remove the extended\n\t\t * inode ref then.\n\t\t */\n\t\treturn btrfs_del_inode_extref(trans, root, name, name_len,\n\t\t\t\t\t      inode_objectid, ref_objectid, index);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&BTRFS_I(inode)->log_mutex"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_running_log_trans",
          "args": [
            "root"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "join_running_log_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "202-217",
          "snippet": "static int join_running_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tsmp_mb();\n\tif (!root->log_root)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tret = 0;\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int join_running_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tsmp_mb();\n\tif (!root->log_root)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tret = 0;\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_del_inode_ref_in_log(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       const char *name, int name_len,\n\t\t\t       struct inode *inode, u64 dirid)\n{\n\tstruct btrfs_root *log;\n\tu64 index;\n\tint ret;\n\n\tif (BTRFS_I(inode)->logged_trans < trans->transid)\n\t\treturn 0;\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn 0;\n\tlog = root->log_root;\n\tmutex_lock(&BTRFS_I(inode)->log_mutex);\n\n\tret = btrfs_del_inode_ref(trans, log, name, name_len, btrfs_ino(inode),\n\t\t\t\t  dirid, &index);\n\tmutex_unlock(&BTRFS_I(inode)->log_mutex);\n\tif (ret == -ENOSPC) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 0;\n\t} else if (ret < 0 && ret != -ENOENT)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\tbtrfs_end_log_trans(root);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_del_dir_entries_in_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2842-2947",
    "snippet": "int btrfs_del_dir_entries_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t const char *name, int name_len,\n\t\t\t\t struct inode *dir, u64 index)\n{\n\tstruct btrfs_root *log;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint err = 0;\n\tint bytes_del = 0;\n\tu64 dir_ino = btrfs_ino(dir);\n\n\tif (BTRFS_I(dir)->logged_trans < trans->transid)\n\t\treturn 0;\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn 0;\n\n\tmutex_lock(&BTRFS_I(dir)->log_mutex);\n\n\tlog = root->log_root;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tdi = btrfs_lookup_dir_item(trans, log, path, dir_ino,\n\t\t\t\t   name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tbytes_del += name_len;\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tdi = btrfs_lookup_dir_index_item(trans, log, path, dir_ino,\n\t\t\t\t\t index, name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tbytes_del += name_len;\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* update the directory size in the log to reflect the names\n\t * we have removed\n\t */\n\tif (bytes_del) {\n\t\tstruct btrfs_key key;\n\n\t\tkey.objectid = dir_ino;\n\t\tkey.offset = 0;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_search_slot(trans, log, &key, path, 0, 1);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 i_size;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\ti_size = btrfs_inode_size(path->nodes[0], item);\n\t\t\tif (i_size > bytes_del)\n\t\t\t\ti_size -= bytes_del;\n\t\t\telse\n\t\t\t\ti_size = 0;\n\t\t\tbtrfs_set_inode_size(path->nodes[0], item, i_size);\n\t\t\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\t\t} else\n\t\t\tret = 0;\n\t\tbtrfs_release_path(path);\n\t}\nfail:\n\tbtrfs_free_path(path);\nout_unlock:\n\tmutex_unlock(&BTRFS_I(dir)->log_mutex);\n\tif (ret == -ENOSPC) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 0;\n\t} else if (ret < 0)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\tbtrfs_end_log_trans(root);\n\n\treturn err;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_log_trans",
          "args": [
            "root"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_log_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "238-245",
          "snippet": "void btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_log_full_commit",
          "args": [
            "root->fs_info",
            "trans"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_log_full_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "43-47",
          "snippet": "static inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&BTRFS_I(dir)->log_mutex"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dir"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[0]"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_size",
          "args": [
            "path->nodes[0]",
            "item",
            "i_size"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "path->nodes[0]",
            "item"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "log",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delete_one_dir_name",
          "args": [
            "trans",
            "log",
            "path",
            "di"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delete_one_dir_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "420-448",
          "snippet": "int btrfs_delete_one_dir_name(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct btrfs_dir_item *di)\n{\n\n\tstruct extent_buffer *leaf;\n\tu32 sub_item_len;\n\tu32 item_len;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tsub_item_len = sizeof(*di) + btrfs_dir_name_len(leaf, di) +\n\t\tbtrfs_dir_data_len(leaf, di);\n\titem_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (sub_item_len == item_len) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t} else {\n\t\t/* MARKER */\n\t\tunsigned long ptr = (unsigned long)di;\n\t\tunsigned long start;\n\n\t\tstart = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\titem_len - (ptr + sub_item_len - start));\n\t\tbtrfs_truncate_item(root, path, item_len - sub_item_len, 1);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_delete_one_dir_name(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      struct btrfs_dir_item *di)\n{\n\n\tstruct extent_buffer *leaf;\n\tu32 sub_item_len;\n\tu32 item_len;\n\tint ret = 0;\n\n\tleaf = path->nodes[0];\n\tsub_item_len = sizeof(*di) + btrfs_dir_name_len(leaf, di) +\n\t\tbtrfs_dir_data_len(leaf, di);\n\titem_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (sub_item_len == item_len) {\n\t\tret = btrfs_del_item(trans, root, path);\n\t} else {\n\t\t/* MARKER */\n\t\tunsigned long ptr = (unsigned long)di;\n\t\tunsigned long start;\n\n\t\tstart = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\n\t\t\titem_len - (ptr + sub_item_len - start));\n\t\tbtrfs_truncate_item(root, path, item_len - sub_item_len, 1);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_index_item",
          "args": [
            "trans",
            "log",
            "path",
            "dir_ino",
            "index",
            "name",
            "name_len",
            "-1"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_index_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "283-305",
          "snippet": "struct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "di"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "trans",
            "log",
            "path",
            "dir_ino",
            "name",
            "name_len",
            "-1"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&BTRFS_I(dir)->log_mutex"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_running_log_trans",
          "args": [
            "root"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "join_running_log_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "202-217",
          "snippet": "static int join_running_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tsmp_mb();\n\tif (!root->log_root)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tret = 0;\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int join_running_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tsmp_mb();\n\tif (!root->log_root)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tret = 0;\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "dir"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nint btrfs_del_dir_entries_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t const char *name, int name_len,\n\t\t\t\t struct inode *dir, u64 index)\n{\n\tstruct btrfs_root *log;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint err = 0;\n\tint bytes_del = 0;\n\tu64 dir_ino = btrfs_ino(dir);\n\n\tif (BTRFS_I(dir)->logged_trans < trans->transid)\n\t\treturn 0;\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn 0;\n\n\tmutex_lock(&BTRFS_I(dir)->log_mutex);\n\n\tlog = root->log_root;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tdi = btrfs_lookup_dir_item(trans, log, path, dir_ino,\n\t\t\t\t   name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tbytes_del += name_len;\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tdi = btrfs_lookup_dir_index_item(trans, log, path, dir_ino,\n\t\t\t\t\t index, name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tbytes_del += name_len;\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* update the directory size in the log to reflect the names\n\t * we have removed\n\t */\n\tif (bytes_del) {\n\t\tstruct btrfs_key key;\n\n\t\tkey.objectid = dir_ino;\n\t\tkey.offset = 0;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tbtrfs_release_path(path);\n\n\t\tret = btrfs_search_slot(trans, log, &key, path, 0, 1);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 i_size;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\ti_size = btrfs_inode_size(path->nodes[0], item);\n\t\t\tif (i_size > bytes_del)\n\t\t\t\ti_size -= bytes_del;\n\t\t\telse\n\t\t\t\ti_size = 0;\n\t\t\tbtrfs_set_inode_size(path->nodes[0], item, i_size);\n\t\t\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\t\t} else\n\t\t\tret = 0;\n\t\tbtrfs_release_path(path);\n\t}\nfail:\n\tbtrfs_free_path(path);\nout_unlock:\n\tmutex_unlock(&BTRFS_I(dir)->log_mutex);\n\tif (ret == -ENOSPC) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tret = 0;\n\t} else if (ret < 0)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\tbtrfs_end_log_trans(root);\n\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_free_log_root_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2811-2819",
    "snippet": "int btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_log_tree",
          "args": [
            "trans",
            "fs_info->log_root_tree"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "free_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2759-2796",
          "snippet": "static void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tu64 start;\n\tu64 end;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tret = walk_log_tree(trans, log, &wc);\n\t/* I don't think this can happen but just in case */\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, log, ret);\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(&log->dirty_log_pages,\n\t\t\t\t0, &start, &end, EXTENT_DIRTY | EXTENT_NEW,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(&log->dirty_log_pages, start, end,\n\t\t\t\t  EXTENT_DIRTY | EXTENT_NEW, GFP_NOFS);\n\t}\n\n\t/*\n\t * We may have short-circuited the log tree with the full commit logic\n\t * and left ordered extents on our list, so clear these out to keep us\n\t * from leaking inodes and memory.\n\t */\n\tbtrfs_free_logged_extents(log, 0);\n\tbtrfs_free_logged_extents(log, 1);\n\n\tfree_extent_buffer(log->node);\n\tkfree(log);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tu64 start;\n\tu64 end;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tret = walk_log_tree(trans, log, &wc);\n\t/* I don't think this can happen but just in case */\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, log, ret);\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(&log->dirty_log_pages,\n\t\t\t\t0, &start, &end, EXTENT_DIRTY | EXTENT_NEW,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(&log->dirty_log_pages, start, end,\n\t\t\t\t  EXTENT_DIRTY | EXTENT_NEW, GFP_NOFS);\n\t}\n\n\t/*\n\t * We may have short-circuited the log tree with the full commit logic\n\t * and left ordered extents on our list, so clear these out to keep us\n\t * from leaking inodes and memory.\n\t */\n\tbtrfs_free_logged_extents(log, 0);\n\tbtrfs_free_logged_extents(log, 1);\n\n\tfree_extent_buffer(log->node);\n\tkfree(log);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_free_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2802-2809",
    "snippet": "int btrfs_free_log(struct btrfs_trans_handle *trans, struct btrfs_root *root)\n{\n\tif (root->log_root) {\n\t\tfree_log_tree(trans, root->log_root);\n\t\troot->log_root = NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_log_tree",
          "args": [
            "trans",
            "root->log_root"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "free_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2759-2796",
          "snippet": "static void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tu64 start;\n\tu64 end;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tret = walk_log_tree(trans, log, &wc);\n\t/* I don't think this can happen but just in case */\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, log, ret);\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(&log->dirty_log_pages,\n\t\t\t\t0, &start, &end, EXTENT_DIRTY | EXTENT_NEW,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(&log->dirty_log_pages, start, end,\n\t\t\t\t  EXTENT_DIRTY | EXTENT_NEW, GFP_NOFS);\n\t}\n\n\t/*\n\t * We may have short-circuited the log tree with the full commit logic\n\t * and left ordered extents on our list, so clear these out to keep us\n\t * from leaking inodes and memory.\n\t */\n\tbtrfs_free_logged_extents(log, 0);\n\tbtrfs_free_logged_extents(log, 1);\n\n\tfree_extent_buffer(log->node);\n\tkfree(log);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tu64 start;\n\tu64 end;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tret = walk_log_tree(trans, log, &wc);\n\t/* I don't think this can happen but just in case */\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, log, ret);\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(&log->dirty_log_pages,\n\t\t\t\t0, &start, &end, EXTENT_DIRTY | EXTENT_NEW,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(&log->dirty_log_pages, start, end,\n\t\t\t\t  EXTENT_DIRTY | EXTENT_NEW, GFP_NOFS);\n\t}\n\n\t/*\n\t * We may have short-circuited the log tree with the full commit logic\n\t * and left ordered extents on our list, so clear these out to keep us\n\t * from leaking inodes and memory.\n\t */\n\tbtrfs_free_logged_extents(log, 0);\n\tbtrfs_free_logged_extents(log, 1);\n\n\tfree_extent_buffer(log->node);\n\tkfree(log);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_log(struct btrfs_trans_handle *trans, struct btrfs_root *root)\n{\n\tif (root->log_root) {\n\t\tfree_log_tree(trans, root->log_root);\n\t\troot->log_root = NULL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_log_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2759-2796",
    "snippet": "static void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tu64 start;\n\tu64 end;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tret = walk_log_tree(trans, log, &wc);\n\t/* I don't think this can happen but just in case */\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, log, ret);\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(&log->dirty_log_pages,\n\t\t\t\t0, &start, &end, EXTENT_DIRTY | EXTENT_NEW,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(&log->dirty_log_pages, start, end,\n\t\t\t\t  EXTENT_DIRTY | EXTENT_NEW, GFP_NOFS);\n\t}\n\n\t/*\n\t * We may have short-circuited the log tree with the full commit logic\n\t * and left ordered extents on our list, so clear these out to keep us\n\t * from leaking inodes and memory.\n\t */\n\tbtrfs_free_logged_extents(log, 0);\n\tbtrfs_free_logged_extents(log, 1);\n\n\tfree_extent_buffer(log->node);\n\tkfree(log);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "log->node"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_logged_extents",
          "args": [
            "log",
            "1"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_logged_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "518-534",
          "snippet": "void btrfs_free_logged_extents(struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_free_logged_extents(struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_bits",
          "args": [
            "&log->dirty_log_pages",
            "start",
            "end",
            "EXTENT_DIRTY | EXTENT_NEW",
            "GFP_NOFS"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1277-1281",
          "snippet": "int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit",
          "args": [
            "&log->dirty_log_pages",
            "0",
            "&start",
            "&end",
            "EXTENT_DIRTY | EXTENT_NEW",
            "NULL"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1477-1516",
          "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "log",
            "ret"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_log_tree",
          "args": [
            "trans",
            "log",
            "&wc"
          ],
          "line": 2770
        },
        "resolved": true,
        "details": {
          "function_name": "walk_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2336-2404",
          "snippet": "static int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\textent_buffer_get(log->node);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* was the root node processed? if not, catch it here */\n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free) {\n\t\t\tstruct extent_buffer *next;\n\n\t\t\tnext = path->nodes[orig_level];\n\n\t\t\tif (trans) {\n\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\tclean_tree_block(trans, log, next);\n\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t}\n\n\t\t\tWARN_ON(log->root_key.objectid !=\n\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\tret = btrfs_free_and_pin_reserved_extent(log, next->start,\n\t\t\t\t\t\t\t next->len);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\textent_buffer_get(log->node);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* was the root node processed? if not, catch it here */\n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free) {\n\t\t\tstruct extent_buffer *next;\n\n\t\t\tnext = path->nodes[orig_level];\n\n\t\t\tif (trans) {\n\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\tclean_tree_block(trans, log, next);\n\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t}\n\n\t\t\tWARN_ON(log->root_key.objectid !=\n\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\tret = btrfs_free_and_pin_reserved_extent(log, next->start,\n\t\t\t\t\t\t\t next->len);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tu64 start;\n\tu64 end;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tret = walk_log_tree(trans, log, &wc);\n\t/* I don't think this can happen but just in case */\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, log, ret);\n\n\twhile (1) {\n\t\tret = find_first_extent_bit(&log->dirty_log_pages,\n\t\t\t\t0, &start, &end, EXTENT_DIRTY | EXTENT_NEW,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tclear_extent_bits(&log->dirty_log_pages, start, end,\n\t\t\t\t  EXTENT_DIRTY | EXTENT_NEW, GFP_NOFS);\n\t}\n\n\t/*\n\t * We may have short-circuited the log tree with the full commit logic\n\t * and left ordered extents on our list, so clear these out to keep us\n\t * from leaking inodes and memory.\n\t */\n\tbtrfs_free_logged_extents(log, 0);\n\tbtrfs_free_logged_extents(log, 1);\n\n\tfree_extent_buffer(log->node);\n\tkfree(log);\n}"
  },
  {
    "function_name": "btrfs_sync_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2511-2757",
    "snippet": "int btrfs_sync_log(struct btrfs_trans_handle *trans,\n\t\t   struct btrfs_root *root, struct btrfs_log_ctx *ctx)\n{\n\tint index1;\n\tint index2;\n\tint mark;\n\tint ret;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_root *log_root_tree = root->fs_info->log_root_tree;\n\tint log_transid = 0;\n\tstruct btrfs_log_ctx root_log_ctx;\n\tstruct blk_plug plug;\n\n\tmutex_lock(&root->log_mutex);\n\tlog_transid = ctx->log_transid;\n\tif (root->log_transid_committed >= log_transid) {\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\n\tindex1 = log_transid % 2;\n\tif (atomic_read(&root->log_commit[index1])) {\n\t\twait_log_commit(trans, root, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\tASSERT(log_transid == root->log_transid);\n\tatomic_set(&root->log_commit[index1], 1);\n\n\t/* wait for previous tree log sync to complete */\n\tif (atomic_read(&root->log_commit[(index1 + 1) % 2]))\n\t\twait_log_commit(trans, root, log_transid - 1);\n\n\twhile (1) {\n\t\tint batch = atomic_read(&root->log_batch);\n\t\t/* when we're on an ssd, just kick the log commit out */\n\t\tif (!btrfs_test_opt(root, SSD) &&\n\t\t    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {\n\t\t\tmutex_unlock(&root->log_mutex);\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tmutex_lock(&root->log_mutex);\n\t\t}\n\t\twait_for_writer(trans, root);\n\t\tif (batch == atomic_read(&root->log_batch))\n\t\t\tbreak;\n\t}\n\n\t/* bail out if we need to do a full commit */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tret = -EAGAIN;\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_transid % 2 == 0)\n\t\tmark = EXTENT_DIRTY;\n\telse\n\t\tmark = EXTENT_NEW;\n\n\t/* we start IO on  all the marked extents here, but we don't actually\n\t * wait for them until later.\n\t */\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (ret) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_root_node(&log->root_item, log->node);\n\n\troot->log_transid++;\n\tlog->log_transid = root->log_transid;\n\troot->log_start_pid = 0;\n\t/*\n\t * IO has been started, blocks of the log tree have WRITTEN flag set\n\t * in their headers. new modifications of the log will be written to\n\t * new positions. so it's safe to allow log writers to go in.\n\t */\n\tmutex_unlock(&root->log_mutex);\n\n\tbtrfs_init_log_ctx(&root_log_ctx);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tatomic_inc(&log_root_tree->log_batch);\n\tatomic_inc(&log_root_tree->log_writers);\n\n\tindex2 = log_root_tree->log_transid % 2;\n\tlist_add_tail(&root_log_ctx.list, &log_root_tree->log_ctxs[index2]);\n\troot_log_ctx.log_transid = log_root_tree->log_transid;\n\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tret = update_log_root(trans, log);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tif (atomic_dec_and_test(&log_root_tree->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&log_root_tree->log_writer_wait))\n\t\t\twake_up(&log_root_tree->log_writer_wait);\n\t}\n\n\tif (ret) {\n\t\tif (!list_empty(&root_log_ctx.list))\n\t\t\tlist_del_init(&root_log_ctx.list);\n\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\n\t\tif (ret != -ENOSPC) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (log_root_tree->log_transid_committed >= root_log_ctx.log_transid) {\n\t\tblk_finish_plug(&plug);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\n\tindex2 = root_log_ctx.log_transid % 2;\n\tif (atomic_read(&log_root_tree->log_commit[index2])) {\n\t\tblk_finish_plug(&plug);\n\t\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages,\n\t\t\t\t\t\tmark);\n\t\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tif (!ret)\n\t\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\tASSERT(root_log_ctx.log_transid == log_root_tree->log_transid);\n\tatomic_set(&log_root_tree->log_commit[index2], 1);\n\n\tif (atomic_read(&log_root_tree->log_commit[(index2 + 1) % 2])) {\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid - 1);\n\t}\n\n\twait_for_writer(trans, log_root_tree);\n\n\t/*\n\t * now that we've moved on to the tree of log tree roots,\n\t * check the full commit flag again\n\t */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out_wake_log_root;\n\t}\n\n\tret = btrfs_write_marked_extents(log_root_tree,\n\t\t\t\t\t &log_root_tree->dirty_log_pages,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_NEW);\n\tblk_finish_plug(&plug);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (!ret)\n\t\tret = btrfs_wait_marked_extents(log_root_tree,\n\t\t\t\t\t\t&log_root_tree->dirty_log_pages,\n\t\t\t\t\t\tEXTENT_NEW | EXTENT_DIRTY);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_for_commit,\n\t\t\t\tlog_root_tree->node->start);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_for_commit,\n\t\t\t\tbtrfs_header_level(log_root_tree->node));\n\n\tlog_root_tree->log_transid++;\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * nobody else is going to jump in and write the the ctree\n\t * super here because the log_commit atomic below is protecting\n\t * us.  We must be called with a transaction handle pinning\n\t * the running transaction open, so a full commit can't hop\n\t * in and cause problems either.\n\t */\n\tret = write_ctree_super(trans, root->fs_info->tree_root, 1);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->last_log_commit < log_transid)\n\t\troot->last_log_commit = log_transid;\n\tmutex_unlock(&root->log_mutex);\n\nout_wake_log_root:\n\t/*\n\t * We needn't get log_mutex here because we are sure all\n\t * the other tasks are blocked.\n\t */\n\tbtrfs_remove_all_log_ctxs(log_root_tree, index2, ret);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tlog_root_tree->log_transid_committed++;\n\tatomic_set(&log_root_tree->log_commit[index2], 0);\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tif (waitqueue_active(&log_root_tree->log_commit_wait[index2]))\n\t\twake_up(&log_root_tree->log_commit_wait[index2]);\nout:\n\t/* See above. */\n\tbtrfs_remove_all_log_ctxs(root, index1, ret);\n\n\tmutex_lock(&root->log_mutex);\n\troot->log_transid_committed++;\n\tatomic_set(&root->log_commit[index1], 0);\n\tmutex_unlock(&root->log_mutex);\n\n\tif (waitqueue_active(&root->log_commit_wait[index1]))\n\t\twake_up(&root->log_commit_wait[index1]);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&root->log_commit_wait[index1]"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&root->log_commit_wait[index1]"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->log_commit[index1]",
            "0"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remove_all_log_ctxs",
          "args": [
            "root",
            "index1",
            "ret"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remove_all_log_ctxs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2483-2497",
          "snippet": "static inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,\n\t\t\t\t\t     int index, int error)\n{\n\tstruct btrfs_log_ctx *ctx;\n\n\tif (!error) {\n\t\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(ctx, &root->log_ctxs[index], list)\n\t\tctx->log_ret = error;\n\n\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,\n\t\t\t\t\t     int index, int error)\n{\n\tstruct btrfs_log_ctx *ctx;\n\n\tif (!error) {\n\t\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(ctx, &root->log_ctxs[index], list)\n\t\tctx->log_ret = error;\n\n\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&log_root_tree->log_commit_wait[index2]"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&log_root_tree->log_commit[index2]",
            "0"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_log_full_commit",
          "args": [
            "root->fs_info",
            "trans"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_log_full_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "43-47",
          "snippet": "static inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline void btrfs_set_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\tACCESS_ONCE(fs_info->last_trans_log_full_commit) = trans->transid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_ctree_super",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "1"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "write_ctree_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3518-3522",
          "snippet": "int write_ctree_super(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root, int max_mirrors)\n{\n\treturn write_all_supers(root, max_mirrors);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint write_ctree_super(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root, int max_mirrors)\n{\n\treturn write_all_supers(root, max_mirrors);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_log_root_level",
          "args": [
            "root->fs_info->super_for_commit",
            "btrfs_header_level(log_root_tree->node)"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "log_root_tree->node"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_super_log_root",
          "args": [
            "root->fs_info->super_for_commit",
            "log_root_tree->node->start"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_wait_logged_extents",
          "args": [
            "trans",
            "log",
            "log_transid"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_logged_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "486-516",
          "snippet": "void btrfs_wait_logged_extents(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tstruct inode *inode = ordered->inode;\n\t\t\tu64 start = ordered->file_offset;\n\t\t\tu64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(!inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_IO_DONE,\n\t\t\t\t\t\t   &ordered->flags));\n\n\t\tlist_add_tail(&ordered->trans_list, &trans->ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_logged_extents(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\n\t\tif (!test_bit(BTRFS_ORDERED_IO_DONE, &ordered->flags) &&\n\t\t    !test_bit(BTRFS_ORDERED_DIRECT, &ordered->flags)) {\n\t\t\tstruct inode *inode = ordered->inode;\n\t\t\tu64 start = ordered->file_offset;\n\t\t\tu64 end = ordered->file_offset + ordered->len - 1;\n\n\t\t\tWARN_ON(!inode);\n\t\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\t\t}\n\t\twait_event(ordered->wait, test_bit(BTRFS_ORDERED_IO_DONE,\n\t\t\t\t\t\t   &ordered->flags));\n\n\t\tlist_add_tail(&ordered->trans_list, &trans->ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_logged_extents",
          "args": [
            "log",
            "log_transid"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_logged_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "518-534",
          "snippet": "void btrfs_free_logged_extents(struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_free_logged_extents(struct btrfs_root *log, u64 transid)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tint index = transid % 2;\n\n\tspin_lock_irq(&log->log_extents_lock[index]);\n\twhile (!list_empty(&log->logged_list[index])) {\n\t\tordered = list_first_entry(&log->logged_list[index],\n\t\t\t\t\t   struct btrfs_ordered_extent,\n\t\t\t\t\t   log_list);\n\t\tlist_del_init(&ordered->log_list);\n\t\tspin_unlock_irq(&log->log_extents_lock[index]);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tspin_lock_irq(&log->log_extents_lock[index]);\n\t}\n\tspin_unlock_irq(&log->log_extents_lock[index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_marked_extents",
          "args": [
            "log_root_tree",
            "&log_root_tree->dirty_log_pages",
            "EXTENT_NEW | EXTENT_DIRTY"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_marked_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "911-970",
          "snippet": "int btrfs_wait_marked_extents(struct btrfs_root *root,\n\t\t\t      struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tbool errors = false;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through clear_btree_io_tree()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT,\n\t\t\t\t       0, 0, &cached_state, GFP_NOFS);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\n\tif (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tif ((mark & EXTENT_DIRTY) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG1_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\n\t\tif ((mark & EXTENT_NEW) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG2_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t} else {\n\t\tif (test_and_clear_bit(BTRFS_INODE_BTREE_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t}\n\n\tif (errors && !werr)\n\t\twerr = -EIO;\n\n\treturn werr;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_wait_marked_extents(struct btrfs_root *root,\n\t\t\t      struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tbool errors = false;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through clear_btree_io_tree()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT,\n\t\t\t\t       0, 0, &cached_state, GFP_NOFS);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\n\tif (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tif ((mark & EXTENT_DIRTY) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG1_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\n\t\tif ((mark & EXTENT_NEW) &&\n\t\t    test_and_clear_bit(BTRFS_INODE_BTREE_LOG2_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t} else {\n\t\tif (test_and_clear_bit(BTRFS_INODE_BTREE_ERR,\n\t\t\t\t       &btree_ino->runtime_flags))\n\t\t\terrors = true;\n\t}\n\n\tif (errors && !werr)\n\t\twerr = -EIO;\n\n\treturn werr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_write_marked_extents",
          "args": [
            "log_root_tree",
            "&log_root_tree->dirty_log_pages",
            "EXTENT_DIRTY | EXTENT_NEW"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_write_marked_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "857-903",
          "snippet": "int btrfs_write_marked_extents(struct btrfs_root *root,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state, GFP_NOFS);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to btrfs_wait_marked_extents() would not know that writeback\n\t\t * for this range started and therefore wouldn't wait for it to\n\t\t * finish - we don't want to commit a superblock that points to\n\t\t * btree nodes/leafs for which writeback hasn't finished yet\n\t\t * (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through clear_btree_io_tree()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\treturn werr;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_write_marked_extents(struct btrfs_root *root,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = root->fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state, GFP_NOFS);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to btrfs_wait_marked_extents() would not know that writeback\n\t\t * for this range started and therefore wouldn't wait for it to\n\t\t * finish - we don't want to commit a superblock that points to\n\t\t * btree nodes/leafs for which writeback hasn't finished yet\n\t\t * (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through clear_btree_io_tree()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\treturn werr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_need_log_full_commit",
          "args": [
            "root->fs_info",
            "trans"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_need_log_full_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "49-54",
          "snippet": "static inline int btrfs_need_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\treturn ACCESS_ONCE(fs_info->last_trans_log_full_commit) ==\n\t\ttrans->transid;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline int btrfs_need_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\treturn ACCESS_ONCE(fs_info->last_trans_log_full_commit) ==\n\t\ttrans->transid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_writer",
          "args": [
            "trans",
            "log_root_tree"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2452-2466",
          "snippet": "static void wait_for_writer(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (atomic_read(&root->log_writers)) {\n\t\tprepare_to_wait(&root->log_writer_wait,\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tif (atomic_read(&root->log_writers))\n\t\t\tschedule();\n\t\tfinish_wait(&root->log_writer_wait, &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t}\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void wait_for_writer(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (atomic_read(&root->log_writers)) {\n\t\tprepare_to_wait(&root->log_writer_wait,\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tif (atomic_read(&root->log_writers))\n\t\t\tschedule();\n\t\tfinish_wait(&root->log_writer_wait, &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_log_commit",
          "args": [
            "trans",
            "log_root_tree",
            "root_log_ctx.log_transid - 1"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "wait_log_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2426-2450",
          "snippet": "static void wait_log_commit(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root, int transid)\n{\n\tDEFINE_WAIT(wait);\n\tint index = transid % 2;\n\n\t/*\n\t * we only allow two pending log transactions at a time,\n\t * so we know that if ours is more than 2 older than the\n\t * current transaction, we're done\n\t */\n\tdo {\n\t\tprepare_to_wait(&root->log_commit_wait[index],\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\n\t\tif (root->log_transid_committed < transid &&\n\t\t    atomic_read(&root->log_commit[index]))\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->log_commit_wait[index], &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t} while (root->log_transid_committed < transid &&\n\t\t atomic_read(&root->log_commit[index]));\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void wait_log_commit(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root, int transid)\n{\n\tDEFINE_WAIT(wait);\n\tint index = transid % 2;\n\n\t/*\n\t * we only allow two pending log transactions at a time,\n\t * so we know that if ours is more than 2 older than the\n\t * current transaction, we're done\n\t */\n\tdo {\n\t\tprepare_to_wait(&root->log_commit_wait[index],\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\n\t\tif (root->log_transid_committed < transid &&\n\t\t    atomic_read(&root->log_commit[index]))\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->log_commit_wait[index], &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t} while (root->log_transid_committed < transid &&\n\t\t atomic_read(&root->log_commit[index]));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&log_root_tree->log_commit[(index2 + 1) % 2]"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&log_root_tree->log_commit[index2]",
            "1"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "root_log_ctx.log_transid == log_root_tree->log_transid"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&log_root_tree->log_commit[index2]"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&root_log_ctx.list"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&root_log_ctx.list"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&log_root_tree->log_writer_wait"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&log_root_tree->log_writers"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_log_root",
          "args": [
            "trans",
            "log"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "update_log_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2410-2424",
          "snippet": "static int update_log_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *log)\n{\n\tint ret;\n\n\tif (log->log_transid == 1) {\n\t\t/* insert root item on the first sync */\n\t\tret = btrfs_insert_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t} else {\n\t\tret = btrfs_update_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int update_log_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *log)\n{\n\tint ret;\n\n\tif (log->log_transid == 1) {\n\t\t/* insert root item on the first sync */\n\t\tret = btrfs_insert_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t} else {\n\t\tret = btrfs_update_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root_log_ctx.list",
            "&log_root_tree->log_ctxs[index2]"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&log_root_tree->log_writers"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&log_root_tree->log_batch"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&log_root_tree->log_mutex"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_log_ctx",
          "args": [
            "&root_log_ctx"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_log_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "35-41",
          "snippet": "static inline void btrfs_init_log_ctx(struct btrfs_log_ctx *ctx)\n{\n\tctx->log_ret = 0;\n\tctx->log_transid = 0;\n\tctx->io_err = 0;\n\tINIT_LIST_HEAD(&ctx->list);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline void btrfs_init_log_ctx(struct btrfs_log_ctx *ctx)\n{\n\tctx->log_ret = 0;\n\tctx->log_transid = 0;\n\tctx->io_err = 0;\n\tINIT_LIST_HEAD(&ctx->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "&log->root_item",
            "log->node"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_batch"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_MULTI_LOG_TASKS",
            "&root->state"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SSD"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_batch"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_commit[(index1 + 1) % 2]"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&root->log_commit[index1]",
            "1"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "log_transid == root->log_transid"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_commit[index1]"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nint btrfs_sync_log(struct btrfs_trans_handle *trans,\n\t\t   struct btrfs_root *root, struct btrfs_log_ctx *ctx)\n{\n\tint index1;\n\tint index2;\n\tint mark;\n\tint ret;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_root *log_root_tree = root->fs_info->log_root_tree;\n\tint log_transid = 0;\n\tstruct btrfs_log_ctx root_log_ctx;\n\tstruct blk_plug plug;\n\n\tmutex_lock(&root->log_mutex);\n\tlog_transid = ctx->log_transid;\n\tif (root->log_transid_committed >= log_transid) {\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\n\tindex1 = log_transid % 2;\n\tif (atomic_read(&root->log_commit[index1])) {\n\t\twait_log_commit(trans, root, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\tASSERT(log_transid == root->log_transid);\n\tatomic_set(&root->log_commit[index1], 1);\n\n\t/* wait for previous tree log sync to complete */\n\tif (atomic_read(&root->log_commit[(index1 + 1) % 2]))\n\t\twait_log_commit(trans, root, log_transid - 1);\n\n\twhile (1) {\n\t\tint batch = atomic_read(&root->log_batch);\n\t\t/* when we're on an ssd, just kick the log commit out */\n\t\tif (!btrfs_test_opt(root, SSD) &&\n\t\t    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {\n\t\t\tmutex_unlock(&root->log_mutex);\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tmutex_lock(&root->log_mutex);\n\t\t}\n\t\twait_for_writer(trans, root);\n\t\tif (batch == atomic_read(&root->log_batch))\n\t\t\tbreak;\n\t}\n\n\t/* bail out if we need to do a full commit */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tret = -EAGAIN;\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_transid % 2 == 0)\n\t\tmark = EXTENT_DIRTY;\n\telse\n\t\tmark = EXTENT_NEW;\n\n\t/* we start IO on  all the marked extents here, but we don't actually\n\t * wait for them until later.\n\t */\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (ret) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tbtrfs_set_root_node(&log->root_item, log->node);\n\n\troot->log_transid++;\n\tlog->log_transid = root->log_transid;\n\troot->log_start_pid = 0;\n\t/*\n\t * IO has been started, blocks of the log tree have WRITTEN flag set\n\t * in their headers. new modifications of the log will be written to\n\t * new positions. so it's safe to allow log writers to go in.\n\t */\n\tmutex_unlock(&root->log_mutex);\n\n\tbtrfs_init_log_ctx(&root_log_ctx);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tatomic_inc(&log_root_tree->log_batch);\n\tatomic_inc(&log_root_tree->log_writers);\n\n\tindex2 = log_root_tree->log_transid % 2;\n\tlist_add_tail(&root_log_ctx.list, &log_root_tree->log_ctxs[index2]);\n\troot_log_ctx.log_transid = log_root_tree->log_transid;\n\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tret = update_log_root(trans, log);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tif (atomic_dec_and_test(&log_root_tree->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&log_root_tree->log_writer_wait))\n\t\t\twake_up(&log_root_tree->log_writer_wait);\n\t}\n\n\tif (ret) {\n\t\tif (!list_empty(&root_log_ctx.list))\n\t\t\tlist_del_init(&root_log_ctx.list);\n\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\n\t\tif (ret != -ENOSPC) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (log_root_tree->log_transid_committed >= root_log_ctx.log_transid) {\n\t\tblk_finish_plug(&plug);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\n\tindex2 = root_log_ctx.log_transid % 2;\n\tif (atomic_read(&log_root_tree->log_commit[index2])) {\n\t\tblk_finish_plug(&plug);\n\t\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages,\n\t\t\t\t\t\tmark);\n\t\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tif (!ret)\n\t\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\tASSERT(root_log_ctx.log_transid == log_root_tree->log_transid);\n\tatomic_set(&log_root_tree->log_commit[index2], 1);\n\n\tif (atomic_read(&log_root_tree->log_commit[(index2 + 1) % 2])) {\n\t\twait_log_commit(trans, log_root_tree,\n\t\t\t\troot_log_ctx.log_transid - 1);\n\t}\n\n\twait_for_writer(trans, log_root_tree);\n\n\t/*\n\t * now that we've moved on to the tree of log tree roots,\n\t * check the full commit flag again\n\t */\n\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out_wake_log_root;\n\t}\n\n\tret = btrfs_write_marked_extents(log_root_tree,\n\t\t\t\t\t &log_root_tree->dirty_log_pages,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_NEW);\n\tblk_finish_plug(&plug);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tret = btrfs_wait_marked_extents(log, &log->dirty_log_pages, mark);\n\tif (!ret)\n\t\tret = btrfs_wait_marked_extents(log_root_tree,\n\t\t\t\t\t\t&log_root_tree->dirty_log_pages,\n\t\t\t\t\t\tEXTENT_NEW | EXTENT_DIRTY);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_free_logged_extents(log, log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tbtrfs_wait_logged_extents(trans, log, log_transid);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_for_commit,\n\t\t\t\tlog_root_tree->node->start);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_for_commit,\n\t\t\t\tbtrfs_header_level(log_root_tree->node));\n\n\tlog_root_tree->log_transid++;\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * nobody else is going to jump in and write the the ctree\n\t * super here because the log_commit atomic below is protecting\n\t * us.  We must be called with a transaction handle pinning\n\t * the running transaction open, so a full commit can't hop\n\t * in and cause problems either.\n\t */\n\tret = write_ctree_super(trans, root->fs_info->tree_root, 1);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(root->fs_info, trans);\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->last_log_commit < log_transid)\n\t\troot->last_log_commit = log_transid;\n\tmutex_unlock(&root->log_mutex);\n\nout_wake_log_root:\n\t/*\n\t * We needn't get log_mutex here because we are sure all\n\t * the other tasks are blocked.\n\t */\n\tbtrfs_remove_all_log_ctxs(log_root_tree, index2, ret);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\tlog_root_tree->log_transid_committed++;\n\tatomic_set(&log_root_tree->log_commit[index2], 0);\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\tif (waitqueue_active(&log_root_tree->log_commit_wait[index2]))\n\t\twake_up(&log_root_tree->log_commit_wait[index2]);\nout:\n\t/* See above. */\n\tbtrfs_remove_all_log_ctxs(root, index1, ret);\n\n\tmutex_lock(&root->log_mutex);\n\troot->log_transid_committed++;\n\tatomic_set(&root->log_commit[index1], 0);\n\tmutex_unlock(&root->log_mutex);\n\n\tif (waitqueue_active(&root->log_commit_wait[index1]))\n\t\twake_up(&root->log_commit_wait[index1]);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_remove_all_log_ctxs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2483-2497",
    "snippet": "static inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,\n\t\t\t\t\t     int index, int error)\n{\n\tstruct btrfs_log_ctx *ctx;\n\n\tif (!error) {\n\t\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(ctx, &root->log_ctxs[index], list)\n\t\tctx->log_ret = error;\n\n\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->log_ctxs[index]"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ctx",
            "&root->log_ctxs[index]",
            "list"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&root->log_ctxs[index]"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,\n\t\t\t\t\t     int index, int error)\n{\n\tstruct btrfs_log_ctx *ctx;\n\n\tif (!error) {\n\t\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(ctx, &root->log_ctxs[index], list)\n\t\tctx->log_ret = error;\n\n\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n}"
  },
  {
    "function_name": "btrfs_remove_log_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2468-2477",
    "snippet": "static inline void btrfs_remove_log_ctx(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tmutex_lock(&root->log_mutex);\n\tlist_del_init(&ctx->list);\n\tmutex_unlock(&root->log_mutex);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ctx->list"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic inline void btrfs_remove_log_ctx(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tmutex_lock(&root->log_mutex);\n\tlist_del_init(&ctx->list);\n\tmutex_unlock(&root->log_mutex);\n}"
  },
  {
    "function_name": "wait_for_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2452-2466",
    "snippet": "static void wait_for_writer(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (atomic_read(&root->log_writers)) {\n\t\tprepare_to_wait(&root->log_writer_wait,\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tif (atomic_read(&root->log_writers))\n\t\t\tschedule();\n\t\tfinish_wait(&root->log_writer_wait, &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t}\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&root->log_writer_wait",
            "&wait"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_writers"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&root->log_writer_wait",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_writers"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void wait_for_writer(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (atomic_read(&root->log_writers)) {\n\t\tprepare_to_wait(&root->log_writer_wait,\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tif (atomic_read(&root->log_writers))\n\t\t\tschedule();\n\t\tfinish_wait(&root->log_writer_wait, &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t}\n}"
  },
  {
    "function_name": "wait_log_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2426-2450",
    "snippet": "static void wait_log_commit(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root, int transid)\n{\n\tDEFINE_WAIT(wait);\n\tint index = transid % 2;\n\n\t/*\n\t * we only allow two pending log transactions at a time,\n\t * so we know that if ours is more than 2 older than the\n\t * current transaction, we're done\n\t */\n\tdo {\n\t\tprepare_to_wait(&root->log_commit_wait[index],\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\n\t\tif (root->log_transid_committed < transid &&\n\t\t    atomic_read(&root->log_commit[index]))\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->log_commit_wait[index], &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t} while (root->log_transid_committed < transid &&\n\t\t atomic_read(&root->log_commit[index]));\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_commit[index]"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&root->log_commit_wait[index]",
            "&wait"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&root->log_commit[index]"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&root->log_commit_wait[index]",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void wait_log_commit(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root, int transid)\n{\n\tDEFINE_WAIT(wait);\n\tint index = transid % 2;\n\n\t/*\n\t * we only allow two pending log transactions at a time,\n\t * so we know that if ours is more than 2 older than the\n\t * current transaction, we're done\n\t */\n\tdo {\n\t\tprepare_to_wait(&root->log_commit_wait[index],\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\t\tmutex_unlock(&root->log_mutex);\n\n\t\tif (root->log_transid_committed < transid &&\n\t\t    atomic_read(&root->log_commit[index]))\n\t\t\tschedule();\n\n\t\tfinish_wait(&root->log_commit_wait[index], &wait);\n\t\tmutex_lock(&root->log_mutex);\n\t} while (root->log_transid_committed < transid &&\n\t\t atomic_read(&root->log_commit[index]));\n}"
  },
  {
    "function_name": "update_log_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2410-2424",
    "snippet": "static int update_log_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *log)\n{\n\tint ret;\n\n\tif (log->log_transid == 1) {\n\t\t/* insert root item on the first sync */\n\t\tret = btrfs_insert_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t} else {\n\t\tret = btrfs_update_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_update_root",
          "args": [
            "trans",
            "log->fs_info->log_root_tree",
            "&log->root_key",
            "&log->root_item"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "135-210",
          "snippet": "int btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_root",
          "args": [
            "trans",
            "log->fs_info->log_root_tree",
            "&log->root_key",
            "&log->root_item"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "212-220",
          "snippet": "int btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int update_log_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *log)\n{\n\tint ret;\n\n\tif (log->log_transid == 1) {\n\t\t/* insert root item on the first sync */\n\t\tret = btrfs_insert_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t} else {\n\t\tret = btrfs_update_root(trans, log->fs_info->log_root_tree,\n\t\t\t\t&log->root_key, &log->root_item);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "walk_log_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2336-2404",
    "snippet": "static int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\textent_buffer_get(log->node);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* was the root node processed? if not, catch it here */\n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free) {\n\t\t\tstruct extent_buffer *next;\n\n\t\t\tnext = path->nodes[orig_level];\n\n\t\t\tif (trans) {\n\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\tclean_tree_block(trans, log, next);\n\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t}\n\n\t\t\tWARN_ON(log->root_key.objectid !=\n\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\tret = btrfs_free_and_pin_reserved_extent(log, next->start,\n\t\t\t\t\t\t\t next->len);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_and_pin_reserved_extent",
          "args": [
            "log",
            "next->start",
            "next->len"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_and_pin_reserved_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6981-6985",
          "snippet": "int btrfs_free_and_pin_reserved_extent(struct btrfs_root *root,\n\t\t\t\t       u64 start, u64 len)\n{\n\treturn __btrfs_free_reserved_extent(root, start, len, 1, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_and_pin_reserved_extent(struct btrfs_root *root,\n\t\t\t\t       u64 start, u64 len)\n{\n\treturn __btrfs_free_reserved_extent(root, start, len, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "log->root_key.objectid !=\n\t\t\t\tBTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "next"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_tree_block_writeback",
          "args": [
            "next"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_tree_block_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1143-1147",
          "snippet": "int btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "log",
            "next"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "next"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "next"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wc->process_func",
          "args": [
            "log",
            "path->nodes[orig_level]",
            "wc",
            "btrfs_header_generation(path->nodes[orig_level])"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "path->nodes[orig_level]"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_up_log_tree",
          "args": [
            "trans",
            "log",
            "path",
            "&level",
            "wc"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "walk_up_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2273-2329",
          "snippet": "static noinline int walk_up_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path, int *level,\n\t\t\t\t struct walk_control *wc)\n{\n\tu64 root_owner;\n\tint i;\n\tint slot;\n\tint ret;\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL - 1 && path->nodes[i]; i++) {\n\t\tslot = path->slots[i];\n\t\tif (slot + 1 < btrfs_header_nritems(path->nodes[i])) {\n\t\t\tpath->slots[i]++;\n\t\t\t*level = i;\n\t\t\tWARN_ON(*level == 0);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tstruct extent_buffer *parent;\n\t\t\tif (path->nodes[*level] == root->node)\n\t\t\t\tparent = path->nodes[*level];\n\t\t\telse\n\t\t\t\tparent = path->nodes[*level + 1];\n\n\t\t\troot_owner = btrfs_header_owner(parent);\n\t\t\tret = wc->process_func(root, path->nodes[*level], wc,\n\t\t\t\t btrfs_header_generation(path->nodes[*level]));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (wc->free) {\n\t\t\t\tstruct extent_buffer *next;\n\n\t\t\t\tnext = path->nodes[*level];\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner != BTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\tpath->nodes[*level]->start,\n\t\t\t\t\t\tpath->nodes[*level]->len);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tfree_extent_buffer(path->nodes[*level]);\n\t\t\tpath->nodes[*level] = NULL;\n\t\t\t*level = i + 1;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int walk_up_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path, int *level,\n\t\t\t\t struct walk_control *wc)\n{\n\tu64 root_owner;\n\tint i;\n\tint slot;\n\tint ret;\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL - 1 && path->nodes[i]; i++) {\n\t\tslot = path->slots[i];\n\t\tif (slot + 1 < btrfs_header_nritems(path->nodes[i])) {\n\t\t\tpath->slots[i]++;\n\t\t\t*level = i;\n\t\t\tWARN_ON(*level == 0);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tstruct extent_buffer *parent;\n\t\t\tif (path->nodes[*level] == root->node)\n\t\t\t\tparent = path->nodes[*level];\n\t\t\telse\n\t\t\t\tparent = path->nodes[*level + 1];\n\n\t\t\troot_owner = btrfs_header_owner(parent);\n\t\t\tret = wc->process_func(root, path->nodes[*level], wc,\n\t\t\t\t btrfs_header_generation(path->nodes[*level]));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (wc->free) {\n\t\t\t\tstruct extent_buffer *next;\n\n\t\t\t\tnext = path->nodes[*level];\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner != BTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\tpath->nodes[*level]->start,\n\t\t\t\t\t\tpath->nodes[*level]->len);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tfree_extent_buffer(path->nodes[*level]);\n\t\t\tpath->nodes[*level] = NULL;\n\t\t\t*level = i + 1;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_down_log_tree",
          "args": [
            "trans",
            "log",
            "path",
            "&level",
            "wc"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "walk_down_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "2176-2271",
          "snippet": "static noinline int walk_down_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path, int *level,\n\t\t\t\t   struct walk_control *wc)\n{\n\tu64 root_owner;\n\tu64 bytenr;\n\tu64 ptr_gen;\n\tstruct extent_buffer *next;\n\tstruct extent_buffer *cur;\n\tstruct extent_buffer *parent;\n\tu32 blocksize;\n\tint ret = 0;\n\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\twhile (*level > 0) {\n\t\tWARN_ON(*level < 0);\n\t\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\t\tcur = path->nodes[*level];\n\n\t\tWARN_ON(btrfs_header_level(cur) != *level);\n\n\t\tif (path->slots[*level] >=\n\t\t    btrfs_header_nritems(cur))\n\t\t\tbreak;\n\n\t\tbytenr = btrfs_node_blockptr(cur, path->slots[*level]);\n\t\tptr_gen = btrfs_node_ptr_generation(cur, path->slots[*level]);\n\t\tblocksize = root->nodesize;\n\n\t\tparent = path->nodes[*level];\n\t\troot_owner = btrfs_header_owner(parent);\n\n\t\tnext = btrfs_find_create_tree_block(root, bytenr);\n\t\tif (!next)\n\t\t\treturn -ENOMEM;\n\n\t\tif (*level == 1) {\n\t\t\tret = wc->process_func(root, next, wc, ptr_gen);\n\t\t\tif (ret) {\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpath->slots[*level]++;\n\t\t\tif (wc->free) {\n\t\t\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner !=\n\t\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\t\t bytenr, blocksize);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_extent_buffer(next);\n\t\t\tcontinue;\n\t\t}\n\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\tif (ret) {\n\t\t\tfree_extent_buffer(next);\n\t\t\treturn ret;\n\t\t}\n\n\t\tWARN_ON(*level <= 0);\n\t\tif (path->nodes[*level-1])\n\t\t\tfree_extent_buffer(path->nodes[*level-1]);\n\t\tpath->nodes[*level-1] = next;\n\t\t*level = btrfs_header_level(next);\n\t\tpath->slots[*level] = 0;\n\t\tcond_resched();\n\t}\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\tpath->slots[*level] = btrfs_header_nritems(path->nodes[*level]);\n\n\tcond_resched();\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int walk_down_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path, int *level,\n\t\t\t\t   struct walk_control *wc)\n{\n\tu64 root_owner;\n\tu64 bytenr;\n\tu64 ptr_gen;\n\tstruct extent_buffer *next;\n\tstruct extent_buffer *cur;\n\tstruct extent_buffer *parent;\n\tu32 blocksize;\n\tint ret = 0;\n\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\twhile (*level > 0) {\n\t\tWARN_ON(*level < 0);\n\t\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\t\tcur = path->nodes[*level];\n\n\t\tWARN_ON(btrfs_header_level(cur) != *level);\n\n\t\tif (path->slots[*level] >=\n\t\t    btrfs_header_nritems(cur))\n\t\t\tbreak;\n\n\t\tbytenr = btrfs_node_blockptr(cur, path->slots[*level]);\n\t\tptr_gen = btrfs_node_ptr_generation(cur, path->slots[*level]);\n\t\tblocksize = root->nodesize;\n\n\t\tparent = path->nodes[*level];\n\t\troot_owner = btrfs_header_owner(parent);\n\n\t\tnext = btrfs_find_create_tree_block(root, bytenr);\n\t\tif (!next)\n\t\t\treturn -ENOMEM;\n\n\t\tif (*level == 1) {\n\t\t\tret = wc->process_func(root, next, wc, ptr_gen);\n\t\t\tif (ret) {\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpath->slots[*level]++;\n\t\t\tif (wc->free) {\n\t\t\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner !=\n\t\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\t\t bytenr, blocksize);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_extent_buffer(next);\n\t\t\tcontinue;\n\t\t}\n\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\tif (ret) {\n\t\t\tfree_extent_buffer(next);\n\t\t\treturn ret;\n\t\t}\n\n\t\tWARN_ON(*level <= 0);\n\t\tif (path->nodes[*level-1])\n\t\t\tfree_extent_buffer(path->nodes[*level-1]);\n\t\tpath->nodes[*level-1] = next;\n\t\t*level = btrfs_header_level(next);\n\t\tpath->slots[*level] = 0;\n\t\tcond_resched();\n\t}\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\tpath->slots[*level] = btrfs_header_nritems(path->nodes[*level]);\n\n\tcond_resched();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "log->node"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "log->node"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\textent_buffer_get(log->node);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* was the root node processed? if not, catch it here */\n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free) {\n\t\t\tstruct extent_buffer *next;\n\n\t\t\tnext = path->nodes[orig_level];\n\n\t\t\tif (trans) {\n\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\tclean_tree_block(trans, log, next);\n\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t}\n\n\t\t\tWARN_ON(log->root_key.objectid !=\n\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\tret = btrfs_free_and_pin_reserved_extent(log, next->start,\n\t\t\t\t\t\t\t next->len);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "walk_up_log_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2273-2329",
    "snippet": "static noinline int walk_up_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path, int *level,\n\t\t\t\t struct walk_control *wc)\n{\n\tu64 root_owner;\n\tint i;\n\tint slot;\n\tint ret;\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL - 1 && path->nodes[i]; i++) {\n\t\tslot = path->slots[i];\n\t\tif (slot + 1 < btrfs_header_nritems(path->nodes[i])) {\n\t\t\tpath->slots[i]++;\n\t\t\t*level = i;\n\t\t\tWARN_ON(*level == 0);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tstruct extent_buffer *parent;\n\t\t\tif (path->nodes[*level] == root->node)\n\t\t\t\tparent = path->nodes[*level];\n\t\t\telse\n\t\t\t\tparent = path->nodes[*level + 1];\n\n\t\t\troot_owner = btrfs_header_owner(parent);\n\t\t\tret = wc->process_func(root, path->nodes[*level], wc,\n\t\t\t\t btrfs_header_generation(path->nodes[*level]));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (wc->free) {\n\t\t\t\tstruct extent_buffer *next;\n\n\t\t\t\tnext = path->nodes[*level];\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner != BTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\tpath->nodes[*level]->start,\n\t\t\t\t\t\tpath->nodes[*level]->len);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tfree_extent_buffer(path->nodes[*level]);\n\t\t\tpath->nodes[*level] = NULL;\n\t\t\t*level = i + 1;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "path->nodes[*level]"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_and_pin_reserved_extent",
          "args": [
            "root",
            "path->nodes[*level]->start",
            "path->nodes[*level]->len"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_and_pin_reserved_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6981-6985",
          "snippet": "int btrfs_free_and_pin_reserved_extent(struct btrfs_root *root,\n\t\t\t\t       u64 start, u64 len)\n{\n\treturn __btrfs_free_reserved_extent(root, start, len, 1, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_and_pin_reserved_extent(struct btrfs_root *root,\n\t\t\t\t       u64 start, u64 len)\n{\n\treturn __btrfs_free_reserved_extent(root, start, len, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root_owner != BTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "next"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_tree_block_writeback",
          "args": [
            "next"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_tree_block_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1143-1147",
          "snippet": "int btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "root",
            "next"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "next"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "next"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wc->process_func",
          "args": [
            "root",
            "path->nodes[*level]",
            "wc",
            "btrfs_header_generation(path->nodes[*level])"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "path->nodes[*level]"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "parent"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level == 0"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[i]"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int walk_up_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path, int *level,\n\t\t\t\t struct walk_control *wc)\n{\n\tu64 root_owner;\n\tint i;\n\tint slot;\n\tint ret;\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL - 1 && path->nodes[i]; i++) {\n\t\tslot = path->slots[i];\n\t\tif (slot + 1 < btrfs_header_nritems(path->nodes[i])) {\n\t\t\tpath->slots[i]++;\n\t\t\t*level = i;\n\t\t\tWARN_ON(*level == 0);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tstruct extent_buffer *parent;\n\t\t\tif (path->nodes[*level] == root->node)\n\t\t\t\tparent = path->nodes[*level];\n\t\t\telse\n\t\t\t\tparent = path->nodes[*level + 1];\n\n\t\t\troot_owner = btrfs_header_owner(parent);\n\t\t\tret = wc->process_func(root, path->nodes[*level], wc,\n\t\t\t\t btrfs_header_generation(path->nodes[*level]));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (wc->free) {\n\t\t\t\tstruct extent_buffer *next;\n\n\t\t\t\tnext = path->nodes[*level];\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner != BTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\tpath->nodes[*level]->start,\n\t\t\t\t\t\tpath->nodes[*level]->len);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tfree_extent_buffer(path->nodes[*level]);\n\t\t\tpath->nodes[*level] = NULL;\n\t\t\t*level = i + 1;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "walk_down_log_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2176-2271",
    "snippet": "static noinline int walk_down_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path, int *level,\n\t\t\t\t   struct walk_control *wc)\n{\n\tu64 root_owner;\n\tu64 bytenr;\n\tu64 ptr_gen;\n\tstruct extent_buffer *next;\n\tstruct extent_buffer *cur;\n\tstruct extent_buffer *parent;\n\tu32 blocksize;\n\tint ret = 0;\n\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\twhile (*level > 0) {\n\t\tWARN_ON(*level < 0);\n\t\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\t\tcur = path->nodes[*level];\n\n\t\tWARN_ON(btrfs_header_level(cur) != *level);\n\n\t\tif (path->slots[*level] >=\n\t\t    btrfs_header_nritems(cur))\n\t\t\tbreak;\n\n\t\tbytenr = btrfs_node_blockptr(cur, path->slots[*level]);\n\t\tptr_gen = btrfs_node_ptr_generation(cur, path->slots[*level]);\n\t\tblocksize = root->nodesize;\n\n\t\tparent = path->nodes[*level];\n\t\troot_owner = btrfs_header_owner(parent);\n\n\t\tnext = btrfs_find_create_tree_block(root, bytenr);\n\t\tif (!next)\n\t\t\treturn -ENOMEM;\n\n\t\tif (*level == 1) {\n\t\t\tret = wc->process_func(root, next, wc, ptr_gen);\n\t\t\tif (ret) {\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpath->slots[*level]++;\n\t\t\tif (wc->free) {\n\t\t\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner !=\n\t\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\t\t bytenr, blocksize);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_extent_buffer(next);\n\t\t\tcontinue;\n\t\t}\n\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\tif (ret) {\n\t\t\tfree_extent_buffer(next);\n\t\t\treturn ret;\n\t\t}\n\n\t\tWARN_ON(*level <= 0);\n\t\tif (path->nodes[*level-1])\n\t\t\tfree_extent_buffer(path->nodes[*level-1]);\n\t\tpath->nodes[*level-1] = next;\n\t\t*level = btrfs_header_level(next);\n\t\tpath->slots[*level] = 0;\n\t\tcond_resched();\n\t}\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\tpath->slots[*level] = btrfs_header_nritems(path->nodes[*level]);\n\n\tcond_resched();\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[*level]"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level >= BTRFS_MAX_LEVEL"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level < 0"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "next"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "path->nodes[*level-1]"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level <= 0"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_buffer",
          "args": [
            "next",
            "ptr_gen"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3831-3835",
          "snippet": "int btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_and_pin_reserved_extent",
          "args": [
            "root",
            "bytenr",
            "blocksize"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_and_pin_reserved_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6981-6985",
          "snippet": "int btrfs_free_and_pin_reserved_extent(struct btrfs_root *root,\n\t\t\t\t       u64 start, u64 len)\n{\n\treturn __btrfs_free_reserved_extent(root, start, len, 1, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_free_and_pin_reserved_extent(struct btrfs_root *root,\n\t\t\t\t       u64 start, u64 len)\n{\n\treturn __btrfs_free_reserved_extent(root, start, len, 1, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root_owner !=\n\t\t\t\t\tBTRFS_TREE_LOG_OBJECTID"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "next"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_tree_block_writeback",
          "args": [
            "next"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_tree_block_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1143-1147",
          "snippet": "int btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "root",
            "next"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "next"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "next"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wc->process_func",
          "args": [
            "root",
            "next",
            "wc",
            "ptr_gen"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_create_tree_block",
          "args": [
            "root",
            "bytenr"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_create_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1128-1134",
          "snippet": "struct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_create_tree_block(struct btrfs_root *root,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn alloc_test_extent_buffer(root->fs_info, bytenr);\n\treturn alloc_extent_buffer(root->fs_info, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "parent"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "cur",
            "path->slots[*level]"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "cur",
            "path->slots[*level]"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "cur"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_level(cur) != *level"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "cur"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level >= BTRFS_MAX_LEVEL"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level < 0"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level >= BTRFS_MAX_LEVEL"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*level < 0"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int walk_down_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path, int *level,\n\t\t\t\t   struct walk_control *wc)\n{\n\tu64 root_owner;\n\tu64 bytenr;\n\tu64 ptr_gen;\n\tstruct extent_buffer *next;\n\tstruct extent_buffer *cur;\n\tstruct extent_buffer *parent;\n\tu32 blocksize;\n\tint ret = 0;\n\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\twhile (*level > 0) {\n\t\tWARN_ON(*level < 0);\n\t\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\t\tcur = path->nodes[*level];\n\n\t\tWARN_ON(btrfs_header_level(cur) != *level);\n\n\t\tif (path->slots[*level] >=\n\t\t    btrfs_header_nritems(cur))\n\t\t\tbreak;\n\n\t\tbytenr = btrfs_node_blockptr(cur, path->slots[*level]);\n\t\tptr_gen = btrfs_node_ptr_generation(cur, path->slots[*level]);\n\t\tblocksize = root->nodesize;\n\n\t\tparent = path->nodes[*level];\n\t\troot_owner = btrfs_header_owner(parent);\n\n\t\tnext = btrfs_find_create_tree_block(root, bytenr);\n\t\tif (!next)\n\t\t\treturn -ENOMEM;\n\n\t\tif (*level == 1) {\n\t\t\tret = wc->process_func(root, next, wc, ptr_gen);\n\t\t\tif (ret) {\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpath->slots[*level]++;\n\t\t\tif (wc->free) {\n\t\t\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_set_lock_blocking(next);\n\t\t\t\t\tclean_tree_block(trans, root, next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t}\n\n\t\t\t\tWARN_ON(root_owner !=\n\t\t\t\t\tBTRFS_TREE_LOG_OBJECTID);\n\t\t\t\tret = btrfs_free_and_pin_reserved_extent(root,\n\t\t\t\t\t\t\t bytenr, blocksize);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_extent_buffer(next);\n\t\t\tcontinue;\n\t\t}\n\t\tret = btrfs_read_buffer(next, ptr_gen);\n\t\tif (ret) {\n\t\t\tfree_extent_buffer(next);\n\t\t\treturn ret;\n\t\t}\n\n\t\tWARN_ON(*level <= 0);\n\t\tif (path->nodes[*level-1])\n\t\t\tfree_extent_buffer(path->nodes[*level-1]);\n\t\tpath->nodes[*level-1] = next;\n\t\t*level = btrfs_header_level(next);\n\t\tpath->slots[*level] = 0;\n\t\tcond_resched();\n\t}\n\tWARN_ON(*level < 0);\n\tWARN_ON(*level >= BTRFS_MAX_LEVEL);\n\n\tpath->slots[*level] = btrfs_header_nritems(path->nodes[*level]);\n\n\tcond_resched();\n\treturn 0;\n}"
  },
  {
    "function_name": "replay_one_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "2071-2174",
    "snippet": "static int replay_one_buffer(struct btrfs_root *log, struct extent_buffer *eb,\n\t\t\t     struct walk_control *wc, u64 gen)\n{\n\tint nritems;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = wc->replay_dest;\n\tstruct btrfs_key key;\n\tint level;\n\tint i;\n\tint ret;\n\n\tret = btrfs_read_buffer(eb, gen);\n\tif (ret)\n\t\treturn ret;\n\n\tlevel = btrfs_header_level(eb);\n\n\tif (level != 0)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnritems = btrfs_header_nritems(eb);\n\tfor (i = 0; i < nritems; i++) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, i);\n\n\t\t/* inode keys are done during the first stage */\n\t\tif (key.type == BTRFS_INODE_ITEM_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_INODES) {\n\t\t\tstruct btrfs_inode_item *inode_item;\n\t\t\tu32 mode;\n\n\t\t\tinode_item = btrfs_item_ptr(eb, i,\n\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tmode = btrfs_inode_mode(eb, inode_item);\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tret = replay_dir_deletes(wc->trans,\n\t\t\t\t\t root, log, path, key.objectid, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t/* for regular files, make sure corresponding\n\t\t\t * orhpan item exist. extents past the new EOF\n\t\t\t * will be truncated later by orphan cleanup.\n\t\t\t */\n\t\t\tif (S_ISREG(mode)) {\n\t\t\t\tret = insert_orphan_item(wc->trans, root,\n\t\t\t\t\t\t\t key.objectid);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(wc->trans, root,\n\t\t\t\t\t\tpath, key.objectid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type == BTRFS_DIR_INDEX_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_DIR_INDEX) {\n\t\t\tret = replay_one_dir_item(wc->trans, root, path,\n\t\t\t\t\t\t  eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage < LOG_WALK_REPLAY_ALL)\n\t\t\tcontinue;\n\n\t\t/* these keys are simply copied */\n\t\tif (key.type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (key.type == BTRFS_INODE_REF_KEY ||\n\t\t\t   key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = add_inode_ref(wc->trans, root, log, path,\n\t\t\t\t\t    eb, i, &key);\n\t\t\tif (ret && ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t} else if (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tret = replay_one_extent(wc->trans, root, path,\n\t\t\t\t\t\teb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (key.type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tret = replay_one_dir_item(wc->trans, root, path,\n\t\t\t\t\t\t  eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define LOG_WALK_REPLAY_ALL 3",
      "#define LOG_WALK_REPLAY_DIR_INDEX 2",
      "#define LOG_WALK_REPLAY_INODES 1"
    ],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replay_one_dir_item",
          "args": [
            "wc->trans",
            "root",
            "path",
            "eb",
            "i",
            "&key"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "replay_one_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1729-1756",
          "snippet": "static noinline int replay_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size = btrfs_item_size_nr(eb, slot);\n\tstruct btrfs_dir_item *di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di))\n\t\t\treturn -EIO;\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tret = replay_one_name(trans, root, path, eb, di, key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int replay_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size = btrfs_item_size_nr(eb, slot);\n\tstruct btrfs_dir_item *di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di))\n\t\t\treturn -EIO;\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tret = replay_one_name(trans, root, path, eb, di, key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replay_one_extent",
          "args": [
            "wc->trans",
            "root",
            "path",
            "eb",
            "i",
            "&key"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "replay_one_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "576-756",
          "snippet": "static noinline int replay_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct extent_buffer *eb, int slot,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tint found_type;\n\tu64 extent_end;\n\tu64 start = key->offset;\n\tu64 nbytes = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct inode *inode = NULL;\n\tunsigned long size;\n\tint ret = 0;\n\n\titem = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(eb, item);\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tnbytes = btrfs_file_extent_num_bytes(eb, item);\n\t\textent_end = start + nbytes;\n\n\t\t/*\n\t\t * We don't add to the inodes nbytes if we are prealloc or a\n\t\t * hole.\n\t\t */\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tnbytes = 0;\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize = btrfs_file_extent_inline_len(eb, slot, item);\n\t\tnbytes = btrfs_file_extent_ram_bytes(eb, item);\n\t\textent_end = ALIGN(start + size, root->sectorsize);\n\t} else {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, key->objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * first check to see if we already have this extent in the\n\t * file.  This must be done before the btrfs_drop_extents run\n\t * so we don't try to drop this extent.\n\t */\n\tret = btrfs_lookup_file_extent(trans, root, path, btrfs_ino(inode),\n\t\t\t\t       start, 0);\n\n\tif (ret == 0 &&\n\t    (found_type == BTRFS_FILE_EXTENT_REG ||\n\t     found_type == BTRFS_FILE_EXTENT_PREALLOC)) {\n\t\tstruct btrfs_file_extent_item cmp1;\n\t\tstruct btrfs_file_extent_item cmp2;\n\t\tstruct btrfs_file_extent_item *existing;\n\t\tstruct extent_buffer *leaf;\n\n\t\tleaf = path->nodes[0];\n\t\texisting = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_file_extent_item);\n\n\t\tread_extent_buffer(eb, &cmp1, (unsigned long)item,\n\t\t\t\t   sizeof(cmp1));\n\t\tread_extent_buffer(leaf, &cmp2, (unsigned long)existing,\n\t\t\t\t   sizeof(cmp2));\n\n\t\t/*\n\t\t * we already have a pointer to this exact extent,\n\t\t * we don't have to do anything\n\t\t */\n\t\tif (memcmp(&cmp1, &cmp2, sizeof(cmp1)) == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* drop any overlapping extents */\n\tret = btrfs_drop_extents(trans, root, inode, start, extent_end, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 offset;\n\t\tunsigned long dest_offset;\n\t\tstruct btrfs_key ins;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, key,\n\t\t\t\t\t      sizeof(*item));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdest_offset = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\t\t    path->slots[0]);\n\t\tcopy_extent_buffer(path->nodes[0], eb, dest_offset,\n\t\t\t\t(unsigned long)item,  sizeof(*item));\n\n\t\tins.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tins.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\t\toffset = key->offset - btrfs_file_extent_offset(eb, item);\n\n\t\tif (ins.objectid > 0) {\n\t\t\tu64 csum_start;\n\t\t\tu64 csum_end;\n\t\t\tLIST_HEAD(ordered_sums);\n\t\t\t/*\n\t\t\t * is this extent already allocated in the extent\n\t\t\t * allocation tree?  If so, just add a reference\n\t\t\t */\n\t\t\tret = btrfs_lookup_data_extent(root, ins.objectid,\n\t\t\t\t\t\tins.offset);\n\t\t\tif (ret == 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tins.objectid, ins.offset,\n\t\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * insert the extent pointer in the extent\n\t\t\t\t * allocation tree\n\t\t\t\t */\n\t\t\t\tret = btrfs_alloc_logged_file_extent(trans,\n\t\t\t\t\t\troot, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, &ins);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tif (btrfs_file_extent_compression(eb, item)) {\n\t\t\t\tcsum_start = ins.objectid;\n\t\t\t\tcsum_end = csum_start + ins.offset;\n\t\t\t} else {\n\t\t\t\tcsum_start = ins.objectid +\n\t\t\t\t\tbtrfs_file_extent_offset(eb, item);\n\t\t\t\tcsum_end = csum_start +\n\t\t\t\t\tbtrfs_file_extent_num_bytes(eb, item);\n\t\t\t}\n\n\t\t\tret = btrfs_lookup_csums_range(root->log_root,\n\t\t\t\t\t\tcsum_start, csum_end - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\twhile (!list_empty(&ordered_sums)) {\n\t\t\t\tstruct btrfs_ordered_sum *sums;\n\t\t\t\tsums = list_entry(ordered_sums.next,\n\t\t\t\t\t\tstruct btrfs_ordered_sum,\n\t\t\t\t\t\tlist);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_csum_file_blocks(trans,\n\t\t\t\t\t\troot->fs_info->csum_root,\n\t\t\t\t\t\tsums);\n\t\t\t\tlist_del(&sums->list);\n\t\t\t\tkfree(sums);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t/* inline extents are easy, we just overwrite them */\n\t\tret = overwrite_item(trans, root, path, eb, slot, key);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tinode_add_bytes(inode, nbytes);\n\tret = btrfs_update_inode(trans, root, inode);\nout:\n\tif (inode)\n\t\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int replay_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct extent_buffer *eb, int slot,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tint found_type;\n\tu64 extent_end;\n\tu64 start = key->offset;\n\tu64 nbytes = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct inode *inode = NULL;\n\tunsigned long size;\n\tint ret = 0;\n\n\titem = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(eb, item);\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tnbytes = btrfs_file_extent_num_bytes(eb, item);\n\t\textent_end = start + nbytes;\n\n\t\t/*\n\t\t * We don't add to the inodes nbytes if we are prealloc or a\n\t\t * hole.\n\t\t */\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tnbytes = 0;\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize = btrfs_file_extent_inline_len(eb, slot, item);\n\t\tnbytes = btrfs_file_extent_ram_bytes(eb, item);\n\t\textent_end = ALIGN(start + size, root->sectorsize);\n\t} else {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, key->objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * first check to see if we already have this extent in the\n\t * file.  This must be done before the btrfs_drop_extents run\n\t * so we don't try to drop this extent.\n\t */\n\tret = btrfs_lookup_file_extent(trans, root, path, btrfs_ino(inode),\n\t\t\t\t       start, 0);\n\n\tif (ret == 0 &&\n\t    (found_type == BTRFS_FILE_EXTENT_REG ||\n\t     found_type == BTRFS_FILE_EXTENT_PREALLOC)) {\n\t\tstruct btrfs_file_extent_item cmp1;\n\t\tstruct btrfs_file_extent_item cmp2;\n\t\tstruct btrfs_file_extent_item *existing;\n\t\tstruct extent_buffer *leaf;\n\n\t\tleaf = path->nodes[0];\n\t\texisting = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_file_extent_item);\n\n\t\tread_extent_buffer(eb, &cmp1, (unsigned long)item,\n\t\t\t\t   sizeof(cmp1));\n\t\tread_extent_buffer(leaf, &cmp2, (unsigned long)existing,\n\t\t\t\t   sizeof(cmp2));\n\n\t\t/*\n\t\t * we already have a pointer to this exact extent,\n\t\t * we don't have to do anything\n\t\t */\n\t\tif (memcmp(&cmp1, &cmp2, sizeof(cmp1)) == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* drop any overlapping extents */\n\tret = btrfs_drop_extents(trans, root, inode, start, extent_end, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 offset;\n\t\tunsigned long dest_offset;\n\t\tstruct btrfs_key ins;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, key,\n\t\t\t\t\t      sizeof(*item));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdest_offset = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\t\t    path->slots[0]);\n\t\tcopy_extent_buffer(path->nodes[0], eb, dest_offset,\n\t\t\t\t(unsigned long)item,  sizeof(*item));\n\n\t\tins.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tins.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\t\toffset = key->offset - btrfs_file_extent_offset(eb, item);\n\n\t\tif (ins.objectid > 0) {\n\t\t\tu64 csum_start;\n\t\t\tu64 csum_end;\n\t\t\tLIST_HEAD(ordered_sums);\n\t\t\t/*\n\t\t\t * is this extent already allocated in the extent\n\t\t\t * allocation tree?  If so, just add a reference\n\t\t\t */\n\t\t\tret = btrfs_lookup_data_extent(root, ins.objectid,\n\t\t\t\t\t\tins.offset);\n\t\t\tif (ret == 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tins.objectid, ins.offset,\n\t\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * insert the extent pointer in the extent\n\t\t\t\t * allocation tree\n\t\t\t\t */\n\t\t\t\tret = btrfs_alloc_logged_file_extent(trans,\n\t\t\t\t\t\troot, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, &ins);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tif (btrfs_file_extent_compression(eb, item)) {\n\t\t\t\tcsum_start = ins.objectid;\n\t\t\t\tcsum_end = csum_start + ins.offset;\n\t\t\t} else {\n\t\t\t\tcsum_start = ins.objectid +\n\t\t\t\t\tbtrfs_file_extent_offset(eb, item);\n\t\t\t\tcsum_end = csum_start +\n\t\t\t\t\tbtrfs_file_extent_num_bytes(eb, item);\n\t\t\t}\n\n\t\t\tret = btrfs_lookup_csums_range(root->log_root,\n\t\t\t\t\t\tcsum_start, csum_end - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\twhile (!list_empty(&ordered_sums)) {\n\t\t\t\tstruct btrfs_ordered_sum *sums;\n\t\t\t\tsums = list_entry(ordered_sums.next,\n\t\t\t\t\t\tstruct btrfs_ordered_sum,\n\t\t\t\t\t\tlist);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_csum_file_blocks(trans,\n\t\t\t\t\t\troot->fs_info->csum_root,\n\t\t\t\t\t\tsums);\n\t\t\t\tlist_del(&sums->list);\n\t\t\t\tkfree(sums);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t/* inline extents are easy, we just overwrite them */\n\t\tret = overwrite_item(trans, root, path, eb, slot, key);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tinode_add_bytes(inode, nbytes);\n\tret = btrfs_update_inode(trans, root, inode);\nout:\n\tif (inode)\n\t\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_inode_ref",
          "args": [
            "wc->trans",
            "root",
            "log",
            "path",
            "eb",
            "i",
            "&key"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "add_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1141-1268",
          "snippet": "static noinline int add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct extent_buffer *eb, int slot,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct inode *dir = NULL;\n\tstruct inode *inode = NULL;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tchar *name = NULL;\n\tint namelen;\n\tint ret;\n\tint search_done = 0;\n\tint log_ref_ver = 0;\n\tu64 parent_objectid;\n\tu64 inode_objectid;\n\tu64 ref_index = 0;\n\tint ref_struct_size;\n\n\tref_ptr = btrfs_item_ptr_offset(eb, slot);\n\tref_end = ref_ptr + btrfs_item_size_nr(eb, slot);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tstruct btrfs_inode_extref *r;\n\n\t\tref_struct_size = sizeof(struct btrfs_inode_extref);\n\t\tlog_ref_ver = 1;\n\t\tr = (struct btrfs_inode_extref *)ref_ptr;\n\t\tparent_objectid = btrfs_inode_extref_parent(eb, r);\n\t} else {\n\t\tref_struct_size = sizeof(struct btrfs_inode_ref);\n\t\tparent_objectid = key->offset;\n\t}\n\tinode_objectid = key->objectid;\n\n\t/*\n\t * it is possible that we didn't log all the parent directories\n\t * for a given inode.  If we don't find the dir, just don't\n\t * copy the back ref in.  The link count fixup code will take\n\t * care of the rest\n\t */\n\tdir = read_one_inode(root, parent_objectid);\n\tif (!dir) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, inode_objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (ref_ptr < ref_end) {\n\t\tif (log_ref_ver) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t\t&ref_index, &parent_objectid);\n\t\t\t/*\n\t\t\t * parent object can change from one array\n\t\t\t * item to another.\n\t\t\t */\n\t\t\tif (!dir)\n\t\t\t\tdir = read_one_inode(root, parent_objectid);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t     &ref_index);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/* if we already have a perfect match, we're done */\n\t\tif (!inode_in_dir(root, path, btrfs_ino(dir), btrfs_ino(inode),\n\t\t\t\t  ref_index, name, namelen)) {\n\t\t\t/*\n\t\t\t * look for a conflicting back reference in the\n\t\t\t * metadata. if we find one we have to unlink that name\n\t\t\t * of the file before we add our new link.  Later on, we\n\t\t\t * overwrite any existing back reference, and we don't\n\t\t\t * want to create dangling pointers in the directory.\n\t\t\t */\n\n\t\t\tif (!search_done) {\n\t\t\t\tret = __add_inode_ref(trans, root, path, log,\n\t\t\t\t\t\t      dir, inode, eb,\n\t\t\t\t\t\t      inode_objectid,\n\t\t\t\t\t\t      parent_objectid,\n\t\t\t\t\t\t      ref_index, name, namelen,\n\t\t\t\t\t\t      &search_done);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret == 1)\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert our name */\n\t\t\tret = btrfs_add_link(trans, dir, inode, name, namelen,\n\t\t\t\t\t     0, ref_index);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tbtrfs_update_inode(trans, root, inode);\n\t\t}\n\n\t\tref_ptr = (unsigned long)(ref_ptr + ref_struct_size) + namelen;\n\t\tkfree(name);\n\t\tname = NULL;\n\t\tif (log_ref_ver) {\n\t\t\tiput(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\t/* finally write the back reference in the inode */\n\tret = overwrite_item(trans, root, path, eb, slot, key);\nout:\n\tbtrfs_release_path(path);\n\tkfree(name);\n\tiput(dir);\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct extent_buffer *eb, int slot,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct inode *dir = NULL;\n\tstruct inode *inode = NULL;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tchar *name = NULL;\n\tint namelen;\n\tint ret;\n\tint search_done = 0;\n\tint log_ref_ver = 0;\n\tu64 parent_objectid;\n\tu64 inode_objectid;\n\tu64 ref_index = 0;\n\tint ref_struct_size;\n\n\tref_ptr = btrfs_item_ptr_offset(eb, slot);\n\tref_end = ref_ptr + btrfs_item_size_nr(eb, slot);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tstruct btrfs_inode_extref *r;\n\n\t\tref_struct_size = sizeof(struct btrfs_inode_extref);\n\t\tlog_ref_ver = 1;\n\t\tr = (struct btrfs_inode_extref *)ref_ptr;\n\t\tparent_objectid = btrfs_inode_extref_parent(eb, r);\n\t} else {\n\t\tref_struct_size = sizeof(struct btrfs_inode_ref);\n\t\tparent_objectid = key->offset;\n\t}\n\tinode_objectid = key->objectid;\n\n\t/*\n\t * it is possible that we didn't log all the parent directories\n\t * for a given inode.  If we don't find the dir, just don't\n\t * copy the back ref in.  The link count fixup code will take\n\t * care of the rest\n\t */\n\tdir = read_one_inode(root, parent_objectid);\n\tif (!dir) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, inode_objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (ref_ptr < ref_end) {\n\t\tif (log_ref_ver) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t\t&ref_index, &parent_objectid);\n\t\t\t/*\n\t\t\t * parent object can change from one array\n\t\t\t * item to another.\n\t\t\t */\n\t\t\tif (!dir)\n\t\t\t\tdir = read_one_inode(root, parent_objectid);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t     &ref_index);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/* if we already have a perfect match, we're done */\n\t\tif (!inode_in_dir(root, path, btrfs_ino(dir), btrfs_ino(inode),\n\t\t\t\t  ref_index, name, namelen)) {\n\t\t\t/*\n\t\t\t * look for a conflicting back reference in the\n\t\t\t * metadata. if we find one we have to unlink that name\n\t\t\t * of the file before we add our new link.  Later on, we\n\t\t\t * overwrite any existing back reference, and we don't\n\t\t\t * want to create dangling pointers in the directory.\n\t\t\t */\n\n\t\t\tif (!search_done) {\n\t\t\t\tret = __add_inode_ref(trans, root, path, log,\n\t\t\t\t\t\t      dir, inode, eb,\n\t\t\t\t\t\t      inode_objectid,\n\t\t\t\t\t\t      parent_objectid,\n\t\t\t\t\t\t      ref_index, name, namelen,\n\t\t\t\t\t\t      &search_done);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret == 1)\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert our name */\n\t\t\tret = btrfs_add_link(trans, dir, inode, name, namelen,\n\t\t\t\t\t     0, ref_index);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tbtrfs_update_inode(trans, root, inode);\n\t\t}\n\n\t\tref_ptr = (unsigned long)(ref_ptr + ref_struct_size) + namelen;\n\t\tkfree(name);\n\t\tname = NULL;\n\t\tif (log_ref_ver) {\n\t\t\tiput(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\t/* finally write the back reference in the inode */\n\tret = overwrite_item(trans, root, path, eb, slot, key);\nout:\n\tbtrfs_release_path(path);\n\tkfree(name);\n\tiput(dir);\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "overwrite_item",
          "args": [
            "wc->trans",
            "root",
            "path",
            "eb",
            "i",
            "&key"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "overwrite_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "341-539",
          "snippet": "static noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_to_fixup_dir",
          "args": [
            "wc->trans",
            "root",
            "path",
            "key.objectid"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "link_to_fixup_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1501-1535",
          "snippet": "static noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_orphan_item",
          "args": [
            "wc->trans",
            "root",
            "key.objectid"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "insert_orphan_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1270-1280",
          "snippet": "static int insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 ino)\n{\n\tint ret;\n\n\tret = btrfs_insert_orphan_item(trans, root, ino);\n\tif (ret == -EEXIST)\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 ino)\n{\n\tint ret;\n\n\tret = btrfs_insert_orphan_item(trans, root, ino);\n\tif (ret == -EEXIST)\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replay_dir_deletes",
          "args": [
            "wc->trans",
            "root",
            "log",
            "path",
            "key.objectid",
            "0"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "replay_dir_deletes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1964-2058",
          "snippet": "static noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint key_type = BTRFS_DIR_LOG_ITEM_KEY;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_ITEM_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t/* it isn't an error if the inode isn't there, that can happen\n\t * because we replay the deletes before we copy in the inode item\n\t * from the log\n\t */\n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\nagain:\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid, key_type,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type)\n\t\t\t\tgoto next_type;\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, root, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\nnext_type:\n\tret = 0;\n\tif (key_type == BTRFS_DIR_LOG_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_LOG_INDEX_KEY;\n\t\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);\nstatic noinline struct;\n\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint key_type = BTRFS_DIR_LOG_ITEM_KEY;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_ITEM_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t/* it isn't an error if the inode isn't there, that can happen\n\t * because we replay the deletes before we copy in the inode item\n\t * from the log\n\t */\n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\nagain:\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid, key_type,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type)\n\t\t\t\tgoto next_type;\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, root, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\nnext_type:\n\tret = 0;\n\tif (key_type == BTRFS_DIR_LOG_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_LOG_INDEX_KEY;\n\t\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "eb",
            "inode_item"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "i",
            "structbtrfs_inode_item"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&key",
            "i"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_buffer",
          "args": [
            "eb",
            "gen"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3831-3835",
          "snippet": "int btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define LOG_WALK_REPLAY_ALL 3\n#define LOG_WALK_REPLAY_DIR_INDEX 2\n#define LOG_WALK_REPLAY_INODES 1\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int replay_one_buffer(struct btrfs_root *log, struct extent_buffer *eb,\n\t\t\t     struct walk_control *wc, u64 gen)\n{\n\tint nritems;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = wc->replay_dest;\n\tstruct btrfs_key key;\n\tint level;\n\tint i;\n\tint ret;\n\n\tret = btrfs_read_buffer(eb, gen);\n\tif (ret)\n\t\treturn ret;\n\n\tlevel = btrfs_header_level(eb);\n\n\tif (level != 0)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnritems = btrfs_header_nritems(eb);\n\tfor (i = 0; i < nritems; i++) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, i);\n\n\t\t/* inode keys are done during the first stage */\n\t\tif (key.type == BTRFS_INODE_ITEM_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_INODES) {\n\t\t\tstruct btrfs_inode_item *inode_item;\n\t\t\tu32 mode;\n\n\t\t\tinode_item = btrfs_item_ptr(eb, i,\n\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tmode = btrfs_inode_mode(eb, inode_item);\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tret = replay_dir_deletes(wc->trans,\n\t\t\t\t\t root, log, path, key.objectid, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t/* for regular files, make sure corresponding\n\t\t\t * orhpan item exist. extents past the new EOF\n\t\t\t * will be truncated later by orphan cleanup.\n\t\t\t */\n\t\t\tif (S_ISREG(mode)) {\n\t\t\t\tret = insert_orphan_item(wc->trans, root,\n\t\t\t\t\t\t\t key.objectid);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(wc->trans, root,\n\t\t\t\t\t\tpath, key.objectid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type == BTRFS_DIR_INDEX_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_DIR_INDEX) {\n\t\t\tret = replay_one_dir_item(wc->trans, root, path,\n\t\t\t\t\t\t  eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage < LOG_WALK_REPLAY_ALL)\n\t\t\tcontinue;\n\n\t\t/* these keys are simply copied */\n\t\tif (key.type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (key.type == BTRFS_INODE_REF_KEY ||\n\t\t\t   key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = add_inode_ref(wc->trans, root, log, path,\n\t\t\t\t\t    eb, i, &key);\n\t\t\tif (ret && ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t} else if (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tret = replay_one_extent(wc->trans, root, path,\n\t\t\t\t\t\teb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (key.type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tret = replay_one_dir_item(wc->trans, root, path,\n\t\t\t\t\t\t  eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "replay_dir_deletes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1964-2058",
    "snippet": "static noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint key_type = BTRFS_DIR_LOG_ITEM_KEY;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_ITEM_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t/* it isn't an error if the inode isn't there, that can happen\n\t * because we replay the deletes before we copy in the inode item\n\t * from the log\n\t */\n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\nagain:\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid, key_type,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type)\n\t\t\t\tgoto next_type;\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, root, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\nnext_type:\n\tret = 0;\n\tif (key_type == BTRFS_DIR_LOG_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_LOG_INDEX_KEY;\n\t\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dir"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "log_path"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_item_in_log",
          "args": [
            "trans",
            "root",
            "log",
            "path",
            "log_path",
            "dir",
            "&found_key"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "check_item_in_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1846-1952",
          "snippet": "static noinline int check_item_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_root *log,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_path *log_path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_key *dir_key)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_dir_item *log_di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tchar *name;\n\tstruct inode *inode;\n\tstruct btrfs_key location;\n\nagain:\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tname = kmalloc(name_len, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t\t\t  name_len);\n\t\tlog_di = NULL;\n\t\tif (log && dir_key->type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_item(trans, log, log_path,\n\t\t\t\t\t\t       dir_key->objectid,\n\t\t\t\t\t\t       name, name_len, 0);\n\t\t} else if (log && dir_key->type == BTRFS_DIR_INDEX_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_index_item(trans, log,\n\t\t\t\t\t\t     log_path,\n\t\t\t\t\t\t     dir_key->objectid,\n\t\t\t\t\t\t     dir_key->offset,\n\t\t\t\t\t\t     name, name_len, 0);\n\t\t}\n\t\tif (!log_di || (IS_ERR(log_di) && PTR_ERR(log_di) == -ENOENT)) {\n\t\t\tbtrfs_dir_item_key_to_cpu(eb, di, &location);\n\t\t\tbtrfs_release_path(path);\n\t\t\tbtrfs_release_path(log_path);\n\t\t\tinode = read_one_inode(root, location.objectid);\n\t\t\tif (!inode) {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(trans, root,\n\t\t\t\t\t\tpath, location.objectid);\n\t\t\tif (ret) {\n\t\t\t\tkfree(name);\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tinc_nlink(inode);\n\t\t\tret = btrfs_unlink_inode(trans, root, dir, inode,\n\t\t\t\t\t\t name, name_len);\n\t\t\tif (!ret)\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\tkfree(name);\n\t\t\tiput(inode);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t/* there might still be more names under this key\n\t\t\t * check and repeat if required\n\t\t\t */\n\t\t\tret = btrfs_search_slot(NULL, root, dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto again;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (IS_ERR(log_di)) {\n\t\t\tkfree(name);\n\t\t\treturn PTR_ERR(log_di);\n\t\t}\n\t\tbtrfs_release_path(log_path);\n\t\tkfree(name);\n\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(log_path);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int check_item_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_root *log,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_path *log_path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_key *dir_key)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_dir_item *log_di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tchar *name;\n\tstruct inode *inode;\n\tstruct btrfs_key location;\n\nagain:\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tname = kmalloc(name_len, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t\t\t  name_len);\n\t\tlog_di = NULL;\n\t\tif (log && dir_key->type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_item(trans, log, log_path,\n\t\t\t\t\t\t       dir_key->objectid,\n\t\t\t\t\t\t       name, name_len, 0);\n\t\t} else if (log && dir_key->type == BTRFS_DIR_INDEX_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_index_item(trans, log,\n\t\t\t\t\t\t     log_path,\n\t\t\t\t\t\t     dir_key->objectid,\n\t\t\t\t\t\t     dir_key->offset,\n\t\t\t\t\t\t     name, name_len, 0);\n\t\t}\n\t\tif (!log_di || (IS_ERR(log_di) && PTR_ERR(log_di) == -ENOENT)) {\n\t\t\tbtrfs_dir_item_key_to_cpu(eb, di, &location);\n\t\t\tbtrfs_release_path(path);\n\t\t\tbtrfs_release_path(log_path);\n\t\t\tinode = read_one_inode(root, location.objectid);\n\t\t\tif (!inode) {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(trans, root,\n\t\t\t\t\t\tpath, location.objectid);\n\t\t\tif (ret) {\n\t\t\t\tkfree(name);\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tinc_nlink(inode);\n\t\t\tret = btrfs_unlink_inode(trans, root, dir, inode,\n\t\t\t\t\t\t name, name_len);\n\t\t\tif (!ret)\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\tkfree(name);\n\t\t\tiput(inode);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t/* there might still be more names under this key\n\t\t\t * check and repeat if required\n\t\t\t */\n\t\t\tret = btrfs_search_slot(NULL, root, dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto again;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (IS_ERR(log_di)) {\n\t\t\tkfree(name);\n\t\t\treturn PTR_ERR(log_di);\n\t\t}\n\t\tbtrfs_release_path(log_path);\n\t\tkfree(name);\n\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(log_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&dir_key",
            "path",
            "0",
            "0"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_dir_range",
          "args": [
            "log",
            "path",
            "dirid",
            "key_type",
            "&range_start",
            "&range_end"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "find_dir_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1769-1839",
          "snippet": "static noinline int find_dir_range(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u64 dirid, int key_type,\n\t\t\t\t   u64 *start_ret, u64 *end_ret)\n{\n\tstruct btrfs_key key;\n\tu64 found_end;\n\tstruct btrfs_dir_log_item *item;\n\tint ret;\n\tint nritems;\n\n\tif (*start_ret == (u64)-1)\n\t\treturn 1;\n\n\tkey.objectid = dirid;\n\tkey.type = key_type;\n\tkey.offset = *start_ret;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\tif (ret != 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto next;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\n\tif (*start_ret >= key.offset && *start_ret <= found_end) {\n\t\tret = 0;\n\t\t*start_ret = key.offset;\n\t\t*end_ret = found_end;\n\t\tgoto out;\n\t}\n\tret = 1;\nnext:\n\t/* check the next slot in the tree to see if it is a valid item */\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (path->slots[0] >= nritems) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tpath->slots[0]++;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\t*start_ret = key.offset;\n\t*end_ret = found_end;\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int find_dir_range(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u64 dirid, int key_type,\n\t\t\t\t   u64 *start_ret, u64 *end_ret)\n{\n\tstruct btrfs_key key;\n\tu64 found_end;\n\tstruct btrfs_dir_log_item *item;\n\tint ret;\n\tint nritems;\n\n\tif (*start_ret == (u64)-1)\n\t\treturn 1;\n\n\tkey.objectid = dirid;\n\tkey.type = key_type;\n\tkey.offset = *start_ret;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\tif (ret != 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto next;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\n\tif (*start_ret >= key.offset && *start_ret <= found_end) {\n\t\tret = 0;\n\t\t*start_ret = key.offset;\n\t\t*end_ret = found_end;\n\t\tgoto out;\n\t}\n\tret = 1;\nnext:\n\t/* check the next slot in the tree to see if it is a valid item */\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (path->slots[0] >= nritems) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tpath->slots[0]++;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\t*start_ret = key.offset;\n\t*end_ret = found_end;\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "dirid"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);\nstatic noinline struct;\n\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint key_type = BTRFS_DIR_LOG_ITEM_KEY;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_ITEM_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t/* it isn't an error if the inode isn't there, that can happen\n\t * because we replay the deletes before we copy in the inode item\n\t * from the log\n\t */\n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\nagain:\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid, key_type,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type)\n\t\t\t\tgoto next_type;\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, root, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\nnext_type:\n\tret = 0;\n\tif (key_type == BTRFS_DIR_LOG_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_LOG_INDEX_KEY;\n\t\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_item_in_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1846-1952",
    "snippet": "static noinline int check_item_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_root *log,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_path *log_path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_key *dir_key)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_dir_item *log_di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tchar *name;\n\tstruct inode *inode;\n\tstruct btrfs_key location;\n\nagain:\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tname = kmalloc(name_len, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t\t\t  name_len);\n\t\tlog_di = NULL;\n\t\tif (log && dir_key->type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_item(trans, log, log_path,\n\t\t\t\t\t\t       dir_key->objectid,\n\t\t\t\t\t\t       name, name_len, 0);\n\t\t} else if (log && dir_key->type == BTRFS_DIR_INDEX_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_index_item(trans, log,\n\t\t\t\t\t\t     log_path,\n\t\t\t\t\t\t     dir_key->objectid,\n\t\t\t\t\t\t     dir_key->offset,\n\t\t\t\t\t\t     name, name_len, 0);\n\t\t}\n\t\tif (!log_di || (IS_ERR(log_di) && PTR_ERR(log_di) == -ENOENT)) {\n\t\t\tbtrfs_dir_item_key_to_cpu(eb, di, &location);\n\t\t\tbtrfs_release_path(path);\n\t\t\tbtrfs_release_path(log_path);\n\t\t\tinode = read_one_inode(root, location.objectid);\n\t\t\tif (!inode) {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(trans, root,\n\t\t\t\t\t\tpath, location.objectid);\n\t\t\tif (ret) {\n\t\t\t\tkfree(name);\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tinc_nlink(inode);\n\t\t\tret = btrfs_unlink_inode(trans, root, dir, inode,\n\t\t\t\t\t\t name, name_len);\n\t\t\tif (!ret)\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\tkfree(name);\n\t\t\tiput(inode);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t/* there might still be more names under this key\n\t\t\t * check and repeat if required\n\t\t\t */\n\t\t\tret = btrfs_search_slot(NULL, root, dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto again;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (IS_ERR(log_di)) {\n\t\t\tkfree(name);\n\t\t\treturn PTR_ERR(log_di);\n\t\t}\n\t\tbtrfs_release_path(log_path);\n\t\tkfree(name);\n\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(log_path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "log_path"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "log_di"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "log_di"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "dir_key",
            "path",
            "0",
            "0"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_items",
          "args": [
            "trans",
            "root"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1205-1209",
          "snippet": "int btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlink_inode",
          "args": [
            "trans",
            "root",
            "dir",
            "inode",
            "name",
            "name_len"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3957-3969",
          "snippet": "int btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_to_fixup_dir",
          "args": [
            "trans",
            "root",
            "path",
            "location.objectid"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "link_to_fixup_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1501-1535",
          "snippet": "static noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "location.objectid"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "eb",
            "di",
            "&location"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "log_di"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "log_di"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_index_item",
          "args": [
            "trans",
            "log",
            "log_path",
            "dir_key->objectid",
            "dir_key->offset",
            "name",
            "name_len",
            "0"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_index_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "283-305",
          "snippet": "struct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "trans",
            "log",
            "log_path",
            "dir_key->objectid",
            "name",
            "name_len",
            "0"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "name",
            "(unsigned long)(di + 1)",
            "name_len"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "name_len",
            "GFP_NOFS"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "eb",
            "di"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_dir_item",
          "args": [
            "root",
            "eb",
            "di"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "450-482",
          "snippet": "int verify_dir_item(struct btrfs_root *root,\n\t\t    struct extent_buffer *leaf,\n\t\t    struct btrfs_dir_item *dir_item)\n{\n\tu16 namelen = BTRFS_NAME_LEN;\n\tu8 type = btrfs_dir_type(leaf, dir_item);\n\n\tif (type >= BTRFS_FT_MAX) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item type: %d\",\n\t\t       (int)type);\n\t\treturn 1;\n\t}\n\n\tif (type == BTRFS_FT_XATTR)\n\t\tnamelen = XATTR_NAME_MAX;\n\n\tif (btrfs_dir_name_len(leaf, dir_item) > namelen) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name len: %u\",\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\t/* BTRFS_MAX_XATTR_SIZE is the same for all dir items */\n\tif ((btrfs_dir_data_len(leaf, dir_item) +\n\t     btrfs_dir_name_len(leaf, dir_item)) > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name + data len: %u + %u\",\n\t\t       (unsigned)btrfs_dir_name_len(leaf, dir_item),\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint verify_dir_item(struct btrfs_root *root,\n\t\t    struct extent_buffer *leaf,\n\t\t    struct btrfs_dir_item *dir_item)\n{\n\tu16 namelen = BTRFS_NAME_LEN;\n\tu8 type = btrfs_dir_type(leaf, dir_item);\n\n\tif (type >= BTRFS_FT_MAX) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item type: %d\",\n\t\t       (int)type);\n\t\treturn 1;\n\t}\n\n\tif (type == BTRFS_FT_XATTR)\n\t\tnamelen = XATTR_NAME_MAX;\n\n\tif (btrfs_dir_name_len(leaf, dir_item) > namelen) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name len: %u\",\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\t/* BTRFS_MAX_XATTR_SIZE is the same for all dir items */\n\tif ((btrfs_dir_data_len(leaf, dir_item) +\n\t     btrfs_dir_name_len(leaf, dir_item)) > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name + data len: %u + %u\",\n\t\t       (unsigned)btrfs_dir_name_len(leaf, dir_item),\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int check_item_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_root *log,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_path *log_path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_key *dir_key)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_dir_item *log_di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tchar *name;\n\tstruct inode *inode;\n\tstruct btrfs_key location;\n\nagain:\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tname = kmalloc(name_len, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t\t\t  name_len);\n\t\tlog_di = NULL;\n\t\tif (log && dir_key->type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_item(trans, log, log_path,\n\t\t\t\t\t\t       dir_key->objectid,\n\t\t\t\t\t\t       name, name_len, 0);\n\t\t} else if (log && dir_key->type == BTRFS_DIR_INDEX_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_index_item(trans, log,\n\t\t\t\t\t\t     log_path,\n\t\t\t\t\t\t     dir_key->objectid,\n\t\t\t\t\t\t     dir_key->offset,\n\t\t\t\t\t\t     name, name_len, 0);\n\t\t}\n\t\tif (!log_di || (IS_ERR(log_di) && PTR_ERR(log_di) == -ENOENT)) {\n\t\t\tbtrfs_dir_item_key_to_cpu(eb, di, &location);\n\t\t\tbtrfs_release_path(path);\n\t\t\tbtrfs_release_path(log_path);\n\t\t\tinode = read_one_inode(root, location.objectid);\n\t\t\tif (!inode) {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(trans, root,\n\t\t\t\t\t\tpath, location.objectid);\n\t\t\tif (ret) {\n\t\t\t\tkfree(name);\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tinc_nlink(inode);\n\t\t\tret = btrfs_unlink_inode(trans, root, dir, inode,\n\t\t\t\t\t\t name, name_len);\n\t\t\tif (!ret)\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\tkfree(name);\n\t\t\tiput(inode);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t/* there might still be more names under this key\n\t\t\t * check and repeat if required\n\t\t\t */\n\t\t\tret = btrfs_search_slot(NULL, root, dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto again;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (IS_ERR(log_di)) {\n\t\t\tkfree(name);\n\t\t\treturn PTR_ERR(log_di);\n\t\t}\n\t\tbtrfs_release_path(log_path);\n\t\tkfree(name);\n\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(log_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_dir_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1769-1839",
    "snippet": "static noinline int find_dir_range(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u64 dirid, int key_type,\n\t\t\t\t   u64 *start_ret, u64 *end_ret)\n{\n\tstruct btrfs_key key;\n\tu64 found_end;\n\tstruct btrfs_dir_log_item *item;\n\tint ret;\n\tint nritems;\n\n\tif (*start_ret == (u64)-1)\n\t\treturn 1;\n\n\tkey.objectid = dirid;\n\tkey.type = key_type;\n\tkey.offset = *start_ret;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\tif (ret != 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto next;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\n\tif (*start_ret >= key.offset && *start_ret <= found_end) {\n\t\tret = 0;\n\t\t*start_ret = key.offset;\n\t\t*end_ret = found_end;\n\t\tgoto out;\n\t}\n\tret = 1;\nnext:\n\t/* check the next slot in the tree to see if it is a valid item */\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (path->slots[0] >= nritems) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tpath->slots[0]++;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\t*start_ret = key.offset;\n\t*end_ret = found_end;\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_log_end",
          "args": [
            "path->nodes[0]",
            "item"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_dir_log_item"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&key",
            "path->slots[0]"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_log_end",
          "args": [
            "path->nodes[0]",
            "item"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_dir_log_item"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int find_dir_range(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u64 dirid, int key_type,\n\t\t\t\t   u64 *start_ret, u64 *end_ret)\n{\n\tstruct btrfs_key key;\n\tu64 found_end;\n\tstruct btrfs_dir_log_item *item;\n\tint ret;\n\tint nritems;\n\n\tif (*start_ret == (u64)-1)\n\t\treturn 1;\n\n\tkey.objectid = dirid;\n\tkey.type = key_type;\n\tkey.offset = *start_ret;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\tif (ret != 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto next;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\n\tif (*start_ret >= key.offset && *start_ret <= found_end) {\n\t\tret = 0;\n\t\t*start_ret = key.offset;\n\t\t*end_ret = found_end;\n\t\tgoto out;\n\t}\n\tret = 1;\nnext:\n\t/* check the next slot in the tree to see if it is a valid item */\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (path->slots[0] >= nritems) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tpath->slots[0]++;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\t*start_ret = key.offset;\n\t*end_ret = found_end;\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "replay_one_dir_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1729-1756",
    "snippet": "static noinline int replay_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size = btrfs_item_size_nr(eb, slot);\n\tstruct btrfs_dir_item *di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di))\n\t\t\treturn -EIO;\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tret = replay_one_name(trans, root, path, eb, di, key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "replay_one_name",
          "args": [
            "trans",
            "root",
            "path",
            "eb",
            "di",
            "key"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "replay_one_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1609-1721",
          "snippet": "static noinline int replay_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *eb,\n\t\t\t\t    struct btrfs_dir_item *di,\n\t\t\t\t    struct btrfs_key *key)\n{\n\tchar *name;\n\tint name_len;\n\tstruct btrfs_dir_item *dst_di;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key log_key;\n\tstruct inode *dir;\n\tu8 log_type;\n\tint exists;\n\tint ret = 0;\n\tbool update_size = (key->type == BTRFS_DIR_INDEX_KEY);\n\n\tdir = read_one_inode(root, key->objectid);\n\tif (!dir)\n\t\treturn -EIO;\n\n\tname_len = btrfs_dir_name_len(eb, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlog_type = btrfs_dir_type(eb, di);\n\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t   name_len);\n\n\tbtrfs_dir_item_key_to_cpu(eb, di, &log_key);\n\texists = btrfs_lookup_inode(trans, root, path, &log_key, 0);\n\tif (exists == 0)\n\t\texists = 1;\n\telse\n\t\texists = 0;\n\tbtrfs_release_path(path);\n\n\tif (key->type == BTRFS_DIR_ITEM_KEY) {\n\t\tdst_di = btrfs_lookup_dir_item(trans, root, path, key->objectid,\n\t\t\t\t       name, name_len, 1);\n\t} else if (key->type == BTRFS_DIR_INDEX_KEY) {\n\t\tdst_di = btrfs_lookup_dir_index_item(trans, root, path,\n\t\t\t\t\t\t     key->objectid,\n\t\t\t\t\t\t     key->offset, name,\n\t\t\t\t\t\t     name_len, 1);\n\t} else {\n\t\t/* Corruption */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (IS_ERR_OR_NULL(dst_di)) {\n\t\t/* we need a sequence number to insert, so we only\n\t\t * do inserts for the BTRFS_DIR_INDEX_KEY types\n\t\t */\n\t\tif (key->type != BTRFS_DIR_INDEX_KEY)\n\t\t\tgoto out;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], dst_di, &found_key);\n\t/* the existing item matches the logged item */\n\tif (found_key.objectid == log_key.objectid &&\n\t    found_key.type == log_key.type &&\n\t    found_key.offset == log_key.offset &&\n\t    btrfs_dir_type(path->nodes[0], dst_di) == log_type) {\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * don't drop the conflicting directory entry if the inode\n\t * for the new entry doesn't exist\n\t */\n\tif (!exists)\n\t\tgoto out;\n\n\tret = drop_one_dir_item(trans, root, path, dir, dst_di);\n\tif (ret)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_DIR_INDEX_KEY)\n\t\tgoto insert;\nout:\n\tbtrfs_release_path(path);\n\tif (!ret && update_size) {\n\t\tbtrfs_i_size_write(dir, dir->i_size + name_len * 2);\n\t\tret = btrfs_update_inode(trans, root, dir);\n\t}\n\tkfree(name);\n\tiput(dir);\n\treturn ret;\n\ninsert:\n\tif (name_in_log_ref(root->log_root, name, name_len,\n\t\t\t    key->objectid, log_key.objectid)) {\n\t\t/* The dentry will be added later. */\n\t\tret = 0;\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\tret = insert_one_name(trans, root, path, key->objectid, key->offset,\n\t\t\t      name, name_len, log_type, &log_key);\n\tif (ret && ret != -ENOENT && ret != -EEXIST)\n\t\tgoto out;\n\tupdate_size = false;\n\tret = 0;\n\tgoto out;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int replay_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *eb,\n\t\t\t\t    struct btrfs_dir_item *di,\n\t\t\t\t    struct btrfs_key *key)\n{\n\tchar *name;\n\tint name_len;\n\tstruct btrfs_dir_item *dst_di;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key log_key;\n\tstruct inode *dir;\n\tu8 log_type;\n\tint exists;\n\tint ret = 0;\n\tbool update_size = (key->type == BTRFS_DIR_INDEX_KEY);\n\n\tdir = read_one_inode(root, key->objectid);\n\tif (!dir)\n\t\treturn -EIO;\n\n\tname_len = btrfs_dir_name_len(eb, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlog_type = btrfs_dir_type(eb, di);\n\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t   name_len);\n\n\tbtrfs_dir_item_key_to_cpu(eb, di, &log_key);\n\texists = btrfs_lookup_inode(trans, root, path, &log_key, 0);\n\tif (exists == 0)\n\t\texists = 1;\n\telse\n\t\texists = 0;\n\tbtrfs_release_path(path);\n\n\tif (key->type == BTRFS_DIR_ITEM_KEY) {\n\t\tdst_di = btrfs_lookup_dir_item(trans, root, path, key->objectid,\n\t\t\t\t       name, name_len, 1);\n\t} else if (key->type == BTRFS_DIR_INDEX_KEY) {\n\t\tdst_di = btrfs_lookup_dir_index_item(trans, root, path,\n\t\t\t\t\t\t     key->objectid,\n\t\t\t\t\t\t     key->offset, name,\n\t\t\t\t\t\t     name_len, 1);\n\t} else {\n\t\t/* Corruption */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (IS_ERR_OR_NULL(dst_di)) {\n\t\t/* we need a sequence number to insert, so we only\n\t\t * do inserts for the BTRFS_DIR_INDEX_KEY types\n\t\t */\n\t\tif (key->type != BTRFS_DIR_INDEX_KEY)\n\t\t\tgoto out;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], dst_di, &found_key);\n\t/* the existing item matches the logged item */\n\tif (found_key.objectid == log_key.objectid &&\n\t    found_key.type == log_key.type &&\n\t    found_key.offset == log_key.offset &&\n\t    btrfs_dir_type(path->nodes[0], dst_di) == log_type) {\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * don't drop the conflicting directory entry if the inode\n\t * for the new entry doesn't exist\n\t */\n\tif (!exists)\n\t\tgoto out;\n\n\tret = drop_one_dir_item(trans, root, path, dir, dst_di);\n\tif (ret)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_DIR_INDEX_KEY)\n\t\tgoto insert;\nout:\n\tbtrfs_release_path(path);\n\tif (!ret && update_size) {\n\t\tbtrfs_i_size_write(dir, dir->i_size + name_len * 2);\n\t\tret = btrfs_update_inode(trans, root, dir);\n\t}\n\tkfree(name);\n\tiput(dir);\n\treturn ret;\n\ninsert:\n\tif (name_in_log_ref(root->log_root, name, name_len,\n\t\t\t    key->objectid, log_key.objectid)) {\n\t\t/* The dentry will be added later. */\n\t\tret = 0;\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\tret = insert_one_name(trans, root, path, key->objectid, key->offset,\n\t\t\t      name, name_len, log_type, &log_key);\n\tif (ret && ret != -ENOENT && ret != -EEXIST)\n\t\tgoto out;\n\tupdate_size = false;\n\tret = 0;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "eb",
            "di"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verify_dir_item",
          "args": [
            "root",
            "eb",
            "di"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "verify_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "450-482",
          "snippet": "int verify_dir_item(struct btrfs_root *root,\n\t\t    struct extent_buffer *leaf,\n\t\t    struct btrfs_dir_item *dir_item)\n{\n\tu16 namelen = BTRFS_NAME_LEN;\n\tu8 type = btrfs_dir_type(leaf, dir_item);\n\n\tif (type >= BTRFS_FT_MAX) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item type: %d\",\n\t\t       (int)type);\n\t\treturn 1;\n\t}\n\n\tif (type == BTRFS_FT_XATTR)\n\t\tnamelen = XATTR_NAME_MAX;\n\n\tif (btrfs_dir_name_len(leaf, dir_item) > namelen) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name len: %u\",\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\t/* BTRFS_MAX_XATTR_SIZE is the same for all dir items */\n\tif ((btrfs_dir_data_len(leaf, dir_item) +\n\t     btrfs_dir_name_len(leaf, dir_item)) > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name + data len: %u + %u\",\n\t\t       (unsigned)btrfs_dir_name_len(leaf, dir_item),\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint verify_dir_item(struct btrfs_root *root,\n\t\t    struct extent_buffer *leaf,\n\t\t    struct btrfs_dir_item *dir_item)\n{\n\tu16 namelen = BTRFS_NAME_LEN;\n\tu8 type = btrfs_dir_type(leaf, dir_item);\n\n\tif (type >= BTRFS_FT_MAX) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item type: %d\",\n\t\t       (int)type);\n\t\treturn 1;\n\t}\n\n\tif (type == BTRFS_FT_XATTR)\n\t\tnamelen = XATTR_NAME_MAX;\n\n\tif (btrfs_dir_name_len(leaf, dir_item) > namelen) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name len: %u\",\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\t/* BTRFS_MAX_XATTR_SIZE is the same for all dir items */\n\tif ((btrfs_dir_data_len(leaf, dir_item) +\n\t     btrfs_dir_name_len(leaf, dir_item)) > BTRFS_MAX_XATTR_SIZE(root)) {\n\t\tbtrfs_crit(root->fs_info, \"invalid dir item name + data len: %u + %u\",\n\t\t       (unsigned)btrfs_dir_name_len(leaf, dir_item),\n\t\t       (unsigned)btrfs_dir_data_len(leaf, dir_item));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int replay_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size = btrfs_item_size_nr(eb, slot);\n\tstruct btrfs_dir_item *di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tif (verify_dir_item(root, eb, di))\n\t\t\treturn -EIO;\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tret = replay_one_name(trans, root, path, eb, di, key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "replay_one_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1609-1721",
    "snippet": "static noinline int replay_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *eb,\n\t\t\t\t    struct btrfs_dir_item *di,\n\t\t\t\t    struct btrfs_key *key)\n{\n\tchar *name;\n\tint name_len;\n\tstruct btrfs_dir_item *dst_di;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key log_key;\n\tstruct inode *dir;\n\tu8 log_type;\n\tint exists;\n\tint ret = 0;\n\tbool update_size = (key->type == BTRFS_DIR_INDEX_KEY);\n\n\tdir = read_one_inode(root, key->objectid);\n\tif (!dir)\n\t\treturn -EIO;\n\n\tname_len = btrfs_dir_name_len(eb, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlog_type = btrfs_dir_type(eb, di);\n\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t   name_len);\n\n\tbtrfs_dir_item_key_to_cpu(eb, di, &log_key);\n\texists = btrfs_lookup_inode(trans, root, path, &log_key, 0);\n\tif (exists == 0)\n\t\texists = 1;\n\telse\n\t\texists = 0;\n\tbtrfs_release_path(path);\n\n\tif (key->type == BTRFS_DIR_ITEM_KEY) {\n\t\tdst_di = btrfs_lookup_dir_item(trans, root, path, key->objectid,\n\t\t\t\t       name, name_len, 1);\n\t} else if (key->type == BTRFS_DIR_INDEX_KEY) {\n\t\tdst_di = btrfs_lookup_dir_index_item(trans, root, path,\n\t\t\t\t\t\t     key->objectid,\n\t\t\t\t\t\t     key->offset, name,\n\t\t\t\t\t\t     name_len, 1);\n\t} else {\n\t\t/* Corruption */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (IS_ERR_OR_NULL(dst_di)) {\n\t\t/* we need a sequence number to insert, so we only\n\t\t * do inserts for the BTRFS_DIR_INDEX_KEY types\n\t\t */\n\t\tif (key->type != BTRFS_DIR_INDEX_KEY)\n\t\t\tgoto out;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], dst_di, &found_key);\n\t/* the existing item matches the logged item */\n\tif (found_key.objectid == log_key.objectid &&\n\t    found_key.type == log_key.type &&\n\t    found_key.offset == log_key.offset &&\n\t    btrfs_dir_type(path->nodes[0], dst_di) == log_type) {\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * don't drop the conflicting directory entry if the inode\n\t * for the new entry doesn't exist\n\t */\n\tif (!exists)\n\t\tgoto out;\n\n\tret = drop_one_dir_item(trans, root, path, dir, dst_di);\n\tif (ret)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_DIR_INDEX_KEY)\n\t\tgoto insert;\nout:\n\tbtrfs_release_path(path);\n\tif (!ret && update_size) {\n\t\tbtrfs_i_size_write(dir, dir->i_size + name_len * 2);\n\t\tret = btrfs_update_inode(trans, root, dir);\n\t}\n\tkfree(name);\n\tiput(dir);\n\treturn ret;\n\ninsert:\n\tif (name_in_log_ref(root->log_root, name, name_len,\n\t\t\t    key->objectid, log_key.objectid)) {\n\t\t/* The dentry will be added later. */\n\t\tret = 0;\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\tret = insert_one_name(trans, root, path, key->objectid, key->offset,\n\t\t\t      name, name_len, log_type, &log_key);\n\tif (ret && ret != -ENOENT && ret != -EEXIST)\n\t\tgoto out;\n\tupdate_size = false;\n\tret = 0;\n\tgoto out;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_one_name",
          "args": [
            "trans",
            "root",
            "path",
            "key->objectid",
            "key->offset",
            "name",
            "name_len",
            "log_type",
            "&log_key"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "insert_one_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1542-1570",
          "snippet": "static noinline int insert_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    u64 dirid, u64 index,\n\t\t\t\t    char *name, int name_len, u8 type,\n\t\t\t\t    struct btrfs_key *location)\n{\n\tstruct inode *inode;\n\tstruct inode *dir;\n\tint ret;\n\n\tinode = read_one_inode(root, location->objectid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tdir = read_one_inode(root, dirid);\n\tif (!dir) {\n\t\tiput(inode);\n\t\treturn -EIO;\n\t}\n\n\tret = btrfs_add_link(trans, dir, inode, name, name_len, 1, index);\n\n\t/* FIXME, put inode into FIXUP list */\n\n\tiput(inode);\n\tiput(dir);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int insert_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    u64 dirid, u64 index,\n\t\t\t\t    char *name, int name_len, u8 type,\n\t\t\t\t    struct btrfs_key *location)\n{\n\tstruct inode *inode;\n\tstruct inode *dir;\n\tint ret;\n\n\tinode = read_one_inode(root, location->objectid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tdir = read_one_inode(root, dirid);\n\tif (!dir) {\n\t\tiput(inode);\n\t\treturn -EIO;\n\t}\n\n\tret = btrfs_add_link(trans, dir, inode, name, name_len, 1, index);\n\n\t/* FIXME, put inode into FIXUP list */\n\n\tiput(inode);\n\tiput(dir);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "name_in_log_ref",
          "args": [
            "root->log_root",
            "name",
            "name_len",
            "key->objectid",
            "log_key.objectid"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "name_in_log_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1576-1594",
          "snippet": "static bool name_in_log_ref(struct btrfs_root *log_root,\n\t\t\t    const char *name, const int name_len,\n\t\t\t    const u64 dirid, const u64 ino)\n{\n\tstruct btrfs_key search_key;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = dirid;\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\tsearch_key.offset = btrfs_extref_hash(dirid, name, name_len);\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic bool name_in_log_ref(struct btrfs_root *log_root,\n\t\t\t    const char *name, const int name_len,\n\t\t\t    const u64 dirid, const u64 ino)\n{\n\tstruct btrfs_key search_key;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = dirid;\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\tsearch_key.offset = btrfs_extref_hash(dirid, name, name_len);\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dir"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "dir"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_i_size_write",
          "args": [
            "dir",
            "dir->i_size + name_len * 2"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_one_dir_item",
          "args": [
            "trans",
            "root",
            "path",
            "dir",
            "dst_di"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "drop_one_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "766-809",
          "snippet": "static noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tname_len = btrfs_dir_name_len(leaf, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, name, (unsigned long)(di + 1), name_len);\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (ret)\n\t\tgoto out;\n\telse\n\t\tret = btrfs_run_delayed_items(trans, root);\nout:\n\tkfree(name);\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tname_len = btrfs_dir_name_len(leaf, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, name, (unsigned long)(di + 1), name_len);\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (ret)\n\t\tgoto out;\n\telse\n\t\tret = btrfs_run_delayed_items(trans, root);\nout:\n\tkfree(name);\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_type",
          "args": [
            "path->nodes[0]",
            "dst_di"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "dst_di",
            "&found_key"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "dst_di"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_index_item",
          "args": [
            "trans",
            "root",
            "path",
            "key->objectid",
            "key->offset",
            "name",
            "name_len",
            "1"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_index_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "283-305",
          "snippet": "struct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "trans",
            "root",
            "path",
            "key->objectid",
            "name",
            "name_len",
            "1"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_inode",
          "args": [
            "trans",
            "root",
            "path",
            "&log_key",
            "0"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-item.c",
          "lines": "416-440",
          "snippet": "int btrfs_lookup_inode(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t       *root, struct btrfs_path *path,\n\t\t       struct btrfs_key *location, int mod)\n{\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\n\tret = btrfs_search_slot(trans, root, location, path, ins_len, cow);\n\tif (ret > 0 && location->type == BTRFS_ROOT_ITEM_KEY &&\n\t    location->offset == (u64)-1 && path->slots[0] != 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid == location->objectid &&\n\t\t    found_key.type == location->type) {\n\t\t\tpath->slots[0]--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_lookup_inode(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t       *root, struct btrfs_path *path,\n\t\t       struct btrfs_key *location, int mod)\n{\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key found_key;\n\n\tret = btrfs_search_slot(trans, root, location, path, ins_len, cow);\n\tif (ret > 0 && location->type == BTRFS_ROOT_ITEM_KEY &&\n\t    location->offset == (u64)-1 && path->slots[0] != 0) {\n\t\tslot = path->slots[0] - 1;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid == location->objectid &&\n\t\t    found_key.type == location->type) {\n\t\t\tpath->slots[0]--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "name",
            "(unsigned long)(di + 1)",
            "name_len"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_type",
          "args": [
            "eb",
            "di"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "name_len",
            "GFP_NOFS"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "eb",
            "di"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "key->objectid"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int replay_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *eb,\n\t\t\t\t    struct btrfs_dir_item *di,\n\t\t\t\t    struct btrfs_key *key)\n{\n\tchar *name;\n\tint name_len;\n\tstruct btrfs_dir_item *dst_di;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key log_key;\n\tstruct inode *dir;\n\tu8 log_type;\n\tint exists;\n\tint ret = 0;\n\tbool update_size = (key->type == BTRFS_DIR_INDEX_KEY);\n\n\tdir = read_one_inode(root, key->objectid);\n\tif (!dir)\n\t\treturn -EIO;\n\n\tname_len = btrfs_dir_name_len(eb, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlog_type = btrfs_dir_type(eb, di);\n\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t   name_len);\n\n\tbtrfs_dir_item_key_to_cpu(eb, di, &log_key);\n\texists = btrfs_lookup_inode(trans, root, path, &log_key, 0);\n\tif (exists == 0)\n\t\texists = 1;\n\telse\n\t\texists = 0;\n\tbtrfs_release_path(path);\n\n\tif (key->type == BTRFS_DIR_ITEM_KEY) {\n\t\tdst_di = btrfs_lookup_dir_item(trans, root, path, key->objectid,\n\t\t\t\t       name, name_len, 1);\n\t} else if (key->type == BTRFS_DIR_INDEX_KEY) {\n\t\tdst_di = btrfs_lookup_dir_index_item(trans, root, path,\n\t\t\t\t\t\t     key->objectid,\n\t\t\t\t\t\t     key->offset, name,\n\t\t\t\t\t\t     name_len, 1);\n\t} else {\n\t\t/* Corruption */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (IS_ERR_OR_NULL(dst_di)) {\n\t\t/* we need a sequence number to insert, so we only\n\t\t * do inserts for the BTRFS_DIR_INDEX_KEY types\n\t\t */\n\t\tif (key->type != BTRFS_DIR_INDEX_KEY)\n\t\t\tgoto out;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], dst_di, &found_key);\n\t/* the existing item matches the logged item */\n\tif (found_key.objectid == log_key.objectid &&\n\t    found_key.type == log_key.type &&\n\t    found_key.offset == log_key.offset &&\n\t    btrfs_dir_type(path->nodes[0], dst_di) == log_type) {\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * don't drop the conflicting directory entry if the inode\n\t * for the new entry doesn't exist\n\t */\n\tif (!exists)\n\t\tgoto out;\n\n\tret = drop_one_dir_item(trans, root, path, dir, dst_di);\n\tif (ret)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_DIR_INDEX_KEY)\n\t\tgoto insert;\nout:\n\tbtrfs_release_path(path);\n\tif (!ret && update_size) {\n\t\tbtrfs_i_size_write(dir, dir->i_size + name_len * 2);\n\t\tret = btrfs_update_inode(trans, root, dir);\n\t}\n\tkfree(name);\n\tiput(dir);\n\treturn ret;\n\ninsert:\n\tif (name_in_log_ref(root->log_root, name, name_len,\n\t\t\t    key->objectid, log_key.objectid)) {\n\t\t/* The dentry will be added later. */\n\t\tret = 0;\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\tret = insert_one_name(trans, root, path, key->objectid, key->offset,\n\t\t\t      name, name_len, log_type, &log_key);\n\tif (ret && ret != -ENOENT && ret != -EEXIST)\n\t\tgoto out;\n\tupdate_size = false;\n\tret = 0;\n\tgoto out;\n}"
  },
  {
    "function_name": "name_in_log_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1576-1594",
    "snippet": "static bool name_in_log_ref(struct btrfs_root *log_root,\n\t\t\t    const char *name, const int name_len,\n\t\t\t    const u64 dirid, const u64 ino)\n{\n\tstruct btrfs_key search_key;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = dirid;\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\tsearch_key.offset = btrfs_extref_hash(dirid, name, name_len);\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "backref_in_log",
          "args": [
            "log_root",
            "&search_key",
            "dirid",
            "name",
            "name_len"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "backref_in_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "858-910",
          "snippet": "static noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tunsigned long name_ptr;\n\tint found_name_len;\n\tint item_size;\n\tint ret;\n\tint match = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tif (btrfs_find_name_in_ext_backref(path, ref_objectid,\n\t\t\t\t\t\t   name, namelen, NULL))\n\t\t\tmatch = 1;\n\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\tfound_name_len = btrfs_inode_ref_name_len(path->nodes[0], ref);\n\t\tif (found_name_len == namelen) {\n\t\t\tname_ptr = (unsigned long)(ref + 1);\n\t\t\tret = memcmp_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t\t   name_ptr, namelen);\n\t\t\tif (ret == 0) {\n\t\t\t\tmatch = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tptr = (unsigned long)(ref + 1) + found_name_len;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn match;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tunsigned long name_ptr;\n\tint found_name_len;\n\tint item_size;\n\tint ret;\n\tint match = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tif (btrfs_find_name_in_ext_backref(path, ref_objectid,\n\t\t\t\t\t\t   name, namelen, NULL))\n\t\t\tmatch = 1;\n\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\tfound_name_len = btrfs_inode_ref_name_len(path->nodes[0], ref);\n\t\tif (found_name_len == namelen) {\n\t\t\tname_ptr = (unsigned long)(ref + 1);\n\t\t\tret = memcmp_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t\t   name_ptr, namelen);\n\t\t\tif (ret == 0) {\n\t\t\t\tmatch = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tptr = (unsigned long)(ref + 1) + found_name_len;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extref_hash",
          "args": [
            "dirid",
            "name",
            "name_len"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extref_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.h",
          "lines": "36-40",
          "snippet": "static inline u64 btrfs_extref_hash(u64 parent_objectid, const char *name,\n\t\t\t\t    int len)\n{\n\treturn (u64) btrfs_crc32c(parent_objectid, name, len);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 btrfs_extref_hash(u64 parent_objectid, const char *name,\n\t\t\t\t    int len)\n{\n\treturn (u64) btrfs_crc32c(parent_objectid, name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic bool name_in_log_ref(struct btrfs_root *log_root,\n\t\t\t    const char *name, const int name_len,\n\t\t\t    const u64 dirid, const u64 ino)\n{\n\tstruct btrfs_key search_key;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = dirid;\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\tsearch_key.offset = btrfs_extref_hash(dirid, name, name_len);\n\tif (backref_in_log(log_root, &search_key, dirid, name, name_len))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "insert_one_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1542-1570",
    "snippet": "static noinline int insert_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    u64 dirid, u64 index,\n\t\t\t\t    char *name, int name_len, u8 type,\n\t\t\t\t    struct btrfs_key *location)\n{\n\tstruct inode *inode;\n\tstruct inode *dir;\n\tint ret;\n\n\tinode = read_one_inode(root, location->objectid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tdir = read_one_inode(root, dirid);\n\tif (!dir) {\n\t\tiput(inode);\n\t\treturn -EIO;\n\t}\n\n\tret = btrfs_add_link(trans, dir, inode, name, name_len, 1, index);\n\n\t/* FIXME, put inode into FIXUP list */\n\n\tiput(inode);\n\tiput(dir);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "dir"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_link",
          "args": [
            "trans",
            "dir",
            "inode",
            "name",
            "name_len",
            "1",
            "index"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5996-6062",
          "snippet": "int btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "dirid"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int insert_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    u64 dirid, u64 index,\n\t\t\t\t    char *name, int name_len, u8 type,\n\t\t\t\t    struct btrfs_key *location)\n{\n\tstruct inode *inode;\n\tstruct inode *dir;\n\tint ret;\n\n\tinode = read_one_inode(root, location->objectid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tdir = read_one_inode(root, dirid);\n\tif (!dir) {\n\t\tiput(inode);\n\t\treturn -EIO;\n\t}\n\n\tret = btrfs_add_link(trans, dir, inode, name, name_len, 1, index);\n\n\t/* FIXME, put inode into FIXUP list */\n\n\tiput(inode);\n\tiput(dir);\n\treturn ret;\n}"
  },
  {
    "function_name": "link_to_fixup_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1501-1535",
    "snippet": "static noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "1"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "&key",
            "0"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "objectid"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fixup_inode_link_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1441-1493",
    "snippet": "static noinline int fixup_inode_link_counts(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret == 1) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_TREE_LOG_FIXUP_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t\tinode = read_one_inode(root, key.offset);\n\t\tif (!inode)\n\t\t\treturn -EIO;\n\n\t\tret = fixup_inode_link_count(trans, root, inode);\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * fixup on a directory may create new entries,\n\t\t * make sure we always look for the highset possible\n\t\t * offset\n\t\t */\n\t\tkey.offset = (u64)-1;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_inode_link_count",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_inode_link_counts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1441-1493",
          "snippet": "static noinline int fixup_inode_link_counts(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret == 1) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_TREE_LOG_FIXUP_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t\tinode = read_one_inode(root, key.offset);\n\t\tif (!inode)\n\t\t\treturn -EIO;\n\n\t\tret = fixup_inode_link_count(trans, root, inode);\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * fixup on a directory may create new entries,\n\t\t * make sure we always look for the highset possible\n\t\t * offset\n\t\t */\n\t\tkey.offset = (u64)-1;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "key.offset"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "root",
            "path"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&key",
            "path->slots[0]"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int fixup_inode_link_counts(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret == 1) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_TREE_LOG_FIXUP_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t\tinode = read_one_inode(root, key.offset);\n\t\tif (!inode)\n\t\t\treturn -EIO;\n\n\t\tret = fixup_inode_link_count(trans, root, inode);\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * fixup on a directory may create new entries,\n\t\t * make sure we always look for the highset possible\n\t\t * offset\n\t\t */\n\t\tkey.offset = (u64)-1;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "fixup_inode_link_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1393-1439",
    "snippet": "static noinline int fixup_inode_link_count(struct btrfs_trans_handle *trans,\n\t\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tu64 nlink = 0;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = count_inode_refs(root, inode, path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink = ret;\n\n\tret = count_inode_extrefs(root, inode, path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink += ret;\n\n\tret = 0;\n\n\tif (nlink != inode->i_nlink) {\n\t\tset_nlink(inode, nlink);\n\t\tbtrfs_update_inode(trans, root, inode);\n\t}\n\tBTRFS_I(inode)->index_cnt = (u64)-1;\n\n\tif (inode->i_nlink == 0) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tret = replay_dir_deletes(trans, root, NULL, path,\n\t\t\t\t\t\t ino, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = insert_orphan_item(trans, root, ino);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_orphan_item",
          "args": [
            "trans",
            "root",
            "ino"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "insert_orphan_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1270-1280",
          "snippet": "static int insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 ino)\n{\n\tint ret;\n\n\tret = btrfs_insert_orphan_item(trans, root, ino);\n\tif (ret == -EEXIST)\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 ino)\n{\n\tint ret;\n\n\tret = btrfs_insert_orphan_item(trans, root, ino);\n\tif (ret == -EEXIST)\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replay_dir_deletes",
          "args": [
            "trans",
            "root",
            "NULL",
            "path",
            "ino",
            "1"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "replay_dir_deletes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1964-2058",
          "snippet": "static noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint key_type = BTRFS_DIR_LOG_ITEM_KEY;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_ITEM_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t/* it isn't an error if the inode isn't there, that can happen\n\t * because we replay the deletes before we copy in the inode item\n\t * from the log\n\t */\n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\nagain:\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid, key_type,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type)\n\t\t\t\tgoto next_type;\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, root, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\nnext_type:\n\tret = 0;\n\tif (key_type == BTRFS_DIR_LOG_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_LOG_INDEX_KEY;\n\t\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);\nstatic noinline struct;\n\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint key_type = BTRFS_DIR_LOG_ITEM_KEY;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_ITEM_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t/* it isn't an error if the inode isn't there, that can happen\n\t * because we replay the deletes before we copy in the inode item\n\t * from the log\n\t */\n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\nagain:\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid, key_type,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type)\n\t\t\t\tgoto next_type;\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, root, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\nnext_type:\n\tret = 0;\n\tif (key_type == BTRFS_DIR_LOG_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_LOG_INDEX_KEY;\n\t\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "nlink"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_inode_extrefs",
          "args": [
            "root",
            "inode",
            "path"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "count_inode_extrefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1282-1324",
          "snippet": "static int count_inode_extrefs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret = 0;\n\tint name_len;\n\tunsigned int nlink = 0;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tu64 inode_objectid = btrfs_ino(inode);\n\tu64 offset = 0;\n\tunsigned long ptr;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(root, inode_objectid, offset, path,\n\t\t\t\t\t    &extref, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\t\tname_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tnlink++;\n\n\t\t\tcur_offset += name_len + sizeof(*extref);\n\t\t}\n\n\t\toffset++;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\tif (ret < 0 && ret != -ENOENT)\n\t\treturn ret;\n\treturn nlink;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int count_inode_extrefs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret = 0;\n\tint name_len;\n\tunsigned int nlink = 0;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tu64 inode_objectid = btrfs_ino(inode);\n\tu64 offset = 0;\n\tunsigned long ptr;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(root, inode_objectid, offset, path,\n\t\t\t\t\t    &extref, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\t\tname_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tnlink++;\n\n\t\t\tcur_offset += name_len + sizeof(*extref);\n\t\t}\n\n\t\toffset++;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\tif (ret < 0 && ret != -ENOENT)\n\t\treturn ret;\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_inode_refs",
          "args": [
            "root",
            "inode",
            "path"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "count_inode_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1326-1381",
          "snippet": "static int count_inode_refs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tunsigned int nlink = 0;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tint name_len;\n\tu64 ino = btrfs_ino(inode);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\nprocess_slot:\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t      path->slots[0]);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_INODE_REF_KEY)\n\t\t\tbreak;\n\t\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tstruct btrfs_inode_ref *ref;\n\n\t\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\t\tname_len = btrfs_inode_ref_name_len(path->nodes[0],\n\t\t\t\t\t\t\t    ref);\n\t\t\tptr = (unsigned long)(ref + 1) + name_len;\n\t\t\tnlink++;\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\t\tif (path->slots[0] > 0) {\n\t\t\tpath->slots[0]--;\n\t\t\tgoto process_slot;\n\t\t}\n\t\tkey.offset--;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\treturn nlink;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int count_inode_refs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tunsigned int nlink = 0;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tint name_len;\n\tu64 ino = btrfs_ino(inode);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\nprocess_slot:\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t      path->slots[0]);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_INODE_REF_KEY)\n\t\t\tbreak;\n\t\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tstruct btrfs_inode_ref *ref;\n\n\t\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\t\tname_len = btrfs_inode_ref_name_len(path->nodes[0],\n\t\t\t\t\t\t\t    ref);\n\t\t\tptr = (unsigned long)(ref + 1) + name_len;\n\t\t\tnlink++;\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\t\tif (path->slots[0] > 0) {\n\t\t\tpath->slots[0]--;\n\t\t\tgoto process_slot;\n\t\t}\n\t\tkey.offset--;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\treturn nlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int fixup_inode_link_count(struct btrfs_trans_handle *trans,\n\t\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tu64 nlink = 0;\n\tu64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = count_inode_refs(root, inode, path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink = ret;\n\n\tret = count_inode_extrefs(root, inode, path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink += ret;\n\n\tret = 0;\n\n\tif (nlink != inode->i_nlink) {\n\t\tset_nlink(inode, nlink);\n\t\tbtrfs_update_inode(trans, root, inode);\n\t}\n\tBTRFS_I(inode)->index_cnt = (u64)-1;\n\n\tif (inode->i_nlink == 0) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tret = replay_dir_deletes(trans, root, NULL, path,\n\t\t\t\t\t\t ino, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = insert_orphan_item(trans, root, ino);\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "count_inode_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1326-1381",
    "snippet": "static int count_inode_refs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tunsigned int nlink = 0;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tint name_len;\n\tu64 ino = btrfs_ino(inode);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\nprocess_slot:\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t      path->slots[0]);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_INODE_REF_KEY)\n\t\t\tbreak;\n\t\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tstruct btrfs_inode_ref *ref;\n\n\t\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\t\tname_len = btrfs_inode_ref_name_len(path->nodes[0],\n\t\t\t\t\t\t\t    ref);\n\t\t\tptr = (unsigned long)(ref + 1) + name_len;\n\t\t\tnlink++;\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\t\tif (path->slots[0] > 0) {\n\t\t\tpath->slots[0]--;\n\t\t\tgoto process_slot;\n\t\t}\n\t\tkey.offset--;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\treturn nlink;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "path->nodes[0]",
            "ref"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&key",
            "path->slots[0]"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic int count_inode_refs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tunsigned int nlink = 0;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tint name_len;\n\tu64 ino = btrfs_ino(inode);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\nprocess_slot:\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t      path->slots[0]);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_INODE_REF_KEY)\n\t\t\tbreak;\n\t\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tstruct btrfs_inode_ref *ref;\n\n\t\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\t\tname_len = btrfs_inode_ref_name_len(path->nodes[0],\n\t\t\t\t\t\t\t    ref);\n\t\t\tptr = (unsigned long)(ref + 1) + name_len;\n\t\t\tnlink++;\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\t\tif (path->slots[0] > 0) {\n\t\t\tpath->slots[0]--;\n\t\t\tgoto process_slot;\n\t\t}\n\t\tkey.offset--;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\treturn nlink;\n}"
  },
  {
    "function_name": "count_inode_extrefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1282-1324",
    "snippet": "static int count_inode_extrefs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret = 0;\n\tint name_len;\n\tunsigned int nlink = 0;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tu64 inode_objectid = btrfs_ino(inode);\n\tu64 offset = 0;\n\tunsigned long ptr;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(root, inode_objectid, offset, path,\n\t\t\t\t\t    &extref, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\t\tname_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tnlink++;\n\n\t\t\tcur_offset += name_len + sizeof(*extref);\n\t\t}\n\n\t\toffset++;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\tif (ret < 0 && ret != -ENOENT)\n\t\treturn ret;\n\treturn nlink;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "leaf",
            "extref"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_one_extref",
          "args": [
            "root",
            "inode_objectid",
            "offset",
            "path",
            "&extref",
            "&offset"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_one_extref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1249-1315",
          "snippet": "int btrfs_find_one_extref(struct btrfs_root *root, u64 inode_objectid,\n\t\t\t  u64 start_off, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode_extref **ret_extref,\n\t\t\t  u64 *found_off)\n{\n\tint ret, slot;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = start_off;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * If the item at offset is not found,\n\t\t\t * btrfs_search_slot will point us to the slot\n\t\t\t * where it should be inserted. In our case\n\t\t\t * that will be the slot directly before the\n\t\t\t * next INODE_REF_KEY_V2 item. In the case\n\t\t\t * that we're pointing to the last slot in a\n\t\t\t * leaf, we must move one leaf over.\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret) {\n\t\t\t\tif (ret >= 1)\n\t\t\t\t\tret = -ENOENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/*\n\t\t * Check that we're still looking at an extended ref key for\n\t\t * this particular objectid. If we have different\n\t\t * objectid or type then there are no more to be found\n\t\t * in the tree and we can exit.\n\t\t */\n\t\tret = -ENOENT;\n\t\tif (found_key.objectid != inode_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\tret = 0;\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\textref = (struct btrfs_inode_extref *)ptr;\n\t\t*ret_extref = extref;\n\t\tif (found_off)\n\t\t\t*found_off = found_key.offset;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_one_extref(struct btrfs_root *root, u64 inode_objectid,\n\t\t\t  u64 start_off, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode_extref **ret_extref,\n\t\t\t  u64 *found_off)\n{\n\tint ret, slot;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = start_off;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * If the item at offset is not found,\n\t\t\t * btrfs_search_slot will point us to the slot\n\t\t\t * where it should be inserted. In our case\n\t\t\t * that will be the slot directly before the\n\t\t\t * next INODE_REF_KEY_V2 item. In the case\n\t\t\t * that we're pointing to the last slot in a\n\t\t\t * leaf, we must move one leaf over.\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret) {\n\t\t\t\tif (ret >= 1)\n\t\t\t\t\tret = -ENOENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/*\n\t\t * Check that we're still looking at an extended ref key for\n\t\t * this particular objectid. If we have different\n\t\t * objectid or type then there are no more to be found\n\t\t * in the tree and we can exit.\n\t\t */\n\t\tret = -ENOENT;\n\t\tif (found_key.objectid != inode_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\tret = 0;\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\textref = (struct btrfs_inode_extref *)ptr;\n\t\t*ret_extref = extref;\n\t\tif (found_off)\n\t\t\t*found_off = found_key.offset;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int count_inode_extrefs(struct btrfs_root *root,\n\t\t\t       struct inode *inode, struct btrfs_path *path)\n{\n\tint ret = 0;\n\tint name_len;\n\tunsigned int nlink = 0;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tu64 inode_objectid = btrfs_ino(inode);\n\tu64 offset = 0;\n\tunsigned long ptr;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(root, inode_objectid, offset, path,\n\t\t\t\t\t    &extref, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\t\tname_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tnlink++;\n\n\t\t\tcur_offset += name_len + sizeof(*extref);\n\t\t}\n\n\t\toffset++;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\tif (ret < 0 && ret != -ENOENT)\n\t\treturn ret;\n\treturn nlink;\n}"
  },
  {
    "function_name": "insert_orphan_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1270-1280",
    "snippet": "static int insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 ino)\n{\n\tint ret;\n\n\tret = btrfs_insert_orphan_item(trans, root, ino);\n\tif (ret == -EEXIST)\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_insert_orphan_item",
          "args": [
            "trans",
            "root",
            "ino"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_orphan_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/orphan.c",
          "lines": "22-41",
          "snippet": "int btrfs_insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = offset;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int insert_orphan_item(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 ino)\n{\n\tint ret;\n\n\tret = btrfs_insert_orphan_item(trans, root, ino);\n\tif (ret == -EEXIST)\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "add_inode_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1141-1268",
    "snippet": "static noinline int add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct extent_buffer *eb, int slot,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct inode *dir = NULL;\n\tstruct inode *inode = NULL;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tchar *name = NULL;\n\tint namelen;\n\tint ret;\n\tint search_done = 0;\n\tint log_ref_ver = 0;\n\tu64 parent_objectid;\n\tu64 inode_objectid;\n\tu64 ref_index = 0;\n\tint ref_struct_size;\n\n\tref_ptr = btrfs_item_ptr_offset(eb, slot);\n\tref_end = ref_ptr + btrfs_item_size_nr(eb, slot);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tstruct btrfs_inode_extref *r;\n\n\t\tref_struct_size = sizeof(struct btrfs_inode_extref);\n\t\tlog_ref_ver = 1;\n\t\tr = (struct btrfs_inode_extref *)ref_ptr;\n\t\tparent_objectid = btrfs_inode_extref_parent(eb, r);\n\t} else {\n\t\tref_struct_size = sizeof(struct btrfs_inode_ref);\n\t\tparent_objectid = key->offset;\n\t}\n\tinode_objectid = key->objectid;\n\n\t/*\n\t * it is possible that we didn't log all the parent directories\n\t * for a given inode.  If we don't find the dir, just don't\n\t * copy the back ref in.  The link count fixup code will take\n\t * care of the rest\n\t */\n\tdir = read_one_inode(root, parent_objectid);\n\tif (!dir) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, inode_objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (ref_ptr < ref_end) {\n\t\tif (log_ref_ver) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t\t&ref_index, &parent_objectid);\n\t\t\t/*\n\t\t\t * parent object can change from one array\n\t\t\t * item to another.\n\t\t\t */\n\t\t\tif (!dir)\n\t\t\t\tdir = read_one_inode(root, parent_objectid);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t     &ref_index);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/* if we already have a perfect match, we're done */\n\t\tif (!inode_in_dir(root, path, btrfs_ino(dir), btrfs_ino(inode),\n\t\t\t\t  ref_index, name, namelen)) {\n\t\t\t/*\n\t\t\t * look for a conflicting back reference in the\n\t\t\t * metadata. if we find one we have to unlink that name\n\t\t\t * of the file before we add our new link.  Later on, we\n\t\t\t * overwrite any existing back reference, and we don't\n\t\t\t * want to create dangling pointers in the directory.\n\t\t\t */\n\n\t\t\tif (!search_done) {\n\t\t\t\tret = __add_inode_ref(trans, root, path, log,\n\t\t\t\t\t\t      dir, inode, eb,\n\t\t\t\t\t\t      inode_objectid,\n\t\t\t\t\t\t      parent_objectid,\n\t\t\t\t\t\t      ref_index, name, namelen,\n\t\t\t\t\t\t      &search_done);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret == 1)\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert our name */\n\t\t\tret = btrfs_add_link(trans, dir, inode, name, namelen,\n\t\t\t\t\t     0, ref_index);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tbtrfs_update_inode(trans, root, inode);\n\t\t}\n\n\t\tref_ptr = (unsigned long)(ref_ptr + ref_struct_size) + namelen;\n\t\tkfree(name);\n\t\tname = NULL;\n\t\tif (log_ref_ver) {\n\t\t\tiput(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\t/* finally write the back reference in the inode */\n\tret = overwrite_item(trans, root, path, eb, slot, key);\nout:\n\tbtrfs_release_path(path);\n\tkfree(name);\n\tiput(dir);\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "overwrite_item",
          "args": [
            "trans",
            "root",
            "path",
            "eb",
            "slot",
            "key"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "overwrite_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "341-539",
          "snippet": "static noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_link",
          "args": [
            "trans",
            "dir",
            "inode",
            "name",
            "namelen",
            "0",
            "ref_index"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5996-6062",
          "snippet": "int btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_add_link(struct btrfs_trans_handle *trans,\n\t\t   struct inode *parent_inode, struct inode *inode,\n\t\t   const char *name, int name_len, int add_backref, u64 index)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = BTRFS_I(parent_inode)->root;\n\tu64 ino = btrfs_ino(inode);\n\tu64 parent_ino = btrfs_ino(parent_inode);\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tmemcpy(&key, &BTRFS_I(inode)->root->root_key, sizeof(key));\n\t} else {\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_INODE_ITEM_KEY;\n\t\tkey.offset = 0;\n\t}\n\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_add_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t\t parent_ino, index, name, name_len);\n\t} else if (add_backref) {\n\t\tret = btrfs_insert_inode_ref(trans, root, name, name_len, ino,\n\t\t\t\t\t     parent_ino, index);\n\t}\n\n\t/* Nothing to clean up yet */\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_insert_dir_item(trans, root, name, name_len,\n\t\t\t\t    parent_inode, &key,\n\t\t\t\t    btrfs_inode_type(inode), index);\n\tif (ret == -EEXIST || ret == -EOVERFLOW)\n\t\tgoto fail_dir_item;\n\telse if (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tbtrfs_i_size_write(parent_inode, parent_inode->i_size +\n\t\t\t   name_len * 2);\n\tinode_inc_iversion(parent_inode);\n\tparent_inode->i_mtime = parent_inode->i_ctime = CURRENT_TIME;\n\tret = btrfs_update_inode(trans, root, parent_inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\treturn ret;\n\nfail_dir_item:\n\tif (unlikely(ino == BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tu64 local_index;\n\t\tint err;\n\t\terr = btrfs_del_root_ref(trans, root->fs_info->tree_root,\n\t\t\t\t key.objectid, root->root_key.objectid,\n\t\t\t\t parent_ino, &local_index, name, name_len);\n\n\t} else if (add_backref) {\n\t\tu64 local_index;\n\t\tint err;\n\n\t\terr = btrfs_del_inode_ref(trans, root, name, name_len,\n\t\t\t\t\t  ino, parent_ino, &local_index);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_inode_ref",
          "args": [
            "trans",
            "root",
            "path",
            "log",
            "dir",
            "inode",
            "eb",
            "inode_objectid",
            "parent_objectid",
            "ref_index",
            "name",
            "namelen",
            "&search_done"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "__add_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "912-1091",
          "snippet": "static inline int __add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_root *log_root,\n\t\t\t\t  struct inode *dir, struct inode *inode,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  u64 inode_objectid, u64 parent_objectid,\n\t\t\t\t  u64 ref_index, char *name, int namelen,\n\t\t\t\t  int *search_done)\n{\n\tint ret;\n\tchar *victim_name;\n\tint victim_name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_inode_extref *extref;\n\nagain:\n\t/* Search old style refs */\n\tsearch_key.objectid = inode_objectid;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = parent_objectid;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret == 0) {\n\t\tstruct btrfs_inode_ref *victim_ref;\n\t\tunsigned long ptr;\n\t\tunsigned long ptr_end;\n\n\t\tleaf = path->nodes[0];\n\n\t\t/* are we trying to overwrite a back ref for the root directory\n\t\t * if so, just jump out, we're done\n\t\t */\n\t\tif (search_key.objectid == search_key.offset)\n\t\t\treturn 1;\n\n\t\t/* check all the names in this back reference to see\n\t\t * if they are in the log.  if so, we allow them to stay\n\t\t * otherwise they must be unlinked as a conflict\n\t\t */\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(leaf, path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tvictim_ref = (struct btrfs_inode_ref *)ptr;\n\t\t\tvictim_name_len = btrfs_inode_ref_name_len(leaf,\n\t\t\t\t\t\t\t\t   victim_ref);\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tread_extent_buffer(leaf, victim_name,\n\t\t\t\t\t   (unsigned long)(victim_ref + 1),\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid,\n\t\t\t\t\t    victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tinc_nlink(inode);\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tret = btrfs_unlink_inode(trans, root, dir,\n\t\t\t\t\t\t\t inode, victim_name,\n\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\n\t\t\tptr = (unsigned long)(victim_ref + 1) + victim_name_len;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: we have searched root tree and checked the\n\t\t * coresponding ref, it does not need to check again.\n\t\t */\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* Same search but for extended refs */\n\textref = btrfs_lookup_inode_extref(NULL, root, path, name, namelen,\n\t\t\t\t\t   inode_objectid, parent_objectid, 0,\n\t\t\t\t\t   0);\n\tif (!IS_ERR_OR_NULL(extref)) {\n\t\tu32 item_size;\n\t\tu32 cur_offset = 0;\n\t\tunsigned long base;\n\t\tstruct inode *victim_parent;\n\n\t\tleaf = path->nodes[0];\n\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tbase = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *)(base + cur_offset);\n\n\t\t\tvictim_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tif (btrfs_inode_extref_parent(leaf, extref) != parent_objectid)\n\t\t\t\tgoto next;\n\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tread_extent_buffer(leaf, victim_name, (unsigned long)&extref->name,\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tsearch_key.objectid = inode_objectid;\n\t\t\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tsearch_key.offset = btrfs_extref_hash(parent_objectid,\n\t\t\t\t\t\t\t      victim_name,\n\t\t\t\t\t\t\t      victim_name_len);\n\t\t\tret = 0;\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid, victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tvictim_parent = read_one_inode(root,\n\t\t\t\t\t\t\t       parent_objectid);\n\t\t\t\tif (victim_parent) {\n\t\t\t\t\tinc_nlink(inode);\n\t\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\t\tret = btrfs_unlink_inode(trans, root,\n\t\t\t\t\t\t\t\t victim_parent,\n\t\t\t\t\t\t\t\t inode,\n\t\t\t\t\t\t\t\t victim_name,\n\t\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = btrfs_run_delayed_items(\n\t\t\t\t\t\t\t\t  trans, root);\n\t\t\t\t}\n\t\t\t\tiput(victim_parent);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\nnext:\n\t\t\tcur_offset += victim_name_len + sizeof(*extref);\n\t\t}\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicting sequence number */\n\tdi = btrfs_lookup_dir_index_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t\t ref_index, name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicing name */\n\tdi = btrfs_lookup_dir_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t   name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic inline int __add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_root *log_root,\n\t\t\t\t  struct inode *dir, struct inode *inode,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  u64 inode_objectid, u64 parent_objectid,\n\t\t\t\t  u64 ref_index, char *name, int namelen,\n\t\t\t\t  int *search_done)\n{\n\tint ret;\n\tchar *victim_name;\n\tint victim_name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_inode_extref *extref;\n\nagain:\n\t/* Search old style refs */\n\tsearch_key.objectid = inode_objectid;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = parent_objectid;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret == 0) {\n\t\tstruct btrfs_inode_ref *victim_ref;\n\t\tunsigned long ptr;\n\t\tunsigned long ptr_end;\n\n\t\tleaf = path->nodes[0];\n\n\t\t/* are we trying to overwrite a back ref for the root directory\n\t\t * if so, just jump out, we're done\n\t\t */\n\t\tif (search_key.objectid == search_key.offset)\n\t\t\treturn 1;\n\n\t\t/* check all the names in this back reference to see\n\t\t * if they are in the log.  if so, we allow them to stay\n\t\t * otherwise they must be unlinked as a conflict\n\t\t */\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(leaf, path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tvictim_ref = (struct btrfs_inode_ref *)ptr;\n\t\t\tvictim_name_len = btrfs_inode_ref_name_len(leaf,\n\t\t\t\t\t\t\t\t   victim_ref);\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tread_extent_buffer(leaf, victim_name,\n\t\t\t\t\t   (unsigned long)(victim_ref + 1),\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid,\n\t\t\t\t\t    victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tinc_nlink(inode);\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tret = btrfs_unlink_inode(trans, root, dir,\n\t\t\t\t\t\t\t inode, victim_name,\n\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\n\t\t\tptr = (unsigned long)(victim_ref + 1) + victim_name_len;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: we have searched root tree and checked the\n\t\t * coresponding ref, it does not need to check again.\n\t\t */\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* Same search but for extended refs */\n\textref = btrfs_lookup_inode_extref(NULL, root, path, name, namelen,\n\t\t\t\t\t   inode_objectid, parent_objectid, 0,\n\t\t\t\t\t   0);\n\tif (!IS_ERR_OR_NULL(extref)) {\n\t\tu32 item_size;\n\t\tu32 cur_offset = 0;\n\t\tunsigned long base;\n\t\tstruct inode *victim_parent;\n\n\t\tleaf = path->nodes[0];\n\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tbase = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *)(base + cur_offset);\n\n\t\t\tvictim_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tif (btrfs_inode_extref_parent(leaf, extref) != parent_objectid)\n\t\t\t\tgoto next;\n\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tread_extent_buffer(leaf, victim_name, (unsigned long)&extref->name,\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tsearch_key.objectid = inode_objectid;\n\t\t\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tsearch_key.offset = btrfs_extref_hash(parent_objectid,\n\t\t\t\t\t\t\t      victim_name,\n\t\t\t\t\t\t\t      victim_name_len);\n\t\t\tret = 0;\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid, victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tvictim_parent = read_one_inode(root,\n\t\t\t\t\t\t\t       parent_objectid);\n\t\t\t\tif (victim_parent) {\n\t\t\t\t\tinc_nlink(inode);\n\t\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\t\tret = btrfs_unlink_inode(trans, root,\n\t\t\t\t\t\t\t\t victim_parent,\n\t\t\t\t\t\t\t\t inode,\n\t\t\t\t\t\t\t\t victim_name,\n\t\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = btrfs_run_delayed_items(\n\t\t\t\t\t\t\t\t  trans, root);\n\t\t\t\t}\n\t\t\t\tiput(victim_parent);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\nnext:\n\t\t\tcur_offset += victim_name_len + sizeof(*extref);\n\t\t}\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicting sequence number */\n\tdi = btrfs_lookup_dir_index_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t\t ref_index, name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicing name */\n\tdi = btrfs_lookup_dir_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t   name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_in_dir",
          "args": [
            "root",
            "path",
            "btrfs_ino(dir)",
            "btrfs_ino(inode)",
            "ref_index",
            "name",
            "namelen"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "inode_in_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "816-846",
          "snippet": "static noinline int inode_in_dir(struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 dirid, u64 objectid, u64 index,\n\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key location;\n\tint match = 0;\n\n\tdi = btrfs_lookup_dir_index_item(NULL, root, path, dirid,\n\t\t\t\t\t index, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dirid, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tmatch = 1;\nout:\n\tbtrfs_release_path(path);\n\treturn match;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int inode_in_dir(struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 dirid, u64 objectid, u64 index,\n\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key location;\n\tint match = 0;\n\n\tdi = btrfs_lookup_dir_index_item(NULL, root, path, dirid,\n\t\t\t\t\t index, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dirid, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tmatch = 1;\nout:\n\tbtrfs_release_path(path);\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_get_fields",
          "args": [
            "eb",
            "ref_ptr",
            "&namelen",
            "&name",
            "&ref_index"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "ref_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1116-1133",
          "snippet": "static int ref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t  u32 *namelen, char **name, u64 *index)\n{\n\tstruct btrfs_inode_ref *ref;\n\n\tref = (struct btrfs_inode_ref *)ref_ptr;\n\n\t*namelen = btrfs_inode_ref_name_len(eb, ref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)(ref + 1), *namelen);\n\n\t*index = btrfs_inode_ref_index(eb, ref);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int ref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t  u32 *namelen, char **name, u64 *index)\n{\n\tstruct btrfs_inode_ref *ref;\n\n\tref = (struct btrfs_inode_ref *)ref_ptr;\n\n\t*namelen = btrfs_inode_ref_name_len(eb, ref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)(ref + 1), *namelen);\n\n\t*index = btrfs_inode_ref_index(eb, ref);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "parent_objectid"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extref_get_fields",
          "args": [
            "eb",
            "ref_ptr",
            "&namelen",
            "&name",
            "&ref_index",
            "&parent_objectid"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "extref_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1093-1114",
          "snippet": "static int extref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t     u32 *namelen, char **name, u64 *index,\n\t\t\t     u64 *parent_objectid)\n{\n\tstruct btrfs_inode_extref *extref;\n\n\textref = (struct btrfs_inode_extref *)ref_ptr;\n\n\t*namelen = btrfs_inode_extref_name_len(eb, extref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)&extref->name,\n\t\t\t   *namelen);\n\n\t*index = btrfs_inode_extref_index(eb, extref);\n\tif (parent_objectid)\n\t\t*parent_objectid = btrfs_inode_extref_parent(eb, extref);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int extref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t     u32 *namelen, char **name, u64 *index,\n\t\t\t     u64 *parent_objectid)\n{\n\tstruct btrfs_inode_extref *extref;\n\n\textref = (struct btrfs_inode_extref *)ref_ptr;\n\n\t*namelen = btrfs_inode_extref_name_len(eb, extref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)&extref->name,\n\t\t\t   *namelen);\n\n\t*index = btrfs_inode_extref_index(eb, extref);\n\tif (parent_objectid)\n\t\t*parent_objectid = btrfs_inode_extref_parent(eb, extref);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_parent",
          "args": [
            "eb",
            "r"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct extent_buffer *eb, int slot,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct inode *dir = NULL;\n\tstruct inode *inode = NULL;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tchar *name = NULL;\n\tint namelen;\n\tint ret;\n\tint search_done = 0;\n\tint log_ref_ver = 0;\n\tu64 parent_objectid;\n\tu64 inode_objectid;\n\tu64 ref_index = 0;\n\tint ref_struct_size;\n\n\tref_ptr = btrfs_item_ptr_offset(eb, slot);\n\tref_end = ref_ptr + btrfs_item_size_nr(eb, slot);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tstruct btrfs_inode_extref *r;\n\n\t\tref_struct_size = sizeof(struct btrfs_inode_extref);\n\t\tlog_ref_ver = 1;\n\t\tr = (struct btrfs_inode_extref *)ref_ptr;\n\t\tparent_objectid = btrfs_inode_extref_parent(eb, r);\n\t} else {\n\t\tref_struct_size = sizeof(struct btrfs_inode_ref);\n\t\tparent_objectid = key->offset;\n\t}\n\tinode_objectid = key->objectid;\n\n\t/*\n\t * it is possible that we didn't log all the parent directories\n\t * for a given inode.  If we don't find the dir, just don't\n\t * copy the back ref in.  The link count fixup code will take\n\t * care of the rest\n\t */\n\tdir = read_one_inode(root, parent_objectid);\n\tif (!dir) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, inode_objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (ref_ptr < ref_end) {\n\t\tif (log_ref_ver) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t\t&ref_index, &parent_objectid);\n\t\t\t/*\n\t\t\t * parent object can change from one array\n\t\t\t * item to another.\n\t\t\t */\n\t\t\tif (!dir)\n\t\t\t\tdir = read_one_inode(root, parent_objectid);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t     &ref_index);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/* if we already have a perfect match, we're done */\n\t\tif (!inode_in_dir(root, path, btrfs_ino(dir), btrfs_ino(inode),\n\t\t\t\t  ref_index, name, namelen)) {\n\t\t\t/*\n\t\t\t * look for a conflicting back reference in the\n\t\t\t * metadata. if we find one we have to unlink that name\n\t\t\t * of the file before we add our new link.  Later on, we\n\t\t\t * overwrite any existing back reference, and we don't\n\t\t\t * want to create dangling pointers in the directory.\n\t\t\t */\n\n\t\t\tif (!search_done) {\n\t\t\t\tret = __add_inode_ref(trans, root, path, log,\n\t\t\t\t\t\t      dir, inode, eb,\n\t\t\t\t\t\t      inode_objectid,\n\t\t\t\t\t\t      parent_objectid,\n\t\t\t\t\t\t      ref_index, name, namelen,\n\t\t\t\t\t\t      &search_done);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret == 1)\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* insert our name */\n\t\t\tret = btrfs_add_link(trans, dir, inode, name, namelen,\n\t\t\t\t\t     0, ref_index);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tbtrfs_update_inode(trans, root, inode);\n\t\t}\n\n\t\tref_ptr = (unsigned long)(ref_ptr + ref_struct_size) + namelen;\n\t\tkfree(name);\n\t\tname = NULL;\n\t\tif (log_ref_ver) {\n\t\t\tiput(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\t/* finally write the back reference in the inode */\n\tret = overwrite_item(trans, root, path, eb, slot, key);\nout:\n\tbtrfs_release_path(path);\n\tkfree(name);\n\tiput(dir);\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "ref_get_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1116-1133",
    "snippet": "static int ref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t  u32 *namelen, char **name, u64 *index)\n{\n\tstruct btrfs_inode_ref *ref;\n\n\tref = (struct btrfs_inode_ref *)ref_ptr;\n\n\t*namelen = btrfs_inode_ref_name_len(eb, ref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)(ref + 1), *namelen);\n\n\t*index = btrfs_inode_ref_index(eb, ref);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_inode_ref_index",
          "args": [
            "eb",
            "ref"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "*name",
            "(unsigned long)(ref + 1)",
            "*namelen"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "*namelen",
            "GFP_NOFS"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "eb",
            "ref"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int ref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t  u32 *namelen, char **name, u64 *index)\n{\n\tstruct btrfs_inode_ref *ref;\n\n\tref = (struct btrfs_inode_ref *)ref_ptr;\n\n\t*namelen = btrfs_inode_ref_name_len(eb, ref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)(ref + 1), *namelen);\n\n\t*index = btrfs_inode_ref_index(eb, ref);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "extref_get_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "1093-1114",
    "snippet": "static int extref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t     u32 *namelen, char **name, u64 *index,\n\t\t\t     u64 *parent_objectid)\n{\n\tstruct btrfs_inode_extref *extref;\n\n\textref = (struct btrfs_inode_extref *)ref_ptr;\n\n\t*namelen = btrfs_inode_extref_name_len(eb, extref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)&extref->name,\n\t\t\t   *namelen);\n\n\t*index = btrfs_inode_extref_index(eb, extref);\n\tif (parent_objectid)\n\t\t*parent_objectid = btrfs_inode_extref_parent(eb, extref);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_inode_extref_parent",
          "args": [
            "eb",
            "extref"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_index",
          "args": [
            "eb",
            "extref"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "*name",
            "(unsigned long)&extref->name",
            "*namelen"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "*namelen",
            "GFP_NOFS"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "eb",
            "extref"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int extref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t     u32 *namelen, char **name, u64 *index,\n\t\t\t     u64 *parent_objectid)\n{\n\tstruct btrfs_inode_extref *extref;\n\n\textref = (struct btrfs_inode_extref *)ref_ptr;\n\n\t*namelen = btrfs_inode_extref_name_len(eb, extref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)&extref->name,\n\t\t\t   *namelen);\n\n\t*index = btrfs_inode_extref_index(eb, extref);\n\tif (parent_objectid)\n\t\t*parent_objectid = btrfs_inode_extref_parent(eb, extref);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__add_inode_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "912-1091",
    "snippet": "static inline int __add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_root *log_root,\n\t\t\t\t  struct inode *dir, struct inode *inode,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  u64 inode_objectid, u64 parent_objectid,\n\t\t\t\t  u64 ref_index, char *name, int namelen,\n\t\t\t\t  int *search_done)\n{\n\tint ret;\n\tchar *victim_name;\n\tint victim_name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_inode_extref *extref;\n\nagain:\n\t/* Search old style refs */\n\tsearch_key.objectid = inode_objectid;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = parent_objectid;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret == 0) {\n\t\tstruct btrfs_inode_ref *victim_ref;\n\t\tunsigned long ptr;\n\t\tunsigned long ptr_end;\n\n\t\tleaf = path->nodes[0];\n\n\t\t/* are we trying to overwrite a back ref for the root directory\n\t\t * if so, just jump out, we're done\n\t\t */\n\t\tif (search_key.objectid == search_key.offset)\n\t\t\treturn 1;\n\n\t\t/* check all the names in this back reference to see\n\t\t * if they are in the log.  if so, we allow them to stay\n\t\t * otherwise they must be unlinked as a conflict\n\t\t */\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(leaf, path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tvictim_ref = (struct btrfs_inode_ref *)ptr;\n\t\t\tvictim_name_len = btrfs_inode_ref_name_len(leaf,\n\t\t\t\t\t\t\t\t   victim_ref);\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tread_extent_buffer(leaf, victim_name,\n\t\t\t\t\t   (unsigned long)(victim_ref + 1),\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid,\n\t\t\t\t\t    victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tinc_nlink(inode);\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tret = btrfs_unlink_inode(trans, root, dir,\n\t\t\t\t\t\t\t inode, victim_name,\n\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\n\t\t\tptr = (unsigned long)(victim_ref + 1) + victim_name_len;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: we have searched root tree and checked the\n\t\t * coresponding ref, it does not need to check again.\n\t\t */\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* Same search but for extended refs */\n\textref = btrfs_lookup_inode_extref(NULL, root, path, name, namelen,\n\t\t\t\t\t   inode_objectid, parent_objectid, 0,\n\t\t\t\t\t   0);\n\tif (!IS_ERR_OR_NULL(extref)) {\n\t\tu32 item_size;\n\t\tu32 cur_offset = 0;\n\t\tunsigned long base;\n\t\tstruct inode *victim_parent;\n\n\t\tleaf = path->nodes[0];\n\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tbase = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *)(base + cur_offset);\n\n\t\t\tvictim_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tif (btrfs_inode_extref_parent(leaf, extref) != parent_objectid)\n\t\t\t\tgoto next;\n\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tread_extent_buffer(leaf, victim_name, (unsigned long)&extref->name,\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tsearch_key.objectid = inode_objectid;\n\t\t\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tsearch_key.offset = btrfs_extref_hash(parent_objectid,\n\t\t\t\t\t\t\t      victim_name,\n\t\t\t\t\t\t\t      victim_name_len);\n\t\t\tret = 0;\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid, victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tvictim_parent = read_one_inode(root,\n\t\t\t\t\t\t\t       parent_objectid);\n\t\t\t\tif (victim_parent) {\n\t\t\t\t\tinc_nlink(inode);\n\t\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\t\tret = btrfs_unlink_inode(trans, root,\n\t\t\t\t\t\t\t\t victim_parent,\n\t\t\t\t\t\t\t\t inode,\n\t\t\t\t\t\t\t\t victim_name,\n\t\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = btrfs_run_delayed_items(\n\t\t\t\t\t\t\t\t  trans, root);\n\t\t\t\t}\n\t\t\t\tiput(victim_parent);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\nnext:\n\t\t\tcur_offset += victim_name_len + sizeof(*extref);\n\t\t}\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicting sequence number */\n\tdi = btrfs_lookup_dir_index_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t\t ref_index, name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicing name */\n\tdi = btrfs_lookup_dir_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t   name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_one_dir_item",
          "args": [
            "trans",
            "root",
            "path",
            "dir",
            "di"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "drop_one_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "766-809",
          "snippet": "static noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tname_len = btrfs_dir_name_len(leaf, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, name, (unsigned long)(di + 1), name_len);\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (ret)\n\t\tgoto out;\n\telse\n\t\tret = btrfs_run_delayed_items(trans, root);\nout:\n\tkfree(name);\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tname_len = btrfs_dir_name_len(leaf, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, name, (unsigned long)(di + 1), name_len);\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (ret)\n\t\tgoto out;\n\telse\n\t\tret = btrfs_run_delayed_items(trans, root);\nout:\n\tkfree(name);\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "trans",
            "root",
            "path",
            "btrfs_ino(dir)",
            "name",
            "namelen",
            "0"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "dir"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_index_item",
          "args": [
            "trans",
            "root",
            "path",
            "btrfs_ino(dir)",
            "ref_index",
            "name",
            "namelen",
            "0"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_index_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "283-305",
          "snippet": "struct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "victim_name"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "victim_name"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "victim_parent"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_items",
          "args": [
            "trans",
            "root"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1205-1209",
          "snippet": "int btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlink_inode",
          "args": [
            "trans",
            "root",
            "victim_parent",
            "inode",
            "victim_name",
            "victim_name_len"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3957-3969",
          "snippet": "int btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "parent_objectid"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backref_in_log",
          "args": [
            "log_root",
            "&search_key",
            "parent_objectid",
            "victim_name",
            "victim_name_len"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "backref_in_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "858-910",
          "snippet": "static noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tunsigned long name_ptr;\n\tint found_name_len;\n\tint item_size;\n\tint ret;\n\tint match = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tif (btrfs_find_name_in_ext_backref(path, ref_objectid,\n\t\t\t\t\t\t   name, namelen, NULL))\n\t\t\tmatch = 1;\n\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\tfound_name_len = btrfs_inode_ref_name_len(path->nodes[0], ref);\n\t\tif (found_name_len == namelen) {\n\t\t\tname_ptr = (unsigned long)(ref + 1);\n\t\t\tret = memcmp_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t\t   name_ptr, namelen);\n\t\t\tif (ret == 0) {\n\t\t\t\tmatch = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tptr = (unsigned long)(ref + 1) + found_name_len;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn match;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tunsigned long name_ptr;\n\tint found_name_len;\n\tint item_size;\n\tint ret;\n\tint match = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tif (btrfs_find_name_in_ext_backref(path, ref_objectid,\n\t\t\t\t\t\t   name, namelen, NULL))\n\t\t\tmatch = 1;\n\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\tfound_name_len = btrfs_inode_ref_name_len(path->nodes[0], ref);\n\t\tif (found_name_len == namelen) {\n\t\t\tname_ptr = (unsigned long)(ref + 1);\n\t\t\tret = memcmp_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t\t   name_ptr, namelen);\n\t\t\tif (ret == 0) {\n\t\t\t\tmatch = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tptr = (unsigned long)(ref + 1) + found_name_len;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extref_hash",
          "args": [
            "parent_objectid",
            "victim_name",
            "victim_name_len"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extref_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.h",
          "lines": "36-40",
          "snippet": "static inline u64 btrfs_extref_hash(u64 parent_objectid, const char *name,\n\t\t\t\t    int len)\n{\n\treturn (u64) btrfs_crc32c(parent_objectid, name, len);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 btrfs_extref_hash(u64 parent_objectid, const char *name,\n\t\t\t\t    int len)\n{\n\treturn (u64) btrfs_crc32c(parent_objectid, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "victim_name",
            "(unsigned long)&extref->name",
            "victim_name_len"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "victim_name_len",
            "GFP_NOFS"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_parent",
          "args": [
            "leaf",
            "extref"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "leaf",
            "extref"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "extref"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_inode_extref",
          "args": [
            "NULL",
            "root",
            "path",
            "name",
            "namelen",
            "inode_objectid",
            "parent_objectid",
            "0",
            "0"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_inode_extref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-item.c",
          "lines": "95-119",
          "snippet": "struct btrfs_inode_extref *\nbtrfs_lookup_inode_extref(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  u64 inode_objectid, u64 ref_objectid, int ins_len,\n\t\t\t  int cow)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_extref *extref;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = btrfs_extref_hash(ref_objectid, name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\tif (!btrfs_find_name_in_ext_backref(path, ref_objectid, name, name_len, &extref))\n\t\treturn NULL;\n\treturn extref;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_inode_extref *\nbtrfs_lookup_inode_extref(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  u64 inode_objectid, u64 ref_objectid, int ins_len,\n\t\t\t  int cow)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_inode_extref *extref;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = btrfs_extref_hash(ref_objectid, name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\tif (!btrfs_find_name_in_ext_backref(path, ref_objectid, name, name_len, &extref))\n\t\treturn NULL;\n\treturn extref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "victim_name"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "victim_name"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "leaf",
            "victim_ref"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&search_key",
            "path",
            "0",
            "0"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic inline int __add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_root *log_root,\n\t\t\t\t  struct inode *dir, struct inode *inode,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  u64 inode_objectid, u64 parent_objectid,\n\t\t\t\t  u64 ref_index, char *name, int namelen,\n\t\t\t\t  int *search_done)\n{\n\tint ret;\n\tchar *victim_name;\n\tint victim_name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_inode_extref *extref;\n\nagain:\n\t/* Search old style refs */\n\tsearch_key.objectid = inode_objectid;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = parent_objectid;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret == 0) {\n\t\tstruct btrfs_inode_ref *victim_ref;\n\t\tunsigned long ptr;\n\t\tunsigned long ptr_end;\n\n\t\tleaf = path->nodes[0];\n\n\t\t/* are we trying to overwrite a back ref for the root directory\n\t\t * if so, just jump out, we're done\n\t\t */\n\t\tif (search_key.objectid == search_key.offset)\n\t\t\treturn 1;\n\n\t\t/* check all the names in this back reference to see\n\t\t * if they are in the log.  if so, we allow them to stay\n\t\t * otherwise they must be unlinked as a conflict\n\t\t */\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(leaf, path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tvictim_ref = (struct btrfs_inode_ref *)ptr;\n\t\t\tvictim_name_len = btrfs_inode_ref_name_len(leaf,\n\t\t\t\t\t\t\t\t   victim_ref);\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tread_extent_buffer(leaf, victim_name,\n\t\t\t\t\t   (unsigned long)(victim_ref + 1),\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid,\n\t\t\t\t\t    victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tinc_nlink(inode);\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tret = btrfs_unlink_inode(trans, root, dir,\n\t\t\t\t\t\t\t inode, victim_name,\n\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = btrfs_run_delayed_items(trans, root);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\n\t\t\tptr = (unsigned long)(victim_ref + 1) + victim_name_len;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: we have searched root tree and checked the\n\t\t * coresponding ref, it does not need to check again.\n\t\t */\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* Same search but for extended refs */\n\textref = btrfs_lookup_inode_extref(NULL, root, path, name, namelen,\n\t\t\t\t\t   inode_objectid, parent_objectid, 0,\n\t\t\t\t\t   0);\n\tif (!IS_ERR_OR_NULL(extref)) {\n\t\tu32 item_size;\n\t\tu32 cur_offset = 0;\n\t\tunsigned long base;\n\t\tstruct inode *victim_parent;\n\n\t\tleaf = path->nodes[0];\n\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tbase = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *)(base + cur_offset);\n\n\t\t\tvictim_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tif (btrfs_inode_extref_parent(leaf, extref) != parent_objectid)\n\t\t\t\tgoto next;\n\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tread_extent_buffer(leaf, victim_name, (unsigned long)&extref->name,\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tsearch_key.objectid = inode_objectid;\n\t\t\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tsearch_key.offset = btrfs_extref_hash(parent_objectid,\n\t\t\t\t\t\t\t      victim_name,\n\t\t\t\t\t\t\t      victim_name_len);\n\t\t\tret = 0;\n\t\t\tif (!backref_in_log(log_root, &search_key,\n\t\t\t\t\t    parent_objectid, victim_name,\n\t\t\t\t\t    victim_name_len)) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tvictim_parent = read_one_inode(root,\n\t\t\t\t\t\t\t       parent_objectid);\n\t\t\t\tif (victim_parent) {\n\t\t\t\t\tinc_nlink(inode);\n\t\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\t\tret = btrfs_unlink_inode(trans, root,\n\t\t\t\t\t\t\t\t victim_parent,\n\t\t\t\t\t\t\t\t inode,\n\t\t\t\t\t\t\t\t victim_name,\n\t\t\t\t\t\t\t\t victim_name_len);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = btrfs_run_delayed_items(\n\t\t\t\t\t\t\t\t  trans, root);\n\t\t\t\t}\n\t\t\t\tiput(victim_parent);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\nnext:\n\t\t\tcur_offset += victim_name_len + sizeof(*extref);\n\t\t}\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicting sequence number */\n\tdi = btrfs_lookup_dir_index_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t\t ref_index, name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicing name */\n\tdi = btrfs_lookup_dir_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t   name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "backref_in_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "858-910",
    "snippet": "static noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tunsigned long name_ptr;\n\tint found_name_len;\n\tint item_size;\n\tint ret;\n\tint match = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tif (btrfs_find_name_in_ext_backref(path, ref_objectid,\n\t\t\t\t\t\t   name, namelen, NULL))\n\t\t\tmatch = 1;\n\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\tfound_name_len = btrfs_inode_ref_name_len(path->nodes[0], ref);\n\t\tif (found_name_len == namelen) {\n\t\t\tname_ptr = (unsigned long)(ref + 1);\n\t\t\tret = memcmp_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t\t   name_ptr, namelen);\n\t\t\tif (ret == 0) {\n\t\t\t\tmatch = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tptr = (unsigned long)(ref + 1) + found_name_len;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn match;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp_extent_buffer",
          "args": [
            "path->nodes[0]",
            "name",
            "name_ptr",
            "namelen"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5320-5354",
          "snippet": "int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "path->nodes[0]",
            "ref"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_name_in_ext_backref",
          "args": [
            "path",
            "ref_objectid",
            "name",
            "namelen",
            "NULL"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_name_in_ext_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-item.c",
          "lines": "54-92",
          "snippet": "int btrfs_find_name_in_ext_backref(struct btrfs_path *path, u64 ref_objectid,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   struct btrfs_inode_extref **extref_ret)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_inode_extref *extref;\n\tunsigned long ptr;\n\tunsigned long name_ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t/*\n\t * Search all extended backrefs in this item. We're only\n\t * looking through any collisions so most of the time this is\n\t * just going to compare against one buffer. If all is well,\n\t * we'll return success and the inode ref object.\n\t */\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\tname_ptr = (unsigned long)(&extref->name);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\tif (ref_name_len == name_len &&\n\t\t    btrfs_inode_extref_parent(leaf, extref) == ref_objectid &&\n\t\t    (memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)) {\n\t\t\tif (extref_ret)\n\t\t\t\t*extref_ret = extref;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_find_name_in_ext_backref(struct btrfs_path *path, u64 ref_objectid,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   struct btrfs_inode_extref **extref_ret)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_inode_extref *extref;\n\tunsigned long ptr;\n\tunsigned long name_ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t/*\n\t * Search all extended backrefs in this item. We're only\n\t * looking through any collisions so most of the time this is\n\t * just going to compare against one buffer. If all is well,\n\t * we'll return success and the inode ref object.\n\t */\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\tname_ptr = (unsigned long)(&extref->name);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\tif (ref_name_len == name_len &&\n\t\t    btrfs_inode_extref_parent(leaf, extref) == ref_objectid &&\n\t\t    (memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)) {\n\t\t\tif (extref_ret)\n\t\t\t\t*extref_ret = extref;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "log",
            "key",
            "path",
            "0",
            "0"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_ref *ref;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tunsigned long name_ptr;\n\tint found_name_len;\n\tint item_size;\n\tint ret;\n\tint match = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tif (btrfs_find_name_in_ext_backref(path, ref_objectid,\n\t\t\t\t\t\t   name, namelen, NULL))\n\t\t\tmatch = 1;\n\n\t\tgoto out;\n\t}\n\n\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\tfound_name_len = btrfs_inode_ref_name_len(path->nodes[0], ref);\n\t\tif (found_name_len == namelen) {\n\t\t\tname_ptr = (unsigned long)(ref + 1);\n\t\t\tret = memcmp_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t\t   name_ptr, namelen);\n\t\t\tif (ret == 0) {\n\t\t\t\tmatch = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tptr = (unsigned long)(ref + 1) + found_name_len;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn match;\n}"
  },
  {
    "function_name": "inode_in_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "816-846",
    "snippet": "static noinline int inode_in_dir(struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 dirid, u64 objectid, u64 index,\n\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key location;\n\tint match = 0;\n\n\tdi = btrfs_lookup_dir_index_item(NULL, root, path, dirid,\n\t\t\t\t\t index, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dirid, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tmatch = 1;\nout:\n\tbtrfs_release_path(path);\n\treturn match;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "di",
            "&location"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "NULL",
            "root",
            "path",
            "dirid",
            "name",
            "name_len",
            "0"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_index_item",
          "args": [
            "NULL",
            "root",
            "path",
            "dirid",
            "index",
            "name",
            "name_len",
            "0"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_index_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "283-305",
          "snippet": "struct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path, u64 dir,\n\t\t\t    u64 objectid, const char *name, int name_len,\n\t\t\t    int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int inode_in_dir(struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 dirid, u64 objectid, u64 index,\n\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key location;\n\tint match = 0;\n\n\tdi = btrfs_lookup_dir_index_item(NULL, root, path, dirid,\n\t\t\t\t\t index, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dirid, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tmatch = 1;\nout:\n\tbtrfs_release_path(path);\n\treturn match;\n}"
  },
  {
    "function_name": "drop_one_dir_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "766-809",
    "snippet": "static noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tname_len = btrfs_dir_name_len(leaf, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, name, (unsigned long)(di + 1), name_len);\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (ret)\n\t\tgoto out;\n\telse\n\t\tret = btrfs_run_delayed_items(trans, root);\nout:\n\tkfree(name);\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_run_delayed_items",
          "args": [
            "trans",
            "root"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "1205-1209",
          "snippet": "int btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nint btrfs_run_delayed_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\treturn __btrfs_run_delayed_items(trans, root, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlink_inode",
          "args": [
            "trans",
            "root",
            "dir",
            "inode",
            "name",
            "name_len"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3957-3969",
          "snippet": "int btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_unlink_inode(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root,\n\t\t       struct inode *dir, struct inode *inode,\n\t\t       const char *name, int name_len)\n{\n\tint ret;\n\tret = __btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (!ret) {\n\t\tdrop_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_to_fixup_dir",
          "args": [
            "trans",
            "root",
            "path",
            "location.objectid"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "link_to_fixup_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "1501-1535",
          "snippet": "static noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, inode);\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "location.objectid"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "name",
            "(unsigned long)(di + 1)",
            "name_len"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "name_len",
            "GFP_NOFS"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_name_len",
          "args": [
            "leaf",
            "di"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "leaf",
            "di",
            "&location"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tname_len = btrfs_dir_name_len(leaf, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, name, (unsigned long)(di + 1), name_len);\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_unlink_inode(trans, root, dir, inode, name, name_len);\n\tif (ret)\n\t\tgoto out;\n\telse\n\t\tret = btrfs_run_delayed_items(trans, root);\nout:\n\tkfree(name);\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "replay_one_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "576-756",
    "snippet": "static noinline int replay_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct extent_buffer *eb, int slot,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tint found_type;\n\tu64 extent_end;\n\tu64 start = key->offset;\n\tu64 nbytes = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct inode *inode = NULL;\n\tunsigned long size;\n\tint ret = 0;\n\n\titem = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(eb, item);\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tnbytes = btrfs_file_extent_num_bytes(eb, item);\n\t\textent_end = start + nbytes;\n\n\t\t/*\n\t\t * We don't add to the inodes nbytes if we are prealloc or a\n\t\t * hole.\n\t\t */\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tnbytes = 0;\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize = btrfs_file_extent_inline_len(eb, slot, item);\n\t\tnbytes = btrfs_file_extent_ram_bytes(eb, item);\n\t\textent_end = ALIGN(start + size, root->sectorsize);\n\t} else {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, key->objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * first check to see if we already have this extent in the\n\t * file.  This must be done before the btrfs_drop_extents run\n\t * so we don't try to drop this extent.\n\t */\n\tret = btrfs_lookup_file_extent(trans, root, path, btrfs_ino(inode),\n\t\t\t\t       start, 0);\n\n\tif (ret == 0 &&\n\t    (found_type == BTRFS_FILE_EXTENT_REG ||\n\t     found_type == BTRFS_FILE_EXTENT_PREALLOC)) {\n\t\tstruct btrfs_file_extent_item cmp1;\n\t\tstruct btrfs_file_extent_item cmp2;\n\t\tstruct btrfs_file_extent_item *existing;\n\t\tstruct extent_buffer *leaf;\n\n\t\tleaf = path->nodes[0];\n\t\texisting = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_file_extent_item);\n\n\t\tread_extent_buffer(eb, &cmp1, (unsigned long)item,\n\t\t\t\t   sizeof(cmp1));\n\t\tread_extent_buffer(leaf, &cmp2, (unsigned long)existing,\n\t\t\t\t   sizeof(cmp2));\n\n\t\t/*\n\t\t * we already have a pointer to this exact extent,\n\t\t * we don't have to do anything\n\t\t */\n\t\tif (memcmp(&cmp1, &cmp2, sizeof(cmp1)) == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* drop any overlapping extents */\n\tret = btrfs_drop_extents(trans, root, inode, start, extent_end, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 offset;\n\t\tunsigned long dest_offset;\n\t\tstruct btrfs_key ins;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, key,\n\t\t\t\t\t      sizeof(*item));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdest_offset = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\t\t    path->slots[0]);\n\t\tcopy_extent_buffer(path->nodes[0], eb, dest_offset,\n\t\t\t\t(unsigned long)item,  sizeof(*item));\n\n\t\tins.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tins.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\t\toffset = key->offset - btrfs_file_extent_offset(eb, item);\n\n\t\tif (ins.objectid > 0) {\n\t\t\tu64 csum_start;\n\t\t\tu64 csum_end;\n\t\t\tLIST_HEAD(ordered_sums);\n\t\t\t/*\n\t\t\t * is this extent already allocated in the extent\n\t\t\t * allocation tree?  If so, just add a reference\n\t\t\t */\n\t\t\tret = btrfs_lookup_data_extent(root, ins.objectid,\n\t\t\t\t\t\tins.offset);\n\t\t\tif (ret == 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tins.objectid, ins.offset,\n\t\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * insert the extent pointer in the extent\n\t\t\t\t * allocation tree\n\t\t\t\t */\n\t\t\t\tret = btrfs_alloc_logged_file_extent(trans,\n\t\t\t\t\t\troot, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, &ins);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tif (btrfs_file_extent_compression(eb, item)) {\n\t\t\t\tcsum_start = ins.objectid;\n\t\t\t\tcsum_end = csum_start + ins.offset;\n\t\t\t} else {\n\t\t\t\tcsum_start = ins.objectid +\n\t\t\t\t\tbtrfs_file_extent_offset(eb, item);\n\t\t\t\tcsum_end = csum_start +\n\t\t\t\t\tbtrfs_file_extent_num_bytes(eb, item);\n\t\t\t}\n\n\t\t\tret = btrfs_lookup_csums_range(root->log_root,\n\t\t\t\t\t\tcsum_start, csum_end - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\twhile (!list_empty(&ordered_sums)) {\n\t\t\t\tstruct btrfs_ordered_sum *sums;\n\t\t\t\tsums = list_entry(ordered_sums.next,\n\t\t\t\t\t\tstruct btrfs_ordered_sum,\n\t\t\t\t\t\tlist);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_csum_file_blocks(trans,\n\t\t\t\t\t\troot->fs_info->csum_root,\n\t\t\t\t\t\tsums);\n\t\t\t\tlist_del(&sums->list);\n\t\t\t\tkfree(sums);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t/* inline extents are easy, we just overwrite them */\n\t\tret = overwrite_item(trans, root, path, eb, slot, key);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tinode_add_bytes(inode, nbytes);\n\tret = btrfs_update_inode(trans, root, inode);\nout:\n\tif (inode)\n\t\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_inode",
          "args": [
            "trans",
            "root",
            "inode"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_inode_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3841-3851",
          "snippet": "noinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nnoinline int btrfs_update_inode_fallback(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct inode *inode)\n{\n\tint ret;\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret == -ENOSPC)\n\t\treturn btrfs_update_inode_item(trans, root, inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "nbytes"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "overwrite_item",
          "args": [
            "trans",
            "root",
            "path",
            "eb",
            "slot",
            "key"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "overwrite_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "341-539",
          "snippet": "static noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sums"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sums->list"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_file_blocks",
          "args": [
            "trans",
            "root->fs_info->csum_root",
            "sums"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_file_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "683-877",
          "snippet": "int btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_ordered_sum *sums)\n{\n\tstruct btrfs_key file_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tstruct btrfs_csum_item *item;\n\tstruct btrfs_csum_item *item_end;\n\tstruct extent_buffer *leaf = NULL;\n\tu64 next_offset;\n\tu64 total_bytes = 0;\n\tu64 csum_offset;\n\tu64 bytenr;\n\tu32 nritems;\n\tu32 ins_size;\n\tint index = 0;\n\tint found_next;\n\tint ret;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tnext_offset = (u64)-1;\n\tfound_next = 0;\n\tbytenr = sums->bytenr + total_bytes;\n\tfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tfile_key.offset = bytenr;\n\tfile_key.type = BTRFS_EXTENT_CSUM_KEY;\n\n\titem = btrfs_lookup_csum(trans, root, path, bytenr, 1);\n\tif (!IS_ERR(item)) {\n\t\tret = 0;\n\t\tleaf = path->nodes[0];\n\t\titem_end = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_csum_item);\n\t\titem_end = (struct btrfs_csum_item *)((char *)item_end +\n\t\t\t   btrfs_item_size_nr(leaf, path->slots[0]));\n\t\tgoto found;\n\t}\n\tret = PTR_ERR(item);\n\tif (ret != -EFBIG && ret != -ENOENT)\n\t\tgoto fail_unlock;\n\n\tif (ret == -EFBIG) {\n\t\tu32 item_size;\n\t\t/* we found one, but it isn't big enough yet */\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif ((item_size / csum_size) >=\n\t\t    MAX_CSUM_ITEMS(root, csum_size)) {\n\t\t\t/* already at max size, make a new one */\n\t\t\tgoto insert;\n\t\t}\n\t} else {\n\t\tint slot = path->slots[0] + 1;\n\t\t/* we didn't find a csum item, insert one */\n\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\tif (!nritems || (path->slots[0] >= nritems - 1)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 1)\n\t\t\t\tfound_next = 1;\n\t\t\tif (ret != 0)\n\t\t\t\tgoto insert;\n\t\t\tslot = path->slots[0];\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\n\t\tif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    found_key.type != BTRFS_EXTENT_CSUM_KEY) {\n\t\t\tfound_next = 1;\n\t\t\tgoto insert;\n\t\t}\n\t\tnext_offset = found_key.offset;\n\t\tfound_next = 1;\n\t\tgoto insert;\n\t}\n\n\t/*\n\t * at this point, we know the tree has an item, but it isn't big\n\t * enough yet to put our csum in.  Grow it\n\t */\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(trans, root, &file_key, path,\n\t\t\t\tcsum_size, 1);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto insert;\n\t\tpath->slots[0]--;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\tcsum_offset = (bytenr - found_key.offset) >>\n\t\t\troot->fs_info->sb->s_blocksize_bits;\n\n\tif (found_key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t    csum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\n\t\tgoto insert;\n\t}\n\n\tif (csum_offset == btrfs_item_size_nr(leaf, path->slots[0]) /\n\t    csum_size) {\n\t\tint extend_nr;\n\t\tu64 tmp;\n\t\tu32 diff;\n\t\tu32 free_space;\n\n\t\tif (btrfs_leaf_free_space(root, leaf) <\n\t\t\t\t sizeof(struct btrfs_item) + csum_size * 2)\n\t\t\tgoto insert;\n\n\t\tfree_space = btrfs_leaf_free_space(root, leaf) -\n\t\t\t\t\t sizeof(struct btrfs_item) - csum_size;\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\tWARN_ON(tmp < 1);\n\n\t\textend_nr = max_t(int, 1, (int)tmp);\n\t\tdiff = (csum_offset + extend_nr) * csum_size;\n\t\tdiff = min(diff, MAX_CSUM_ITEMS(root, csum_size) * csum_size);\n\n\t\tdiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tdiff = min(free_space, diff);\n\t\tdiff /= csum_size;\n\t\tdiff *= csum_size;\n\n\t\tbtrfs_extend_item(root, path, diff);\n\t\tret = 0;\n\t\tgoto csum;\n\t}\n\ninsert:\n\tbtrfs_release_path(path);\n\tcsum_offset = 0;\n\tif (found_next) {\n\t\tu64 tmp;\n\n\t\ttmp = sums->len - total_bytes;\n\t\ttmp >>= root->fs_info->sb->s_blocksize_bits;\n\t\ttmp = min(tmp, (next_offset - file_key.offset) >>\n\t\t\t\t\t root->fs_info->sb->s_blocksize_bits);\n\n\t\ttmp = max((u64)1, tmp);\n\t\ttmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\n\t\tins_size = csum_size * tmp;\n\t} else {\n\t\tins_size = csum_size;\n\t}\n\tpath->leave_spinning = 1;\n\tret = btrfs_insert_empty_item(trans, root, path, &file_key,\n\t\t\t\t      ins_size);\n\tpath->leave_spinning = 0;\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\tif (WARN_ON(ret != 0))\n\t\tgoto fail_unlock;\n\tleaf = path->nodes[0];\ncsum:\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\n\titem_end = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t      btrfs_item_size_nr(leaf, path->slots[0]));\n\titem = (struct btrfs_csum_item *)((unsigned char *)item +\n\t\t\t\t\t  csum_offset * csum_size);\nfound:\n\tins_size = (u32)(sums->len - total_bytes) >>\n\t\t   root->fs_info->sb->s_blocksize_bits;\n\tins_size *= csum_size;\n\tins_size = min_t(u32, (unsigned long)item_end - (unsigned long)item,\n\t\t\t      ins_size);\n\twrite_extent_buffer(leaf, sums->sums + index, (unsigned long)item,\n\t\t\t    ins_size);\n\n\tins_size /= csum_size;\n\ttotal_bytes += ins_size * root->sectorsize;\n\tindex += ins_size;\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tif (total_bytes < sums->len) {\n\t\tbtrfs_release_path(path);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n\nfail_unlock:\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ordered_sums.next",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ordered_sums"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csums_range",
          "args": [
            "root->log_root",
            "csum_start",
            "csum_end - 1",
            "&ordered_sums",
            "0"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "eb",
            "item"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "eb",
            "item"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "eb",
            "item"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_logged_file_extent",
          "args": [
            "trans",
            "root",
            "root->root_key.objectid",
            "key->objectid",
            "offset",
            "&ins"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_logged_file_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7177-7206",
          "snippet": "int btrfs_alloc_logged_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   u64 root_objectid, u64 owner, u64 offset,\n\t\t\t\t   struct btrfs_key *ins)\n{\n\tint ret;\n\tstruct btrfs_block_group_cache *block_group;\n\n\t/*\n\t * Mixed block groups will exclude before processing the log so we only\n\t * need to do the exlude dance if this fs isn't mixed.\n\t */\n\tif (!btrfs_fs_incompat(root->fs_info, MIXED_GROUPS)) {\n\t\tret = __exclude_logged_extent(root, ins->objectid, ins->offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tblock_group = btrfs_lookup_block_group(root->fs_info, ins->objectid);\n\tif (!block_group)\n\t\treturn -EINVAL;\n\n\tret = btrfs_update_reserved_bytes(block_group, ins->offset,\n\t\t\t\t\t  RESERVE_ALLOC_NO_ACCOUNT, 0);\n\tBUG_ON(ret); /* logic error */\n\tret = alloc_reserved_file_extent(trans, root, 0, root_objectid,\n\t\t\t\t\t 0, owner, offset, ins, 1);\n\tbtrfs_put_block_group(block_group);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_alloc_logged_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   u64 root_objectid, u64 owner, u64 offset,\n\t\t\t\t   struct btrfs_key *ins)\n{\n\tint ret;\n\tstruct btrfs_block_group_cache *block_group;\n\n\t/*\n\t * Mixed block groups will exclude before processing the log so we only\n\t * need to do the exlude dance if this fs isn't mixed.\n\t */\n\tif (!btrfs_fs_incompat(root->fs_info, MIXED_GROUPS)) {\n\t\tret = __exclude_logged_extent(root, ins->objectid, ins->offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tblock_group = btrfs_lookup_block_group(root->fs_info, ins->objectid);\n\tif (!block_group)\n\t\treturn -EINVAL;\n\n\tret = btrfs_update_reserved_bytes(block_group, ins->offset,\n\t\t\t\t\t  RESERVE_ALLOC_NO_ACCOUNT, 0);\n\tBUG_ON(ret); /* logic error */\n\tret = alloc_reserved_file_extent(trans, root, 0, root_objectid,\n\t\t\t\t\t 0, owner, offset, ins, 1);\n\tbtrfs_put_block_group(block_group);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inc_extent_ref",
          "args": [
            "trans",
            "root",
            "ins.objectid",
            "ins.offset",
            "0",
            "root->root_key.objectid",
            "key->objectid",
            "offset",
            "0"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1942-1966",
          "snippet": "int btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_data_extent",
          "args": [
            "root",
            "ins.objectid",
            "ins.offset"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_data_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "715-732",
          "snippet": "int btrfs_lookup_data_extent(struct btrfs_root *root, u64 start, u64 len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = start;\n\tkey.offset = len;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tret = btrfs_search_slot(NULL, root->fs_info->extent_root, &key, path,\n\t\t\t\t0, 0);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_lookup_data_extent(struct btrfs_root *root, u64 start, u64 len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = start;\n\tkey.offset = len;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tret = btrfs_search_slot(NULL, root->fs_info->extent_root, &key, path,\n\t\t\t\t0, 0);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "ordered_sums"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "eb",
            "item"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "eb",
            "item"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "eb",
            "item"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "path->nodes[0]",
            "eb",
            "dest_offset",
            "(unsigned long)item",
            "sizeof(*item)"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "key",
            "sizeof(*item)"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extents",
          "args": [
            "trans",
            "root",
            "inode",
            "start",
            "extent_end",
            "1"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "1013-1027",
          "snippet": "int btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct inode *inode, u64 start,\n\t\t       u64 end, int drop_cache)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __btrfs_drop_extents(trans, root, inode, path, start, end, NULL,\n\t\t\t\t   drop_cache, 0, 0, NULL);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nint btrfs_drop_extents(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct inode *inode, u64 start,\n\t\t       u64 end, int drop_cache)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __btrfs_drop_extents(trans, root, inode, path, start, end, NULL,\n\t\t\t\t   drop_cache, 0, 0, NULL);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&cmp1",
            "&cmp2",
            "sizeof(cmp1)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "&cmp2",
            "(unsigned long)existing",
            "sizeof(cmp2)"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_file_extent",
          "args": [
            "trans",
            "root",
            "path",
            "btrfs_ino(inode)",
            "start",
            "0"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_file_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "139-154",
          "snippet": "int btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_one_inode",
          "args": [
            "root",
            "key->objectid"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "read_one_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "545-562",
          "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "start + size",
            "root->sectorsize"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_ram_bytes",
          "args": [
            "eb",
            "item"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_inline_len",
          "args": [
            "eb",
            "slot",
            "item"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_file_extent_inline_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3139-3159",
          "snippet": "static inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_file_extent_inline_len(struct extent_buffer *eb,\n\t\t\t\t\t       int slot,\n\t\t\t\t\t       struct btrfs_file_extent_item *fi)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\t/*\n\t * return the space used on disk if this item isn't\n\t * compressed or encoded\n\t */\n\tif (btrfs_token_file_extent_compression(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_encryption(eb, fi, &token) == 0 &&\n\t    btrfs_token_file_extent_other_encoding(eb, fi, &token) == 0) {\n\t\treturn btrfs_file_extent_inline_item_len(eb,\n\t\t\t\t\t\t\t btrfs_item_nr(slot));\n\t}\n\n\t/* otherwise use the ram bytes field */\n\treturn btrfs_token_file_extent_ram_bytes(eb, fi, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "eb",
            "item"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "eb",
            "item"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "eb",
            "item"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int replay_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct extent_buffer *eb, int slot,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tint found_type;\n\tu64 extent_end;\n\tu64 start = key->offset;\n\tu64 nbytes = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct inode *inode = NULL;\n\tunsigned long size;\n\tint ret = 0;\n\n\titem = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(eb, item);\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tnbytes = btrfs_file_extent_num_bytes(eb, item);\n\t\textent_end = start + nbytes;\n\n\t\t/*\n\t\t * We don't add to the inodes nbytes if we are prealloc or a\n\t\t * hole.\n\t\t */\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tnbytes = 0;\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize = btrfs_file_extent_inline_len(eb, slot, item);\n\t\tnbytes = btrfs_file_extent_ram_bytes(eb, item);\n\t\textent_end = ALIGN(start + size, root->sectorsize);\n\t} else {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, key->objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * first check to see if we already have this extent in the\n\t * file.  This must be done before the btrfs_drop_extents run\n\t * so we don't try to drop this extent.\n\t */\n\tret = btrfs_lookup_file_extent(trans, root, path, btrfs_ino(inode),\n\t\t\t\t       start, 0);\n\n\tif (ret == 0 &&\n\t    (found_type == BTRFS_FILE_EXTENT_REG ||\n\t     found_type == BTRFS_FILE_EXTENT_PREALLOC)) {\n\t\tstruct btrfs_file_extent_item cmp1;\n\t\tstruct btrfs_file_extent_item cmp2;\n\t\tstruct btrfs_file_extent_item *existing;\n\t\tstruct extent_buffer *leaf;\n\n\t\tleaf = path->nodes[0];\n\t\texisting = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_file_extent_item);\n\n\t\tread_extent_buffer(eb, &cmp1, (unsigned long)item,\n\t\t\t\t   sizeof(cmp1));\n\t\tread_extent_buffer(leaf, &cmp2, (unsigned long)existing,\n\t\t\t\t   sizeof(cmp2));\n\n\t\t/*\n\t\t * we already have a pointer to this exact extent,\n\t\t * we don't have to do anything\n\t\t */\n\t\tif (memcmp(&cmp1, &cmp2, sizeof(cmp1)) == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* drop any overlapping extents */\n\tret = btrfs_drop_extents(trans, root, inode, start, extent_end, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 offset;\n\t\tunsigned long dest_offset;\n\t\tstruct btrfs_key ins;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, key,\n\t\t\t\t\t      sizeof(*item));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdest_offset = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\t\t    path->slots[0]);\n\t\tcopy_extent_buffer(path->nodes[0], eb, dest_offset,\n\t\t\t\t(unsigned long)item,  sizeof(*item));\n\n\t\tins.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tins.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\t\toffset = key->offset - btrfs_file_extent_offset(eb, item);\n\n\t\tif (ins.objectid > 0) {\n\t\t\tu64 csum_start;\n\t\t\tu64 csum_end;\n\t\t\tLIST_HEAD(ordered_sums);\n\t\t\t/*\n\t\t\t * is this extent already allocated in the extent\n\t\t\t * allocation tree?  If so, just add a reference\n\t\t\t */\n\t\t\tret = btrfs_lookup_data_extent(root, ins.objectid,\n\t\t\t\t\t\tins.offset);\n\t\t\tif (ret == 0) {\n\t\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tins.objectid, ins.offset,\n\t\t\t\t\t\t0, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * insert the extent pointer in the extent\n\t\t\t\t * allocation tree\n\t\t\t\t */\n\t\t\t\tret = btrfs_alloc_logged_file_extent(trans,\n\t\t\t\t\t\troot, root->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, &ins);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tif (btrfs_file_extent_compression(eb, item)) {\n\t\t\t\tcsum_start = ins.objectid;\n\t\t\t\tcsum_end = csum_start + ins.offset;\n\t\t\t} else {\n\t\t\t\tcsum_start = ins.objectid +\n\t\t\t\t\tbtrfs_file_extent_offset(eb, item);\n\t\t\t\tcsum_end = csum_start +\n\t\t\t\t\tbtrfs_file_extent_num_bytes(eb, item);\n\t\t\t}\n\n\t\t\tret = btrfs_lookup_csums_range(root->log_root,\n\t\t\t\t\t\tcsum_start, csum_end - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\twhile (!list_empty(&ordered_sums)) {\n\t\t\t\tstruct btrfs_ordered_sum *sums;\n\t\t\t\tsums = list_entry(ordered_sums.next,\n\t\t\t\t\t\tstruct btrfs_ordered_sum,\n\t\t\t\t\t\tlist);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_csum_file_blocks(trans,\n\t\t\t\t\t\troot->fs_info->csum_root,\n\t\t\t\t\t\tsums);\n\t\t\t\tlist_del(&sums->list);\n\t\t\t\tkfree(sums);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t/* inline extents are easy, we just overwrite them */\n\t\tret = overwrite_item(trans, root, path, eb, slot, key);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tinode_add_bytes(inode, nbytes);\n\tret = btrfs_update_inode(trans, root, inode);\nout:\n\tif (inode)\n\t\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "read_one_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "545-562",
    "snippet": "inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "root->fs_info->sb",
            "&key",
            "root",
            "NULL"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\ninode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode)) {\n\t\tinode = NULL;\n\t} else if (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "overwrite_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "341-539",
    "snippet": "static noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[0]"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_generation",
          "args": [
            "path->nodes[0]",
            "dst_item",
            "trans->transid"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_generation",
          "args": [
            "path->nodes[0]",
            "dst_item"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_size",
          "args": [
            "path->nodes[0]",
            "dst_item",
            "saved_i_size"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "path->nodes[0]",
            "eb",
            "dst_ptr",
            "src_ptr",
            "item_size"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "path->nodes[0]",
            "dst_item"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "btrfs_inode_mode(path->nodes[0], dst_item)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "path->nodes[0]",
            "dst_item"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "btrfs_inode_mode(eb, src_item)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "eb",
            "src_item"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_inode_size",
          "args": [
            "dst_eb",
            "dst_item",
            "ino_size",
            "&token"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_size",
          "args": [
            "eb",
            "src_item"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "btrfs_inode_mode(dst_eb, dst_item)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "dst_eb",
            "dst_item"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "btrfs_inode_mode(eb, src_item)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "eb",
            "src_item"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_generation",
          "args": [
            "eb",
            "src_item"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extend_item",
          "args": [
            "root",
            "path",
            "item_size - found_size"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4634-4697",
          "snippet": "void btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_item",
          "args": [
            "root",
            "path",
            "item_size",
            "1"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4535-4629",
          "snippet": "void btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "key",
            "item_size"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_size",
          "args": [
            "eb",
            "item",
            "0"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "eb",
            "item"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_nbytes",
          "args": [
            "eb",
            "item",
            "0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_inode_item"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_size",
          "args": [
            "eb",
            "item",
            "0"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_mode",
          "args": [
            "eb",
            "item"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_nbytes",
          "args": [
            "eb",
            "item",
            "nbytes"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_inode_item"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_nbytes",
          "args": [
            "path->nodes[0]",
            "item"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "src_copy"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dst_copy"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dst_copy",
            "src_copy",
            "item_size"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "path->nodes[0]",
            "dst_copy",
            "dst_ptr",
            "item_size"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "src_copy"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dst_copy"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "item_size",
            "GFP_NOFS"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "key",
            "path",
            "0",
            "0"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "slot"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline struct;\n\nstatic noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(root, path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(root, path,\n\t\t\t\t\t  item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item))) {\n\t\t\t\tstruct btrfs_map_token token;\n\t\t\t\tu64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t\tbtrfs_init_map_token(&token);\n\t\t\t\tbtrfs_set_token_inode_size(dst_eb, dst_item,\n\t\t\t\t\t\t\t   ino_size, &token);\n\t\t\t}\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}"
  },
  {
    "function_name": "process_one_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "296-325",
    "snippet": "static int process_one_buffer(struct btrfs_root *log,\n\t\t\t      struct extent_buffer *eb,\n\t\t\t      struct walk_control *wc, u64 gen)\n{\n\tint ret = 0;\n\n\t/*\n\t * If this fs is mixed then we need to be able to process the leaves to\n\t * pin down any logged extents, so we have to read the block.\n\t */\n\tif (btrfs_fs_incompat(log->fs_info, MIXED_GROUPS)) {\n\t\tret = btrfs_read_buffer(eb, gen);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (wc->pin)\n\t\tret = btrfs_pin_extent_for_log_replay(log->fs_info->extent_root,\n\t\t\t\t\t\t      eb->start, eb->len);\n\n\tif (!ret && btrfs_buffer_uptodate(eb, gen, 0)) {\n\t\tif (wc->pin && btrfs_header_level(eb) == 0)\n\t\t\tret = btrfs_exclude_logged_extents(log, eb);\n\t\tif (wc->write)\n\t\t\tbtrfs_write_tree_block(eb);\n\t\tif (wc->wait)\n\t\t\tbtrfs_wait_tree_block_writeback(eb);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_wait_tree_block_writeback",
          "args": [
            "eb"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_tree_block_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1143-1147",
          "snippet": "int btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t\t       buf->start, buf->start + buf->len - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_write_tree_block",
          "args": [
            "eb"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_write_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1137-1141",
          "snippet": "int btrfs_write_tree_block(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawrite_range(buf->pages[0]->mapping, buf->start,\n\t\t\t\t\tbuf->start + buf->len - 1);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_write_tree_block(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawrite_range(buf->pages[0]->mapping, buf->start,\n\t\t\t\t\tbuf->start + buf->len - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_exclude_logged_extents",
          "args": [
            "log",
            "eb"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_exclude_logged_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5591-5618",
          "snippet": "int btrfs_exclude_logged_extents(struct btrfs_root *log,\n\t\t\t\t struct extent_buffer *eb)\n{\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key key;\n\tint found_type;\n\tint i;\n\n\tif (!btrfs_fs_incompat(log->fs_info, MIXED_GROUPS))\n\t\treturn 0;\n\n\tfor (i = 0; i < btrfs_header_nritems(eb); i++) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\titem = btrfs_item_ptr(eb, i, struct btrfs_file_extent_item);\n\t\tfound_type = btrfs_file_extent_type(eb, item);\n\t\tif (found_type == BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tcontinue;\n\t\tkey.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tkey.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\t__exclude_logged_extent(log, key.objectid, key.offset);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_exclude_logged_extents(struct btrfs_root *log,\n\t\t\t\t struct extent_buffer *eb)\n{\n\tstruct btrfs_file_extent_item *item;\n\tstruct btrfs_key key;\n\tint found_type;\n\tint i;\n\n\tif (!btrfs_fs_incompat(log->fs_info, MIXED_GROUPS))\n\t\treturn 0;\n\n\tfor (i = 0; i < btrfs_header_nritems(eb); i++) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\titem = btrfs_item_ptr(eb, i, struct btrfs_file_extent_item);\n\t\tfound_type = btrfs_file_extent_type(eb, item);\n\t\tif (found_type == BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tcontinue;\n\t\tkey.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tkey.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\t__exclude_logged_extent(log, key.objectid, key.offset);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_buffer_uptodate",
          "args": [
            "eb",
            "gen",
            "0"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3741-3756",
          "snippet": "int btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_pin_extent_for_log_replay",
          "args": [
            "log->fs_info->extent_root",
            "eb->start",
            "eb->len"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_pin_extent_for_log_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5520-5544",
          "snippet": "int btrfs_pin_extent_for_log_replay(struct btrfs_root *root,\n\t\t\t\t    u64 bytenr, u64 num_bytes)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tint ret;\n\n\tcache = btrfs_lookup_block_group(root->fs_info, bytenr);\n\tif (!cache)\n\t\treturn -EINVAL;\n\n\t/*\n\t * pull in the free space cache (if any) so that our pin\n\t * removes the free space from the cache.  We have load_only set\n\t * to one because the slow code to read in the free extents does check\n\t * the pinned extents.\n\t */\n\tcache_block_group(cache, 1);\n\n\tpin_down_extent(root, cache, bytenr, num_bytes, 0);\n\n\t/* remove us from the free space cache (if we're there at all) */\n\tret = btrfs_remove_free_space(cache, bytenr, num_bytes);\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_pin_extent_for_log_replay(struct btrfs_root *root,\n\t\t\t\t    u64 bytenr, u64 num_bytes)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tint ret;\n\n\tcache = btrfs_lookup_block_group(root->fs_info, bytenr);\n\tif (!cache)\n\t\treturn -EINVAL;\n\n\t/*\n\t * pull in the free space cache (if any) so that our pin\n\t * removes the free space from the cache.  We have load_only set\n\t * to one because the slow code to read in the free extents does check\n\t * the pinned extents.\n\t */\n\tcache_block_group(cache, 1);\n\n\tpin_down_extent(root, cache, bytenr, num_bytes, 0);\n\n\t/* remove us from the free space cache (if we're there at all) */\n\tret = btrfs_remove_free_space(cache, bytenr, num_bytes);\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_read_buffer",
          "args": [
            "eb",
            "gen"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3831-3835",
          "snippet": "int btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_incompat",
          "args": [
            "log->fs_info",
            "MIXED_GROUPS"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4064-4069",
          "snippet": "static inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int process_one_buffer(struct btrfs_root *log,\n\t\t\t      struct extent_buffer *eb,\n\t\t\t      struct walk_control *wc, u64 gen)\n{\n\tint ret = 0;\n\n\t/*\n\t * If this fs is mixed then we need to be able to process the leaves to\n\t * pin down any logged extents, so we have to read the block.\n\t */\n\tif (btrfs_fs_incompat(log->fs_info, MIXED_GROUPS)) {\n\t\tret = btrfs_read_buffer(eb, gen);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (wc->pin)\n\t\tret = btrfs_pin_extent_for_log_replay(log->fs_info->extent_root,\n\t\t\t\t\t\t      eb->start, eb->len);\n\n\tif (!ret && btrfs_buffer_uptodate(eb, gen, 0)) {\n\t\tif (wc->pin && btrfs_header_level(eb) == 0)\n\t\t\tret = btrfs_exclude_logged_extents(log, eb);\n\t\tif (wc->write)\n\t\t\tbtrfs_write_tree_block(eb);\n\t\tif (wc->wait)\n\t\t\tbtrfs_wait_tree_block_writeback(eb);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_end_log_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "238-245",
    "snippet": "void btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&root->log_writer_wait"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&root->log_writer_wait"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&root->log_writers"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&root->log_writer_wait))\n\t\t\twake_up(&root->log_writer_wait);\n\t}\n}"
  },
  {
    "function_name": "btrfs_pin_log_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "224-232",
    "snippet": "int btrfs_pin_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tatomic_inc(&root->log_writers);\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_writers"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_pin_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tatomic_inc(&root->log_writers);\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "join_running_log_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "202-217",
    "snippet": "static int join_running_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tsmp_mb();\n\tif (!root->log_root)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tret = 0;\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_writers"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int join_running_log_trans(struct btrfs_root *root)\n{\n\tint ret = -ENOENT;\n\n\tsmp_mb();\n\tif (!root->log_root)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tret = 0;\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "start_log_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
    "lines": "139-195",
    "snippet": "static int start_log_trans(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tint index;\n\tint ret;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!root->log_start_pid) {\n\t\t\troot->log_start_pid = current->pid;\n\t\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t} else if (root->log_start_pid != current->pid) {\n\t\t\tset_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t}\n\n\t\tatomic_inc(&root->log_batch);\n\t\tatomic_inc(&root->log_writers);\n\t\tif (ctx) {\n\t\t\tindex = root->log_transid % 2;\n\t\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\t\tctx->log_transid = root->log_transid;\n\t\t}\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\tif (!root->fs_info->log_root_tree)\n\t\tret = btrfs_init_log_root_tree(trans, root->fs_info);\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!root->log_root) {\n\t\tret = btrfs_add_log_tree(trans, root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\troot->log_start_pid = current->pid;\n\tatomic_inc(&root->log_batch);\n\tatomic_inc(&root->log_writers);\n\tif (ctx) {\n\t\tindex = root->log_transid % 2;\n\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\tctx->log_transid = root->log_transid;\n\t}\nout:\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"backref.h\"",
      "#include \"print-tree.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"tree-log.h\"",
      "#include <linux/list_sort.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ctx->list",
            "&root->log_ctxs[index]"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_writers"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_batch"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_ROOT_MULTI_LOG_TASKS",
            "&root->state"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_log_tree",
          "args": [
            "trans",
            "root"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_log_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1455-1483",
          "snippet": "int btrfs_add_log_tree(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_root *log_root;\n\tstruct btrfs_inode_item *inode_item;\n\n\tlog_root = alloc_log_tree(trans, root->fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\n\tlog_root->last_trans = trans->transid;\n\tlog_root->root_key.offset = root->root_key.objectid;\n\n\tinode_item = &log_root->root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_node(&log_root->root_item, log_root->node);\n\n\tWARN_ON(root->log_root);\n\troot->log_root = log_root;\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_add_log_tree(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_root *log_root;\n\tstruct btrfs_inode_item *inode_item;\n\n\tlog_root = alloc_log_tree(trans, root->fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\n\tlog_root->last_trans = trans->transid;\n\tlog_root->root_key.offset = root->root_key.objectid;\n\n\tinode_item = &log_root->root_item.inode;\n\tbtrfs_set_stack_inode_generation(inode_item, 1);\n\tbtrfs_set_stack_inode_size(inode_item, 3);\n\tbtrfs_set_stack_inode_nlink(inode_item, 1);\n\tbtrfs_set_stack_inode_nbytes(inode_item, root->nodesize);\n\tbtrfs_set_stack_inode_mode(inode_item, S_IFDIR | 0755);\n\n\tbtrfs_set_root_node(&log_root->root_item, log_root->node);\n\n\tWARN_ON(root->log_root);\n\troot->log_root = log_root;\n\troot->log_transid = 0;\n\troot->log_transid_committed = -1;\n\troot->last_log_commit = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_log_root_tree",
          "args": [
            "trans",
            "root->fs_info"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_log_root_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1442-1453",
          "snippet": "int btrfs_init_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *log_root;\n\n\tlog_root = alloc_log_tree(trans, fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\tWARN_ON(fs_info->log_root_tree);\n\tfs_info->log_root_tree = log_root;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_init_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *log_root;\n\n\tlog_root = alloc_log_tree(trans, fs_info);\n\tif (IS_ERR(log_root))\n\t\treturn PTR_ERR(log_root);\n\tWARN_ON(fs_info->log_root_tree);\n\tfs_info->log_root_tree = log_root;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->tree_log_mutex"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ctx->list",
            "&root->log_ctxs[index]"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_writers"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&root->log_batch"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_ROOT_MULTI_LOG_TASKS",
            "&root->state"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_need_log_full_commit",
          "args": [
            "root->fs_info",
            "trans"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_need_log_full_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.h",
          "lines": "49-54",
          "snippet": "static inline int btrfs_need_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\treturn ACCESS_ONCE(fs_info->last_trans_log_full_commit) ==\n\t\ttrans->transid;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"ctree.h\"\n\nstatic inline int btrfs_need_log_full_commit(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t     struct btrfs_trans_handle *trans)\n{\n\treturn ACCESS_ONCE(fs_info->last_trans_log_full_commit) ==\n\t\ttrans->transid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->log_mutex"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   const loff_t start,\n\t\t\t   const loff_t end,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic noinline struct;\n\nstatic int start_log_trans(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tint index;\n\tint ret;\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->log_root) {\n\t\tif (btrfs_need_log_full_commit(root->fs_info, trans)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!root->log_start_pid) {\n\t\t\troot->log_start_pid = current->pid;\n\t\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t} else if (root->log_start_pid != current->pid) {\n\t\t\tset_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t}\n\n\t\tatomic_inc(&root->log_batch);\n\t\tatomic_inc(&root->log_writers);\n\t\tif (ctx) {\n\t\t\tindex = root->log_transid % 2;\n\t\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\t\tctx->log_transid = root->log_transid;\n\t\t}\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn 0;\n\t}\n\n\tret = 0;\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\tif (!root->fs_info->log_root_tree)\n\t\tret = btrfs_init_log_root_tree(trans, root->fs_info);\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!root->log_root) {\n\t\tret = btrfs_add_log_tree(trans, root);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\troot->log_start_pid = current->pid;\n\tatomic_inc(&root->log_batch);\n\tatomic_inc(&root->log_writers);\n\tif (ctx) {\n\t\tindex = root->log_transid % 2;\n\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\tctx->log_transid = root->log_transid;\n\t}\nout:\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}"
  }
]