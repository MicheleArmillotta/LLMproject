[
  {
    "function_name": "afs_vl_get_entry_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlclient.c",
    "lines": "190-219",
    "snippet": "int afs_vl_get_entry_by_id(struct in_addr *addr,\n\t\t\t   struct key *key,\n\t\t\t   afs_volid_t volid,\n\t\t\t   afs_voltype_t voltype,\n\t\t\t   struct afs_cache_vlocation *entry,\n\t\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryById, 12, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYID);\n\t*bp++ = htonl(volid);\n\t*bp   = htonl(voltype);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXVLGetEntryById = {\n\t.name\t\t= \"VL.GetEntryById\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "addr",
            "call",
            "GFP_KERNEL",
            "wait_mode"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "voltype"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "volid"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "VLGETENTRYBYID"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_VL_PORT"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXVLGetEntryById",
            "12",
            "384"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n\nstatic const struct afs_call_type afs_RXVLGetEntryById = {\n\t.name\t\t= \"VL.GetEntryById\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_vl_get_entry_by_id(struct in_addr *addr,\n\t\t\t   struct key *key,\n\t\t\t   afs_volid_t volid,\n\t\t\t   afs_voltype_t voltype,\n\t\t\t   struct afs_cache_vlocation *entry,\n\t\t\t   const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryById, 12, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYID);\n\t*bp++ = htonl(volid);\n\t*bp   = htonl(voltype);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}"
  },
  {
    "function_name": "afs_vl_get_entry_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlclient.c",
    "lines": "150-185",
    "snippet": "int afs_vl_get_entry_by_name(struct in_addr *addr,\n\t\t\t     struct key *key,\n\t\t\t     const char *volname,\n\t\t\t     struct afs_cache_vlocation *entry,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t volnamesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tvolnamesz = strlen(volname);\n\tpadsz = (4 - (volnamesz & 3)) & 3;\n\treqsz = 8 + volnamesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryByName, reqsz, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYNAME);\n\t*bp++ = htonl(volnamesz);\n\tmemcpy(bp, volname, volnamesz);\n\tif (padsz > 0)\n\t\tmemset((void *) bp + volnamesz, 0, padsz);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct afs_call_type afs_RXVLGetEntryByName = {\n\t.name\t\t= \"VL.GetEntryByName\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_make_call",
          "args": [
            "addr",
            "call",
            "GFP_KERNEL",
            "wait_mode"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "afs_make_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "338-420",
          "snippet": "int afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nint afs_make_call(struct in_addr *addr, struct afs_call *call, gfp_t gfp,\n\t\t  const struct afs_wait_mode *wait_mode)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_call *rxcall;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tint ret;\n\tstruct sk_buff *skb;\n\n\t_enter(\"%x,{%d},\", addr->s_addr, ntohs(call->port));\n\n\tASSERT(call->type != NULL);\n\tASSERT(call->type->name != NULL);\n\n\t_debug(\"____MAKE %p{%s,%x} [%d]____\",\n\t       call, call->type->name, key_serial(call->key),\n\t       atomic_read(&afs_outstanding_calls));\n\n\tcall->wait_mode = wait_mode;\n\tcall->async_workfn = afs_process_async_call;\n\tINIT_WORK(&call->async_work, afs_async_workfn);\n\n\tmemset(&srx, 0, sizeof(srx));\n\tsrx.srx_family = AF_RXRPC;\n\tsrx.srx_service = call->service_id;\n\tsrx.transport_type = SOCK_DGRAM;\n\tsrx.transport_len = sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family = AF_INET;\n\tsrx.transport.sin.sin_port = call->port;\n\tmemcpy(&srx.transport.sin.sin_addr, addr, 4);\n\n\t/* create a call */\n\trxcall = rxrpc_kernel_begin_call(afs_socket, &srx, call->key,\n\t\t\t\t\t (unsigned long) call, gfp);\n\tcall->key = NULL;\n\tif (IS_ERR(rxcall)) {\n\t\tret = PTR_ERR(rxcall);\n\t\tgoto error_kill_call;\n\t}\n\n\tcall->rxcall = rxcall;\n\n\t/* send the request */\n\tiov[0].iov_base\t= call->request;\n\tiov[0].iov_len\t= call->request_size;\n\n\tmsg.msg_name\t\t= NULL;\n\tmsg.msg_namelen\t\t= 0;\n\tiov_iter_kvec(&msg.msg_iter, WRITE | ITER_KVEC, iov, 1,\n\t\t      call->request_size);\n\tmsg.msg_control\t\t= NULL;\n\tmsg.msg_controllen\t= 0;\n\tmsg.msg_flags\t\t= (call->send_pages ? MSG_MORE : 0);\n\n\t/* have to change the state *before* sending the last packet as RxRPC\n\t * might give us the reply before it returns from sending the\n\t * request */\n\tif (!call->send_pages)\n\t\tcall->state = AFS_CALL_AWAIT_REPLY;\n\tret = rxrpc_kernel_send_data(rxcall, &msg, call->request_size);\n\tif (ret < 0)\n\t\tgoto error_do_abort;\n\n\tif (call->send_pages) {\n\t\tret = afs_send_pages(call, &msg, iov);\n\t\tif (ret < 0)\n\t\t\tgoto error_do_abort;\n\t}\n\n\t/* at this point, an async call may no longer exist as it may have\n\t * already completed */\n\treturn wait_mode->wait(call);\n\nerror_do_abort:\n\trxrpc_kernel_abort_call(rxcall, RX_USER_ABORT);\n\twhile ((skb = skb_dequeue(&call->rx_queue)))\n\t\tafs_free_skb(skb);\nerror_kill_call:\n\tafs_end_call(call);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *) bp + volnamesz",
            "0",
            "padsz"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bp",
            "volname",
            "volnamesz"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "volnamesz"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "VLGETENTRYBYNAME"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "AFS_VL_PORT"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_alloc_flat_call",
          "args": [
            "&afs_RXVLGetEntryByName",
            "reqsz",
            "384"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "afs_alloc_flat_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "218-255",
          "snippet": "struct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t afs_outstanding_calls;",
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic atomic_t afs_outstanding_calls;\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\n\nstruct afs_call *afs_alloc_flat_call(const struct afs_call_type *type,\n\t\t\t\t     size_t request_size, size_t reply_size)\n{\n\tstruct afs_call *call;\n\n\tcall = kzalloc(sizeof(*call), GFP_NOFS);\n\tif (!call)\n\t\tgoto nomem_call;\n\n\t_debug(\"CALL %p{%s} [%d]\",\n\t       call, type->name, atomic_read(&afs_outstanding_calls));\n\tatomic_inc(&afs_outstanding_calls);\n\n\tcall->type = type;\n\tcall->request_size = request_size;\n\tcall->reply_max = reply_size;\n\n\tif (request_size) {\n\t\tcall->request = kmalloc(request_size, GFP_NOFS);\n\t\tif (!call->request)\n\t\t\tgoto nomem_free;\n\t}\n\n\tif (reply_size) {\n\t\tcall->buffer = kmalloc(reply_size, GFP_NOFS);\n\t\tif (!call->buffer)\n\t\t\tgoto nomem_free;\n\t}\n\n\tinit_waitqueue_head(&call->waitq);\n\tskb_queue_head_init(&call->rx_queue);\n\treturn call;\n\nnomem_free:\n\tafs_free_call(call);\nnomem_call:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "volname"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n\nstatic const struct afs_call_type afs_RXVLGetEntryByName = {\n\t.name\t\t= \"VL.GetEntryByName\",\n\t.deliver\t= afs_deliver_vl_get_entry_by_xxx,\n\t.abort_to_error\t= afs_vl_abort_to_error,\n\t.destructor\t= afs_flat_call_destructor,\n};\n\nint afs_vl_get_entry_by_name(struct in_addr *addr,\n\t\t\t     struct key *key,\n\t\t\t     const char *volname,\n\t\t\t     struct afs_cache_vlocation *entry,\n\t\t\t     const struct afs_wait_mode *wait_mode)\n{\n\tstruct afs_call *call;\n\tsize_t volnamesz, reqsz, padsz;\n\t__be32 *bp;\n\n\t_enter(\"\");\n\n\tvolnamesz = strlen(volname);\n\tpadsz = (4 - (volnamesz & 3)) & 3;\n\treqsz = 8 + volnamesz + padsz;\n\n\tcall = afs_alloc_flat_call(&afs_RXVLGetEntryByName, reqsz, 384);\n\tif (!call)\n\t\treturn -ENOMEM;\n\n\tcall->key = key;\n\tcall->reply = entry;\n\tcall->service_id = VL_SERVICE;\n\tcall->port = htons(AFS_VL_PORT);\n\n\t/* marshall the parameters */\n\tbp = call->request;\n\t*bp++ = htonl(VLGETENTRYBYNAME);\n\t*bp++ = htonl(volnamesz);\n\tmemcpy(bp, volname, volnamesz);\n\tif (padsz > 0)\n\t\tmemset((void *) bp + volnamesz, 0, padsz);\n\n\t/* initiate the call */\n\treturn afs_make_call(addr, call, GFP_KERNEL, wait_mode);\n}"
  },
  {
    "function_name": "afs_deliver_vl_get_entry_by_xxx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlclient.c",
    "lines": "61-125",
    "snippet": "static int afs_deliver_vl_get_entry_by_xxx(struct afs_call *call,\n\t\t\t\t\t   struct sk_buff *skb, bool last)\n{\n\tstruct afs_cache_vlocation *entry;\n\t__be32 *bp;\n\tu32 tmp;\n\tint loop;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tentry = call->reply;\n\tbp = call->buffer;\n\n\tfor (loop = 0; loop < 64; loop++)\n\t\tentry->name[loop] = ntohl(*bp++);\n\tentry->name[loop] = 0;\n\tbp++; /* final NUL */\n\n\tbp++; /* type */\n\tentry->nservers = ntohl(*bp++);\n\n\tfor (loop = 0; loop < 8; loop++)\n\t\tentry->servers[loop].s_addr = *bp++;\n\n\tbp += 8; /* partition IDs */\n\n\tfor (loop = 0; loop < 8; loop++) {\n\t\ttmp = ntohl(*bp++);\n\t\tentry->srvtmask[loop] = 0;\n\t\tif (tmp & AFS_VLSF_RWVOL)\n\t\t\tentry->srvtmask[loop] |= AFS_VOL_VTM_RW;\n\t\tif (tmp & AFS_VLSF_ROVOL)\n\t\t\tentry->srvtmask[loop] |= AFS_VOL_VTM_RO;\n\t\tif (tmp & AFS_VLSF_BACKVOL)\n\t\t\tentry->srvtmask[loop] |= AFS_VOL_VTM_BAK;\n\t}\n\n\tentry->vid[0] = ntohl(*bp++);\n\tentry->vid[1] = ntohl(*bp++);\n\tentry->vid[2] = ntohl(*bp++);\n\n\tbp++; /* clone ID */\n\n\ttmp = ntohl(*bp++); /* flags */\n\tentry->vidmask = 0;\n\tif (tmp & AFS_VLF_RWEXISTS)\n\t\tentry->vidmask |= AFS_VOL_VTM_RW;\n\tif (tmp & AFS_VLF_ROEXISTS)\n\t\tentry->vidmask |= AFS_VOL_VTM_RO;\n\tif (tmp & AFS_VLF_BACKEXISTS)\n\t\tentry->vidmask |= AFS_VOL_VTM_BAK;\n\tif (!entry->vidmask)\n\t\treturn -EBADMSG;\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [done]\""
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*bp++"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_transfer_reply",
          "args": [
            "call",
            "skb"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "afs_transfer_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "668-675",
          "snippet": "void afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_wake_up_call_waiter(struct afs_call *);",
            "static int afs_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_wake_up_async_call(struct afs_call *);",
            "static int afs_dont_wait_for_call_to_complete(struct afs_call *);",
            "static void afs_process_async_call(struct afs_call *);",
            "static void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);",
            "static int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic void afs_wake_up_call_waiter(struct afs_call *);\nstatic int afs_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_wake_up_async_call(struct afs_call *);\nstatic int afs_dont_wait_for_call_to_complete(struct afs_call *);\nstatic void afs_process_async_call(struct afs_call *);\nstatic void afs_rx_interceptor(struct sock *, unsigned long, struct sk_buff *);\nstatic int afs_deliver_cm_op_id(struct afs_call *, struct sk_buff *, bool);\n\nvoid afs_transfer_reply(struct afs_call *call, struct sk_buff *skb)\n{\n\tsize_t len = skb->len;\n\n\tif (skb_copy_bits(skb, 0, call->buffer + call->reply_size, len) < 0)\n\t\tBUG();\n\tcall->reply_size += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\",,%u\"",
            "last"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n\nstatic int afs_deliver_vl_get_entry_by_xxx(struct afs_call *call,\n\t\t\t\t\t   struct sk_buff *skb, bool last)\n{\n\tstruct afs_cache_vlocation *entry;\n\t__be32 *bp;\n\tu32 tmp;\n\tint loop;\n\n\t_enter(\",,%u\", last);\n\n\tafs_transfer_reply(call, skb);\n\tif (!last)\n\t\treturn 0;\n\n\tif (call->reply_size != call->reply_max)\n\t\treturn -EBADMSG;\n\n\t/* unmarshall the reply once we've received all of it */\n\tentry = call->reply;\n\tbp = call->buffer;\n\n\tfor (loop = 0; loop < 64; loop++)\n\t\tentry->name[loop] = ntohl(*bp++);\n\tentry->name[loop] = 0;\n\tbp++; /* final NUL */\n\n\tbp++; /* type */\n\tentry->nservers = ntohl(*bp++);\n\n\tfor (loop = 0; loop < 8; loop++)\n\t\tentry->servers[loop].s_addr = *bp++;\n\n\tbp += 8; /* partition IDs */\n\n\tfor (loop = 0; loop < 8; loop++) {\n\t\ttmp = ntohl(*bp++);\n\t\tentry->srvtmask[loop] = 0;\n\t\tif (tmp & AFS_VLSF_RWVOL)\n\t\t\tentry->srvtmask[loop] |= AFS_VOL_VTM_RW;\n\t\tif (tmp & AFS_VLSF_ROVOL)\n\t\t\tentry->srvtmask[loop] |= AFS_VOL_VTM_RO;\n\t\tif (tmp & AFS_VLSF_BACKVOL)\n\t\t\tentry->srvtmask[loop] |= AFS_VOL_VTM_BAK;\n\t}\n\n\tentry->vid[0] = ntohl(*bp++);\n\tentry->vid[1] = ntohl(*bp++);\n\tentry->vid[2] = ntohl(*bp++);\n\n\tbp++; /* clone ID */\n\n\ttmp = ntohl(*bp++); /* flags */\n\tentry->vidmask = 0;\n\tif (tmp & AFS_VLF_RWEXISTS)\n\t\tentry->vidmask |= AFS_VOL_VTM_RW;\n\tif (tmp & AFS_VLF_ROEXISTS)\n\t\tentry->vidmask |= AFS_VOL_VTM_RO;\n\tif (tmp & AFS_VLF_BACKEXISTS)\n\t\tentry->vidmask |= AFS_VOL_VTM_BAK;\n\tif (!entry->vidmask)\n\t\treturn -EBADMSG;\n\n\t_leave(\" = 0 [done]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_vl_abort_to_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlclient.c",
    "lines": "20-56",
    "snippet": "static int afs_vl_abort_to_error(u32 abort_code)\n{\n\t_enter(\"%u\", abort_code);\n\n\tswitch (abort_code) {\n\tcase AFSVL_IDEXIST:\t\treturn -EEXIST;\n\tcase AFSVL_IO:\t\t\treturn -EREMOTEIO;\n\tcase AFSVL_NAMEEXIST:\t\treturn -EEXIST;\n\tcase AFSVL_CREATEFAIL:\t\treturn -EREMOTEIO;\n\tcase AFSVL_NOENT:\t\treturn -ENOMEDIUM;\n\tcase AFSVL_EMPTY:\t\treturn -ENOMEDIUM;\n\tcase AFSVL_ENTDELETED:\t\treturn -ENOMEDIUM;\n\tcase AFSVL_BADNAME:\t\treturn -EINVAL;\n\tcase AFSVL_BADINDEX:\t\treturn -EINVAL;\n\tcase AFSVL_BADVOLTYPE:\t\treturn -EINVAL;\n\tcase AFSVL_BADSERVER:\t\treturn -EINVAL;\n\tcase AFSVL_BADPARTITION:\treturn -EINVAL;\n\tcase AFSVL_REPSFULL:\t\treturn -EFBIG;\n\tcase AFSVL_NOREPSERVER:\t\treturn -ENOENT;\n\tcase AFSVL_DUPREPSERVER:\treturn -EEXIST;\n\tcase AFSVL_RWNOTFOUND:\t\treturn -ENOENT;\n\tcase AFSVL_BADREFCOUNT:\t\treturn -EINVAL;\n\tcase AFSVL_SIZEEXCEEDED:\treturn -EINVAL;\n\tcase AFSVL_BADENTRY:\t\treturn -EINVAL;\n\tcase AFSVL_BADVOLIDBUMP:\treturn -EINVAL;\n\tcase AFSVL_IDALREADYHASHED:\treturn -EINVAL;\n\tcase AFSVL_ENTRYLOCKED:\t\treturn -EBUSY;\n\tcase AFSVL_BADVOLOPER:\t\treturn -EBADRQC;\n\tcase AFSVL_BADRELLOCKTYPE:\treturn -EINVAL;\n\tcase AFSVL_RERELEASE:\t\treturn -EREMOTEIO;\n\tcase AFSVL_BADSERVERFLAG:\treturn -EINVAL;\n\tcase AFSVL_PERM:\t\treturn -EACCES;\n\tcase AFSVL_NOMEM:\t\treturn -EREMOTEIO;\n\tdefault:\n\t\treturn afs_abort_to_error(abort_code);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_abort_to_error",
          "args": [
            "abort_code"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "afs_abort_to_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/misc.c",
          "lines": "22-75",
          "snippet": "int afs_abort_to_error(u32 abort_code)\n{\n\tswitch (abort_code) {\n\tcase 13:\t\treturn -EACCES;\n\tcase 27:\t\treturn -EFBIG;\n\tcase 30:\t\treturn -EROFS;\n\tcase VSALVAGE:\t\treturn -EIO;\n\tcase VNOVNODE:\t\treturn -ENOENT;\n\tcase VNOVOL:\t\treturn -ENOMEDIUM;\n\tcase VVOLEXISTS:\treturn -EEXIST;\n\tcase VNOSERVICE:\treturn -EIO;\n\tcase VOFFLINE:\t\treturn -ENOENT;\n\tcase VONLINE:\t\treturn -EEXIST;\n\tcase VDISKFULL:\t\treturn -ENOSPC;\n\tcase VOVERQUOTA:\treturn -EDQUOT;\n\tcase VBUSY:\t\treturn -EBUSY;\n\tcase VMOVED:\t\treturn -ENXIO;\n\tcase 0x2f6df0a:\t\treturn -EWOULDBLOCK;\n\tcase 0x2f6df0c:\t\treturn -EACCES;\n\tcase 0x2f6df0f:\t\treturn -EBUSY;\n\tcase 0x2f6df10:\t\treturn -EEXIST;\n\tcase 0x2f6df11:\t\treturn -EXDEV;\n\tcase 0x2f6df13:\t\treturn -ENOTDIR;\n\tcase 0x2f6df14:\t\treturn -EISDIR;\n\tcase 0x2f6df15:\t\treturn -EINVAL;\n\tcase 0x2f6df1a:\t\treturn -EFBIG;\n\tcase 0x2f6df1b:\t\treturn -ENOSPC;\n\tcase 0x2f6df1d:\t\treturn -EROFS;\n\tcase 0x2f6df1e:\t\treturn -EMLINK;\n\tcase 0x2f6df20:\t\treturn -EDOM;\n\tcase 0x2f6df21:\t\treturn -ERANGE;\n\tcase 0x2f6df22:\t\treturn -EDEADLK;\n\tcase 0x2f6df23:\t\treturn -ENAMETOOLONG;\n\tcase 0x2f6df24:\t\treturn -ENOLCK;\n\tcase 0x2f6df26:\t\treturn -ENOTEMPTY;\n\tcase 0x2f6df78:\t\treturn -EDQUOT;\n\n\tcase RXKADINCONSISTENCY: return -EPROTO;\n\tcase RXKADPACKETSHORT:\treturn -EPROTO;\n\tcase RXKADLEVELFAIL:\treturn -EKEYREJECTED;\n\tcase RXKADTICKETLEN:\treturn -EKEYREJECTED;\n\tcase RXKADOUTOFSEQUENCE: return -EPROTO;\n\tcase RXKADNOAUTH:\treturn -EKEYREJECTED;\n\tcase RXKADBADKEY:\treturn -EKEYREJECTED;\n\tcase RXKADBADTICKET:\treturn -EKEYREJECTED;\n\tcase RXKADUNKNOWNKEY:\treturn -EKEYREJECTED;\n\tcase RXKADEXPIRED:\treturn -EKEYEXPIRED;\n\tcase RXKADSEALEDINCON:\treturn -EKEYREJECTED;\n\tcase RXKADDATALEN:\treturn -EKEYREJECTED;\n\tcase RXKADILLEGALLEVEL:\treturn -EKEYREJECTED;\n\n\tdefault:\t\treturn -EREMOTEIO;\n\t}\n}",
          "includes": [
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_abort_to_error(u32 abort_code)\n{\n\tswitch (abort_code) {\n\tcase 13:\t\treturn -EACCES;\n\tcase 27:\t\treturn -EFBIG;\n\tcase 30:\t\treturn -EROFS;\n\tcase VSALVAGE:\t\treturn -EIO;\n\tcase VNOVNODE:\t\treturn -ENOENT;\n\tcase VNOVOL:\t\treturn -ENOMEDIUM;\n\tcase VVOLEXISTS:\treturn -EEXIST;\n\tcase VNOSERVICE:\treturn -EIO;\n\tcase VOFFLINE:\t\treturn -ENOENT;\n\tcase VONLINE:\t\treturn -EEXIST;\n\tcase VDISKFULL:\t\treturn -ENOSPC;\n\tcase VOVERQUOTA:\treturn -EDQUOT;\n\tcase VBUSY:\t\treturn -EBUSY;\n\tcase VMOVED:\t\treturn -ENXIO;\n\tcase 0x2f6df0a:\t\treturn -EWOULDBLOCK;\n\tcase 0x2f6df0c:\t\treturn -EACCES;\n\tcase 0x2f6df0f:\t\treturn -EBUSY;\n\tcase 0x2f6df10:\t\treturn -EEXIST;\n\tcase 0x2f6df11:\t\treturn -EXDEV;\n\tcase 0x2f6df13:\t\treturn -ENOTDIR;\n\tcase 0x2f6df14:\t\treturn -EISDIR;\n\tcase 0x2f6df15:\t\treturn -EINVAL;\n\tcase 0x2f6df1a:\t\treturn -EFBIG;\n\tcase 0x2f6df1b:\t\treturn -ENOSPC;\n\tcase 0x2f6df1d:\t\treturn -EROFS;\n\tcase 0x2f6df1e:\t\treturn -EMLINK;\n\tcase 0x2f6df20:\t\treturn -EDOM;\n\tcase 0x2f6df21:\t\treturn -ERANGE;\n\tcase 0x2f6df22:\t\treturn -EDEADLK;\n\tcase 0x2f6df23:\t\treturn -ENAMETOOLONG;\n\tcase 0x2f6df24:\t\treturn -ENOLCK;\n\tcase 0x2f6df26:\t\treturn -ENOTEMPTY;\n\tcase 0x2f6df78:\t\treturn -EDQUOT;\n\n\tcase RXKADINCONSISTENCY: return -EPROTO;\n\tcase RXKADPACKETSHORT:\treturn -EPROTO;\n\tcase RXKADLEVELFAIL:\treturn -EKEYREJECTED;\n\tcase RXKADTICKETLEN:\treturn -EKEYREJECTED;\n\tcase RXKADOUTOFSEQUENCE: return -EPROTO;\n\tcase RXKADNOAUTH:\treturn -EKEYREJECTED;\n\tcase RXKADBADKEY:\treturn -EKEYREJECTED;\n\tcase RXKADBADTICKET:\treturn -EKEYREJECTED;\n\tcase RXKADUNKNOWNKEY:\treturn -EKEYREJECTED;\n\tcase RXKADEXPIRED:\treturn -EKEYEXPIRED;\n\tcase RXKADSEALEDINCON:\treturn -EKEYREJECTED;\n\tcase RXKADDATALEN:\treturn -EKEYREJECTED;\n\tcase RXKADILLEGALLEVEL:\treturn -EKEYREJECTED;\n\n\tdefault:\t\treturn -EREMOTEIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%u\"",
            "abort_code"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n\nstatic int afs_vl_abort_to_error(u32 abort_code)\n{\n\t_enter(\"%u\", abort_code);\n\n\tswitch (abort_code) {\n\tcase AFSVL_IDEXIST:\t\treturn -EEXIST;\n\tcase AFSVL_IO:\t\t\treturn -EREMOTEIO;\n\tcase AFSVL_NAMEEXIST:\t\treturn -EEXIST;\n\tcase AFSVL_CREATEFAIL:\t\treturn -EREMOTEIO;\n\tcase AFSVL_NOENT:\t\treturn -ENOMEDIUM;\n\tcase AFSVL_EMPTY:\t\treturn -ENOMEDIUM;\n\tcase AFSVL_ENTDELETED:\t\treturn -ENOMEDIUM;\n\tcase AFSVL_BADNAME:\t\treturn -EINVAL;\n\tcase AFSVL_BADINDEX:\t\treturn -EINVAL;\n\tcase AFSVL_BADVOLTYPE:\t\treturn -EINVAL;\n\tcase AFSVL_BADSERVER:\t\treturn -EINVAL;\n\tcase AFSVL_BADPARTITION:\treturn -EINVAL;\n\tcase AFSVL_REPSFULL:\t\treturn -EFBIG;\n\tcase AFSVL_NOREPSERVER:\t\treturn -ENOENT;\n\tcase AFSVL_DUPREPSERVER:\treturn -EEXIST;\n\tcase AFSVL_RWNOTFOUND:\t\treturn -ENOENT;\n\tcase AFSVL_BADREFCOUNT:\t\treturn -EINVAL;\n\tcase AFSVL_SIZEEXCEEDED:\treturn -EINVAL;\n\tcase AFSVL_BADENTRY:\t\treturn -EINVAL;\n\tcase AFSVL_BADVOLIDBUMP:\treturn -EINVAL;\n\tcase AFSVL_IDALREADYHASHED:\treturn -EINVAL;\n\tcase AFSVL_ENTRYLOCKED:\t\treturn -EBUSY;\n\tcase AFSVL_BADVOLOPER:\t\treturn -EBADRQC;\n\tcase AFSVL_BADRELLOCKTYPE:\treturn -EINVAL;\n\tcase AFSVL_RERELEASE:\t\treturn -EREMOTEIO;\n\tcase AFSVL_BADSERVERFLAG:\treturn -EINVAL;\n\tcase AFSVL_PERM:\t\treturn -EACCES;\n\tcase AFSVL_NOMEM:\t\treturn -EREMOTEIO;\n\tdefault:\n\t\treturn afs_abort_to_error(abort_code);\n\t}\n}"
  }
]