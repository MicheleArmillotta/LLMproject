[
  {
    "function_name": "udf_time_to_disk_stamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
    "lines": "119-168",
    "snippet": "struct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
      "#define SECS_PER_HOUR\t(60 * 60)"
    ],
    "globals_used": [
      "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__isleap",
          "args": [
            "y"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "y"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEAPS_THRU_END_OF",
          "args": [
            "y - 1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEAPS_THRU_END_OF",
          "args": [
            "yg - 1"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__isleap",
          "args": [
            "y"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x1000 | (offset & 0x0FFF)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\nstruct timestamp *\nudf_time_to_disk_stamp(struct timestamp *dest, struct timespec ts)\n{\n\tlong int days, rem, y;\n\tconst unsigned short int *ip;\n\tint16_t offset;\n\n\toffset = -sys_tz.tz_minuteswest;\n\n\tif (!dest)\n\t\treturn NULL;\n\n\tdest->typeAndTimezone = cpu_to_le16(0x1000 | (offset & 0x0FFF));\n\n\tts.tv_sec += offset * 60;\n\tdays = ts.tv_sec / SECS_PER_DAY;\n\trem = ts.tv_sec % SECS_PER_DAY;\n\tdest->hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tdest->minute = rem / 60;\n\tdest->second = rem % 60;\n\ty = 1970;\n\n#define DIV(a, b) ((a) / (b) - ((a) % (b) < 0))\n#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\tlong int yg = y + days / 365 - (days % 365 < 0);\n\n\t\t/* Adjust DAYS and Y to match the guessed year.  */\n\t\tdays -= ((yg - y) * 365\n\t\t\t + LEAPS_THRU_END_OF(yg - 1)\n\t\t\t - LEAPS_THRU_END_OF(y - 1));\n\t\ty = yg;\n\t}\n\tdest->year = cpu_to_le16(y);\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < (long int)ip[y]; --y)\n\t\tcontinue;\n\tdays -= ip[y];\n\tdest->month = y + 1;\n\tdest->day = days + 1;\n\n\tdest->centiseconds = ts.tv_nsec / 10000000;\n\tdest->hundredsOfMicroseconds = (ts.tv_nsec / 1000 -\n\t\t\t\t\tdest->centiseconds * 10000) / 100;\n\tdest->microseconds = (ts.tv_nsec / 1000 - dest->centiseconds * 10000 -\n\t\t\t      dest->hundredsOfMicroseconds * 100);\n\treturn dest;\n}"
  },
  {
    "function_name": "udf_disk_stamp_to_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udftime.c",
    "lines": "87-117",
    "snippet": "struct timespec *\nudf_disk_stamp_to_time(struct timespec *dest, struct timestamp src)\n{\n\tint yday;\n\tu16 typeAndTimezone = le16_to_cpu(src.typeAndTimezone);\n\tu16 year = le16_to_cpu(src.year);\n\tuint8_t type = typeAndTimezone >> 12;\n\tint16_t offset;\n\n\tif (type == 1) {\n\t\toffset = typeAndTimezone << 4;\n\t\t/* sign extent offset */\n\t\toffset = (offset >> 4);\n\t\tif (offset == -2047) /* unspecified offset */\n\t\t\toffset = 0;\n\t} else\n\t\toffset = 0;\n\n\tif ((year < EPOCH_YEAR) ||\n\t    (year >= EPOCH_YEAR + MAX_YEAR_SECONDS)) {\n\t\treturn NULL;\n\t}\n\tdest->tv_sec = year_seconds[year - EPOCH_YEAR];\n\tdest->tv_sec -= offset * 60;\n\n\tyday = ((__mon_yday[__isleap(year)][src.month - 1]) + src.day - 1);\n\tdest->tv_sec += (((yday * 24) + src.hour) * 60 + src.minute) * 60 + src.second;\n\tdest->tv_nsec = 1000 * (src.centiseconds * 10000 +\n\t\t\tsrc.hundredsOfMicroseconds * 100 + src.microseconds);\n\treturn dest;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/types.h>",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [
      "#define MAX_YEAR_SECONDS\t69",
      "#define EPOCH_YEAR 1970"
    ],
    "globals_used": [
      "static const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};",
      "static time_t year_seconds[MAX_YEAR_SECONDS] = {\n/*1970*/ SPY(0,   0, 0), SPY(1,   0, 0), SPY(2,   0, 0), SPY(3,   1, 0),\n/*1974*/ SPY(4,   1, 0), SPY(5,   1, 0), SPY(6,   1, 0), SPY(7,   2, 0),\n/*1978*/ SPY(8,   2, 0), SPY(9,   2, 0), SPY(10,  2, 0), SPY(11,  3, 0),\n/*1982*/ SPY(12,  3, 0), SPY(13,  3, 0), SPY(14,  3, 0), SPY(15,  4, 0),\n/*1986*/ SPY(16,  4, 0), SPY(17,  4, 0), SPY(18,  4, 0), SPY(19,  5, 0),\n/*1990*/ SPY(20,  5, 0), SPY(21,  5, 0), SPY(22,  5, 0), SPY(23,  6, 0),\n/*1994*/ SPY(24,  6, 0), SPY(25,  6, 0), SPY(26,  6, 0), SPY(27,  7, 0),\n/*1998*/ SPY(28,  7, 0), SPY(29,  7, 0), SPY(30,  7, 0), SPY(31,  8, 0),\n/*2002*/ SPY(32,  8, 0), SPY(33,  8, 0), SPY(34,  8, 0), SPY(35,  9, 0),\n/*2006*/ SPY(36,  9, 0), SPY(37,  9, 0), SPY(38,  9, 0), SPY(39, 10, 0),\n/*2010*/ SPY(40, 10, 0), SPY(41, 10, 0), SPY(42, 10, 0), SPY(43, 11, 0),\n/*2014*/ SPY(44, 11, 0), SPY(45, 11, 0), SPY(46, 11, 0), SPY(47, 12, 0),\n/*2018*/ SPY(48, 12, 0), SPY(49, 12, 0), SPY(50, 12, 0), SPY(51, 13, 0),\n/*2022*/ SPY(52, 13, 0), SPY(53, 13, 0), SPY(54, 13, 0), SPY(55, 14, 0),\n/*2026*/ SPY(56, 14, 0), SPY(57, 14, 0), SPY(58, 14, 0), SPY(59, 15, 0),\n/*2030*/ SPY(60, 15, 0), SPY(61, 15, 0), SPY(62, 15, 0), SPY(63, 16, 0),\n/*2034*/ SPY(64, 16, 0), SPY(65, 16, 0), SPY(66, 16, 0), SPY(67, 17, 0),\n/*2038*/ SPY(68, 17, 0)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__isleap",
          "args": [
            "year"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "src.year"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/types.h>\n#include \"udfdecl.h\"\n\n#define MAX_YEAR_SECONDS\t69\n#define EPOCH_YEAR 1970\n\nstatic const unsigned short int __mon_yday[2][13] = {\n\t/* Normal years.  */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years.  */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\nstatic time_t year_seconds[MAX_YEAR_SECONDS] = {\n/*1970*/ SPY(0,   0, 0), SPY(1,   0, 0), SPY(2,   0, 0), SPY(3,   1, 0),\n/*1974*/ SPY(4,   1, 0), SPY(5,   1, 0), SPY(6,   1, 0), SPY(7,   2, 0),\n/*1978*/ SPY(8,   2, 0), SPY(9,   2, 0), SPY(10,  2, 0), SPY(11,  3, 0),\n/*1982*/ SPY(12,  3, 0), SPY(13,  3, 0), SPY(14,  3, 0), SPY(15,  4, 0),\n/*1986*/ SPY(16,  4, 0), SPY(17,  4, 0), SPY(18,  4, 0), SPY(19,  5, 0),\n/*1990*/ SPY(20,  5, 0), SPY(21,  5, 0), SPY(22,  5, 0), SPY(23,  6, 0),\n/*1994*/ SPY(24,  6, 0), SPY(25,  6, 0), SPY(26,  6, 0), SPY(27,  7, 0),\n/*1998*/ SPY(28,  7, 0), SPY(29,  7, 0), SPY(30,  7, 0), SPY(31,  8, 0),\n/*2002*/ SPY(32,  8, 0), SPY(33,  8, 0), SPY(34,  8, 0), SPY(35,  9, 0),\n/*2006*/ SPY(36,  9, 0), SPY(37,  9, 0), SPY(38,  9, 0), SPY(39, 10, 0),\n/*2010*/ SPY(40, 10, 0), SPY(41, 10, 0), SPY(42, 10, 0), SPY(43, 11, 0),\n/*2014*/ SPY(44, 11, 0), SPY(45, 11, 0), SPY(46, 11, 0), SPY(47, 12, 0),\n/*2018*/ SPY(48, 12, 0), SPY(49, 12, 0), SPY(50, 12, 0), SPY(51, 13, 0),\n/*2022*/ SPY(52, 13, 0), SPY(53, 13, 0), SPY(54, 13, 0), SPY(55, 14, 0),\n/*2026*/ SPY(56, 14, 0), SPY(57, 14, 0), SPY(58, 14, 0), SPY(59, 15, 0),\n/*2030*/ SPY(60, 15, 0), SPY(61, 15, 0), SPY(62, 15, 0), SPY(63, 16, 0),\n/*2034*/ SPY(64, 16, 0), SPY(65, 16, 0), SPY(66, 16, 0), SPY(67, 17, 0),\n/*2038*/ SPY(68, 17, 0)\n};\n\nstruct timespec *\nudf_disk_stamp_to_time(struct timespec *dest, struct timestamp src)\n{\n\tint yday;\n\tu16 typeAndTimezone = le16_to_cpu(src.typeAndTimezone);\n\tu16 year = le16_to_cpu(src.year);\n\tuint8_t type = typeAndTimezone >> 12;\n\tint16_t offset;\n\n\tif (type == 1) {\n\t\toffset = typeAndTimezone << 4;\n\t\t/* sign extent offset */\n\t\toffset = (offset >> 4);\n\t\tif (offset == -2047) /* unspecified offset */\n\t\t\toffset = 0;\n\t} else\n\t\toffset = 0;\n\n\tif ((year < EPOCH_YEAR) ||\n\t    (year >= EPOCH_YEAR + MAX_YEAR_SECONDS)) {\n\t\treturn NULL;\n\t}\n\tdest->tv_sec = year_seconds[year - EPOCH_YEAR];\n\tdest->tv_sec -= offset * 60;\n\n\tyday = ((__mon_yday[__isleap(year)][src.month - 1]) + src.day - 1);\n\tdest->tv_sec += (((yday * 24) + src.hour) * 60 + src.minute) * 60 + src.second;\n\tdest->tv_nsec = 1000 * (src.centiseconds * 10000 +\n\t\t\tsrc.hundredsOfMicroseconds * 100 + src.microseconds);\n\treturn dest;\n}"
  }
]