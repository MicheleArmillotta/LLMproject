[
  {
    "function_name": "ialloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
    "lines": "72-165",
    "snippet": "struct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_drop",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1487-1508",
          "snippet": "void dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_drop(struct inode *inode)\n{\n\tint cnt;\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn;\n\n\t/*\n\t * Test before calling to rule out calls from proc and such\n\t * where we are not allowed to block. Note that this is\n\t * actually reliable test even without the lock - the caller\n\t * must assure that nobody can come after the DQUOT_DROP and\n\t * add quota pointers back anyway.\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (i_dquot(inode)[cnt])\n\t\t\tbreak;\n\t}\n\n\tif (cnt < MAXQUOTAS)\n\t\t__dquot_drop(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"ialloc returns inode = 0x%p\\n\"",
            "inode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "29-46",
          "snippet": "void jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&jfs_inode->ea",
            "0",
            "sizeof(dxd_t)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&jfs_inode->acl",
            "0",
            "sizeof(dxd_t)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "parent"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_inode",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1651-1685",
          "snippet": "int dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_alloc_inode(struct inode *inode)\n{\n\tint cnt, ret = 0, index;\n\tstruct dquot_warn warn[MAXQUOTAS];\n\tstruct dquot * const *dquots = i_dquot(inode);\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\twarn[cnt].w_type = QUOTA_NL_NOWARN;\n\n\tindex = srcu_read_lock(&dquot_srcu);\n\tspin_lock(&dq_data_lock);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tret = check_idq(dquots[cnt], 1, &warn[cnt]);\n\t\tif (ret)\n\t\t\tgoto warn_put_all;\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!dquots[cnt])\n\t\t\tcontinue;\n\t\tdquot_incr_inodes(dquots[cnt], 1);\n\t}\n\nwarn_put_all:\n\tspin_unlock(&dq_data_lock);\n\tif (ret == 0)\n\t\tmark_all_dquot_dirty(dquots);\n\tsrcu_read_unlock(&dquot_srcu, index);\n\tflush_warnings(warn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "parent",
            "mode"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_locked",
          "args": [
            "inode"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1323-1362",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"ialloc: diAlloc returned %d!\"",
            "rc"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diAlloc",
          "args": [
            "parent",
            "S_ISDIR(mode)",
            "inode"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "diAllocBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_imap.c",
          "lines": "2024-2124",
          "snippet": "static int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diAllocAG(struct inomap *, int, bool, struct inode *);",
            "static int diAllocAny(struct inomap *, int, bool, struct inode *);",
            "static int diAllocBit(struct inomap *, struct iag *, int);",
            "static int diAllocExt(struct inomap *, int, struct inode *);",
            "static int diAllocIno(struct inomap *, int, struct inode *);",
            "static int diFindFree(u32, int);",
            "static int diNewExt(struct inomap *, struct iag *, int);",
            "static int diNewIAG(struct inomap *, int *, int, struct metapage **);",
            "static int diIAGRead(struct inomap * imap, int, struct metapage **);",
            "static int copy_from_dinode(struct dinode *, struct inode *);",
            "static void copy_to_dinode(struct dinode *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int diAllocAG(struct inomap *, int, bool, struct inode *);\nstatic int diAllocAny(struct inomap *, int, bool, struct inode *);\nstatic int diAllocBit(struct inomap *, struct iag *, int);\nstatic int diAllocExt(struct inomap *, int, struct inode *);\nstatic int diAllocIno(struct inomap *, int, struct inode *);\nstatic int diFindFree(u32, int);\nstatic int diNewExt(struct inomap *, struct iag *, int);\nstatic int diNewIAG(struct inomap *, int *, int, struct metapage **);\nstatic int diIAGRead(struct inomap * imap, int, struct metapage **);\nstatic int copy_from_dinode(struct dinode *, struct inode *);\nstatic void copy_to_dinode(struct dinode *, struct inode *);\n\nstatic int diAllocBit(struct inomap * imap, struct iag * iagp, int ino)\n{\n\tint extno, bitno, agno, sword, rc;\n\tstruct metapage *amp = NULL, *bmp = NULL;\n\tstruct iag *aiagp = NULL, *biagp = NULL;\n\tu32 mask;\n\n\t/* check if this is the last free inode within the iag.\n\t * if so, it will have to be removed from the ag free\n\t * inode list, so get the iags preceding and following\n\t * it on the list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif ((int) le32_to_cpu(iagp->inofreefwd) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap, le32_to_cpu(iagp->inofreefwd),\n\t\t\t\t       &amp)))\n\t\t\t\treturn (rc);\n\t\t\taiagp = (struct iag *) amp->data;\n\t\t}\n\n\t\tif ((int) le32_to_cpu(iagp->inofreeback) >= 0) {\n\t\t\tif ((rc =\n\t\t\t     diIAGRead(imap,\n\t\t\t\t       le32_to_cpu(iagp->inofreeback),\n\t\t\t\t       &bmp))) {\n\t\t\t\tif (amp)\n\t\t\t\t\trelease_metapage(amp);\n\t\t\t\treturn (rc);\n\t\t\t}\n\t\t\tbiagp = (struct iag *) bmp->data;\n\t\t}\n\t}\n\n\t/* get the ag number, extent number, inode number within\n\t * the extent.\n\t */\n\tagno = BLKTOAG(le64_to_cpu(iagp->agstart), JFS_SBI(imap->im_ipimap->i_sb));\n\textno = ino >> L2INOSPEREXT;\n\tbitno = ino & (INOSPEREXT - 1);\n\n\t/* compute the mask for setting the map.\n\t */\n\tmask = HIGHORDER >> bitno;\n\n\t/* the inode should be free and backed.\n\t */\n\tif (((le32_to_cpu(iagp->pmap[extno]) & mask) != 0) ||\n\t    ((le32_to_cpu(iagp->wmap[extno]) & mask) != 0) ||\n\t    (addressPXD(&iagp->inoext[extno]) == 0)) {\n\t\tif (amp)\n\t\t\trelease_metapage(amp);\n\t\tif (bmp)\n\t\t\trelease_metapage(bmp);\n\n\t\tjfs_error(imap->im_ipimap->i_sb, \"iag inconsistent\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* mark the inode as allocated in the working map.\n\t */\n\tiagp->wmap[extno] |= cpu_to_le32(mask);\n\n\t/* check if all inodes within the extent are now\n\t * allocated.  if so, update the free inode summary\n\t * map to reflect this.\n\t */\n\tif (iagp->wmap[extno] == cpu_to_le32(ONES)) {\n\t\tsword = extno >> L2EXTSPERSUM;\n\t\tbitno = extno & (EXTSPERSUM - 1);\n\t\tiagp->inosmap[sword] |= cpu_to_le32(HIGHORDER >> bitno);\n\t}\n\n\t/* if this was the last free inode in the iag, remove the\n\t * iag from the ag free inode list.\n\t */\n\tif (iagp->nfreeinos == cpu_to_le32(1)) {\n\t\tif (amp) {\n\t\t\taiagp->inofreeback = iagp->inofreeback;\n\t\t\twrite_metapage(amp);\n\t\t}\n\n\t\tif (bmp) {\n\t\t\tbiagp->inofreefwd = iagp->inofreefwd;\n\t\t\twrite_metapage(bmp);\n\t\t} else {\n\t\t\timap->im_agctl[agno].inofree =\n\t\t\t    le32_to_cpu(iagp->inofreefwd);\n\t\t}\n\t\tiagp->inofreefwd = iagp->inofreeback = cpu_to_le32(-1);\n\t}\n\n\t/* update the free inode count at the iag, ag, inode\n\t * map levels.\n\t */\n\tle32_add_cpu(&iagp->nfreeinos, -1);\n\timap->im_agctl[agno].numfree -= 1;\n\tatomic_dec(&imap->im_numfree);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"ialloc: new_inode returned NULL!\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstruct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "jfs_get_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
    "lines": "48-64",
    "snippet": "void jfs_get_inode_flags(struct jfs_inode_info *jfs_ip)\n{\n\tunsigned int flags = jfs_ip->vfs_inode.i_flags;\n\n\tjfs_ip->mode2 &= ~(JFS_IMMUTABLE_FL | JFS_APPEND_FL | JFS_NOATIME_FL |\n\t\t\t   JFS_DIRSYNC_FL | JFS_SYNC_FL);\n\tif (flags & S_IMMUTABLE)\n\t\tjfs_ip->mode2 |= JFS_IMMUTABLE_FL;\n\tif (flags & S_APPEND)\n\t\tjfs_ip->mode2 |= JFS_APPEND_FL;\n\tif (flags & S_NOATIME)\n\t\tjfs_ip->mode2 |= JFS_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tjfs_ip->mode2 |= JFS_DIRSYNC_FL;\n\tif (flags & S_SYNC)\n\t\tjfs_ip->mode2 |= JFS_SYNC_FL;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid jfs_get_inode_flags(struct jfs_inode_info *jfs_ip)\n{\n\tunsigned int flags = jfs_ip->vfs_inode.i_flags;\n\n\tjfs_ip->mode2 &= ~(JFS_IMMUTABLE_FL | JFS_APPEND_FL | JFS_NOATIME_FL |\n\t\t\t   JFS_DIRSYNC_FL | JFS_SYNC_FL);\n\tif (flags & S_IMMUTABLE)\n\t\tjfs_ip->mode2 |= JFS_IMMUTABLE_FL;\n\tif (flags & S_APPEND)\n\t\tjfs_ip->mode2 |= JFS_APPEND_FL;\n\tif (flags & S_NOATIME)\n\t\tjfs_ip->mode2 |= JFS_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tjfs_ip->mode2 |= JFS_DIRSYNC_FL;\n\tif (flags & S_SYNC)\n\t\tjfs_ip->mode2 |= JFS_SYNC_FL;\n}"
  },
  {
    "function_name": "jfs_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
    "lines": "29-46",
    "snippet": "void jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_imap.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_set_flags",
          "args": [
            "inode",
            "new_fl",
            "S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1979-1990",
          "snippet": "void inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = ACCESS_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = ACCESS_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nvoid jfs_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = JFS_IP(inode)->mode2;\n\tunsigned int new_fl = 0;\n\n\tif (flags & JFS_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & JFS_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & JFS_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & JFS_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (flags & JFS_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tinode_set_flags(inode, new_fl, S_IMMUTABLE | S_APPEND | S_NOATIME |\n\t\t\tS_DIRSYNC | S_SYNC);\n}"
  }
]