[
  {
    "function_name": "do_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1858-1911",
    "snippet": "void do_balance(struct tree_balance *tb, struct item_head *ih,\n\t\tconst char *body, int flag)\n{\n\tint child_pos;\t\t/* position of a child node in its parent */\n\tint h;\t\t\t/* level of the tree being processed */\n\n\t/*\n\t * in our processing of one level we sometimes determine what\n\t * must be inserted into the next higher level.  This insertion\n\t * consists of a key or two keys and their corresponding\n\t * pointers\n\t */\n\tstruct item_head insert_key[2];\n\n\t/* inserted node-ptrs for the next level */\n\tstruct buffer_head *insert_ptr[2];\n\n\ttb->tb_mode = flag;\n\ttb->need_balance_dirty = 0;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\treiserfs_panic(tb->tb_sb, \"clm-6000\", \"fs generation has \"\n\t\t\t       \"changed\");\n\t}\n\t/* if we have no real work to do  */\n\tif (!tb->insert_size[0]) {\n\t\treiserfs_warning(tb->tb_sb, \"PAP-12350\",\n\t\t\t\t \"insert_size == 0, mode == %c\", flag);\n\t\tunfix_nodes(tb);\n\t\treturn;\n\t}\n\n\tatomic_inc(&fs_generation(tb->tb_sb));\n\tdo_balance_starts(tb);\n\n\t/*\n\t * balance_leaf returns 0 except if combining L R and S into\n\t * one node.  see balance_internal() for explanation of this\n\t * line of code.\n\t */\n\tchild_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +\n\t    balance_leaf(tb, ih, body, flag, insert_key, insert_ptr);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_after_balance_leaf(tb);\n#endif\n\n\t/* Balance internal level of the tree. */\n\tfor (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)\n\t\tchild_pos = balance_internal(tb, h, child_pos, insert_key,\n\t\t\t\t\t     insert_ptr);\n\n\tdo_balance_completed(tb);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_completed",
          "args": [
            "tb"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1817-1838",
          "snippet": "static inline void do_balance_completed(struct tree_balance *tb)\n{\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_leaf_level(tb);\n\tcheck_internal_levels(tb);\n\tREISERFS_SB(tb->tb_sb)->cur_tb = NULL;\n#endif\n\n\t/*\n\t * reiserfs_free_block is no longer schedule safe.  So, we need to\n\t * put the buffers we want freed on the thrown list during do_balance,\n\t * and then free them now\n\t */\n\n\tREISERFS_SB(tb->tb_sb)->s_do_balance++;\n\n\t/* release all nodes hold to perform the balancing */\n\tunfix_nodes(tb);\n\n\tfree_thrown(tb);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void do_balance_completed(struct tree_balance *tb)\n{\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_leaf_level(tb);\n\tcheck_internal_levels(tb);\n\tREISERFS_SB(tb->tb_sb)->cur_tb = NULL;\n#endif\n\n\t/*\n\t * reiserfs_free_block is no longer schedule safe.  So, we need to\n\t * put the buffers we want freed on the thrown list during do_balance,\n\t * and then free them now\n\t */\n\n\tREISERFS_SB(tb->tb_sb)->s_do_balance++;\n\n\t/* release all nodes hold to perform the balancing */\n\tunfix_nodes(tb);\n\n\tfree_thrown(tb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_internal",
          "args": [
            "tb",
            "h",
            "child_pos",
            "insert_key",
            "insert_ptr"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "balance_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "803-1160",
          "snippet": "int balance_internal(struct tree_balance *tb,\n\t\t     int h,\t/* level of the tree */\n\t\t     int child_pos,\n\t\t     /* key for insertion on higher level    */\n\t\t     struct item_head *insert_key,\n\t\t     /* node for insertion on higher level */\n\t\t     struct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\t/*\n\t * we return this: it is 0 if there is no S[h],\n\t * else it is tb->S[h]->b_item_order\n\t */\n\tint order;\n\tint insert_num, n, k;\n\tstruct buffer_head *S_new;\n\tstruct item_head new_insert_key;\n\tstruct buffer_head *new_insert_ptr = NULL;\n\tstruct item_head *new_insert_key_addr = insert_key;\n\n\tRFALSE(h < 1, \"h (%d) can not be < 1 on internal level\", h);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[h]);\n\n\torder =\n\t    (tbSh) ? PATH_H_POSITION(tb->tb_path,\n\t\t\t\t     h + 1) /*tb->S[h]->b_item_order */ : 0;\n\n\t/*\n\t * Using insert_size[h] calculate the number insert_num of items\n\t * that must be inserted to or deleted from S[h].\n\t */\n\tinsert_num = tb->insert_size[h] / ((int)(KEY_SIZE + DC_SIZE));\n\n\t/* Check whether insert_num is proper * */\n\tRFALSE(insert_num < -2 || insert_num > 2,\n\t       \"incorrect number of items inserted to the internal node (%d)\",\n\t       insert_num);\n\tRFALSE(h > 1 && (insert_num > 1 || insert_num < -1),\n\t       \"incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level\",\n\t       insert_num, h);\n\n\t/* Make balance in case insert_num < 0 */\n\tif (insert_num < 0) {\n\t\tbalance_internal_when_delete(tb, h, child_pos);\n\t\treturn order;\n\t}\n\n\tk = 0;\n\tif (tb->lnum[h] > 0) {\n\t\t/*\n\t\t * shift lnum[h] items from S[h] to the left neighbor L[h].\n\t\t * check how many of new items fall into L[h] or CFL[h] after\n\t\t * shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tb->L[h]);\t/* number of items in L[h] */\n\t\tif (tb->lnum[h] <= child_pos) {\n\t\t\t/* new items don't fall into L[h] or CFL[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h]);\n\t\t\tchild_pos -= tb->lnum[h];\n\t\t} else if (tb->lnum[h] > child_pos + insert_num) {\n\t\t\t/* all new items fall into L[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h] - insert_num);\n\t\t\t/* insert insert_num keys and node-pointers into L[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next */\n\t\t\t\t\t       n + child_pos + 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/*\n\t\t\t * some items fall into L[h] or CFL[h],\n\t\t\t * but some don't fall\n\t\t\t */\n\t\t\tinternal_shift1_left(tb, h, child_pos + 1);\n\t\t\t/* calculate number of new items that fall into L[h] */\n\t\t\tk = tb->lnum[h] - child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next, */\n\t\t\t\t\t       n + child_pos + 1, k,\n\t\t\t\t\t       insert_key, insert_ptr);\n\n\t\t\treplace_lkey(tb, h, insert_key + k);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in S[h] by\n\t\t\t * node-ptr to insert_ptr[k]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tbSh, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr[k]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr[k]));\n\t\t\tput_dc_block_number(dc, insert_ptr[k]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t\tk++;\n\t\t\tinsert_key += k;\n\t\t\tinsert_ptr += k;\n\t\t\tinsert_num -= k;\n\t\t\tchild_pos = 0;\n\t\t}\n\t}\n\t/* tb->lnum[h] > 0 */\n\tif (tb->rnum[h] > 0) {\n\t\t/*shift rnum[h] items from S[h] to the right neighbor R[h] */\n\t\t/*\n\t\t * check how many of new items fall into R or CFR\n\t\t * after shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tif (n - tb->rnum[h] >= child_pos)\n\t\t\t/* new items fall into S[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h]);\n\t\telse if (n + insert_num - tb->rnum[h] < child_pos) {\n\t\t\t/* all new items fall into R[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h] - insert_num);\n\n\t\t\t/* insert insert_num keys and node-pointers into R[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h],tb->S[h-1]->b_next */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       tb->rnum[h] - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* one of the items falls into CFR[h] */\n\t\t\tinternal_shift1_right(tb, h, n - child_pos + 1);\n\t\t\t/* calculate number of new items that fall into R[h] */\n\t\t\tk = tb->rnum[h] - n + child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h], tb->R[h]->b_child, */\n\t\t\t\t\t       0, k, insert_key + 1,\n\t\t\t\t\t       insert_ptr + 1);\n\n\t\t\treplace_rkey(tb, h, insert_key + insert_num - k - 1);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in R[h] by\n\t\t\t * node-ptr insert_ptr[insert_num-k-1]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tb->R[h], 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr\n\t\t\t\t\t\t   [insert_num - k - 1]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t [insert_num - k - 1]));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->R[h], 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t}\n\n\t/** Fill new node that appears instead of S[h] **/\n\tRFALSE(tb->blknum[h] > 2, \"blknum can not be > 2 for internal level\");\n\tRFALSE(tb->blknum[h] < 0, \"blknum can not be < 0\");\n\n\tif (!tb->blknum[h]) {\t/* node S[h] is empty now */\n\t\tRFALSE(!tbSh, \"S[h] is equal NULL\");\n\n\t\t/* do what is needed for buffer thrown from tree */\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn order;\n\t}\n\n\tif (!tbSh) {\n\t\t/* create new root */\n\t\tstruct disk_child *dc;\n\t\tstruct buffer_head *tbSh_1 = PATH_H_PBUFFER(tb->tb_path, h - 1);\n\t\tstruct block_head *blkh;\n\n\t\tif (tb->blknum[h] != 1)\n\t\t\treiserfs_panic(NULL, \"ibalance-3\", \"One new node \"\n\t\t\t\t       \"required for creating the new root\");\n\t\t/* S[h] = empty buffer from the list FEB. */\n\t\ttbSh = get_FEB(tb);\n\t\tblkh = B_BLK_HEAD(tbSh);\n\t\tset_blkh_level(blkh, h + 1);\n\n\t\t/* Put the unique node-pointer to S[h] that points to S[h-1]. */\n\n\t\tdc = B_N_CHILD(tbSh, 0);\n\t\tput_dc_block_number(dc, tbSh_1->b_blocknr);\n\t\tput_dc_size(dc,\n\t\t\t    (MAX_CHILD_SIZE(tbSh_1) - B_FREE_SPACE(tbSh_1)));\n\n\t\ttb->insert_size[h] -= DC_SIZE;\n\t\tset_blkh_free_space(blkh, blkh_free_space(blkh) - DC_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(tbSh);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t/* put new root into path structure */\n\t\tPATH_OFFSET_PBUFFER(tb->tb_path, ILLEGAL_PATH_ELEMENT_OFFSET) =\n\t\t    tbSh;\n\n\t\t/* Change root in structure super block. */\n\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, tbSh->b_blocknr);\n\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb, SB_TREE_HEIGHT(tb->tb_sb) + 1);\n\t\tdo_balance_mark_sb_dirty(tb, REISERFS_SB(tb->tb_sb)->s_sbh, 1);\n\t}\n\n\tif (tb->blknum[h] == 2) {\n\t\tint snum;\n\t\tstruct buffer_info dest_bi, src_bi;\n\n\t\t/* S_new = free buffer from list FEB */\n\t\tS_new = get_FEB(tb);\n\n\t\tset_blkh_level(B_BLK_HEAD(S_new), h + 1);\n\n\t\tdest_bi.tb = tb;\n\t\tdest_bi.bi_bh = S_new;\n\t\tdest_bi.bi_parent = NULL;\n\t\tdest_bi.bi_position = 0;\n\t\tsrc_bi.tb = tb;\n\t\tsrc_bi.bi_bh = tbSh;\n\t\tsrc_bi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tsnum = (insert_num + n + 1) / 2;\n\t\tif (n - snum >= child_pos) {\n\t\t\t/* new items don't fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/* new_insert_key = (n - snum)'th key in S[h] */\n\t\t\tmemcpy(&new_insert_key, internal_key(tbSh, n - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST, snum, 0);\n\t\t} else if (n + insert_num - snum < child_pos) {\n\t\t\t/* all new items fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/*\n\t\t\t * new_insert_key = (n + insert_item - snum)'th\n\t\t\t * key in S[h]\n\t\t\t */\n\t\t\tmemcpy(&new_insert_key,\n\t\t\t       internal_key(tbSh, n + insert_num - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     snum - insert_num, 0);\n\n\t\t\t/*\n\t\t\t * insert insert_num keys and node-pointers\n\t\t\t * into S_new\n\t\t\t */\n\t\t\tinternal_insert_childs(&dest_bi,\n\t\t\t\t\t       /*S_new,tb->S[h-1]->b_next, */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       snum - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* some items fall into S_new, but some don't fall */\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     n - child_pos + 1, 1);\n\t\t\t/* calculate number of new items that fall into S_new */\n\t\t\tk = snum - n + child_pos - 1;\n\n\t\t\tinternal_insert_childs(&dest_bi, /*S_new, */ 0, k,\n\t\t\t\t\t       insert_key + 1, insert_ptr + 1);\n\n\t\t\t/* new_insert_key = insert_key[insert_num - k - 1] */\n\t\t\tmemcpy(&new_insert_key, insert_key + insert_num - k - 1,\n\t\t\t       KEY_SIZE);\n\t\t\t/*\n\t\t\t * replace first node-ptr in S_new by node-ptr\n\t\t\t * to insert_ptr[insert_num-k-1]\n\t\t\t */\n\n\t\t\tdc = B_N_CHILD(S_new, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    (MAX_CHILD_SIZE\n\t\t\t\t     (insert_ptr[insert_num - k - 1]) -\n\t\t\t\t     B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t  [insert_num - k - 1])));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, S_new, 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t\t/* new_insert_ptr = node_pointer to S_new */\n\t\tnew_insert_ptr = S_new;\n\n\t\tRFALSE(!buffer_journaled(S_new) || buffer_journal_dirty(S_new)\n\t\t       || buffer_dirty(S_new), \"cm-00001: bad S_new (%b)\",\n\t\t       S_new);\n\n\t\t/* S_new is released in unfix_nodes */\n\t}\n\n\tn = B_NR_ITEMS(tbSh);\t/*number of items in S[h] */\n\n\tif (0 <= child_pos && child_pos <= n && insert_num > 0) {\n\t\tbi.tb = tb;\n\t\tbi.bi_bh = tbSh;\n\t\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tinternal_insert_childs(&bi,\t/*tbSh, */\n\t\t\t\t       /*          ( tb->S[h-1]->b_parent == tb->S[h] ) ? tb->S[h-1]->b_next :  tb->S[h]->b_child->b_next, */\n\t\t\t\t       child_pos, insert_num, insert_key,\n\t\t\t\t       insert_ptr);\n\t}\n\n\tmemcpy(new_insert_key_addr, &new_insert_key, KEY_SIZE);\n\tinsert_ptr[0] = new_insert_ptr;\n\n\treturn order;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
            "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nint balance_internal(struct tree_balance *tb,\n\t\t     int h,\t/* level of the tree */\n\t\t     int child_pos,\n\t\t     /* key for insertion on higher level    */\n\t\t     struct item_head *insert_key,\n\t\t     /* node for insertion on higher level */\n\t\t     struct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\t/*\n\t * we return this: it is 0 if there is no S[h],\n\t * else it is tb->S[h]->b_item_order\n\t */\n\tint order;\n\tint insert_num, n, k;\n\tstruct buffer_head *S_new;\n\tstruct item_head new_insert_key;\n\tstruct buffer_head *new_insert_ptr = NULL;\n\tstruct item_head *new_insert_key_addr = insert_key;\n\n\tRFALSE(h < 1, \"h (%d) can not be < 1 on internal level\", h);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[h]);\n\n\torder =\n\t    (tbSh) ? PATH_H_POSITION(tb->tb_path,\n\t\t\t\t     h + 1) /*tb->S[h]->b_item_order */ : 0;\n\n\t/*\n\t * Using insert_size[h] calculate the number insert_num of items\n\t * that must be inserted to or deleted from S[h].\n\t */\n\tinsert_num = tb->insert_size[h] / ((int)(KEY_SIZE + DC_SIZE));\n\n\t/* Check whether insert_num is proper * */\n\tRFALSE(insert_num < -2 || insert_num > 2,\n\t       \"incorrect number of items inserted to the internal node (%d)\",\n\t       insert_num);\n\tRFALSE(h > 1 && (insert_num > 1 || insert_num < -1),\n\t       \"incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level\",\n\t       insert_num, h);\n\n\t/* Make balance in case insert_num < 0 */\n\tif (insert_num < 0) {\n\t\tbalance_internal_when_delete(tb, h, child_pos);\n\t\treturn order;\n\t}\n\n\tk = 0;\n\tif (tb->lnum[h] > 0) {\n\t\t/*\n\t\t * shift lnum[h] items from S[h] to the left neighbor L[h].\n\t\t * check how many of new items fall into L[h] or CFL[h] after\n\t\t * shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tb->L[h]);\t/* number of items in L[h] */\n\t\tif (tb->lnum[h] <= child_pos) {\n\t\t\t/* new items don't fall into L[h] or CFL[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h]);\n\t\t\tchild_pos -= tb->lnum[h];\n\t\t} else if (tb->lnum[h] > child_pos + insert_num) {\n\t\t\t/* all new items fall into L[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h] - insert_num);\n\t\t\t/* insert insert_num keys and node-pointers into L[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next */\n\t\t\t\t\t       n + child_pos + 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/*\n\t\t\t * some items fall into L[h] or CFL[h],\n\t\t\t * but some don't fall\n\t\t\t */\n\t\t\tinternal_shift1_left(tb, h, child_pos + 1);\n\t\t\t/* calculate number of new items that fall into L[h] */\n\t\t\tk = tb->lnum[h] - child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next, */\n\t\t\t\t\t       n + child_pos + 1, k,\n\t\t\t\t\t       insert_key, insert_ptr);\n\n\t\t\treplace_lkey(tb, h, insert_key + k);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in S[h] by\n\t\t\t * node-ptr to insert_ptr[k]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tbSh, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr[k]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr[k]));\n\t\t\tput_dc_block_number(dc, insert_ptr[k]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t\tk++;\n\t\t\tinsert_key += k;\n\t\t\tinsert_ptr += k;\n\t\t\tinsert_num -= k;\n\t\t\tchild_pos = 0;\n\t\t}\n\t}\n\t/* tb->lnum[h] > 0 */\n\tif (tb->rnum[h] > 0) {\n\t\t/*shift rnum[h] items from S[h] to the right neighbor R[h] */\n\t\t/*\n\t\t * check how many of new items fall into R or CFR\n\t\t * after shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tif (n - tb->rnum[h] >= child_pos)\n\t\t\t/* new items fall into S[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h]);\n\t\telse if (n + insert_num - tb->rnum[h] < child_pos) {\n\t\t\t/* all new items fall into R[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h] - insert_num);\n\n\t\t\t/* insert insert_num keys and node-pointers into R[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h],tb->S[h-1]->b_next */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       tb->rnum[h] - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* one of the items falls into CFR[h] */\n\t\t\tinternal_shift1_right(tb, h, n - child_pos + 1);\n\t\t\t/* calculate number of new items that fall into R[h] */\n\t\t\tk = tb->rnum[h] - n + child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h], tb->R[h]->b_child, */\n\t\t\t\t\t       0, k, insert_key + 1,\n\t\t\t\t\t       insert_ptr + 1);\n\n\t\t\treplace_rkey(tb, h, insert_key + insert_num - k - 1);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in R[h] by\n\t\t\t * node-ptr insert_ptr[insert_num-k-1]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tb->R[h], 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr\n\t\t\t\t\t\t   [insert_num - k - 1]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t [insert_num - k - 1]));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->R[h], 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t}\n\n\t/** Fill new node that appears instead of S[h] **/\n\tRFALSE(tb->blknum[h] > 2, \"blknum can not be > 2 for internal level\");\n\tRFALSE(tb->blknum[h] < 0, \"blknum can not be < 0\");\n\n\tif (!tb->blknum[h]) {\t/* node S[h] is empty now */\n\t\tRFALSE(!tbSh, \"S[h] is equal NULL\");\n\n\t\t/* do what is needed for buffer thrown from tree */\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn order;\n\t}\n\n\tif (!tbSh) {\n\t\t/* create new root */\n\t\tstruct disk_child *dc;\n\t\tstruct buffer_head *tbSh_1 = PATH_H_PBUFFER(tb->tb_path, h - 1);\n\t\tstruct block_head *blkh;\n\n\t\tif (tb->blknum[h] != 1)\n\t\t\treiserfs_panic(NULL, \"ibalance-3\", \"One new node \"\n\t\t\t\t       \"required for creating the new root\");\n\t\t/* S[h] = empty buffer from the list FEB. */\n\t\ttbSh = get_FEB(tb);\n\t\tblkh = B_BLK_HEAD(tbSh);\n\t\tset_blkh_level(blkh, h + 1);\n\n\t\t/* Put the unique node-pointer to S[h] that points to S[h-1]. */\n\n\t\tdc = B_N_CHILD(tbSh, 0);\n\t\tput_dc_block_number(dc, tbSh_1->b_blocknr);\n\t\tput_dc_size(dc,\n\t\t\t    (MAX_CHILD_SIZE(tbSh_1) - B_FREE_SPACE(tbSh_1)));\n\n\t\ttb->insert_size[h] -= DC_SIZE;\n\t\tset_blkh_free_space(blkh, blkh_free_space(blkh) - DC_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(tbSh);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t/* put new root into path structure */\n\t\tPATH_OFFSET_PBUFFER(tb->tb_path, ILLEGAL_PATH_ELEMENT_OFFSET) =\n\t\t    tbSh;\n\n\t\t/* Change root in structure super block. */\n\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, tbSh->b_blocknr);\n\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb, SB_TREE_HEIGHT(tb->tb_sb) + 1);\n\t\tdo_balance_mark_sb_dirty(tb, REISERFS_SB(tb->tb_sb)->s_sbh, 1);\n\t}\n\n\tif (tb->blknum[h] == 2) {\n\t\tint snum;\n\t\tstruct buffer_info dest_bi, src_bi;\n\n\t\t/* S_new = free buffer from list FEB */\n\t\tS_new = get_FEB(tb);\n\n\t\tset_blkh_level(B_BLK_HEAD(S_new), h + 1);\n\n\t\tdest_bi.tb = tb;\n\t\tdest_bi.bi_bh = S_new;\n\t\tdest_bi.bi_parent = NULL;\n\t\tdest_bi.bi_position = 0;\n\t\tsrc_bi.tb = tb;\n\t\tsrc_bi.bi_bh = tbSh;\n\t\tsrc_bi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tsnum = (insert_num + n + 1) / 2;\n\t\tif (n - snum >= child_pos) {\n\t\t\t/* new items don't fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/* new_insert_key = (n - snum)'th key in S[h] */\n\t\t\tmemcpy(&new_insert_key, internal_key(tbSh, n - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST, snum, 0);\n\t\t} else if (n + insert_num - snum < child_pos) {\n\t\t\t/* all new items fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/*\n\t\t\t * new_insert_key = (n + insert_item - snum)'th\n\t\t\t * key in S[h]\n\t\t\t */\n\t\t\tmemcpy(&new_insert_key,\n\t\t\t       internal_key(tbSh, n + insert_num - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     snum - insert_num, 0);\n\n\t\t\t/*\n\t\t\t * insert insert_num keys and node-pointers\n\t\t\t * into S_new\n\t\t\t */\n\t\t\tinternal_insert_childs(&dest_bi,\n\t\t\t\t\t       /*S_new,tb->S[h-1]->b_next, */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       snum - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* some items fall into S_new, but some don't fall */\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     n - child_pos + 1, 1);\n\t\t\t/* calculate number of new items that fall into S_new */\n\t\t\tk = snum - n + child_pos - 1;\n\n\t\t\tinternal_insert_childs(&dest_bi, /*S_new, */ 0, k,\n\t\t\t\t\t       insert_key + 1, insert_ptr + 1);\n\n\t\t\t/* new_insert_key = insert_key[insert_num - k - 1] */\n\t\t\tmemcpy(&new_insert_key, insert_key + insert_num - k - 1,\n\t\t\t       KEY_SIZE);\n\t\t\t/*\n\t\t\t * replace first node-ptr in S_new by node-ptr\n\t\t\t * to insert_ptr[insert_num-k-1]\n\t\t\t */\n\n\t\t\tdc = B_N_CHILD(S_new, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    (MAX_CHILD_SIZE\n\t\t\t\t     (insert_ptr[insert_num - k - 1]) -\n\t\t\t\t     B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t  [insert_num - k - 1])));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, S_new, 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t\t/* new_insert_ptr = node_pointer to S_new */\n\t\tnew_insert_ptr = S_new;\n\n\t\tRFALSE(!buffer_journaled(S_new) || buffer_journal_dirty(S_new)\n\t\t       || buffer_dirty(S_new), \"cm-00001: bad S_new (%b)\",\n\t\t       S_new);\n\n\t\t/* S_new is released in unfix_nodes */\n\t}\n\n\tn = B_NR_ITEMS(tbSh);\t/*number of items in S[h] */\n\n\tif (0 <= child_pos && child_pos <= n && insert_num > 0) {\n\t\tbi.tb = tb;\n\t\tbi.bi_bh = tbSh;\n\t\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tinternal_insert_childs(&bi,\t/*tbSh, */\n\t\t\t\t       /*          ( tb->S[h-1]->b_parent == tb->S[h] ) ? tb->S[h-1]->b_next :  tb->S[h]->b_child->b_next, */\n\t\t\t\t       child_pos, insert_num, insert_key,\n\t\t\t\t       insert_ptr);\n\t}\n\n\tmemcpy(new_insert_key_addr, &new_insert_key, KEY_SIZE);\n\tinsert_ptr[0] = new_insert_ptr;\n\n\treturn order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_after_balance_leaf",
          "args": [
            "tb"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "check_after_balance_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1693-1739",
          "snippet": "static void check_after_balance_leaf(struct tree_balance *tb)\n{\n\tif (tb->lnum[0]) {\n\t\tif (B_FREE_SPACE(tb->L[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->L[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FL[0], get_left_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12221\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12355\",\n\t\t\t\t       \"shift to left was incorrect\");\n\t\t}\n\t}\n\tif (tb->rnum[0]) {\n\t\tif (B_FREE_SPACE(tb->R[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->R[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FR[0], get_right_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12222\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12360\",\n\t\t\t\t       \"shift to right was incorrect\");\n\t\t}\n\t}\n\tif (PATH_H_PBUFFER(tb->tb_path, 1) &&\n\t    (B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=\n\t     (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t      dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\tPATH_H_POSITION(tb->tb_path, 1)))))) {\n\t\tint left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));\n\t\tint right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t\t\t     dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t       PATH_H_POSITION(tb->tb_path,\n\t\t\t\t\t\t\t       1))));\n\t\tprint_cur_tb(\"12223\");\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12363\",\n\t\t\t\t \"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; \"\n\t\t\t\t \"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\",\n\t\t\t\t left,\n\t\t\t\t MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),\n\t\t\t\t PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t PATH_H_POSITION(tb->tb_path, 1),\n\t\t\t\t dc_size(B_N_CHILD\n\t\t\t\t\t (PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t  PATH_H_POSITION(tb->tb_path, 1))),\n\t\t\t\t right);\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12365\", \"S is incorrect\");\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_after_balance_leaf(struct tree_balance *tb)\n{\n\tif (tb->lnum[0]) {\n\t\tif (B_FREE_SPACE(tb->L[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->L[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FL[0], get_left_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12221\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12355\",\n\t\t\t\t       \"shift to left was incorrect\");\n\t\t}\n\t}\n\tif (tb->rnum[0]) {\n\t\tif (B_FREE_SPACE(tb->R[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->R[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FR[0], get_right_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12222\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12360\",\n\t\t\t\t       \"shift to right was incorrect\");\n\t\t}\n\t}\n\tif (PATH_H_PBUFFER(tb->tb_path, 1) &&\n\t    (B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=\n\t     (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t      dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\tPATH_H_POSITION(tb->tb_path, 1)))))) {\n\t\tint left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));\n\t\tint right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t\t\t     dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t       PATH_H_POSITION(tb->tb_path,\n\t\t\t\t\t\t\t       1))));\n\t\tprint_cur_tb(\"12223\");\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12363\",\n\t\t\t\t \"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; \"\n\t\t\t\t \"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\",\n\t\t\t\t left,\n\t\t\t\t MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),\n\t\t\t\t PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t PATH_H_POSITION(tb->tb_path, 1),\n\t\t\t\t dc_size(B_N_CHILD\n\t\t\t\t\t (PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t  PATH_H_POSITION(tb->tb_path, 1))),\n\t\t\t\t right);\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12365\", \"S is incorrect\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf",
          "args": [
            "tb",
            "ih",
            "body",
            "flag",
            "insert_key",
            "insert_ptr"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1393-1476",
          "snippet": "static int balance_leaf(struct tree_balance *tb, struct item_head *ih,\n\t\t\tconst char *body, int flag,\n\t\t\tstruct item_head *insert_key,\n\t\t\tstruct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[0]);\n\n\t/* Make balance in case insert_size[0] < 0 */\n\tif (tb->insert_size[0] < 0)\n\t\treturn balance_leaf_when_delete(tb, flag);\n\n\ttb->item_pos = PATH_LAST_POSITION(tb->tb_path),\n\ttb->pos_in_item = tb->tb_path->pos_in_item,\n\ttb->zeroes_num = 0;\n\tif (flag == M_INSERT && !body)\n\t\ttb->zeroes_num = ih_item_len(ih);\n\n\t/*\n\t * for indirect item pos_in_item is measured in unformatted node\n\t * pointers. Recalculate to bytes\n\t */\n\tif (flag != M_INSERT\n\t    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))\n\t\ttb->pos_in_item *= UNFM_P_SIZE;\n\n\tbody += balance_leaf_left(tb, ih, body, flag);\n\n\t/* tb->lnum[0] > 0 */\n\t/* Calculate new item position */\n\ttb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));\n\n\tbalance_leaf_right(tb, ih, body, flag);\n\n\t/* tb->rnum[0] > 0 */\n\tRFALSE(tb->blknum[0] > 3,\n\t       \"PAP-12180: blknum can not be %d. It must be <= 3\", tb->blknum[0]);\n\tRFALSE(tb->blknum[0] < 0,\n\t       \"PAP-12185: blknum can not be %d. It must be >= 0\", tb->blknum[0]);\n\n\t/*\n\t * if while adding to a node we discover that it is possible to split\n\t * it in two, and merge the left part into the left neighbor and the\n\t * right part into the right neighbor, eliminating the node\n\t */\n\tif (tb->blknum[0] == 0) {\t/* node S[0] is empty now */\n\n\t\tRFALSE(!tb->lnum[0] || !tb->rnum[0],\n\t\t       \"PAP-12190: lnum and rnum must not be zero\");\n\t\t/*\n\t\t * if insertion was done before 0-th position in R[0], right\n\t\t * delimiting key of the tb->L[0]'s and left delimiting key are\n\t\t * not set correctly\n\t\t */\n\t\tif (tb->CFL[0]) {\n\t\t\tif (!tb->CFR[0])\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-12195\",\n\t\t\t\t\t       \"CFR not initialized\");\n\t\t\tcopy_key(internal_key(tb->CFL[0], tb->lkey[0]),\n\t\t\t\t internal_key(tb->CFR[0], tb->rkey[0]));\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->CFL[0], 0);\n\t\t}\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tbalance_leaf_new_nodes(tb, ih, body, insert_key, insert_ptr, flag);\n\n\tbalance_leaf_finish_node(tb, ih, body, flag);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (flag == M_PASTE && tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12290\");\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t       \"PAP-12290\", \"insert_size is still not 0 (%d)\",\n\t\t\t       tb->insert_size[0]);\n\t}\n#endif\n\n\t/* Leaf level of the tree is balanced (end of balance_leaf) */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nstatic int balance_leaf(struct tree_balance *tb, struct item_head *ih,\n\t\t\tconst char *body, int flag,\n\t\t\tstruct item_head *insert_key,\n\t\t\tstruct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[0]);\n\n\t/* Make balance in case insert_size[0] < 0 */\n\tif (tb->insert_size[0] < 0)\n\t\treturn balance_leaf_when_delete(tb, flag);\n\n\ttb->item_pos = PATH_LAST_POSITION(tb->tb_path),\n\ttb->pos_in_item = tb->tb_path->pos_in_item,\n\ttb->zeroes_num = 0;\n\tif (flag == M_INSERT && !body)\n\t\ttb->zeroes_num = ih_item_len(ih);\n\n\t/*\n\t * for indirect item pos_in_item is measured in unformatted node\n\t * pointers. Recalculate to bytes\n\t */\n\tif (flag != M_INSERT\n\t    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))\n\t\ttb->pos_in_item *= UNFM_P_SIZE;\n\n\tbody += balance_leaf_left(tb, ih, body, flag);\n\n\t/* tb->lnum[0] > 0 */\n\t/* Calculate new item position */\n\ttb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));\n\n\tbalance_leaf_right(tb, ih, body, flag);\n\n\t/* tb->rnum[0] > 0 */\n\tRFALSE(tb->blknum[0] > 3,\n\t       \"PAP-12180: blknum can not be %d. It must be <= 3\", tb->blknum[0]);\n\tRFALSE(tb->blknum[0] < 0,\n\t       \"PAP-12185: blknum can not be %d. It must be >= 0\", tb->blknum[0]);\n\n\t/*\n\t * if while adding to a node we discover that it is possible to split\n\t * it in two, and merge the left part into the left neighbor and the\n\t * right part into the right neighbor, eliminating the node\n\t */\n\tif (tb->blknum[0] == 0) {\t/* node S[0] is empty now */\n\n\t\tRFALSE(!tb->lnum[0] || !tb->rnum[0],\n\t\t       \"PAP-12190: lnum and rnum must not be zero\");\n\t\t/*\n\t\t * if insertion was done before 0-th position in R[0], right\n\t\t * delimiting key of the tb->L[0]'s and left delimiting key are\n\t\t * not set correctly\n\t\t */\n\t\tif (tb->CFL[0]) {\n\t\t\tif (!tb->CFR[0])\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-12195\",\n\t\t\t\t\t       \"CFR not initialized\");\n\t\t\tcopy_key(internal_key(tb->CFL[0], tb->lkey[0]),\n\t\t\t\t internal_key(tb->CFR[0], tb->rkey[0]));\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->CFL[0], 0);\n\t\t}\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tbalance_leaf_new_nodes(tb, ih, body, insert_key, insert_ptr, flag);\n\n\tbalance_leaf_finish_node(tb, ih, body, flag);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (flag == M_PASTE && tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12290\");\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t       \"PAP-12290\", \"insert_size is still not 0 (%d)\",\n\t\t\t       tb->insert_size[0]);\n\t}\n#endif\n\n\t/* Leaf level of the tree is balanced (end of balance_leaf) */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_B_ITEM_ORDER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_starts",
          "args": [
            "tb"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "do_balance_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1800-1815",
          "snippet": "static inline void do_balance_starts(struct tree_balance *tb)\n{\n\t/* use print_cur_tb() to see initial state of struct tree_balance */\n\n\t/* store_print_tb (tb); */\n\n\t/* do not delete, just comment it out */\n\t/*\n\tprint_tb(flag, PATH_LAST_POSITION(tb->tb_path),\n\t\t tb->tb_path->pos_in_item, tb, \"check\");\n\t*/\n\tRFALSE(check_before_balancing(tb), \"PAP-12340: locked buffers in TB\");\n#ifdef CONFIG_REISERFS_CHECK\n\tREISERFS_SB(tb->tb_sb)->cur_tb = tb;\n#endif\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void do_balance_starts(struct tree_balance *tb)\n{\n\t/* use print_cur_tb() to see initial state of struct tree_balance */\n\n\t/* store_print_tb (tb); */\n\n\t/* do not delete, just comment it out */\n\t/*\n\tprint_tb(flag, PATH_LAST_POSITION(tb->tb_path),\n\t\t tb->tb_path->pos_in_item, tb, \"check\");\n\t*/\n\tRFALSE(check_before_balancing(tb), \"PAP-12340: locked buffers in TB\");\n#ifdef CONFIG_REISERFS_CHECK\n\tREISERFS_SB(tb->tb_sb)->cur_tb = tb;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fs_generation(tb->tb_sb)"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_generation",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unfix_nodes",
          "args": [
            "tb"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "unfix_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2781-2825",
          "snippet": "void unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nvoid unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"PAP-12350\"",
            "\"insert_size == 0, mode == %c\"",
            "flag"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"clm-6000\"",
            "\"fs generation has \"\n\t\t\t       \"changed\""
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILESYSTEM_CHANGED_TB",
          "args": [
            "tb"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid do_balance(struct tree_balance *tb, struct item_head *ih,\n\t\tconst char *body, int flag)\n{\n\tint child_pos;\t\t/* position of a child node in its parent */\n\tint h;\t\t\t/* level of the tree being processed */\n\n\t/*\n\t * in our processing of one level we sometimes determine what\n\t * must be inserted into the next higher level.  This insertion\n\t * consists of a key or two keys and their corresponding\n\t * pointers\n\t */\n\tstruct item_head insert_key[2];\n\n\t/* inserted node-ptrs for the next level */\n\tstruct buffer_head *insert_ptr[2];\n\n\ttb->tb_mode = flag;\n\ttb->need_balance_dirty = 0;\n\n\tif (FILESYSTEM_CHANGED_TB(tb)) {\n\t\treiserfs_panic(tb->tb_sb, \"clm-6000\", \"fs generation has \"\n\t\t\t       \"changed\");\n\t}\n\t/* if we have no real work to do  */\n\tif (!tb->insert_size[0]) {\n\t\treiserfs_warning(tb->tb_sb, \"PAP-12350\",\n\t\t\t\t \"insert_size == 0, mode == %c\", flag);\n\t\tunfix_nodes(tb);\n\t\treturn;\n\t}\n\n\tatomic_inc(&fs_generation(tb->tb_sb));\n\tdo_balance_starts(tb);\n\n\t/*\n\t * balance_leaf returns 0 except if combining L R and S into\n\t * one node.  see balance_internal() for explanation of this\n\t * line of code.\n\t */\n\tchild_pos = PATH_H_B_ITEM_ORDER(tb->tb_path, 0) +\n\t    balance_leaf(tb, ih, body, flag, insert_key, insert_ptr);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_after_balance_leaf(tb);\n#endif\n\n\t/* Balance internal level of the tree. */\n\tfor (h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++)\n\t\tchild_pos = balance_internal(tb, h, child_pos, insert_key,\n\t\t\t\t\t     insert_ptr);\n\n\tdo_balance_completed(tb);\n}"
  },
  {
    "function_name": "do_balance_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1817-1838",
    "snippet": "static inline void do_balance_completed(struct tree_balance *tb)\n{\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_leaf_level(tb);\n\tcheck_internal_levels(tb);\n\tREISERFS_SB(tb->tb_sb)->cur_tb = NULL;\n#endif\n\n\t/*\n\t * reiserfs_free_block is no longer schedule safe.  So, we need to\n\t * put the buffers we want freed on the thrown list during do_balance,\n\t * and then free them now\n\t */\n\n\tREISERFS_SB(tb->tb_sb)->s_do_balance++;\n\n\t/* release all nodes hold to perform the balancing */\n\tunfix_nodes(tb);\n\n\tfree_thrown(tb);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_thrown",
          "args": [
            "tb"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "free_thrown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1533-1549",
          "snippet": "static void free_thrown(struct tree_balance *tb)\n{\n\tint i;\n\tb_blocknr_t blocknr;\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {\n\t\tif (tb->thrown[i]) {\n\t\t\tblocknr = tb->thrown[i]->b_blocknr;\n\t\t\tif (buffer_dirty(tb->thrown[i]))\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12322\",\n\t\t\t\t\t\t \"called with dirty buffer %d\",\n\t\t\t\t\t\t blocknr);\n\t\t\tbrelse(tb->thrown[i]);\t/* incremented in store_thrown */\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void free_thrown(struct tree_balance *tb)\n{\n\tint i;\n\tb_blocknr_t blocknr;\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {\n\t\tif (tb->thrown[i]) {\n\t\t\tblocknr = tb->thrown[i]->b_blocknr;\n\t\t\tif (buffer_dirty(tb->thrown[i]))\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12322\",\n\t\t\t\t\t\t \"called with dirty buffer %d\",\n\t\t\t\t\t\t blocknr);\n\t\t\tbrelse(tb->thrown[i]);\t/* incremented in store_thrown */\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unfix_nodes",
          "args": [
            "tb"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "unfix_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "2781-2825",
          "snippet": "void unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nvoid unfix_nodes(struct tree_balance *tb)\n{\n\tint i;\n\n\t/* Release path buffers. */\n\tpathrelse_and_restore(tb->tb_sb, tb->tb_path);\n\n\t/* brelse all resources collected for balancing */\n\tfor (i = 0; i < MAX_HEIGHT; i++) {\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->L[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->R[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->FR[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFL[i]);\n\t\treiserfs_restore_prepared_buffer(tb->tb_sb, tb->CFR[i]);\n\n\t\tbrelse(tb->L[i]);\n\t\tbrelse(tb->R[i]);\n\t\tbrelse(tb->FL[i]);\n\t\tbrelse(tb->FR[i]);\n\t\tbrelse(tb->CFL[i]);\n\t\tbrelse(tb->CFR[i]);\n\t}\n\n\t/* deal with list of allocated (used and unused) nodes */\n\tfor (i = 0; i < MAX_FEB_SIZE; i++) {\n\t\tif (tb->FEB[i]) {\n\t\t\tb_blocknr_t blocknr = tb->FEB[i]->b_blocknr;\n\t\t\t/*\n\t\t\t * de-allocated block which was not used by\n\t\t\t * balancing and bforget about buffer for it\n\t\t\t */\n\t\t\tbrelse(tb->FEB[i]);\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t\tif (tb->used[i]) {\n\t\t\t/* release used as new nodes including a new root */\n\t\t\tbrelse(tb->used[i]);\n\t\t}\n\t}\n\n\tkfree(tb->vn_buf);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_internal_levels",
          "args": [
            "tb"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "check_internal_levels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1748-1762",
          "snippet": "static void check_internal_levels(struct tree_balance *tb)\n{\n\tint h;\n\n\t/* check all internal nodes */\n\tfor (h = 1; tb->insert_size[h]; h++) {\n\t\tcheck_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),\n\t\t\t\t    \"BAD BUFFER ON PATH\");\n\t\tif (tb->lnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->L[h], \"BAD L\");\n\t\tif (tb->rnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->R[h], \"BAD R\");\n\t}\n\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_internal_levels(struct tree_balance *tb)\n{\n\tint h;\n\n\t/* check all internal nodes */\n\tfor (h = 1; tb->insert_size[h]; h++) {\n\t\tcheck_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),\n\t\t\t\t    \"BAD BUFFER ON PATH\");\n\t\tif (tb->lnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->L[h], \"BAD L\");\n\t\tif (tb->rnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->R[h], \"BAD R\");\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_leaf_level",
          "args": [
            "tb"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "check_leaf_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1741-1746",
          "snippet": "static void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void do_balance_completed(struct tree_balance *tb)\n{\n\n#ifdef CONFIG_REISERFS_CHECK\n\tcheck_leaf_level(tb);\n\tcheck_internal_levels(tb);\n\tREISERFS_SB(tb->tb_sb)->cur_tb = NULL;\n#endif\n\n\t/*\n\t * reiserfs_free_block is no longer schedule safe.  So, we need to\n\t * put the buffers we want freed on the thrown list during do_balance,\n\t * and then free them now\n\t */\n\n\tREISERFS_SB(tb->tb_sb)->s_do_balance++;\n\n\t/* release all nodes hold to perform the balancing */\n\tunfix_nodes(tb);\n\n\tfree_thrown(tb);\n}"
  },
  {
    "function_name": "do_balance_starts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1800-1815",
    "snippet": "static inline void do_balance_starts(struct tree_balance *tb)\n{\n\t/* use print_cur_tb() to see initial state of struct tree_balance */\n\n\t/* store_print_tb (tb); */\n\n\t/* do not delete, just comment it out */\n\t/*\n\tprint_tb(flag, PATH_LAST_POSITION(tb->tb_path),\n\t\t tb->tb_path->pos_in_item, tb, \"check\");\n\t*/\n\tRFALSE(check_before_balancing(tb), \"PAP-12340: locked buffers in TB\");\n#ifdef CONFIG_REISERFS_CHECK\n\tREISERFS_SB(tb->tb_sb)->cur_tb = tb;\n#endif\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "check_before_balancing(tb)",
            "\"PAP-12340: locked buffers in TB\""
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_before_balancing",
          "args": [
            "tb"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "check_before_balancing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1658-1691",
          "snippet": "static int check_before_balancing(struct tree_balance *tb)\n{\n\tint retval = 0;\n\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\treiserfs_panic(tb->tb_sb, \"vs-12335\", \"suspect that schedule \"\n\t\t\t       \"occurred based on cur_tb not being null at \"\n\t\t\t       \"this point in code. do_balance cannot properly \"\n\t\t\t       \"handle concurrent tree accesses on a same \"\n\t\t\t       \"mount point.\");\n\t}\n\n\t/*\n\t * double check that buffers that we will modify are unlocked.\n\t * (fix_nodes should already have prepped all of these for us).\n\t */\n\tif (tb->lnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->L[0], \"L[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FL[0], \"FL[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFL[0], \"CFL[0]\");\n\t\tcheck_leaf(tb->L[0]);\n\t}\n\tif (tb->rnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->R[0], \"R[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FR[0], \"FR[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFR[0], \"CFR[0]\");\n\t\tcheck_leaf(tb->R[0]);\n\t}\n\tretval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),\n\t\t\t\t\t\"S[0]\");\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n\n\treturn retval;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int check_before_balancing(struct tree_balance *tb)\n{\n\tint retval = 0;\n\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\treiserfs_panic(tb->tb_sb, \"vs-12335\", \"suspect that schedule \"\n\t\t\t       \"occurred based on cur_tb not being null at \"\n\t\t\t       \"this point in code. do_balance cannot properly \"\n\t\t\t       \"handle concurrent tree accesses on a same \"\n\t\t\t       \"mount point.\");\n\t}\n\n\t/*\n\t * double check that buffers that we will modify are unlocked.\n\t * (fix_nodes should already have prepped all of these for us).\n\t */\n\tif (tb->lnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->L[0], \"L[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FL[0], \"FL[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFL[0], \"CFL[0]\");\n\t\tcheck_leaf(tb->L[0]);\n\t}\n\tif (tb->rnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->R[0], \"R[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FR[0], \"FR[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFR[0], \"CFR[0]\");\n\t\tcheck_leaf(tb->R[0]);\n\t}\n\tretval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),\n\t\t\t\t\t\"S[0]\");\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void do_balance_starts(struct tree_balance *tb)\n{\n\t/* use print_cur_tb() to see initial state of struct tree_balance */\n\n\t/* store_print_tb (tb); */\n\n\t/* do not delete, just comment it out */\n\t/*\n\tprint_tb(flag, PATH_LAST_POSITION(tb->tb_path),\n\t\t tb->tb_path->pos_in_item, tb, \"check\");\n\t*/\n\tRFALSE(check_before_balancing(tb), \"PAP-12340: locked buffers in TB\");\n#ifdef CONFIG_REISERFS_CHECK\n\tREISERFS_SB(tb->tb_sb)->cur_tb = tb;\n#endif\n}"
  },
  {
    "function_name": "check_internal_levels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1748-1762",
    "snippet": "static void check_internal_levels(struct tree_balance *tb)\n{\n\tint h;\n\n\t/* check all internal nodes */\n\tfor (h = 1; tb->insert_size[h]; h++) {\n\t\tcheck_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),\n\t\t\t\t    \"BAD BUFFER ON PATH\");\n\t\tif (tb->lnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->L[h], \"BAD L\");\n\t\tif (tb->rnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->R[h], \"BAD R\");\n\t}\n\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_internal_node",
          "args": [
            "tb->tb_sb",
            "tb->R[h]",
            "\"BAD R\""
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "check_internal_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1621-1645",
          "snippet": "static void check_internal_node(struct super_block *s, struct buffer_head *bh,\n\t\t\t\tchar *mes)\n{\n\tstruct disk_child *dc;\n\tint i;\n\n\tRFALSE(!bh, \"PAP-12336: bh == 0\");\n\n\tif (!bh || !B_IS_IN_TREE(bh))\n\t\treturn;\n\n\tRFALSE(!buffer_dirty(bh) &&\n\t       !(buffer_journaled(bh) || buffer_journal_dirty(bh)),\n\t       \"PAP-12337: buffer (%b) must be dirty\", bh);\n\tdc = B_N_CHILD(bh, 0);\n\n\tfor (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {\n\t\tif (!is_reusable(s, dc_block_number(dc), 1)) {\n\t\t\tprint_cur_tb(mes);\n\t\t\treiserfs_panic(s, \"PAP-12338\",\n\t\t\t\t       \"invalid child pointer %y in %b\",\n\t\t\t\t       dc, bh);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_internal_node(struct super_block *s, struct buffer_head *bh,\n\t\t\t\tchar *mes)\n{\n\tstruct disk_child *dc;\n\tint i;\n\n\tRFALSE(!bh, \"PAP-12336: bh == 0\");\n\n\tif (!bh || !B_IS_IN_TREE(bh))\n\t\treturn;\n\n\tRFALSE(!buffer_dirty(bh) &&\n\t       !(buffer_journaled(bh) || buffer_journal_dirty(bh)),\n\t       \"PAP-12337: buffer (%b) must be dirty\", bh);\n\tdc = B_N_CHILD(bh, 0);\n\n\tfor (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {\n\t\tif (!is_reusable(s, dc_block_number(dc), 1)) {\n\t\t\tprint_cur_tb(mes);\n\t\t\treiserfs_panic(s, \"PAP-12338\",\n\t\t\t\t       \"invalid child pointer %y in %b\",\n\t\t\t\t       dc, bh);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_internal_levels(struct tree_balance *tb)\n{\n\tint h;\n\n\t/* check all internal nodes */\n\tfor (h = 1; tb->insert_size[h]; h++) {\n\t\tcheck_internal_node(tb->tb_sb, PATH_H_PBUFFER(tb->tb_path, h),\n\t\t\t\t    \"BAD BUFFER ON PATH\");\n\t\tif (tb->lnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->L[h], \"BAD L\");\n\t\tif (tb->rnum[h])\n\t\t\tcheck_internal_node(tb->tb_sb, tb->R[h], \"BAD R\");\n\t}\n\n}"
  },
  {
    "function_name": "check_leaf_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1741-1746",
    "snippet": "static void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_leaf",
          "args": [
            "PATH_PLAST_BUFFER(tb->tb_path)"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "check_leaf_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1741-1746",
          "snippet": "static void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}"
  },
  {
    "function_name": "check_after_balance_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1693-1739",
    "snippet": "static void check_after_balance_leaf(struct tree_balance *tb)\n{\n\tif (tb->lnum[0]) {\n\t\tif (B_FREE_SPACE(tb->L[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->L[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FL[0], get_left_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12221\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12355\",\n\t\t\t\t       \"shift to left was incorrect\");\n\t\t}\n\t}\n\tif (tb->rnum[0]) {\n\t\tif (B_FREE_SPACE(tb->R[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->R[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FR[0], get_right_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12222\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12360\",\n\t\t\t\t       \"shift to right was incorrect\");\n\t\t}\n\t}\n\tif (PATH_H_PBUFFER(tb->tb_path, 1) &&\n\t    (B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=\n\t     (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t      dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\tPATH_H_POSITION(tb->tb_path, 1)))))) {\n\t\tint left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));\n\t\tint right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t\t\t     dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t       PATH_H_POSITION(tb->tb_path,\n\t\t\t\t\t\t\t       1))));\n\t\tprint_cur_tb(\"12223\");\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12363\",\n\t\t\t\t \"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; \"\n\t\t\t\t \"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\",\n\t\t\t\t left,\n\t\t\t\t MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),\n\t\t\t\t PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t PATH_H_POSITION(tb->tb_path, 1),\n\t\t\t\t dc_size(B_N_CHILD\n\t\t\t\t\t (PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t  PATH_H_POSITION(tb->tb_path, 1))),\n\t\t\t\t right);\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12365\", \"S is incorrect\");\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-12365\"",
            "\"S is incorrect\""
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"reiserfs-12363\"",
            "\"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; \"\n\t\t\t\t \"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\"",
            "left",
            "MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0))",
            "PATH_H_PBUFFER(tb->tb_path, 1)",
            "PATH_H_POSITION(tb->tb_path, 1)",
            "dc_size(B_N_CHILD\n\t\t\t\t\t (PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t  PATH_H_POSITION(tb->tb_path, 1)))",
            "right"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD\n\t\t\t\t\t (PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t  PATH_H_POSITION(tb->tb_path, 1))"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 1)",
            "PATH_H_POSITION(tb->tb_path, 1)"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 0)"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "\"12223\""
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t       PATH_H_POSITION(tb->tb_path,\n\t\t\t\t\t\t\t       1))"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 1)",
            "PATH_H_POSITION(tb->tb_path,\n\t\t\t\t\t\t\t       1)"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 0)"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 0)"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\tPATH_H_POSITION(tb->tb_path, 1))"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 1)",
            "PATH_H_POSITION(tb->tb_path, 1)"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 0)"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, 0)"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-12360\"",
            "\"shift to right was incorrect\""
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD\n\t\t\t    (tb->FR[0], get_right_neighbor_position(tb, 0))"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FR[0]",
            "get_right_neighbor_position(tb, 0)"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_right_neighbor_position",
          "args": [
            "tb",
            "0"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "get_right_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1604-1616",
          "snippet": "int get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "tb->R[0]"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "tb->R[0]"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-12355\"",
            "\"shift to left was incorrect\""
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "B_N_CHILD\n\t\t\t    (tb->FL[0], get_left_neighbor_position(tb, 0))"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->FL[0]",
            "get_left_neighbor_position(tb, 0)"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_left_neighbor_position",
          "args": [
            "tb",
            "0"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "get_left_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1590-1602",
          "snippet": "int get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "tb->L[0]"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "tb->L[0]"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_after_balance_leaf(struct tree_balance *tb)\n{\n\tif (tb->lnum[0]) {\n\t\tif (B_FREE_SPACE(tb->L[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->L[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FL[0], get_left_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12221\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12355\",\n\t\t\t\t       \"shift to left was incorrect\");\n\t\t}\n\t}\n\tif (tb->rnum[0]) {\n\t\tif (B_FREE_SPACE(tb->R[0]) !=\n\t\t    MAX_CHILD_SIZE(tb->R[0]) -\n\t\t    dc_size(B_N_CHILD\n\t\t\t    (tb->FR[0], get_right_neighbor_position(tb, 0)))) {\n\t\t\tprint_cur_tb(\"12222\");\n\t\t\treiserfs_panic(tb->tb_sb, \"PAP-12360\",\n\t\t\t\t       \"shift to right was incorrect\");\n\t\t}\n\t}\n\tif (PATH_H_PBUFFER(tb->tb_path, 1) &&\n\t    (B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0)) !=\n\t     (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t      dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\tPATH_H_POSITION(tb->tb_path, 1)))))) {\n\t\tint left = B_FREE_SPACE(PATH_H_PBUFFER(tb->tb_path, 0));\n\t\tint right = (MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)) -\n\t\t\t     dc_size(B_N_CHILD(PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t       PATH_H_POSITION(tb->tb_path,\n\t\t\t\t\t\t\t       1))));\n\t\tprint_cur_tb(\"12223\");\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12363\",\n\t\t\t\t \"B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; \"\n\t\t\t\t \"MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\",\n\t\t\t\t left,\n\t\t\t\t MAX_CHILD_SIZE(PATH_H_PBUFFER(tb->tb_path, 0)),\n\t\t\t\t PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t PATH_H_POSITION(tb->tb_path, 1),\n\t\t\t\t dc_size(B_N_CHILD\n\t\t\t\t\t (PATH_H_PBUFFER(tb->tb_path, 1),\n\t\t\t\t\t  PATH_H_POSITION(tb->tb_path, 1))),\n\t\t\t\t right);\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12365\", \"S is incorrect\");\n\t}\n}"
  },
  {
    "function_name": "check_before_balancing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1658-1691",
    "snippet": "static int check_before_balancing(struct tree_balance *tb)\n{\n\tint retval = 0;\n\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\treiserfs_panic(tb->tb_sb, \"vs-12335\", \"suspect that schedule \"\n\t\t\t       \"occurred based on cur_tb not being null at \"\n\t\t\t       \"this point in code. do_balance cannot properly \"\n\t\t\t       \"handle concurrent tree accesses on a same \"\n\t\t\t       \"mount point.\");\n\t}\n\n\t/*\n\t * double check that buffers that we will modify are unlocked.\n\t * (fix_nodes should already have prepped all of these for us).\n\t */\n\tif (tb->lnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->L[0], \"L[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FL[0], \"FL[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFL[0], \"CFL[0]\");\n\t\tcheck_leaf(tb->L[0]);\n\t}\n\tif (tb->rnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->R[0], \"R[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FR[0], \"FR[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFR[0], \"CFR[0]\");\n\t\tcheck_leaf(tb->R[0]);\n\t}\n\tretval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),\n\t\t\t\t\t\"S[0]\");\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_leaf",
          "args": [
            "PATH_PLAST_BUFFER(tb->tb_path)"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "check_leaf_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1741-1746",
          "snippet": "static void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_leaf_level(struct tree_balance *tb)\n{\n\tcheck_leaf(tb->L[0]);\n\tcheck_leaf(tb->R[0]);\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locked_or_not_in_tree",
          "args": [
            "tb",
            "PATH_PLAST_BUFFER(tb->tb_path)",
            "\"S[0]\""
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "locked_or_not_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1647-1656",
          "snippet": "static int locked_or_not_in_tree(struct tree_balance *tb,\n\t\t\t\t  struct buffer_head *bh, char *which)\n{\n\tif ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||\n\t    !B_IS_IN_TREE(bh)) {\n\t\treiserfs_warning(tb->tb_sb, \"vs-12339\", \"%s (%b)\", which, bh);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int locked_or_not_in_tree(struct tree_balance *tb,\n\t\t\t\t  struct buffer_head *bh, char *which)\n{\n\tif ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||\n\t    !B_IS_IN_TREE(bh)) {\n\t\treiserfs_warning(tb->tb_sb, \"vs-12339\", \"%s (%b)\", which, bh);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-12335\"",
            "\"suspect that schedule \"\n\t\t\t       \"occurred based on cur_tb not being null at \"\n\t\t\t       \"this point in code. do_balance cannot properly \"\n\t\t\t       \"handle concurrent tree accesses on a same \"\n\t\t\t       \"mount point.\""
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int check_before_balancing(struct tree_balance *tb)\n{\n\tint retval = 0;\n\n\tif (REISERFS_SB(tb->tb_sb)->cur_tb) {\n\t\treiserfs_panic(tb->tb_sb, \"vs-12335\", \"suspect that schedule \"\n\t\t\t       \"occurred based on cur_tb not being null at \"\n\t\t\t       \"this point in code. do_balance cannot properly \"\n\t\t\t       \"handle concurrent tree accesses on a same \"\n\t\t\t       \"mount point.\");\n\t}\n\n\t/*\n\t * double check that buffers that we will modify are unlocked.\n\t * (fix_nodes should already have prepped all of these for us).\n\t */\n\tif (tb->lnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->L[0], \"L[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FL[0], \"FL[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFL[0], \"CFL[0]\");\n\t\tcheck_leaf(tb->L[0]);\n\t}\n\tif (tb->rnum[0]) {\n\t\tretval |= locked_or_not_in_tree(tb, tb->R[0], \"R[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->FR[0], \"FR[0]\");\n\t\tretval |= locked_or_not_in_tree(tb, tb->CFR[0], \"CFR[0]\");\n\t\tcheck_leaf(tb->R[0]);\n\t}\n\tretval |= locked_or_not_in_tree(tb, PATH_PLAST_BUFFER(tb->tb_path),\n\t\t\t\t\t\"S[0]\");\n\tcheck_leaf(PATH_PLAST_BUFFER(tb->tb_path));\n\n\treturn retval;\n}"
  },
  {
    "function_name": "locked_or_not_in_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1647-1656",
    "snippet": "static int locked_or_not_in_tree(struct tree_balance *tb,\n\t\t\t\t  struct buffer_head *bh, char *which)\n{\n\tif ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||\n\t    !B_IS_IN_TREE(bh)) {\n\t\treiserfs_warning(tb->tb_sb, \"vs-12339\", \"%s (%b)\", which, bh);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"vs-12339\"",
            "\"%s (%b)\"",
            "which",
            "bh"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "bh"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_prepared",
          "args": [
            "bh"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int locked_or_not_in_tree(struct tree_balance *tb,\n\t\t\t\t  struct buffer_head *bh, char *which)\n{\n\tif ((!buffer_journal_prepared(bh) && buffer_locked(bh)) ||\n\t    !B_IS_IN_TREE(bh)) {\n\t\treiserfs_warning(tb->tb_sb, \"vs-12339\", \"%s (%b)\", which, bh);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_internal_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1621-1645",
    "snippet": "static void check_internal_node(struct super_block *s, struct buffer_head *bh,\n\t\t\t\tchar *mes)\n{\n\tstruct disk_child *dc;\n\tint i;\n\n\tRFALSE(!bh, \"PAP-12336: bh == 0\");\n\n\tif (!bh || !B_IS_IN_TREE(bh))\n\t\treturn;\n\n\tRFALSE(!buffer_dirty(bh) &&\n\t       !(buffer_journaled(bh) || buffer_journal_dirty(bh)),\n\t       \"PAP-12337: buffer (%b) must be dirty\", bh);\n\tdc = B_N_CHILD(bh, 0);\n\n\tfor (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {\n\t\tif (!is_reusable(s, dc_block_number(dc), 1)) {\n\t\t\tprint_cur_tb(mes);\n\t\t\treiserfs_panic(s, \"PAP-12338\",\n\t\t\t\t       \"invalid child pointer %y in %b\",\n\t\t\t\t       dc, bh);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "s",
            "\"PAP-12338\"",
            "\"invalid child pointer %y in %b\"",
            "dc",
            "bh"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "mes"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_reusable",
          "args": [
            "s",
            "dc_block_number(dc)",
            "1"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "is_reusable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "62-113",
          "snippet": "int is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nint is_reusable(struct super_block *s, b_blocknr_t block, int bit_value)\n{\n\tunsigned int bmap, offset;\n\tunsigned int bmap_count = reiserfs_bmap_count(s);\n\n\tif (block == 0 || block >= SB_BLOCK_COUNT(s)) {\n\t\treiserfs_error(s, \"vs-4010\",\n\t\t\t       \"block number is out of range %lu (%u)\",\n\t\t\t       block, SB_BLOCK_COUNT(s));\n\t\treturn 0;\n\t}\n\n\tget_bit_address(s, block, &bmap, &offset);\n\n\t/*\n\t * Old format filesystem? Unlikely, but the bitmaps are all\n\t * up front so we need to account for it.\n\t */\n\tif (unlikely(test_bit(REISERFS_OLD_FORMAT,\n\t\t\t      &REISERFS_SB(s)->s_properties))) {\n\t\tb_blocknr_t bmap1 = REISERFS_SB(s)->s_sbh->b_blocknr + 1;\n\t\tif (block >= bmap1 &&\n\t\t    block <= bmap1 + bmap_count) {\n\t\t\treiserfs_error(s, \"vs-4019\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (offset == 0) {\n\t\t\treiserfs_error(s, \"vs-4020\", \"bitmap block %lu(%u) \"\n\t\t\t\t       \"can't be freed or reused\",\n\t\t\t\t       block, bmap_count);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bmap >= bmap_count) {\n\t\treiserfs_error(s, \"vs-4030\", \"bitmap for requested block \"\n\t\t\t       \"is out of range: block=%lu, bitmap_nr=%u\",\n\t\t\t       block, bmap);\n\t\treturn 0;\n\t}\n\n\tif (bit_value == 0 && block == SB_ROOT_BLOCK(s)) {\n\t\treiserfs_error(s, \"vs-4050\", \"this is root block (%u), \"\n\t\t\t       \"it must be busy\", SB_ROOT_BLOCK(s));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dc_block_number",
          "args": [
            "dc"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "bh"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "bh",
            "0"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!buffer_dirty(bh) &&\n\t       !(buffer_journaled(bh) || buffer_journal_dirty(bh))",
            "\"PAP-12337: buffer (%b) must be dirty\"",
            "bh"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "bh"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_IS_IN_TREE",
          "args": [
            "bh"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "B_IS_IN_TREE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "19-26",
          "snippet": "inline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int B_IS_IN_TREE(const struct buffer_head *bh)\n{\n\n\tRFALSE(B_LEVEL(bh) > MAX_HEIGHT,\n\t       \"PAP-1010: block (%b) has too big level (%z)\", bh, bh);\n\n\treturn (B_LEVEL(bh) != FREE_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!bh",
            "\"PAP-12336: bh == 0\""
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void check_internal_node(struct super_block *s, struct buffer_head *bh,\n\t\t\t\tchar *mes)\n{\n\tstruct disk_child *dc;\n\tint i;\n\n\tRFALSE(!bh, \"PAP-12336: bh == 0\");\n\n\tif (!bh || !B_IS_IN_TREE(bh))\n\t\treturn;\n\n\tRFALSE(!buffer_dirty(bh) &&\n\t       !(buffer_journaled(bh) || buffer_journal_dirty(bh)),\n\t       \"PAP-12337: buffer (%b) must be dirty\", bh);\n\tdc = B_N_CHILD(bh, 0);\n\n\tfor (i = 0; i <= B_NR_ITEMS(bh); i++, dc++) {\n\t\tif (!is_reusable(s, dc_block_number(dc), 1)) {\n\t\t\tprint_cur_tb(mes);\n\t\t\treiserfs_panic(s, \"PAP-12338\",\n\t\t\t\t       \"invalid child pointer %y in %b\",\n\t\t\t\t       dc, bh);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_right_neighbor_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1604-1616",
    "snippet": "int get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "PATH_H_PPARENT(tb->tb_path, h)"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL",
            "\"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\"",
            "h",
            "PATH_H_PPARENT(tb->tb_path, h)",
            "h",
            "tb->FR[h]"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}"
  },
  {
    "function_name": "get_left_neighbor_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1590-1602",
    "snippet": "int get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->FL[h]"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL",
            "\"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\"",
            "h",
            "tb->FL[h]",
            "h",
            "PATH_H_PPARENT(tb->tb_path, h)"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}"
  },
  {
    "function_name": "replace_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1563-1588",
    "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "dest",
            "0"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "internal_key(dest, n_dest)",
            "internal_key(src, n_src)",
            "KEY_SIZE"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "src",
            "n_src"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "internal_key(dest, n_dest)",
            "item_head(src, n_src)",
            "KEY_SIZE"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "src",
            "n_src"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_IS_ITEMS_LEVEL",
          "args": [
            "src"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src)",
            "\"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\"",
            "n_src",
            "B_NR_ITEMS(src)",
            "n_dest",
            "B_NR_ITEMS(dest)"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "n_dest < 0 || n_src < 0",
            "\"vs-12315: src(%d) or dest(%d) key number < 0\"",
            "n_src",
            "n_dest"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!B_IS_KEYS_LEVEL(dest)",
            "\"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\"",
            "dest"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_IS_KEYS_LEVEL",
          "args": [
            "dest"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "dest == NULL || src == NULL",
            "\"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\"",
            "src",
            "dest"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
  },
  {
    "function_name": "reiserfs_invalidate_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1551-1560",
    "snippet": "void reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "store_thrown",
          "args": [
            "tb",
            "bh"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "store_thrown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1516-1531",
          "snippet": "static void store_thrown(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tint i;\n\n\tif (buffer_dirty(bh))\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12320\",\n\t\t\t\t \"called with dirty buffer\");\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++)\n\t\tif (!tb->thrown[i]) {\n\t\t\ttb->thrown[i] = bh;\n\t\t\tget_bh(bh);\t/* free_thrown puts this */\n\t\t\treturn;\n\t\t}\n\treiserfs_warning(tb->tb_sb, \"reiserfs-12321\",\n\t\t\t \"too many thrown buffers\");\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void store_thrown(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tint i;\n\n\tif (buffer_dirty(bh))\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12320\",\n\t\t\t\t \"called with dirty buffer\");\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++)\n\t\tif (!tb->thrown[i]) {\n\t\t\ttb->thrown[i] = bh;\n\t\t\tget_bh(bh);\t/* free_thrown puts this */\n\t\t\treturn;\n\t\t}\n\treiserfs_warning(tb->tb_sb, \"reiserfs-12321\",\n\t\t\t \"too many thrown buffers\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "0"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_level",
          "args": [
            "blkh",
            "FREE_LEVEL"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "bh"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}"
  },
  {
    "function_name": "free_thrown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1533-1549",
    "snippet": "static void free_thrown(struct tree_balance *tb)\n{\n\tint i;\n\tb_blocknr_t blocknr;\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {\n\t\tif (tb->thrown[i]) {\n\t\t\tblocknr = tb->thrown[i]->b_blocknr;\n\t\t\tif (buffer_dirty(tb->thrown[i]))\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12322\",\n\t\t\t\t\t\t \"called with dirty buffer %d\",\n\t\t\t\t\t\t blocknr);\n\t\t\tbrelse(tb->thrown[i]);\t/* incremented in store_thrown */\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_free_block",
          "args": [
            "tb->transaction_handle",
            "NULL",
            "blocknr",
            "0"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "467-488",
          "snippet": "void reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_free_block(struct reiserfs_transaction_handle *th,\n\t\t\t struct inode *inode, b_blocknr_t block,\n\t\t\t int for_unformatted)\n{\n\tstruct super_block *s = th->t_super;\n\n\tBUG_ON(!th->t_trans_id);\n\tRFALSE(!s, \"vs-4061: trying to free block on nonexistent device\");\n\tif (!is_reusable(s, block, 1))\n\t\treturn;\n\n\tif (block > sb_block_count(REISERFS_SB(s)->s_rs)) {\n\t\treiserfs_error(th->t_super, \"bitmap-4072\",\n\t\t\t       \"Trying to free block outside file system \"\n\t\t\t       \"boundaries (%lu > %lu)\",\n\t\t\t       block, sb_block_count(REISERFS_SB(s)->s_rs));\n\t\treturn;\n\t}\n\t/* mark it before we clear it, just in case */\n\tjournal_mark_freed(th, s, block);\n\t_reiserfs_free_block(th, inode, block, for_unformatted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "tb->thrown[i]"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"reiserfs-12322\"",
            "\"called with dirty buffer %d\"",
            "blocknr"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "tb->thrown[i]"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tb->thrown"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void free_thrown(struct tree_balance *tb)\n{\n\tint i;\n\tb_blocknr_t blocknr;\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++) {\n\t\tif (tb->thrown[i]) {\n\t\t\tblocknr = tb->thrown[i]->b_blocknr;\n\t\t\tif (buffer_dirty(tb->thrown[i]))\n\t\t\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12322\",\n\t\t\t\t\t\t \"called with dirty buffer %d\",\n\t\t\t\t\t\t blocknr);\n\t\t\tbrelse(tb->thrown[i]);\t/* incremented in store_thrown */\n\t\t\treiserfs_free_block(tb->transaction_handle, NULL,\n\t\t\t\t\t    blocknr, 0);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "store_thrown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1516-1531",
    "snippet": "static void store_thrown(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tint i;\n\n\tif (buffer_dirty(bh))\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12320\",\n\t\t\t\t \"called with dirty buffer\");\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++)\n\t\tif (!tb->thrown[i]) {\n\t\t\ttb->thrown[i] = bh;\n\t\t\tget_bh(bh);\t/* free_thrown puts this */\n\t\t\treturn;\n\t\t}\n\treiserfs_warning(tb->tb_sb, \"reiserfs-12321\",\n\t\t\t \"too many thrown buffers\");\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"reiserfs-12321\"",
            "\"too many thrown buffers\""
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tb->thrown"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "tb->tb_sb",
            "\"reiserfs-12320\"",
            "\"called with dirty buffer\""
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void store_thrown(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tint i;\n\n\tif (buffer_dirty(bh))\n\t\treiserfs_warning(tb->tb_sb, \"reiserfs-12320\",\n\t\t\t\t \"called with dirty buffer\");\n\tfor (i = 0; i < ARRAY_SIZE(tb->thrown); i++)\n\t\tif (!tb->thrown[i]) {\n\t\t\ttb->thrown[i] = bh;\n\t\t\tget_bh(bh);\t/* free_thrown puts this */\n\t\t\treturn;\n\t\t}\n\treiserfs_warning(tb->tb_sb, \"reiserfs-12321\",\n\t\t\t \"too many thrown buffers\");\n}"
  },
  {
    "function_name": "get_FEB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1494-1513",
    "snippet": "struct buffer_head *get_FEB(struct tree_balance *tb)\n{\n\tint i;\n\tstruct buffer_info bi;\n\n\tfor (i = 0; i < MAX_FEB_SIZE; i++)\n\t\tif (tb->FEB[i] != NULL)\n\t\t\tbreak;\n\n\tif (i == MAX_FEB_SIZE)\n\t\treiserfs_panic(tb->tb_sb, \"vs-12300\", \"FEB list is empty\");\n\n\tbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\n\tmake_empty_node(&bi);\n\tset_buffer_uptodate(tb->FEB[i]);\n\ttb->used[i] = tb->FEB[i];\n\ttb->FEB[i] = NULL;\n\n\treturn tb->used[i];\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "tb->FEB[i]"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_empty_node",
          "args": [
            "&bi"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1479-1491",
          "snippet": "void make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_bh",
          "args": [
            "tb",
            "&bi",
            "tb->FEB[i]"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "46-54",
          "snippet": "static inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-12300\"",
            "\"FEB list is empty\""
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstruct buffer_head *get_FEB(struct tree_balance *tb)\n{\n\tint i;\n\tstruct buffer_info bi;\n\n\tfor (i = 0; i < MAX_FEB_SIZE; i++)\n\t\tif (tb->FEB[i] != NULL)\n\t\t\tbreak;\n\n\tif (i == MAX_FEB_SIZE)\n\t\treiserfs_panic(tb->tb_sb, \"vs-12300\", \"FEB list is empty\");\n\n\tbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\n\tmake_empty_node(&bi);\n\tset_buffer_uptodate(tb->FEB[i]);\n\ttb->used[i] = tb->FEB[i];\n\ttb->FEB[i] = NULL;\n\n\treturn tb->used[i];\n}"
  },
  {
    "function_name": "make_empty_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1479-1491",
    "snippet": "void make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "bi->bi_parent",
            "bi->bi_position"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "MAX_CHILD_SIZE(bi->bi_bh)"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "bi->bi_bh"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "0"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "bi->bi_bh"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "bi->bi_bh == NULL",
            "\"PAP-12295: pointer to the buffer is NULL\""
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}"
  },
  {
    "function_name": "balance_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1393-1476",
    "snippet": "static int balance_leaf(struct tree_balance *tb, struct item_head *ih,\n\t\t\tconst char *body, int flag,\n\t\t\tstruct item_head *insert_key,\n\t\t\tstruct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[0]);\n\n\t/* Make balance in case insert_size[0] < 0 */\n\tif (tb->insert_size[0] < 0)\n\t\treturn balance_leaf_when_delete(tb, flag);\n\n\ttb->item_pos = PATH_LAST_POSITION(tb->tb_path),\n\ttb->pos_in_item = tb->tb_path->pos_in_item,\n\ttb->zeroes_num = 0;\n\tif (flag == M_INSERT && !body)\n\t\ttb->zeroes_num = ih_item_len(ih);\n\n\t/*\n\t * for indirect item pos_in_item is measured in unformatted node\n\t * pointers. Recalculate to bytes\n\t */\n\tif (flag != M_INSERT\n\t    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))\n\t\ttb->pos_in_item *= UNFM_P_SIZE;\n\n\tbody += balance_leaf_left(tb, ih, body, flag);\n\n\t/* tb->lnum[0] > 0 */\n\t/* Calculate new item position */\n\ttb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));\n\n\tbalance_leaf_right(tb, ih, body, flag);\n\n\t/* tb->rnum[0] > 0 */\n\tRFALSE(tb->blknum[0] > 3,\n\t       \"PAP-12180: blknum can not be %d. It must be <= 3\", tb->blknum[0]);\n\tRFALSE(tb->blknum[0] < 0,\n\t       \"PAP-12185: blknum can not be %d. It must be >= 0\", tb->blknum[0]);\n\n\t/*\n\t * if while adding to a node we discover that it is possible to split\n\t * it in two, and merge the left part into the left neighbor and the\n\t * right part into the right neighbor, eliminating the node\n\t */\n\tif (tb->blknum[0] == 0) {\t/* node S[0] is empty now */\n\n\t\tRFALSE(!tb->lnum[0] || !tb->rnum[0],\n\t\t       \"PAP-12190: lnum and rnum must not be zero\");\n\t\t/*\n\t\t * if insertion was done before 0-th position in R[0], right\n\t\t * delimiting key of the tb->L[0]'s and left delimiting key are\n\t\t * not set correctly\n\t\t */\n\t\tif (tb->CFL[0]) {\n\t\t\tif (!tb->CFR[0])\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-12195\",\n\t\t\t\t\t       \"CFR not initialized\");\n\t\t\tcopy_key(internal_key(tb->CFL[0], tb->lkey[0]),\n\t\t\t\t internal_key(tb->CFR[0], tb->rkey[0]));\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->CFL[0], 0);\n\t\t}\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tbalance_leaf_new_nodes(tb, ih, body, insert_key, insert_ptr, flag);\n\n\tbalance_leaf_finish_node(tb, ih, body, flag);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (flag == M_PASTE && tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12290\");\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t       \"PAP-12290\", \"insert_size is still not 0 (%d)\",\n\t\t\t       tb->insert_size[0]);\n\t}\n#endif\n\n\t/* Leaf level of the tree is balanced (end of balance_leaf) */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-12290\"",
            "\"insert_size is still not 0 (%d)\"",
            "tb->insert_size[0]"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "\"12290\""
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_finish_node",
          "args": [
            "tb",
            "ih",
            "body",
            "flag"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_finish_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1366-1377",
          "snippet": "static void balance_leaf_finish_node(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\t/* if we must insert or append into buffer S[0] */\n\tif (0 <= tb->item_pos && tb->item_pos < tb->s0num) {\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_finish_node_insert(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_finish_node_paste(tb, ih, body);\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\t/* if we must insert or append into buffer S[0] */\n\tif (0 <= tb->item_pos && tb->item_pos < tb->s0num) {\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_finish_node_insert(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_finish_node_paste(tb, ih, body);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_new_nodes",
          "args": [
            "tb",
            "ih",
            "body",
            "insert_key",
            "insert_ptr",
            "flag"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_new_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1231-1269",
          "snippet": "static void balance_leaf_new_nodes(struct tree_balance *tb,\n\t\t\t\t   struct item_head * const ih,\n\t\t\t\t   const char * const body,\n\t\t\t\t   struct item_head *insert_key,\n\t\t\t\t   struct buffer_head **insert_ptr,\n\t\t\t\t   int flag)\n{\n\tint i;\n\tfor (i = tb->blknum[0] - 2; i >= 0; i--) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tRFALSE(!tb->snum[i],\n\t\t       \"PAP-12200: snum[%d] == %d. Must be > 0\", i,\n\t\t       tb->snum[i]);\n\n\t\t/* here we shift from S to S_new nodes */\n\n\t\ttb->S_new[i] = get_FEB(tb);\n\n\t\t/* initialized block type and tree level */\n\t\tset_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);\n\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_new_nodes_insert(tb, ih, body, insert_key,\n\t\t\t\t\t\t      insert_ptr, i);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_new_nodes_paste(tb, ih, body, insert_key,\n\t\t\t\t\t\t     insert_ptr, i);\n\n\t\tmemcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);\n\t\tinsert_ptr[i] = tb->S_new[i];\n\n\t\tRFALSE(!buffer_journaled(tb->S_new[i])\n\t\t       || buffer_journal_dirty(tb->S_new[i])\n\t\t       || buffer_dirty(tb->S_new[i]),\n\t\t       \"PAP-12247: S_new[%d] : (%b)\",\n\t\t       i, tb->S_new[i]);\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes(struct tree_balance *tb,\n\t\t\t\t   struct item_head * const ih,\n\t\t\t\t   const char * const body,\n\t\t\t\t   struct item_head *insert_key,\n\t\t\t\t   struct buffer_head **insert_ptr,\n\t\t\t\t   int flag)\n{\n\tint i;\n\tfor (i = tb->blknum[0] - 2; i >= 0; i--) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tRFALSE(!tb->snum[i],\n\t\t       \"PAP-12200: snum[%d] == %d. Must be > 0\", i,\n\t\t       tb->snum[i]);\n\n\t\t/* here we shift from S to S_new nodes */\n\n\t\ttb->S_new[i] = get_FEB(tb);\n\n\t\t/* initialized block type and tree level */\n\t\tset_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);\n\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_new_nodes_insert(tb, ih, body, insert_key,\n\t\t\t\t\t\t      insert_ptr, i);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_new_nodes_paste(tb, ih, body, insert_key,\n\t\t\t\t\t\t     insert_ptr, i);\n\n\t\tmemcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);\n\t\tinsert_ptr[i] = tb->S_new[i];\n\n\t\tRFALSE(!buffer_journaled(tb->S_new[i])\n\t\t       || buffer_journal_dirty(tb->S_new[i])\n\t\t       || buffer_dirty(tb->S_new[i]),\n\t\t       \"PAP-12247: S_new[%d] : (%b)\",\n\t\t       i, tb->S_new[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_invalidate_buffer",
          "args": [
            "tb",
            "tbS0"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_invalidate_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1551-1560",
          "snippet": "void reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "tb->CFL[0]",
            "0"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_key",
          "args": [
            "internal_key(tb->CFL[0], tb->lkey[0])",
            "internal_key(tb->CFR[0], tb->rkey[0])"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "copy_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2993-2997",
          "snippet": "static inline void copy_key(struct reiserfs_key *to,\n\t\t\t    const struct reiserfs_key *from)\n{\n\tmemcpy(to, from, KEY_SIZE);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define KEY_SIZE (sizeof(struct reiserfs_key))"
          ],
          "globals_used": [
            "int reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to);",
            "extern void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from);",
            "extern void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define KEY_SIZE (sizeof(struct reiserfs_key))\n\nint reiserfs_commit_page(struct inode *inode, struct page *page,\n\t\t\t unsigned from, unsigned to);\nextern void copy_item_head(struct item_head *to,\n\t\t\t   const struct item_head *from);\nextern void le_key2cpu_key(struct cpu_key *to, const struct reiserfs_key *from);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\n\nstatic inline void copy_key(struct reiserfs_key *to,\n\t\t\t    const struct reiserfs_key *from)\n{\n\tmemcpy(to, from, KEY_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFR[0]",
            "tb->rkey[0]"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"vs-12195\"",
            "\"CFR not initialized\""
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->lnum[0] || !tb->rnum[0]",
            "\"PAP-12190: lnum and rnum must not be zero\""
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->blknum[0] < 0",
            "\"PAP-12185: blknum can not be %d. It must be >= 0\"",
            "tb->blknum[0]"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->blknum[0] > 3",
            "\"PAP-12180: blknum can not be %d. It must be <= 3\"",
            "tb->blknum[0]"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_leaf_right",
          "args": [
            "tb",
            "ih",
            "body",
            "flag"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "913-926",
          "snippet": "static void balance_leaf_right(struct tree_balance *tb,\n\t\t\t       struct item_head * const ih,\n\t\t\t       const char * const body, int flag)\n{\n\tif (tb->rnum[0] <= 0)\n\t\treturn;\n\n\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\tif (flag == M_INSERT)\n\t\tbalance_leaf_insert_right(tb, ih, body);\n\telse /* M_PASTE */\n\t\tbalance_leaf_paste_right(tb, ih, body);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_right(struct tree_balance *tb,\n\t\t\t       struct item_head * const ih,\n\t\t\t       const char * const body, int flag)\n{\n\tif (tb->rnum[0] <= 0)\n\t\treturn;\n\n\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\tif (flag == M_INSERT)\n\t\tbalance_leaf_insert_right(tb, ih, body);\n\telse /* M_PASTE */\n\t\tbalance_leaf_paste_right(tb, ih, body);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_left",
          "args": [
            "tb",
            "ih",
            "body",
            "flag"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "605-624",
          "snippet": "static unsigned int balance_leaf_left(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\tif (tb->lnum[0] <= 0)\n\t\treturn 0;\n\n\t/* new item or it part falls to L[0], shift it too */\n\tif (tb->item_pos < tb->lnum[0]) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tif (flag == M_INSERT)\n\t\t\treturn balance_leaf_insert_left(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\treturn balance_leaf_paste_left(tb, ih, body);\n\t} else\n\t\t/* new item doesn't fall into L[0] */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_left(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\tif (tb->lnum[0] <= 0)\n\t\treturn 0;\n\n\t/* new item or it part falls to L[0], shift it too */\n\tif (tb->item_pos < tb->lnum[0]) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tif (flag == M_INSERT)\n\t\t\treturn balance_leaf_insert_left(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\treturn balance_leaf_paste_left(tb, ih, body);\n\t} else\n\t\t/* new item doesn't fall into L[0] */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "tb->item_pos"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "tb->tb_path"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_leaf_when_delete",
          "args": [
            "tb",
            "flag"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_when_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "239-287",
          "snippet": "static int balance_leaf_when_delete(struct tree_balance *tb, int flag)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n\tint n;\n\tstruct item_head *ih;\n\n\tRFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,\n\t       \"vs- 12000: level: wrong FR %z\", tb->FR[0]);\n\tRFALSE(tb->blknum[0] > 1,\n\t       \"PAP-12005: tb->blknum == %d, can not be > 1\", tb->blknum[0]);\n\tRFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"PAP-12010: tree can not be empty\");\n\n\tih = item_head(tbS0, item_pos);\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\t/* Delete or truncate the item */\n\n\tBUG_ON(flag != M_DELETE && flag != M_CUT);\n\tif (flag == M_DELETE)\n\t\tbalance_leaf_when_delete_del(tb);\n\telse /* M_CUT */\n\t\tbalance_leaf_when_delete_cut(tb);\n\n\n\t/*\n\t * the rule is that no shifting occurs unless by shifting\n\t * a node can be freed\n\t */\n\tn = B_NR_ITEMS(tbS0);\n\n\n\t/* L[0] takes part in balancing */\n\tif (tb->lnum[0])\n\t\treturn balance_leaf_when_delete_left(tb);\n\n\tif (tb->rnum[0] == -1) {\n\t\t/* all contents of R[0] and S[0] will be in R[0] */\n\t\tleaf_shift_right(tb, n, -1);\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->rnum[0],\n\t       \"PAP-12065: bad rnum parameter must be 0 (%d)\", tb->rnum[0]);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int balance_leaf_when_delete(struct tree_balance *tb, int flag)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n\tint n;\n\tstruct item_head *ih;\n\n\tRFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,\n\t       \"vs- 12000: level: wrong FR %z\", tb->FR[0]);\n\tRFALSE(tb->blknum[0] > 1,\n\t       \"PAP-12005: tb->blknum == %d, can not be > 1\", tb->blknum[0]);\n\tRFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"PAP-12010: tree can not be empty\");\n\n\tih = item_head(tbS0, item_pos);\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\t/* Delete or truncate the item */\n\n\tBUG_ON(flag != M_DELETE && flag != M_CUT);\n\tif (flag == M_DELETE)\n\t\tbalance_leaf_when_delete_del(tb);\n\telse /* M_CUT */\n\t\tbalance_leaf_when_delete_cut(tb);\n\n\n\t/*\n\t * the rule is that no shifting occurs unless by shifting\n\t * a node can be freed\n\t */\n\tn = B_NR_ITEMS(tbS0);\n\n\n\t/* L[0] takes part in balancing */\n\tif (tb->lnum[0])\n\t\treturn balance_leaf_when_delete_left(tb);\n\n\tif (tb->rnum[0] == -1) {\n\t\t/* all contents of R[0] and S[0] will be in R[0] */\n\t\tleaf_shift_right(tb, n, -1);\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->rnum[0],\n\t       \"PAP-12065: bad rnum parameter must be 0 (%d)\", tb->rnum[0]);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "tb->tb_sb",
            "balance_at[0]"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nstatic int balance_leaf(struct tree_balance *tb, struct item_head *ih,\n\t\t\tconst char *body, int flag,\n\t\t\tstruct item_head *insert_key,\n\t\t\tstruct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[0]);\n\n\t/* Make balance in case insert_size[0] < 0 */\n\tif (tb->insert_size[0] < 0)\n\t\treturn balance_leaf_when_delete(tb, flag);\n\n\ttb->item_pos = PATH_LAST_POSITION(tb->tb_path),\n\ttb->pos_in_item = tb->tb_path->pos_in_item,\n\ttb->zeroes_num = 0;\n\tif (flag == M_INSERT && !body)\n\t\ttb->zeroes_num = ih_item_len(ih);\n\n\t/*\n\t * for indirect item pos_in_item is measured in unformatted node\n\t * pointers. Recalculate to bytes\n\t */\n\tif (flag != M_INSERT\n\t    && is_indirect_le_ih(item_head(tbS0, tb->item_pos)))\n\t\ttb->pos_in_item *= UNFM_P_SIZE;\n\n\tbody += balance_leaf_left(tb, ih, body, flag);\n\n\t/* tb->lnum[0] > 0 */\n\t/* Calculate new item position */\n\ttb->item_pos -= (tb->lnum[0] - ((tb->lbytes != -1) ? 1 : 0));\n\n\tbalance_leaf_right(tb, ih, body, flag);\n\n\t/* tb->rnum[0] > 0 */\n\tRFALSE(tb->blknum[0] > 3,\n\t       \"PAP-12180: blknum can not be %d. It must be <= 3\", tb->blknum[0]);\n\tRFALSE(tb->blknum[0] < 0,\n\t       \"PAP-12185: blknum can not be %d. It must be >= 0\", tb->blknum[0]);\n\n\t/*\n\t * if while adding to a node we discover that it is possible to split\n\t * it in two, and merge the left part into the left neighbor and the\n\t * right part into the right neighbor, eliminating the node\n\t */\n\tif (tb->blknum[0] == 0) {\t/* node S[0] is empty now */\n\n\t\tRFALSE(!tb->lnum[0] || !tb->rnum[0],\n\t\t       \"PAP-12190: lnum and rnum must not be zero\");\n\t\t/*\n\t\t * if insertion was done before 0-th position in R[0], right\n\t\t * delimiting key of the tb->L[0]'s and left delimiting key are\n\t\t * not set correctly\n\t\t */\n\t\tif (tb->CFL[0]) {\n\t\t\tif (!tb->CFR[0])\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-12195\",\n\t\t\t\t\t       \"CFR not initialized\");\n\t\t\tcopy_key(internal_key(tb->CFL[0], tb->lkey[0]),\n\t\t\t\t internal_key(tb->CFR[0], tb->rkey[0]));\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->CFL[0], 0);\n\t\t}\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tbalance_leaf_new_nodes(tb, ih, body, insert_key, insert_ptr, flag);\n\n\tbalance_leaf_finish_node(tb, ih, body, flag);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (flag == M_PASTE && tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12290\");\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t       \"PAP-12290\", \"insert_size is still not 0 (%d)\",\n\t\t\t       tb->insert_size[0]);\n\t}\n#endif\n\n\t/* Leaf level of the tree is balanced (end of balance_leaf) */\n\treturn 0;\n}"
  },
  {
    "function_name": "balance_leaf_finish_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1366-1377",
    "snippet": "static void balance_leaf_finish_node(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\t/* if we must insert or append into buffer S[0] */\n\tif (0 <= tb->item_pos && tb->item_pos < tb->s0num) {\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_finish_node_insert(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_finish_node_paste(tb, ih, body);\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_leaf_finish_node_paste",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_finish_node_paste",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1322-1359",
          "snippet": "static void balance_leaf_finish_node_paste(struct tree_balance *tb,\n\t\t\t\t\t   struct item_head * const ih,\n\t\t\t\t\t   const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\n\t/* when directory, may be new entry already pasted */\n\tif (is_direntry_le_ih(pasted)) {\n\t\tbalance_leaf_finish_node_paste_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\tif (tb->pos_in_item == ih_item_len(pasted)) {\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12275: insert size must not be %d\",\n\t\t       tb->insert_size[0]);\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos,\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\n\t\tif (is_indirect_le_ih(pasted))\n\t\t\tset_ih_free_space(pasted, 0);\n\n\t\ttb->insert_size[0] = 0;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\telse if (tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12285\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12285\",\n\t\t    \"insert_size must be 0 (%d)\", tb->insert_size[0]);\n\t}\n#endif\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node_paste(struct tree_balance *tb,\n\t\t\t\t\t   struct item_head * const ih,\n\t\t\t\t\t   const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\n\t/* when directory, may be new entry already pasted */\n\tif (is_direntry_le_ih(pasted)) {\n\t\tbalance_leaf_finish_node_paste_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\tif (tb->pos_in_item == ih_item_len(pasted)) {\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12275: insert size must not be %d\",\n\t\t       tb->insert_size[0]);\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos,\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\n\t\tif (is_indirect_le_ih(pasted))\n\t\t\tset_ih_free_space(pasted, 0);\n\n\t\ttb->insert_size[0] = 0;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\telse if (tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12285\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12285\",\n\t\t    \"insert_size must be 0 (%d)\", tb->insert_size[0]);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_finish_node_insert",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_finish_node_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1271-1286",
          "snippet": "static void balance_leaf_finish_node_insert(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_insert_into_buf(&bi, tb->item_pos, ih, body, tb->zeroes_num);\n\n\t/* If we insert the first key change the delimiting key */\n\tif (tb->item_pos == 0) {\n\t\tif (tb->CFL[0])\t/* can be 0 in reiserfsck */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node_insert(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_insert_into_buf(&bi, tb->item_pos, ih, body, tb->zeroes_num);\n\n\t/* If we insert the first key change the delimiting key */\n\tif (tb->item_pos == 0) {\n\t\tif (tb->CFL[0])\t/* can be 0 in reiserfsck */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\t/* if we must insert or append into buffer S[0] */\n\tif (0 <= tb->item_pos && tb->item_pos < tb->s0num) {\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_finish_node_insert(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_finish_node_paste(tb, ih, body);\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_finish_node_paste",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1322-1359",
    "snippet": "static void balance_leaf_finish_node_paste(struct tree_balance *tb,\n\t\t\t\t\t   struct item_head * const ih,\n\t\t\t\t\t   const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\n\t/* when directory, may be new entry already pasted */\n\tif (is_direntry_le_ih(pasted)) {\n\t\tbalance_leaf_finish_node_paste_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\tif (tb->pos_in_item == ih_item_len(pasted)) {\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12275: insert size must not be %d\",\n\t\t       tb->insert_size[0]);\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos,\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\n\t\tif (is_indirect_le_ih(pasted))\n\t\t\tset_ih_free_space(pasted, 0);\n\n\t\ttb->insert_size[0] = 0;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\telse if (tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12285\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12285\",\n\t\t    \"insert_size must be 0 (%d)\", tb->insert_size[0]);\n\t}\n#endif\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-12285\"",
            "\"insert_size must be 0 (%d)\"",
            "tb->insert_size[0]"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cur_tb",
          "args": [
            "\"12285\""
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "print_cur_tb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "708-711",
          "snippet": "void print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char print_tb_buf[2048];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char print_tb_buf[2048];\n\nvoid print_cur_tb(char *mes)\n{\n\tprintk(\"%s\\n%s\", mes, print_tb_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "pasted",
            "0"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "pasted"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "tb->item_pos",
            "tb->pos_in_item",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_tbS0",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_tbS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "37-44",
          "snippet": "static inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->insert_size[0] <= 0",
            "\"PAP-12275: insert size must not be %d\"",
            "tb->insert_size[0]"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "pasted"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_leaf_finish_node_paste_dirent",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_finish_node_paste_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1288-1320",
          "snippet": "static void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\tstruct buffer_info bi;\n\n\tif (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12260: insert_size is 0 already\");\n\n\t\t/* prepare space */\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->item_pos && !tb->pos_in_item) {\n\t\t\tRFALSE(!tb->CFL[0] || !tb->L[0],\n\t\t\t       \"PAP-12270: CFL[0]/L[0] must  be specified\");\n\t\t\tif (tb->CFL[0])\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    tbS0, 0);\n\t\t}\n\n\t\ttb->insert_size[0] = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\tstruct buffer_info bi;\n\n\tif (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12260: insert_size is 0 already\");\n\n\t\t/* prepare space */\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->item_pos && !tb->pos_in_item) {\n\t\t\tRFALSE(!tb->CFL[0] || !tb->L[0],\n\t\t\t       \"PAP-12270: CFL[0]/L[0] must  be specified\");\n\t\t\tif (tb->CFL[0])\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    tbS0, 0);\n\t\t}\n\n\t\ttb->insert_size[0] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "pasted"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "tb->item_pos"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node_paste(struct tree_balance *tb,\n\t\t\t\t\t   struct item_head * const ih,\n\t\t\t\t\t   const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\n\t/* when directory, may be new entry already pasted */\n\tif (is_direntry_le_ih(pasted)) {\n\t\tbalance_leaf_finish_node_paste_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\tif (tb->pos_in_item == ih_item_len(pasted)) {\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12275: insert size must not be %d\",\n\t\t       tb->insert_size[0]);\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos,\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\n\t\tif (is_indirect_le_ih(pasted))\n\t\t\tset_ih_free_space(pasted, 0);\n\n\t\ttb->insert_size[0] = 0;\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\telse if (tb->insert_size[0]) {\n\t\tprint_cur_tb(\"12285\");\n\t\treiserfs_panic(tb->tb_sb, \"PAP-12285\",\n\t\t    \"insert_size must be 0 (%d)\", tb->insert_size[0]);\n\t}\n#endif\n}"
  },
  {
    "function_name": "balance_leaf_finish_node_paste_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1288-1320",
    "snippet": "static void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\tstruct buffer_info bi;\n\n\tif (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12260: insert_size is 0 already\");\n\n\t\t/* prepare space */\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->item_pos && !tb->pos_in_item) {\n\t\t\tRFALSE(!tb->CFL[0] || !tb->L[0],\n\t\t\t       \"PAP-12270: CFL[0]/L[0] must  be specified\");\n\t\t\tif (tb->CFL[0])\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    tbS0, 0);\n\t\t}\n\n\t\ttb->insert_size[0] = 0;\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFL[0]",
            "tb->lkey[0]",
            "tbS0",
            "0"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->CFL[0] || !tb->L[0]",
            "\"PAP-12270: CFL[0]/L[0] must  be specified\""
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "&bi",
            "tb->item_pos",
            "tb->pos_in_item",
            "1",
            "(struct reiserfs_de_head *)body",
            "body + DEH_SIZE",
            "tb->insert_size[0]"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "tb->item_pos",
            "tb->pos_in_item",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_tbS0",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_tbS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "37-44",
          "snippet": "static inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->insert_size[0]",
            "\"PAP-12260: insert_size is 0 already\""
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "pasted"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "tb->item_pos"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *pasted = item_head(tbS0, tb->item_pos);\n\tstruct buffer_info bi;\n\n\tif (tb->pos_in_item >= 0 && tb->pos_in_item <= ih_entry_count(pasted)) {\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12260: insert_size is 0 already\");\n\n\t\t/* prepare space */\n\t\tbuffer_info_init_tbS0(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos, tb->pos_in_item,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, tb->item_pos, tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->item_pos && !tb->pos_in_item) {\n\t\t\tRFALSE(!tb->CFL[0] || !tb->L[0],\n\t\t\t       \"PAP-12270: CFL[0]/L[0] must  be specified\");\n\t\t\tif (tb->CFL[0])\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    tbS0, 0);\n\t\t}\n\n\t\ttb->insert_size[0] = 0;\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_finish_node_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1271-1286",
    "snippet": "static void balance_leaf_finish_node_insert(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_insert_into_buf(&bi, tb->item_pos, ih, body, tb->zeroes_num);\n\n\t/* If we insert the first key change the delimiting key */\n\tif (tb->item_pos == 0) {\n\t\tif (tb->CFL[0])\t/* can be 0 in reiserfsck */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFL[0]",
            "tb->lkey[0]",
            "tbS0",
            "0"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_insert_into_buf",
          "args": [
            "&bi",
            "tb->item_pos",
            "ih",
            "body",
            "tb->zeroes_num"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_insert_into_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "901-972",
          "snippet": "void leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_tbS0",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_tbS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "37-44",
          "snippet": "static inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_finish_node_insert(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_insert_into_buf(&bi, tb->item_pos, ih, body, tb->zeroes_num);\n\n\t/* If we insert the first key change the delimiting key */\n\tif (tb->item_pos == 0) {\n\t\tif (tb->CFL[0])\t/* can be 0 in reiserfsck */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_new_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1231-1269",
    "snippet": "static void balance_leaf_new_nodes(struct tree_balance *tb,\n\t\t\t\t   struct item_head * const ih,\n\t\t\t\t   const char * const body,\n\t\t\t\t   struct item_head *insert_key,\n\t\t\t\t   struct buffer_head **insert_ptr,\n\t\t\t\t   int flag)\n{\n\tint i;\n\tfor (i = tb->blknum[0] - 2; i >= 0; i--) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tRFALSE(!tb->snum[i],\n\t\t       \"PAP-12200: snum[%d] == %d. Must be > 0\", i,\n\t\t       tb->snum[i]);\n\n\t\t/* here we shift from S to S_new nodes */\n\n\t\ttb->S_new[i] = get_FEB(tb);\n\n\t\t/* initialized block type and tree level */\n\t\tset_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);\n\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_new_nodes_insert(tb, ih, body, insert_key,\n\t\t\t\t\t\t      insert_ptr, i);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_new_nodes_paste(tb, ih, body, insert_key,\n\t\t\t\t\t\t     insert_ptr, i);\n\n\t\tmemcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);\n\t\tinsert_ptr[i] = tb->S_new[i];\n\n\t\tRFALSE(!buffer_journaled(tb->S_new[i])\n\t\t       || buffer_journal_dirty(tb->S_new[i])\n\t\t       || buffer_dirty(tb->S_new[i]),\n\t\t       \"PAP-12247: S_new[%d] : (%b)\",\n\t\t       i, tb->S_new[i]);\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!buffer_journaled(tb->S_new[i])\n\t\t       || buffer_journal_dirty(tb->S_new[i])\n\t\t       || buffer_dirty(tb->S_new[i])",
            "\"PAP-12247: S_new[%d] : (%b)\"",
            "i",
            "tb->S_new[i]"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "tb->S_new[i]"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "tb->S_new[i]"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "tb->S_new[i]"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "insert_key + i",
            "leaf_key(tb->S_new[i], 0)",
            "KEY_SIZE"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_key",
          "args": [
            "tb->S_new[i]",
            "0"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2207-2211",
          "snippet": "static inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_new_nodes_paste",
          "args": [
            "tb",
            "ih",
            "body",
            "insert_key",
            "insert_ptr",
            "i"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_new_nodes_paste",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1201-1228",
          "snippet": "static void balance_leaf_new_nodes_paste(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* pasted item doesn't fall into S_new[i] */\n\tif (n - tb->snum[i] > tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* pasted item or part if it falls to S_new[i] */\n\n\tif (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1)\n\t\t/* we must shift part of the appended item */\n\t\tbalance_leaf_new_nodes_paste_shift(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n\telse\n\t\t/* item falls wholly into S_new[i] */\n\t\tbalance_leaf_new_nodes_paste_whole(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* pasted item doesn't fall into S_new[i] */\n\tif (n - tb->snum[i] > tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* pasted item or part if it falls to S_new[i] */\n\n\tif (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1)\n\t\t/* we must shift part of the appended item */\n\t\tbalance_leaf_new_nodes_paste_shift(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n\telse\n\t\t/* item falls wholly into S_new[i] */\n\t\tbalance_leaf_new_nodes_paste_whole(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_new_nodes_insert",
          "args": [
            "tb",
            "ih",
            "body",
            "insert_key",
            "insert_ptr",
            "i"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_new_nodes_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "928-1017",
          "snippet": "static void balance_leaf_new_nodes_insert(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body,\n\t\t\t\t\t  struct item_head *insert_key,\n\t\t\t\t\t  struct buffer_head **insert_ptr,\n\t\t\t\t\t  int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint shift;\n\n\t/* new item or it part don't falls into S_new[i] */\n\tif (n - tb->snum[i] >= tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* new item or it's part falls to first new node S_new[i] */\n\n\t/* part of new item falls into S_new[i] */\n\tif (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {\n\t\tint old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version;\n\n\t\t/* Move snum[i]-1 items from S[0] to S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,\n\t\t\t\ttb->S_new[i]);\n\n\t\t/* Remember key component and item length */\n\t\tversion = ih_version(ih);\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into S_new[i]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\tset_le_ih_k_offset(ih,\n\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t   ((old_len - tb->sbytes[i]) << shift));\n\n\t\tput_ih_item_len(ih, tb->sbytes[i]);\n\n\t\t/* Insert part of the item into S_new[i] before 0-th item */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\n\t\tif ((old_len - tb->sbytes[i]) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->sbytes[i]) -\n\t\t\t\t\t tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num - (old_len -\n\t\t\t\t\t  tb->sbytes[i]);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[i]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->sbytes[i]);\n\t\ttb->insert_size[0] -= tb->sbytes[i];\n\t} else {\n\t\t/* whole new item falls into S_new[i] */\n\n\t\t/*\n\t\t * Shift snum[0] - 1 items to S_new[i]\n\t\t * (sbytes[i] of split item)\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);\n\n\t\t/* Insert new item into S_new[i] */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_insert(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body,\n\t\t\t\t\t  struct item_head *insert_key,\n\t\t\t\t\t  struct buffer_head **insert_ptr,\n\t\t\t\t\t  int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint shift;\n\n\t/* new item or it part don't falls into S_new[i] */\n\tif (n - tb->snum[i] >= tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* new item or it's part falls to first new node S_new[i] */\n\n\t/* part of new item falls into S_new[i] */\n\tif (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {\n\t\tint old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version;\n\n\t\t/* Move snum[i]-1 items from S[0] to S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,\n\t\t\t\ttb->S_new[i]);\n\n\t\t/* Remember key component and item length */\n\t\tversion = ih_version(ih);\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into S_new[i]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\tset_le_ih_k_offset(ih,\n\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t   ((old_len - tb->sbytes[i]) << shift));\n\n\t\tput_ih_item_len(ih, tb->sbytes[i]);\n\n\t\t/* Insert part of the item into S_new[i] before 0-th item */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\n\t\tif ((old_len - tb->sbytes[i]) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->sbytes[i]) -\n\t\t\t\t\t tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num - (old_len -\n\t\t\t\t\t  tb->sbytes[i]);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[i]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->sbytes[i]);\n\t\ttb->insert_size[0] -= tb->sbytes[i];\n\t} else {\n\t\t/* whole new item falls into S_new[i] */\n\n\t\t/*\n\t\t * Shift snum[0] - 1 items to S_new[i]\n\t\t * (sbytes[i] of split item)\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);\n\n\t\t/* Insert new item into S_new[i] */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_blkh_level",
          "args": [
            "B_BLK_HEAD(tb->S_new[i])",
            "DISK_LEAF_NODE_LEVEL"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "tb->S_new[i]"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_FEB",
          "args": [
            "tb"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "get_FEB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1494-1513",
          "snippet": "struct buffer_head *get_FEB(struct tree_balance *tb)\n{\n\tint i;\n\tstruct buffer_info bi;\n\n\tfor (i = 0; i < MAX_FEB_SIZE; i++)\n\t\tif (tb->FEB[i] != NULL)\n\t\t\tbreak;\n\n\tif (i == MAX_FEB_SIZE)\n\t\treiserfs_panic(tb->tb_sb, \"vs-12300\", \"FEB list is empty\");\n\n\tbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\n\tmake_empty_node(&bi);\n\tset_buffer_uptodate(tb->FEB[i]);\n\ttb->used[i] = tb->FEB[i];\n\ttb->FEB[i] = NULL;\n\n\treturn tb->used[i];\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstruct buffer_head *get_FEB(struct tree_balance *tb)\n{\n\tint i;\n\tstruct buffer_info bi;\n\n\tfor (i = 0; i < MAX_FEB_SIZE; i++)\n\t\tif (tb->FEB[i] != NULL)\n\t\t\tbreak;\n\n\tif (i == MAX_FEB_SIZE)\n\t\treiserfs_panic(tb->tb_sb, \"vs-12300\", \"FEB list is empty\");\n\n\tbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\n\tmake_empty_node(&bi);\n\tset_buffer_uptodate(tb->FEB[i]);\n\ttb->used[i] = tb->FEB[i];\n\ttb->FEB[i] = NULL;\n\n\treturn tb->used[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->snum[i]",
            "\"PAP-12200: snum[%d] == %d. Must be > 0\"",
            "i",
            "tb->snum[i]"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flag != M_INSERT && flag != M_PASTE"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes(struct tree_balance *tb,\n\t\t\t\t   struct item_head * const ih,\n\t\t\t\t   const char * const body,\n\t\t\t\t   struct item_head *insert_key,\n\t\t\t\t   struct buffer_head **insert_ptr,\n\t\t\t\t   int flag)\n{\n\tint i;\n\tfor (i = tb->blknum[0] - 2; i >= 0; i--) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tRFALSE(!tb->snum[i],\n\t\t       \"PAP-12200: snum[%d] == %d. Must be > 0\", i,\n\t\t       tb->snum[i]);\n\n\t\t/* here we shift from S to S_new nodes */\n\n\t\ttb->S_new[i] = get_FEB(tb);\n\n\t\t/* initialized block type and tree level */\n\t\tset_blkh_level(B_BLK_HEAD(tb->S_new[i]), DISK_LEAF_NODE_LEVEL);\n\n\t\tif (flag == M_INSERT)\n\t\t\tbalance_leaf_new_nodes_insert(tb, ih, body, insert_key,\n\t\t\t\t\t\t      insert_ptr, i);\n\t\telse /* M_PASTE */\n\t\t\tbalance_leaf_new_nodes_paste(tb, ih, body, insert_key,\n\t\t\t\t\t\t     insert_ptr, i);\n\n\t\tmemcpy(insert_key + i, leaf_key(tb->S_new[i], 0), KEY_SIZE);\n\t\tinsert_ptr[i] = tb->S_new[i];\n\n\t\tRFALSE(!buffer_journaled(tb->S_new[i])\n\t\t       || buffer_journal_dirty(tb->S_new[i])\n\t\t       || buffer_dirty(tb->S_new[i]),\n\t\t       \"PAP-12247: S_new[%d] : (%b)\",\n\t\t       i, tb->S_new[i]);\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_new_nodes_paste",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1201-1228",
    "snippet": "static void balance_leaf_new_nodes_paste(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* pasted item doesn't fall into S_new[i] */\n\tif (n - tb->snum[i] > tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* pasted item or part if it falls to S_new[i] */\n\n\tif (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1)\n\t\t/* we must shift part of the appended item */\n\t\tbalance_leaf_new_nodes_paste_shift(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n\telse\n\t\t/* item falls wholly into S_new[i] */\n\t\tbalance_leaf_new_nodes_paste_whole(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_leaf_new_nodes_paste_whole",
          "args": [
            "tb",
            "ih",
            "body",
            "insert_key",
            "insert_ptr",
            "i"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_new_nodes_paste_whole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1148-1200",
          "snippet": "static void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,\n\t\t\t\t\t       struct item_head * const ih,\n\t\t\t\t\t       const char * const body,\n\t\t\t\t\t       struct item_head *insert_key,\n\t\t\t\t\t       struct buffer_head **insert_ptr,\n\t\t\t\t\t       int i)\n\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tint leaf_mi;\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih_check = item_head(tbS0, tb->item_pos);\n\n\tif (!is_direntry_le_ih(ih_check) &&\n\t    (tb->pos_in_item != ih_item_len(ih_check) ||\n\t    tb->insert_size[0] <= 0))\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t     \"PAP-12235\",\n\t\t\t     \"pos_in_item must be equal to ih_item_len\");\n#endif\n\n\tleaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\t  tb->sbytes[i], tb->S_new[i]);\n\n\tRFALSE(leaf_mi,\n\t       \"PAP-12240: unexpected value returned by leaf_move_items (%d)\",\n\t       leaf_mi);\n\n\t/* paste into item */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t     tb->pos_in_item, tb->insert_size[0],\n\t\t\t     body, tb->zeroes_num);\n\n\tpasted = item_head(tb->S_new[i], tb->item_pos - n +\n\t\t\t   tb->snum[i]);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/* if we paste to indirect item update ih_free_space */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,\n\t\t\t\t\t       struct item_head * const ih,\n\t\t\t\t\t       const char * const body,\n\t\t\t\t\t       struct item_head *insert_key,\n\t\t\t\t\t       struct buffer_head **insert_ptr,\n\t\t\t\t\t       int i)\n\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tint leaf_mi;\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih_check = item_head(tbS0, tb->item_pos);\n\n\tif (!is_direntry_le_ih(ih_check) &&\n\t    (tb->pos_in_item != ih_item_len(ih_check) ||\n\t    tb->insert_size[0] <= 0))\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t     \"PAP-12235\",\n\t\t\t     \"pos_in_item must be equal to ih_item_len\");\n#endif\n\n\tleaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\t  tb->sbytes[i], tb->S_new[i]);\n\n\tRFALSE(leaf_mi,\n\t       \"PAP-12240: unexpected value returned by leaf_move_items (%d)\",\n\t       leaf_mi);\n\n\t/* paste into item */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t     tb->pos_in_item, tb->insert_size[0],\n\t\t\t     body, tb->zeroes_num);\n\n\tpasted = item_head(tb->S_new[i], tb->item_pos - n +\n\t\t\t   tb->snum[i]);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/* if we paste to indirect item update ih_free_space */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_new_nodes_paste_shift",
          "args": [
            "tb",
            "ih",
            "body",
            "insert_key",
            "insert_ptr",
            "i"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_new_nodes_paste_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1075-1146",
          "snippet": "static void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint n_shift, n_rem, r_zeroes_number, shift;\n\tconst char *r_body;\n\tstruct item_head *tmp;\n\tstruct buffer_info bi;\n\n\tRFALSE(ih, \"PAP-12210: ih must be 0\");\n\n\tif (is_direntry_le_ih(aux_ih)) {\n\t\tbalance_leaf_new_nodes_paste_dirent(tb, ih, body, insert_key,\n\t\t\t\t\t\t    insert_ptr, i);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||\n\t       tb->insert_size[0] <= 0,\n\t       \"PAP-12225: item too short or insert_size <= 0\");\n\n\t/*\n\t * Calculate number of bytes which must be shifted from appended item\n\t */\n\tn_shift = tb->sbytes[i] - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift,\n\t\t\ttb->S_new[i]);\n\n\t/*\n\t * Calculate number of bytes which must remain in body after\n\t * append to S_new[i]\n\t */\n\tn_rem = tb->insert_size[0] - tb->sbytes[i];\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\t/* Append part of body into S_new[0] */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\ttmp = item_head(tb->S_new[i], 0);\n\tshift = 0;\n\tif (is_indirect_le_ih(tmp)) {\n\t\tset_ih_free_space(tmp, 0);\n\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t}\n\tadd_le_ih_k_offset(tmp, n_rem << shift);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint n_shift, n_rem, r_zeroes_number, shift;\n\tconst char *r_body;\n\tstruct item_head *tmp;\n\tstruct buffer_info bi;\n\n\tRFALSE(ih, \"PAP-12210: ih must be 0\");\n\n\tif (is_direntry_le_ih(aux_ih)) {\n\t\tbalance_leaf_new_nodes_paste_dirent(tb, ih, body, insert_key,\n\t\t\t\t\t\t    insert_ptr, i);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||\n\t       tb->insert_size[0] <= 0,\n\t       \"PAP-12225: item too short or insert_size <= 0\");\n\n\t/*\n\t * Calculate number of bytes which must be shifted from appended item\n\t */\n\tn_shift = tb->sbytes[i] - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift,\n\t\t\ttb->S_new[i]);\n\n\t/*\n\t * Calculate number of bytes which must remain in body after\n\t * append to S_new[i]\n\t */\n\tn_rem = tb->insert_size[0] - tb->sbytes[i];\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\t/* Append part of body into S_new[0] */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\ttmp = item_head(tb->S_new[i], 0);\n\tshift = 0;\n\tif (is_indirect_le_ih(tmp)) {\n\t\tset_ih_free_space(tmp, 0);\n\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t}\n\tadd_le_ih_k_offset(tmp, n_rem << shift);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_S_TO_SNEW",
            "tb",
            "tb->snum[i]",
            "tb->sbytes[i]",
            "tb->S_new[i]"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* pasted item doesn't fall into S_new[i] */\n\tif (n - tb->snum[i] > tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* pasted item or part if it falls to S_new[i] */\n\n\tif (tb->item_pos == n - tb->snum[i] && tb->sbytes[i] != -1)\n\t\t/* we must shift part of the appended item */\n\t\tbalance_leaf_new_nodes_paste_shift(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n\telse\n\t\t/* item falls wholly into S_new[i] */\n\t\tbalance_leaf_new_nodes_paste_whole(tb, ih, body, insert_key,\n\t\t\t\t\t\t   insert_ptr, i);\n}"
  },
  {
    "function_name": "balance_leaf_new_nodes_paste_whole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1148-1200",
    "snippet": "static void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,\n\t\t\t\t\t       struct item_head * const ih,\n\t\t\t\t\t       const char * const body,\n\t\t\t\t\t       struct item_head *insert_key,\n\t\t\t\t\t       struct buffer_head **insert_ptr,\n\t\t\t\t\t       int i)\n\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tint leaf_mi;\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih_check = item_head(tbS0, tb->item_pos);\n\n\tif (!is_direntry_le_ih(ih_check) &&\n\t    (tb->pos_in_item != ih_item_len(ih_check) ||\n\t    tb->insert_size[0] <= 0))\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t     \"PAP-12235\",\n\t\t\t     \"pos_in_item must be equal to ih_item_len\");\n#endif\n\n\tleaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\t  tb->sbytes[i], tb->S_new[i]);\n\n\tRFALSE(leaf_mi,\n\t       \"PAP-12240: unexpected value returned by leaf_move_items (%d)\",\n\t       leaf_mi);\n\n\t/* paste into item */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t     tb->pos_in_item, tb->insert_size[0],\n\t\t\t     body, tb->zeroes_num);\n\n\tpasted = item_head(tb->S_new[i], tb->item_pos - n +\n\t\t\t   tb->snum[i]);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/* if we paste to indirect item update ih_free_space */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "pasted",
            "0"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "pasted"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "&bi",
            "tb->item_pos - n + tb->snum[i]",
            "tb->pos_in_item",
            "1",
            "(struct reiserfs_de_head *)body",
            "body + DEH_SIZE",
            "tb->insert_size[0]"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "pasted"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tb->S_new[i]",
            "tb->item_pos - n +\n\t\t\t   tb->snum[i]"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "tb->item_pos - n + tb->snum[i]",
            "tb->pos_in_item",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_bh",
          "args": [
            "tb",
            "&bi",
            "tb->S_new[i]"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "46-54",
          "snippet": "static inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "leaf_mi",
            "\"PAP-12240: unexpected value returned by leaf_move_items (%d)\"",
            "leaf_mi"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_S_TO_SNEW",
            "tb",
            "tb->snum[i]",
            "tb->sbytes[i]",
            "tb->S_new[i]"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"PAP-12235\"",
            "\"pos_in_item must be equal to ih_item_len\""
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih_check"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste_whole(struct tree_balance *tb,\n\t\t\t\t\t       struct item_head * const ih,\n\t\t\t\t\t       const char * const body,\n\t\t\t\t\t       struct item_head *insert_key,\n\t\t\t\t\t       struct buffer_head **insert_ptr,\n\t\t\t\t\t       int i)\n\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tint leaf_mi;\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih_check = item_head(tbS0, tb->item_pos);\n\n\tif (!is_direntry_le_ih(ih_check) &&\n\t    (tb->pos_in_item != ih_item_len(ih_check) ||\n\t    tb->insert_size[0] <= 0))\n\t\treiserfs_panic(tb->tb_sb,\n\t\t\t     \"PAP-12235\",\n\t\t\t     \"pos_in_item must be equal to ih_item_len\");\n#endif\n\n\tleaf_mi = leaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\t  tb->sbytes[i], tb->S_new[i]);\n\n\tRFALSE(leaf_mi,\n\t       \"PAP-12240: unexpected value returned by leaf_move_items (%d)\",\n\t       leaf_mi);\n\n\t/* paste into item */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t     tb->pos_in_item, tb->insert_size[0],\n\t\t\t     body, tb->zeroes_num);\n\n\tpasted = item_head(tb->S_new[i], tb->item_pos - n +\n\t\t\t   tb->snum[i]);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->snum[i],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/* if we paste to indirect item update ih_free_space */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n\n}"
  },
  {
    "function_name": "balance_leaf_new_nodes_paste_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1075-1146",
    "snippet": "static void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint n_shift, n_rem, r_zeroes_number, shift;\n\tconst char *r_body;\n\tstruct item_head *tmp;\n\tstruct buffer_info bi;\n\n\tRFALSE(ih, \"PAP-12210: ih must be 0\");\n\n\tif (is_direntry_le_ih(aux_ih)) {\n\t\tbalance_leaf_new_nodes_paste_dirent(tb, ih, body, insert_key,\n\t\t\t\t\t\t    insert_ptr, i);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||\n\t       tb->insert_size[0] <= 0,\n\t       \"PAP-12225: item too short or insert_size <= 0\");\n\n\t/*\n\t * Calculate number of bytes which must be shifted from appended item\n\t */\n\tn_shift = tb->sbytes[i] - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift,\n\t\t\ttb->S_new[i]);\n\n\t/*\n\t * Calculate number of bytes which must remain in body after\n\t * append to S_new[i]\n\t */\n\tn_rem = tb->insert_size[0] - tb->sbytes[i];\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\t/* Append part of body into S_new[0] */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\ttmp = item_head(tb->S_new[i], 0);\n\tshift = 0;\n\tif (is_indirect_le_ih(tmp)) {\n\t\tset_ih_free_space(tmp, 0);\n\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t}\n\tadd_le_ih_k_offset(tmp, n_rem << shift);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_le_ih_k_offset",
          "args": [
            "tmp",
            "n_rem << shift"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "add_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1516-1519",
          "snippet": "static inline void add_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tadd_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void add_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tadd_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "tmp",
            "0"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "tmp"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tb->S_new[i]",
            "0"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "0",
            "n_shift",
            "tb->insert_size[0] - n_rem",
            "r_body",
            "r_zeroes_number"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_bh",
          "args": [
            "tb",
            "&bi",
            "tb->S_new[i]"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "46-54",
          "snippet": "static inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_S_TO_SNEW",
            "tb",
            "tb->snum[i]",
            "n_shift",
            "tb->S_new[i]"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||\n\t       tb->insert_size[0] <= 0",
            "\"PAP-12225: item too short or insert_size <= 0\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_leaf_new_nodes_paste_dirent",
          "args": [
            "tb",
            "ih",
            "body",
            "insert_key",
            "insert_ptr",
            "i"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_new_nodes_paste_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1020-1073",
          "snippet": "static void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint entry_count = ih_entry_count(aux_ih);\n\tstruct buffer_info bi;\n\n\tif (entry_count - tb->sbytes[i] < tb->pos_in_item &&\n\t    tb->pos_in_item <= entry_count) {\n\t\t/* new directory entry falls into S_new[i] */\n\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12215: insert_size is already 0\");\n\t\tRFALSE(tb->sbytes[i] - 1 >= entry_count,\n\t\t       \"PAP-12220: there are no so much entries (%d), only %d\",\n\t\t       tb->sbytes[i] - 1, entry_count);\n\n\t\t/*\n\t\t * Shift snum[i]-1 items in whole.\n\t\t * Shift sbytes[i] directory entries\n\t\t * from directory item number snum[i]\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i] - 1, tb->S_new[i]);\n\n\t\t/*\n\t\t * Paste given directory entry to\n\t\t * directory item\n\t\t */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t     tb->sbytes[i] - 1, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/* paste new directory entry */\n\t\tleaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t   tb->sbytes[i] - 1, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i], tb->S_new[i]);\n\t}\n\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint entry_count = ih_entry_count(aux_ih);\n\tstruct buffer_info bi;\n\n\tif (entry_count - tb->sbytes[i] < tb->pos_in_item &&\n\t    tb->pos_in_item <= entry_count) {\n\t\t/* new directory entry falls into S_new[i] */\n\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12215: insert_size is already 0\");\n\t\tRFALSE(tb->sbytes[i] - 1 >= entry_count,\n\t\t       \"PAP-12220: there are no so much entries (%d), only %d\",\n\t\t       tb->sbytes[i] - 1, entry_count);\n\n\t\t/*\n\t\t * Shift snum[i]-1 items in whole.\n\t\t * Shift sbytes[i] directory entries\n\t\t * from directory item number snum[i]\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i] - 1, tb->S_new[i]);\n\n\t\t/*\n\t\t * Paste given directory entry to\n\t\t * directory item\n\t\t */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t     tb->sbytes[i] - 1, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/* paste new directory entry */\n\t\tleaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t   tb->sbytes[i] - 1, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i], tb->S_new[i]);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "aux_ih"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih",
            "\"PAP-12210: ih must be 0\""
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste_shift(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint n_shift, n_rem, r_zeroes_number, shift;\n\tconst char *r_body;\n\tstruct item_head *tmp;\n\tstruct buffer_info bi;\n\n\tRFALSE(ih, \"PAP-12210: ih must be 0\");\n\n\tif (is_direntry_le_ih(aux_ih)) {\n\t\tbalance_leaf_new_nodes_paste_dirent(tb, ih, body, insert_key,\n\t\t\t\t\t\t    insert_ptr, i);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)) ||\n\t       tb->insert_size[0] <= 0,\n\t       \"PAP-12225: item too short or insert_size <= 0\");\n\n\t/*\n\t * Calculate number of bytes which must be shifted from appended item\n\t */\n\tn_shift = tb->sbytes[i] - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i], n_shift,\n\t\t\ttb->S_new[i]);\n\n\t/*\n\t * Calculate number of bytes which must remain in body after\n\t * append to S_new[i]\n\t */\n\tn_rem = tb->insert_size[0] - tb->sbytes[i];\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\t/* Append part of body into S_new[0] */\n\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\ttmp = item_head(tb->S_new[i], 0);\n\tshift = 0;\n\tif (is_indirect_le_ih(tmp)) {\n\t\tset_ih_free_space(tmp, 0);\n\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t}\n\tadd_le_ih_k_offset(tmp, n_rem << shift);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}"
  },
  {
    "function_name": "balance_leaf_new_nodes_paste_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "1020-1073",
    "snippet": "static void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint entry_count = ih_entry_count(aux_ih);\n\tstruct buffer_info bi;\n\n\tif (entry_count - tb->sbytes[i] < tb->pos_in_item &&\n\t    tb->pos_in_item <= entry_count) {\n\t\t/* new directory entry falls into S_new[i] */\n\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12215: insert_size is already 0\");\n\t\tRFALSE(tb->sbytes[i] - 1 >= entry_count,\n\t\t       \"PAP-12220: there are no so much entries (%d), only %d\",\n\t\t       tb->sbytes[i] - 1, entry_count);\n\n\t\t/*\n\t\t * Shift snum[i]-1 items in whole.\n\t\t * Shift sbytes[i] directory entries\n\t\t * from directory item number snum[i]\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i] - 1, tb->S_new[i]);\n\n\t\t/*\n\t\t * Paste given directory entry to\n\t\t * directory item\n\t\t */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t     tb->sbytes[i] - 1, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/* paste new directory entry */\n\t\tleaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t   tb->sbytes[i] - 1, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i], tb->S_new[i]);\n\t}\n\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_S_TO_SNEW",
            "tb",
            "tb->snum[i]",
            "tb->sbytes[i]",
            "tb->S_new[i]"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "&bi",
            "0",
            "tb->pos_in_item - entry_count +\n\t\t\t\t   tb->sbytes[i] - 1",
            "1",
            "(struct reiserfs_de_head *) body",
            "body + DEH_SIZE",
            "tb->insert_size[0]"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "0",
            "tb->pos_in_item - entry_count +\n\t\t\t\t     tb->sbytes[i] - 1",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_bh",
          "args": [
            "tb",
            "&bi",
            "tb->S_new[i]"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "46-54",
          "snippet": "static inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->sbytes[i] - 1 >= entry_count",
            "\"PAP-12220: there are no so much entries (%d), only %d\"",
            "tb->sbytes[i] - 1",
            "entry_count"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->insert_size[0]",
            "\"PAP-12215: insert_size is already 0\""
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "aux_ih"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "tb->item_pos"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_paste_dirent(struct tree_balance *tb,\n\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t const char * const body,\n\t\t\t\t\t struct item_head *insert_key,\n\t\t\t\t\t struct buffer_head **insert_ptr,\n\t\t\t\t\t int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct item_head *aux_ih = item_head(tbS0, tb->item_pos);\n\tint entry_count = ih_entry_count(aux_ih);\n\tstruct buffer_info bi;\n\n\tif (entry_count - tb->sbytes[i] < tb->pos_in_item &&\n\t    tb->pos_in_item <= entry_count) {\n\t\t/* new directory entry falls into S_new[i] */\n\n\t\tRFALSE(!tb->insert_size[0],\n\t\t       \"PAP-12215: insert_size is already 0\");\n\t\tRFALSE(tb->sbytes[i] - 1 >= entry_count,\n\t\t       \"PAP-12220: there are no so much entries (%d), only %d\",\n\t\t       tb->sbytes[i] - 1, entry_count);\n\n\t\t/*\n\t\t * Shift snum[i]-1 items in whole.\n\t\t * Shift sbytes[i] directory entries\n\t\t * from directory item number snum[i]\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i] - 1, tb->S_new[i]);\n\n\t\t/*\n\t\t * Paste given directory entry to\n\t\t * directory item\n\t\t */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_paste_in_buffer(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t     tb->sbytes[i] - 1, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/* paste new directory entry */\n\t\tleaf_paste_entries(&bi, 0, tb->pos_in_item - entry_count +\n\t\t\t\t   tb->sbytes[i] - 1, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i],\n\t\t\t\ttb->sbytes[i], tb->S_new[i]);\n\t}\n\n}"
  },
  {
    "function_name": "balance_leaf_new_nodes_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "928-1017",
    "snippet": "static void balance_leaf_new_nodes_insert(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body,\n\t\t\t\t\t  struct item_head *insert_key,\n\t\t\t\t\t  struct buffer_head **insert_ptr,\n\t\t\t\t\t  int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint shift;\n\n\t/* new item or it part don't falls into S_new[i] */\n\tif (n - tb->snum[i] >= tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* new item or it's part falls to first new node S_new[i] */\n\n\t/* part of new item falls into S_new[i] */\n\tif (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {\n\t\tint old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version;\n\n\t\t/* Move snum[i]-1 items from S[0] to S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,\n\t\t\t\ttb->S_new[i]);\n\n\t\t/* Remember key component and item length */\n\t\tversion = ih_version(ih);\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into S_new[i]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\tset_le_ih_k_offset(ih,\n\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t   ((old_len - tb->sbytes[i]) << shift));\n\n\t\tput_ih_item_len(ih, tb->sbytes[i]);\n\n\t\t/* Insert part of the item into S_new[i] before 0-th item */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\n\t\tif ((old_len - tb->sbytes[i]) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->sbytes[i]) -\n\t\t\t\t\t tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num - (old_len -\n\t\t\t\t\t  tb->sbytes[i]);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[i]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->sbytes[i]);\n\t\ttb->insert_size[0] -= tb->sbytes[i];\n\t} else {\n\t\t/* whole new item falls into S_new[i] */\n\n\t\t/*\n\t\t * Shift snum[0] - 1 items to S_new[i]\n\t\t * (sbytes[i] of split item)\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);\n\n\t\t/* Insert new item into S_new[i] */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_insert_into_buf",
          "args": [
            "&bi",
            "tb->item_pos - n + tb->snum[i] - 1",
            "ih",
            "body",
            "tb->zeroes_num"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_insert_into_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "901-972",
          "snippet": "void leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_bh",
          "args": [
            "tb",
            "&bi",
            "tb->S_new[i]"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "46-54",
          "snippet": "static inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_S_TO_SNEW",
            "tb",
            "tb->snum[i] - 1",
            "tb->sbytes[i]",
            "tb->S_new[i]"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "old_len - tb->sbytes[i]"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "ih",
            "old_key_comp"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "tb->sbytes[i]"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_new_nodes_insert(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body,\n\t\t\t\t\t  struct item_head *insert_key,\n\t\t\t\t\t  struct buffer_head **insert_ptr,\n\t\t\t\t\t  int i)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint shift;\n\n\t/* new item or it part don't falls into S_new[i] */\n\tif (n - tb->snum[i] >= tb->item_pos) {\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i], tb->sbytes[i], tb->S_new[i]);\n\t\treturn;\n\t}\n\n\t/* new item or it's part falls to first new node S_new[i] */\n\n\t/* part of new item falls into S_new[i] */\n\tif (tb->item_pos == n - tb->snum[i] + 1 && tb->sbytes[i] != -1) {\n\t\tint old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version;\n\n\t\t/* Move snum[i]-1 items from S[0] to S_new[i] */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb, tb->snum[i] - 1, -1,\n\t\t\t\ttb->S_new[i]);\n\n\t\t/* Remember key component and item length */\n\t\tversion = ih_version(ih);\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into S_new[i]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\tset_le_ih_k_offset(ih,\n\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t   ((old_len - tb->sbytes[i]) << shift));\n\n\t\tput_ih_item_len(ih, tb->sbytes[i]);\n\n\t\t/* Insert part of the item into S_new[i] before 0-th item */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\n\t\tif ((old_len - tb->sbytes[i]) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->sbytes[i]) -\n\t\t\t\t\t tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num - (old_len -\n\t\t\t\t\t  tb->sbytes[i]);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[i]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->sbytes[i]);\n\t\ttb->insert_size[0] -= tb->sbytes[i];\n\t} else {\n\t\t/* whole new item falls into S_new[i] */\n\n\t\t/*\n\t\t * Shift snum[0] - 1 items to S_new[i]\n\t\t * (sbytes[i] of split item)\n\t\t */\n\t\tleaf_move_items(LEAF_FROM_S_TO_SNEW, tb,\n\t\t\t\ttb->snum[i] - 1, tb->sbytes[i], tb->S_new[i]);\n\n\t\t/* Insert new item into S_new[i] */\n\t\tbuffer_info_init_bh(tb, &bi, tb->S_new[i]);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->snum[i] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "913-926",
    "snippet": "static void balance_leaf_right(struct tree_balance *tb,\n\t\t\t       struct item_head * const ih,\n\t\t\t       const char * const body, int flag)\n{\n\tif (tb->rnum[0] <= 0)\n\t\treturn;\n\n\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\tif (flag == M_INSERT)\n\t\tbalance_leaf_insert_right(tb, ih, body);\n\telse /* M_PASTE */\n\t\tbalance_leaf_paste_right(tb, ih, body);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_leaf_paste_right",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "889-910",
          "snippet": "static void balance_leaf_paste_right(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* new item doesn't fall into R[0] */\n\tif (n - tb->rnum[0] > tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* pasted item or part of it falls to R[0] */\n\n\tif (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1)\n\t\t/* we must shift the part of the appended item */\n\t\tbalance_leaf_paste_right_shift(tb, ih, body);\n\telse\n\t\t/* pasted item in whole falls into R[0] */\n\t\tbalance_leaf_paste_right_whole(tb, ih, body);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_right(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* new item doesn't fall into R[0] */\n\tif (n - tb->rnum[0] > tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* pasted item or part of it falls to R[0] */\n\n\tif (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1)\n\t\t/* we must shift the part of the appended item */\n\t\tbalance_leaf_paste_right_shift(tb, ih, body);\n\telse\n\t\t/* pasted item in whole falls into R[0] */\n\t\tbalance_leaf_paste_right_whole(tb, ih, body);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_insert_right",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_insert_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "627-713",
          "snippet": "static void balance_leaf_insert_right(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body)\n{\n\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint ret;\n\n\t/* new item or part of it doesn't fall into R[0] */\n\tif (n - tb->rnum[0] >= tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* new item or its part falls to R[0] */\n\n\t/* part of new item falls into R[0] */\n\tif (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {\n\t\tloff_t old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version, shift;\n\t\tloff_t offset;\n\n\t\tleaf_shift_right(tb, tb->rnum[0] - 1, -1);\n\n\t\tversion = ih_version(ih);\n\n\t\t/* Remember key component and item length */\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into R[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\toffset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << shift);\n\t\tset_le_ih_k_offset(ih, offset);\n\t\tput_ih_item_len(ih, tb->rbytes);\n\n\t\t/* Insert part of the item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tif ((old_len - tb->rbytes) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->rbytes) - tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num -\n\t\t\t\t\t  (old_len - tb->rbytes);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/* Replace right delimiting key by first key in R[0] */\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[0]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->rbytes);\n\n\t\ttb->insert_size[0] -= tb->rbytes;\n\n\t} else {\n\t\t/* whole new item falls into R[0] */\n\n\t\t/* Shift rnum[0]-1 items to R[0] */\n\t\tret = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);\n\n\t\t/* Insert new item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\tif (tb->item_pos - n + tb->rnum[0] - 1 == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_insert_right(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body)\n{\n\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint ret;\n\n\t/* new item or part of it doesn't fall into R[0] */\n\tif (n - tb->rnum[0] >= tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* new item or its part falls to R[0] */\n\n\t/* part of new item falls into R[0] */\n\tif (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {\n\t\tloff_t old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version, shift;\n\t\tloff_t offset;\n\n\t\tleaf_shift_right(tb, tb->rnum[0] - 1, -1);\n\n\t\tversion = ih_version(ih);\n\n\t\t/* Remember key component and item length */\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into R[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\toffset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << shift);\n\t\tset_le_ih_k_offset(ih, offset);\n\t\tput_ih_item_len(ih, tb->rbytes);\n\n\t\t/* Insert part of the item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tif ((old_len - tb->rbytes) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->rbytes) - tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num -\n\t\t\t\t\t  (old_len - tb->rbytes);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/* Replace right delimiting key by first key in R[0] */\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[0]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->rbytes);\n\n\t\ttb->insert_size[0] -= tb->rbytes;\n\n\t} else {\n\t\t/* whole new item falls into R[0] */\n\n\t\t/* Shift rnum[0]-1 items to R[0] */\n\t\tret = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);\n\n\t\t/* Insert new item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\tif (tb->item_pos - n + tb->rnum[0] - 1 == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flag != M_INSERT && flag != M_PASTE"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_right(struct tree_balance *tb,\n\t\t\t       struct item_head * const ih,\n\t\t\t       const char * const body, int flag)\n{\n\tif (tb->rnum[0] <= 0)\n\t\treturn;\n\n\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\tif (flag == M_INSERT)\n\t\tbalance_leaf_insert_right(tb, ih, body);\n\telse /* M_PASTE */\n\t\tbalance_leaf_paste_right(tb, ih, body);\n}"
  },
  {
    "function_name": "balance_leaf_paste_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "889-910",
    "snippet": "static void balance_leaf_paste_right(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* new item doesn't fall into R[0] */\n\tif (n - tb->rnum[0] > tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* pasted item or part of it falls to R[0] */\n\n\tif (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1)\n\t\t/* we must shift the part of the appended item */\n\t\tbalance_leaf_paste_right_shift(tb, ih, body);\n\telse\n\t\t/* pasted item in whole falls into R[0] */\n\t\tbalance_leaf_paste_right_whole(tb, ih, body);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_leaf_paste_right_whole",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_right_whole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "845-887",
          "snippet": "static void balance_leaf_paste_right_whole(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n\t\t\t\t\t\t\tbuffer_info_init_right(tb, &bi);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\t/* append item in R[0] */\n\tif (tb->pos_in_item >= 0) {\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\t}\n\n\t/* paste new entry, if item is directory item */\n\tpasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);\n\tif (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->pos_in_item) {\n\n\t\t\tRFALSE(tb->item_pos - n + tb->rnum[0],\n\t\t\t       \"PAP-12165: directory item must be first \"\n\t\t\t       \"item of node when pasting is in 0th position\");\n\n\t\t\t/* update delimiting keys */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\t\t}\n\t}\n\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_right_whole(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n\t\t\t\t\t\t\tbuffer_info_init_right(tb, &bi);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\t/* append item in R[0] */\n\tif (tb->pos_in_item >= 0) {\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\t}\n\n\t/* paste new entry, if item is directory item */\n\tpasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);\n\tif (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->pos_in_item) {\n\n\t\t\tRFALSE(tb->item_pos - n + tb->rnum[0],\n\t\t\t       \"PAP-12165: directory item must be first \"\n\t\t\t       \"item of node when pasting is in 0th position\");\n\n\t\t\t/* update delimiting keys */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\t\t}\n\t}\n\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_paste_right_shift",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_right_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "767-843",
          "snippet": "static void balance_leaf_paste_right_shift(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n_shift, n_rem, r_zeroes_number, version;\n\tunsigned long temp_rem;\n\tconst char *r_body;\n\tstruct buffer_info bi;\n\n\t/* we append to directory item */\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_right_shift_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\t/*\n\t * Calculate number of bytes which must be shifted\n\t * from appended item\n\t */\n\tn_shift = tb->rbytes - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12155: invalid position to paste. ih_item_len=%d, \"\n\t       \"pos_in_item=%d\", tb->pos_in_item,\n\t       ih_item_len(item_head(tbS0, tb->item_pos)));\n\n\tleaf_shift_right(tb, tb->rnum[0], n_shift);\n\n\t/*\n\t * Calculate number of bytes which must remain in body\n\t * after appending to R[0]\n\t */\n\tn_rem = tb->insert_size[0] - tb->rbytes;\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\ttemp_rem = n_rem;\n\n\tversion = ih_version(item_head(tb->R[0], 0));\n\n\tif (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {\n\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\ttemp_rem = n_rem << shift;\n\t}\n\n\tadd_le_key_k_offset(version, leaf_key(tb->R[0], 0), temp_rem);\n\tadd_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),\n\t\t\t    temp_rem);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[0], 0);\n\n\t/* Append part of body into R[0] */\n\tbuffer_info_init_right(tb, &bi);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\tif (is_indirect_le_ih(item_head(tb->R[0], 0)))\n\t\tset_ih_free_space(item_head(tb->R[0], 0), 0);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nstatic void balance_leaf_paste_right_shift(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n_shift, n_rem, r_zeroes_number, version;\n\tunsigned long temp_rem;\n\tconst char *r_body;\n\tstruct buffer_info bi;\n\n\t/* we append to directory item */\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_right_shift_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\t/*\n\t * Calculate number of bytes which must be shifted\n\t * from appended item\n\t */\n\tn_shift = tb->rbytes - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12155: invalid position to paste. ih_item_len=%d, \"\n\t       \"pos_in_item=%d\", tb->pos_in_item,\n\t       ih_item_len(item_head(tbS0, tb->item_pos)));\n\n\tleaf_shift_right(tb, tb->rnum[0], n_shift);\n\n\t/*\n\t * Calculate number of bytes which must remain in body\n\t * after appending to R[0]\n\t */\n\tn_rem = tb->insert_size[0] - tb->rbytes;\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\ttemp_rem = n_rem;\n\n\tversion = ih_version(item_head(tb->R[0], 0));\n\n\tif (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {\n\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\ttemp_rem = n_rem << shift;\n\t}\n\n\tadd_le_key_k_offset(version, leaf_key(tb->R[0], 0), temp_rem);\n\tadd_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),\n\t\t\t    temp_rem);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[0], 0);\n\n\t/* Append part of body into R[0] */\n\tbuffer_info_init_right(tb, &bi);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\tif (is_indirect_le_ih(item_head(tb->R[0], 0)))\n\t\tset_ih_free_space(item_head(tb->R[0], 0), 0);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_right",
          "args": [
            "tb",
            "tb->rnum[0]",
            "tb->rbytes"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "794-812",
          "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_right(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* new item doesn't fall into R[0] */\n\tif (n - tb->rnum[0] > tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* pasted item or part of it falls to R[0] */\n\n\tif (tb->item_pos == n - tb->rnum[0] && tb->rbytes != -1)\n\t\t/* we must shift the part of the appended item */\n\t\tbalance_leaf_paste_right_shift(tb, ih, body);\n\telse\n\t\t/* pasted item in whole falls into R[0] */\n\t\tbalance_leaf_paste_right_whole(tb, ih, body);\n}"
  },
  {
    "function_name": "balance_leaf_paste_right_whole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "845-887",
    "snippet": "static void balance_leaf_paste_right_whole(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n\t\t\t\t\t\t\tbuffer_info_init_right(tb, &bi);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\t/* append item in R[0] */\n\tif (tb->pos_in_item >= 0) {\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\t}\n\n\t/* paste new entry, if item is directory item */\n\tpasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);\n\tif (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->pos_in_item) {\n\n\t\t\tRFALSE(tb->item_pos - n + tb->rnum[0],\n\t\t\t       \"PAP-12165: directory item must be first \"\n\t\t\t       \"item of node when pasting is in 0th position\");\n\n\t\t\t/* update delimiting keys */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\t\t}\n\t}\n\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "pasted",
            "0"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "pasted"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFR[0]",
            "tb->rkey[0]",
            "tb->R[0]",
            "0"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->item_pos - n + tb->rnum[0]",
            "\"PAP-12165: directory item must be first \"\n\t\t\t       \"item of node when pasting is in 0th position\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "&bi",
            "tb->item_pos - n + tb->rnum[0]",
            "tb->pos_in_item",
            "1",
            "(struct reiserfs_de_head *)body",
            "body + DEH_SIZE",
            "tb->insert_size[0]"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "pasted"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tb->R[0]",
            "tb->item_pos - n + tb->rnum[0]"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "tb->item_pos - n + tb->rnum[0]",
            "tb->pos_in_item",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_right",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "28-35",
          "snippet": "static inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_right",
          "args": [
            "tb",
            "tb->rnum[0]",
            "tb->rbytes"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "794-812",
          "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_right_whole(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct item_head *pasted;\n\tstruct buffer_info bi;\n\n\t\t\t\t\t\t\tbuffer_info_init_right(tb, &bi);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\t/* append item in R[0] */\n\tif (tb->pos_in_item >= 0) {\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t     tb->pos_in_item, tb->insert_size[0], body,\n\t\t\t\t     tb->zeroes_num);\n\t}\n\n\t/* paste new entry, if item is directory item */\n\tpasted = item_head(tb->R[0], tb->item_pos - n + tb->rnum[0]);\n\tif (is_direntry_le_ih(pasted) && tb->pos_in_item >= 0) {\n\t\tleaf_paste_entries(&bi, tb->item_pos - n + tb->rnum[0],\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\tif (!tb->pos_in_item) {\n\n\t\t\tRFALSE(tb->item_pos - n + tb->rnum[0],\n\t\t\t       \"PAP-12165: directory item must be first \"\n\t\t\t       \"item of node when pasting is in 0th position\");\n\n\t\t\t/* update delimiting keys */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\t\t}\n\t}\n\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\ttb->zeroes_num = tb->insert_size[0] = 0;\n}"
  },
  {
    "function_name": "balance_leaf_paste_right_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "767-843",
    "snippet": "static void balance_leaf_paste_right_shift(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n_shift, n_rem, r_zeroes_number, version;\n\tunsigned long temp_rem;\n\tconst char *r_body;\n\tstruct buffer_info bi;\n\n\t/* we append to directory item */\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_right_shift_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\t/*\n\t * Calculate number of bytes which must be shifted\n\t * from appended item\n\t */\n\tn_shift = tb->rbytes - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12155: invalid position to paste. ih_item_len=%d, \"\n\t       \"pos_in_item=%d\", tb->pos_in_item,\n\t       ih_item_len(item_head(tbS0, tb->item_pos)));\n\n\tleaf_shift_right(tb, tb->rnum[0], n_shift);\n\n\t/*\n\t * Calculate number of bytes which must remain in body\n\t * after appending to R[0]\n\t */\n\tn_rem = tb->insert_size[0] - tb->rbytes;\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\ttemp_rem = n_rem;\n\n\tversion = ih_version(item_head(tb->R[0], 0));\n\n\tif (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {\n\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\ttemp_rem = n_rem << shift;\n\t}\n\n\tadd_le_key_k_offset(version, leaf_key(tb->R[0], 0), temp_rem);\n\tadd_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),\n\t\t\t    temp_rem);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[0], 0);\n\n\t/* Append part of body into R[0] */\n\tbuffer_info_init_right(tb, &bi);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\tif (is_indirect_le_ih(item_head(tb->R[0], 0)))\n\t\tset_ih_free_space(item_head(tb->R[0], 0), 0);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "item_head(tb->R[0], 0)",
            "0"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tb->R[0]",
            "0"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "item_head(tb->R[0], 0)"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "0",
            "n_shift",
            "tb->insert_size[0] - n_rem",
            "r_body",
            "r_zeroes_number"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_right",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "28-35",
          "snippet": "static inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "tb->CFR[0]",
            "0"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_le_key_k_offset",
          "args": [
            "version",
            "internal_key(tb->CFR[0], tb->rkey[0])",
            "temp_rem"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "add_le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1509-1514",
          "snippet": "static inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFR[0]",
            "tb->rkey[0]"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_key",
          "args": [
            "tb->R[0]",
            "0"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2207-2211",
          "snippet": "static inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_key",
          "args": [
            "version",
            "leaf_key(tb->R[0], 0)"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1551-1554",
          "snippet": "static inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [
            "#define TYPE_INDIRECT 1"
          ],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\n#define TYPE_INDIRECT 1\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\n\nstatic inline int is_indirect_le_key(int version, struct reiserfs_key *key)\n{\n\treturn le_key_k_type(version, key) == TYPE_INDIRECT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "item_head(tb->R[0], 0)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_shift_right",
          "args": [
            "tb",
            "tb->rnum[0]",
            "n_shift"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "794-812",
          "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos))",
            "\"PAP-12155: invalid position to paste. ih_item_len=%d, \"\n\t       \"pos_in_item=%d\"",
            "tb->pos_in_item",
            "ih_item_len(item_head(tbS0, tb->item_pos))"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_leaf_paste_right_shift_dirent",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_right_shift_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "716-765",
          "snippet": "static void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tint entry_count;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12145: invalid parameter in case of a directory\");\n\tentry_count = ih_entry_count(item_head(tbS0, tb->item_pos));\n\n\t/* new directory entry falls into R[0] */\n\tif (entry_count - tb->rbytes < tb->pos_in_item) {\n\t\tint paste_entry_position;\n\n\t\tRFALSE(tb->rbytes - 1 >= entry_count || !tb->insert_size[0],\n\t\t       \"PAP-12150: no enough of entries to shift to R[0]: \"\n\t\t       \"rbytes=%d, entry_count=%d\", tb->rbytes, entry_count);\n\n\t\t/*\n\t\t * Shift rnum[0]-1 items in whole.\n\t\t * Shift rbytes-1 directory entries from directory\n\t\t * item number rnum[0]\n\t\t */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);\n\n\t\t/* Paste given directory entry to directory item */\n\t\tpaste_entry_position = tb->pos_in_item - entry_count +\n\t\t\t\t       tb->rbytes - 1;\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, 0, paste_entry_position,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, 0, paste_entry_position, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\t/* change delimiting keys */\n\t\tif (paste_entry_position == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into R[0] */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tint entry_count;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12145: invalid parameter in case of a directory\");\n\tentry_count = ih_entry_count(item_head(tbS0, tb->item_pos));\n\n\t/* new directory entry falls into R[0] */\n\tif (entry_count - tb->rbytes < tb->pos_in_item) {\n\t\tint paste_entry_position;\n\n\t\tRFALSE(tb->rbytes - 1 >= entry_count || !tb->insert_size[0],\n\t\t       \"PAP-12150: no enough of entries to shift to R[0]: \"\n\t\t       \"rbytes=%d, entry_count=%d\", tb->rbytes, entry_count);\n\n\t\t/*\n\t\t * Shift rnum[0]-1 items in whole.\n\t\t * Shift rbytes-1 directory entries from directory\n\t\t * item number rnum[0]\n\t\t */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);\n\n\t\t/* Paste given directory entry to directory item */\n\t\tpaste_entry_position = tb->pos_in_item - entry_count +\n\t\t\t\t       tb->rbytes - 1;\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, 0, paste_entry_position,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, 0, paste_entry_position, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\t/* change delimiting keys */\n\t\tif (paste_entry_position == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into R[0] */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nstatic void balance_leaf_paste_right_shift(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n_shift, n_rem, r_zeroes_number, version;\n\tunsigned long temp_rem;\n\tconst char *r_body;\n\tstruct buffer_info bi;\n\n\t/* we append to directory item */\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_right_shift_dirent(tb, ih, body);\n\t\treturn;\n\t}\n\n\t/* regular object */\n\n\t/*\n\t * Calculate number of bytes which must be shifted\n\t * from appended item\n\t */\n\tn_shift = tb->rbytes - tb->insert_size[0];\n\tif (n_shift < 0)\n\t\tn_shift = 0;\n\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12155: invalid position to paste. ih_item_len=%d, \"\n\t       \"pos_in_item=%d\", tb->pos_in_item,\n\t       ih_item_len(item_head(tbS0, tb->item_pos)));\n\n\tleaf_shift_right(tb, tb->rnum[0], n_shift);\n\n\t/*\n\t * Calculate number of bytes which must remain in body\n\t * after appending to R[0]\n\t */\n\tn_rem = tb->insert_size[0] - tb->rbytes;\n\tif (n_rem < 0)\n\t\tn_rem = 0;\n\n\ttemp_rem = n_rem;\n\n\tversion = ih_version(item_head(tb->R[0], 0));\n\n\tif (is_indirect_le_key(version, leaf_key(tb->R[0], 0))) {\n\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\ttemp_rem = n_rem << shift;\n\t}\n\n\tadd_le_key_k_offset(version, leaf_key(tb->R[0], 0), temp_rem);\n\tadd_le_key_k_offset(version, internal_key(tb->CFR[0], tb->rkey[0]),\n\t\t\t    temp_rem);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[0], 0);\n\n\t/* Append part of body into R[0] */\n\tbuffer_info_init_right(tb, &bi);\n\tif (n_rem > tb->zeroes_num) {\n\t\tr_zeroes_number = 0;\n\t\tr_body = body + n_rem - tb->zeroes_num;\n\t} else {\n\t\tr_body = body;\n\t\tr_zeroes_number = tb->zeroes_num - n_rem;\n\t\ttb->zeroes_num -= r_zeroes_number;\n\t}\n\n\tleaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem,\n\t\t\t     r_body, r_zeroes_number);\n\n\tif (is_indirect_le_ih(item_head(tb->R[0], 0)))\n\t\tset_ih_free_space(item_head(tb->R[0], 0), 0);\n\n\ttb->insert_size[0] = n_rem;\n\tif (!n_rem)\n\t\ttb->pos_in_item++;\n}"
  },
  {
    "function_name": "balance_leaf_paste_right_shift_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "716-765",
    "snippet": "static void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tint entry_count;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12145: invalid parameter in case of a directory\");\n\tentry_count = ih_entry_count(item_head(tbS0, tb->item_pos));\n\n\t/* new directory entry falls into R[0] */\n\tif (entry_count - tb->rbytes < tb->pos_in_item) {\n\t\tint paste_entry_position;\n\n\t\tRFALSE(tb->rbytes - 1 >= entry_count || !tb->insert_size[0],\n\t\t       \"PAP-12150: no enough of entries to shift to R[0]: \"\n\t\t       \"rbytes=%d, entry_count=%d\", tb->rbytes, entry_count);\n\n\t\t/*\n\t\t * Shift rnum[0]-1 items in whole.\n\t\t * Shift rbytes-1 directory entries from directory\n\t\t * item number rnum[0]\n\t\t */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);\n\n\t\t/* Paste given directory entry to directory item */\n\t\tpaste_entry_position = tb->pos_in_item - entry_count +\n\t\t\t\t       tb->rbytes - 1;\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, 0, paste_entry_position,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, 0, paste_entry_position, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\t/* change delimiting keys */\n\t\tif (paste_entry_position == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into R[0] */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_shift_right",
          "args": [
            "tb",
            "tb->rnum[0]",
            "tb->rbytes"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "794-812",
          "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFR[0]",
            "tb->rkey[0]",
            "tb->R[0]",
            "0"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "&bi",
            "0",
            "paste_entry_position",
            "1",
            "(struct reiserfs_de_head *) body",
            "body + DEH_SIZE",
            "tb->insert_size[0]"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "0",
            "paste_entry_position",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_right",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "28-35",
          "snippet": "static inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->rbytes - 1 >= entry_count || !tb->insert_size[0]",
            "\"PAP-12150: no enough of entries to shift to R[0]: \"\n\t\t       \"rbytes=%d, entry_count=%d\"",
            "tb->rbytes",
            "entry_count"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "tb->item_pos"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->zeroes_num",
            "\"PAP-12145: invalid parameter in case of a directory\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_right_shift_dirent(struct tree_balance *tb,\n\t\t\t\t     struct item_head * const ih,\n\t\t\t\t     const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tstruct buffer_info bi;\n\tint entry_count;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12145: invalid parameter in case of a directory\");\n\tentry_count = ih_entry_count(item_head(tbS0, tb->item_pos));\n\n\t/* new directory entry falls into R[0] */\n\tif (entry_count - tb->rbytes < tb->pos_in_item) {\n\t\tint paste_entry_position;\n\n\t\tRFALSE(tb->rbytes - 1 >= entry_count || !tb->insert_size[0],\n\t\t       \"PAP-12150: no enough of entries to shift to R[0]: \"\n\t\t       \"rbytes=%d, entry_count=%d\", tb->rbytes, entry_count);\n\n\t\t/*\n\t\t * Shift rnum[0]-1 items in whole.\n\t\t * Shift rbytes-1 directory entries from directory\n\t\t * item number rnum[0]\n\t\t */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes - 1);\n\n\t\t/* Paste given directory entry to directory item */\n\t\tpaste_entry_position = tb->pos_in_item - entry_count +\n\t\t\t\t       tb->rbytes - 1;\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, 0, paste_entry_position,\n\t\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t\t/* paste entry */\n\t\tleaf_paste_entries(&bi, 0, paste_entry_position, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t\t/* change delimiting keys */\n\t\tif (paste_entry_position == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->insert_size[0] = 0;\n\t\ttb->pos_in_item++;\n\t} else {\n\t\t/* new directory entry doesn't fall into R[0] */\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_insert_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "627-713",
    "snippet": "static void balance_leaf_insert_right(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body)\n{\n\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint ret;\n\n\t/* new item or part of it doesn't fall into R[0] */\n\tif (n - tb->rnum[0] >= tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* new item or its part falls to R[0] */\n\n\t/* part of new item falls into R[0] */\n\tif (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {\n\t\tloff_t old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version, shift;\n\t\tloff_t offset;\n\n\t\tleaf_shift_right(tb, tb->rnum[0] - 1, -1);\n\n\t\tversion = ih_version(ih);\n\n\t\t/* Remember key component and item length */\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into R[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\toffset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << shift);\n\t\tset_le_ih_k_offset(ih, offset);\n\t\tput_ih_item_len(ih, tb->rbytes);\n\n\t\t/* Insert part of the item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tif ((old_len - tb->rbytes) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->rbytes) - tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num -\n\t\t\t\t\t  (old_len - tb->rbytes);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/* Replace right delimiting key by first key in R[0] */\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[0]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->rbytes);\n\n\t\ttb->insert_size[0] -= tb->rbytes;\n\n\t} else {\n\t\t/* whole new item falls into R[0] */\n\n\t\t/* Shift rnum[0]-1 items to R[0] */\n\t\tret = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);\n\n\t\t/* Insert new item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\tif (tb->item_pos - n + tb->rnum[0] - 1 == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFR[0]",
            "tb->rkey[0]",
            "tb->R[0]",
            "0"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_insert_into_buf",
          "args": [
            "&bi",
            "tb->item_pos - n + tb->rnum[0] - 1",
            "ih",
            "body",
            "tb->zeroes_num"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_insert_into_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "901-972",
          "snippet": "void leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_right",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "28-35",
          "snippet": "static inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_right",
          "args": [
            "tb",
            "tb->rnum[0] - 1",
            "tb->rbytes"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "794-812",
          "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "old_len - tb->rbytes"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_le_ih_k_offset",
          "args": [
            "ih",
            "old_key_comp"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "set_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1521-1524",
          "snippet": "static inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void set_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tset_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "tb->rbytes"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_ih_k_offset",
          "args": [
            "ih"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1481-1484",
          "snippet": "static inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline loff_t le_ih_k_offset(const struct item_head *ih)\n{\n\treturn le_key_k_offset(ih_version(ih), &(ih->ih_key));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_insert_right(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body)\n{\n\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\tstruct buffer_info bi;\n\tint ret;\n\n\t/* new item or part of it doesn't fall into R[0] */\n\tif (n - tb->rnum[0] >= tb->item_pos) {\n\t\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\t\treturn;\n\t}\n\n\t/* new item or its part falls to R[0] */\n\n\t/* part of new item falls into R[0] */\n\tif (tb->item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1) {\n\t\tloff_t old_key_comp, old_len, r_zeroes_number;\n\t\tconst char *r_body;\n\t\tint version, shift;\n\t\tloff_t offset;\n\n\t\tleaf_shift_right(tb, tb->rnum[0] - 1, -1);\n\n\t\tversion = ih_version(ih);\n\n\t\t/* Remember key component and item length */\n\t\told_key_comp = le_ih_k_offset(ih);\n\t\told_len = ih_item_len(ih);\n\n\t\t/*\n\t\t * Calculate key component and item length to insert\n\t\t * into R[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\toffset = le_ih_k_offset(ih) + ((old_len - tb->rbytes) << shift);\n\t\tset_le_ih_k_offset(ih, offset);\n\t\tput_ih_item_len(ih, tb->rbytes);\n\n\t\t/* Insert part of the item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tif ((old_len - tb->rbytes) > tb->zeroes_num) {\n\t\t\tr_zeroes_number = 0;\n\t\t\tr_body = body + (old_len - tb->rbytes) - tb->zeroes_num;\n\t\t} else {\n\t\t\tr_body = body;\n\t\t\tr_zeroes_number = tb->zeroes_num -\n\t\t\t\t\t  (old_len - tb->rbytes);\n\t\t\ttb->zeroes_num -= r_zeroes_number;\n\t\t}\n\n\t\tleaf_insert_into_buf(&bi, 0, ih, r_body, r_zeroes_number);\n\n\t\t/* Replace right delimiting key by first key in R[0] */\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t/*\n\t\t * Calculate key component and item length to\n\t\t * insert into S[0]\n\t\t */\n\t\tset_le_ih_k_offset(ih, old_key_comp);\n\t\tput_ih_item_len(ih, old_len - tb->rbytes);\n\n\t\ttb->insert_size[0] -= tb->rbytes;\n\n\t} else {\n\t\t/* whole new item falls into R[0] */\n\n\t\t/* Shift rnum[0]-1 items to R[0] */\n\t\tret = leaf_shift_right(tb, tb->rnum[0] - 1, tb->rbytes);\n\n\t\t/* Insert new item into R[0] */\n\t\tbuffer_info_init_right(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, tb->item_pos - n + tb->rnum[0] - 1,\n\t\t\t\t     ih, body, tb->zeroes_num);\n\n\t\tif (tb->item_pos - n + tb->rnum[0] - 1 == 0)\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\ttb->zeroes_num = tb->insert_size[0] = 0;\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "605-624",
    "snippet": "static unsigned int balance_leaf_left(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\tif (tb->lnum[0] <= 0)\n\t\treturn 0;\n\n\t/* new item or it part falls to L[0], shift it too */\n\tif (tb->item_pos < tb->lnum[0]) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tif (flag == M_INSERT)\n\t\t\treturn balance_leaf_insert_left(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\treturn balance_leaf_paste_left(tb, ih, body);\n\t} else\n\t\t/* new item doesn't fall into L[0] */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_shift_left",
          "args": [
            "tb",
            "tb->lnum[0]",
            "tb->lbytes"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "741-786",
          "snippet": "int leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_paste_left",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "592-602",
          "snippet": "static unsigned int balance_leaf_paste_left(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\t/* we must shift the part of the appended item */\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)\n\t\treturn balance_leaf_paste_left_shift(tb, ih, body);\n\telse\n\t\tbalance_leaf_paste_left_whole(tb, ih, body);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_paste_left(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\t/* we must shift the part of the appended item */\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)\n\t\treturn balance_leaf_paste_left_shift(tb, ih, body);\n\telse\n\t\tbalance_leaf_paste_left_whole(tb, ih, body);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_insert_left",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_insert_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "289-355",
          "snippet": "static unsigned int balance_leaf_insert_left(struct tree_balance *tb,\n\t\t\t\t\t     struct item_head *const ih,\n\t\t\t\t\t     const char * const body)\n{\n\tint ret;\n\tstruct buffer_info bi;\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tunsigned body_shift_bytes = 0;\n\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {\n\t\t/* part of new item falls into L[0] */\n\t\tint new_item_len, shift;\n\t\tint version;\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);\n\n\t\t/* Calculate item length to insert to S[0] */\n\t\tnew_item_len = ih_item_len(ih) - tb->lbytes;\n\n\t\t/* Calculate and check item length to insert to L[0] */\n\t\tput_ih_item_len(ih, ih_item_len(ih) - new_item_len);\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12080: there is nothing to insert into L[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t     min_t(int, tb->zeroes_num, ih_item_len(ih)));\n\n\t\tversion = ih_version(ih);\n\n\t\t/*\n\t\t * Calculate key component, item length and body to\n\t\t * insert into S[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\n\t\tadd_le_ih_k_offset(ih, tb->lbytes << shift);\n\n\t\tput_ih_item_len(ih, new_item_len);\n\t\tif (tb->lbytes > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = tb->lbytes - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= tb->lbytes;\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12085: there is nothing to insert into S[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\t} else {\n\t\t/* new item in whole falls into L[0] */\n\t\t/* Shift lnum[0]-1 items to L[0] */\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t\t     tb->zeroes_num);\n\t\ttb->insert_size[0] = 0;\n\t\ttb->zeroes_num = 0;\n\t}\n\treturn body_shift_bytes;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_insert_left(struct tree_balance *tb,\n\t\t\t\t\t     struct item_head *const ih,\n\t\t\t\t\t     const char * const body)\n{\n\tint ret;\n\tstruct buffer_info bi;\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tunsigned body_shift_bytes = 0;\n\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {\n\t\t/* part of new item falls into L[0] */\n\t\tint new_item_len, shift;\n\t\tint version;\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);\n\n\t\t/* Calculate item length to insert to S[0] */\n\t\tnew_item_len = ih_item_len(ih) - tb->lbytes;\n\n\t\t/* Calculate and check item length to insert to L[0] */\n\t\tput_ih_item_len(ih, ih_item_len(ih) - new_item_len);\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12080: there is nothing to insert into L[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t     min_t(int, tb->zeroes_num, ih_item_len(ih)));\n\n\t\tversion = ih_version(ih);\n\n\t\t/*\n\t\t * Calculate key component, item length and body to\n\t\t * insert into S[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\n\t\tadd_le_ih_k_offset(ih, tb->lbytes << shift);\n\n\t\tput_ih_item_len(ih, new_item_len);\n\t\tif (tb->lbytes > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = tb->lbytes - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= tb->lbytes;\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12085: there is nothing to insert into S[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\t} else {\n\t\t/* new item in whole falls into L[0] */\n\t\t/* Shift lnum[0]-1 items to L[0] */\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t\t     tb->zeroes_num);\n\t\ttb->insert_size[0] = 0;\n\t\ttb->zeroes_num = 0;\n\t}\n\treturn body_shift_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flag != M_INSERT && flag != M_PASTE"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_left(struct tree_balance *tb,\n\t\t\t\t      struct item_head * const ih,\n\t\t\t\t      const char * const body, int flag)\n{\n\tif (tb->lnum[0] <= 0)\n\t\treturn 0;\n\n\t/* new item or it part falls to L[0], shift it too */\n\tif (tb->item_pos < tb->lnum[0]) {\n\t\tBUG_ON(flag != M_INSERT && flag != M_PASTE);\n\n\t\tif (flag == M_INSERT)\n\t\t\treturn balance_leaf_insert_left(tb, ih, body);\n\t\telse /* M_PASTE */\n\t\t\treturn balance_leaf_paste_left(tb, ih, body);\n\t} else\n\t\t/* new item doesn't fall into L[0] */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\treturn 0;\n}"
  },
  {
    "function_name": "balance_leaf_paste_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "592-602",
    "snippet": "static unsigned int balance_leaf_paste_left(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\t/* we must shift the part of the appended item */\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)\n\t\treturn balance_leaf_paste_left_shift(tb, ih, body);\n\telse\n\t\tbalance_leaf_paste_left_whole(tb, ih, body);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "balance_leaf_paste_left_whole",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_left_whole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "538-590",
          "snippet": "static void balance_leaf_paste_left_whole(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted;\n\tint ret;\n\n\t/* if we paste into first item of S[0] and it is left mergable */\n\tif (!tb->item_pos &&\n\t    op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {\n\t\t/*\n\t\t * then increment pos_in_item by the size of the\n\t\t * last item in L[0]\n\t\t */\n\t\tpasted = item_head(tb->L[0], n - 1);\n\t\tif (is_direntry_le_ih(pasted))\n\t\t\ttb->pos_in_item += ih_entry_count(pasted);\n\t\telse\n\t\t\ttb->pos_in_item += ih_item_len(pasted);\n\t}\n\n\t/*\n\t * Shift lnum[0] - 1 items in whole.\n\t * Shift lbytes - 1 byte from item number lnum[0]\n\t */\n\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\n\t/* Append to body of item in L[0] */\n\tbuffer_info_init_left(tb, &bi);\n\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret, tb->pos_in_item,\n\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t/* if appended item is directory, paste entry */\n\tpasted = item_head(tb->L[0], n + tb->item_pos - ret);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/*\n\t * if appended item is indirect item, put unformatted node\n\t * into un list\n\t */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->insert_size[0] = 0;\n\ttb->zeroes_num = 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_left_whole(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted;\n\tint ret;\n\n\t/* if we paste into first item of S[0] and it is left mergable */\n\tif (!tb->item_pos &&\n\t    op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {\n\t\t/*\n\t\t * then increment pos_in_item by the size of the\n\t\t * last item in L[0]\n\t\t */\n\t\tpasted = item_head(tb->L[0], n - 1);\n\t\tif (is_direntry_le_ih(pasted))\n\t\t\ttb->pos_in_item += ih_entry_count(pasted);\n\t\telse\n\t\t\ttb->pos_in_item += ih_item_len(pasted);\n\t}\n\n\t/*\n\t * Shift lnum[0] - 1 items in whole.\n\t * Shift lbytes - 1 byte from item number lnum[0]\n\t */\n\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\n\t/* Append to body of item in L[0] */\n\tbuffer_info_init_left(tb, &bi);\n\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret, tb->pos_in_item,\n\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t/* if appended item is directory, paste entry */\n\tpasted = item_head(tb->L[0], n + tb->item_pos - ret);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/*\n\t * if appended item is indirect item, put unformatted node\n\t * into un list\n\t */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->insert_size[0] = 0;\n\ttb->zeroes_num = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_paste_left_shift",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_left_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "419-534",
          "snippet": "static unsigned int balance_leaf_paste_left_shift(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tint body_shift_bytes = 0;\n\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_left_shift_dirent(tb, ih, body);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->lbytes <= 0,\n\t       \"PAP-12095: there is nothing to shift to L[0]. \"\n\t       \"lbytes=%d\", tb->lbytes);\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12100: incorrect position to paste: \"\n\t       \"item_len=%d, pos_in_item=%d\",\n\t       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);\n\n\t/* appended item will be in L[0] in whole */\n\tif (tb->lbytes >= tb->pos_in_item) {\n\t\tstruct item_head *tbS0_pos_ih, *tbL0_ih;\n\t\tstruct item_head *tbS0_0_ih;\n\t\tstruct reiserfs_key *left_delim_key;\n\t\tint ret, l_n, version, temp_l;\n\n\t\ttbS0_pos_ih = item_head(tbS0, tb->item_pos);\n\t\ttbS0_0_ih = item_head(tbS0, 0);\n\n\t\t/*\n\t\t * this bytes number must be appended\n\t\t * to the last item of L[h]\n\t\t */\n\t\tl_n = tb->lbytes - tb->pos_in_item;\n\n\t\t/* Calculate new insert_size[0] */\n\t\ttb->insert_size[0] -= l_n;\n\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12105: there is nothing to paste into \"\n\t\t       \"L[0]. insert_size=%d\", tb->insert_size[0]);\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0],\n\t\t\t\t      ih_item_len(tbS0_pos_ih));\n\n\t\ttbL0_ih = item_head(tb->L[0], n + tb->item_pos - ret);\n\n\t\t/* Append to body of item in L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     ih_item_len(tbL0_ih), l_n, body,\n\t\t\t\t     min_t(int, l_n, tb->zeroes_num));\n\n\t\t/*\n\t\t * 0-th item in S0 can be only of DIRECT type\n\t\t * when l_n != 0\n\t\t */\n\t\ttemp_l = l_n;\n\n\t\tRFALSE(ih_item_len(tbS0_0_ih),\n\t\t       \"PAP-12106: item length must be 0\");\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t       leaf_key(tb->L[0], n + tb->item_pos - ret)),\n\t\t       \"PAP-12107: items must be of the same file\");\n\n\t\tif (is_indirect_le_ih(tbL0_ih)) {\n\t\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\t\ttemp_l = l_n << shift;\n\t\t}\n\t\t/* update key of first item in S0 */\n\t\tversion = ih_version(tbS0_0_ih);\n\t\tadd_le_key_k_offset(version, &tbS0_0_ih->ih_key, temp_l);\n\n\t\t/* update left delimiting key */\n\t\tleft_delim_key = internal_key(tb->CFL[0], tb->lkey[0]);\n\t\tadd_le_key_k_offset(version, left_delim_key, temp_l);\n\n\t\t/*\n\t\t * Calculate new body, position in item and\n\t\t * insert_size[0]\n\t\t */\n\t\tif (l_n > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = l_n - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= l_n;\n\t\ttb->pos_in_item = 0;\n\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t\t\t\t  leaf_key(tb->L[0],\n\t\t\t\t\t\t B_NR_ITEMS(tb->L[0]) - 1)) ||\n\t\t       !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||\n\t\t       !op_is_left_mergeable(left_delim_key, tbS0->b_size),\n\t\t       \"PAP-12120: item must be merge-able with left \"\n\t\t       \"neighboring item\");\n\t} else {\n\t\t/* only part of the appended item will be in L[0] */\n\n\t\t/* Calculate position in item for append in S[0] */\n\t\ttb->pos_in_item -= tb->lbytes;\n\n\t\tRFALSE(tb->pos_in_item <= 0,\n\t\t       \"PAP-12125: no place for paste. pos_in_item=%d\",\n\t\t       tb->pos_in_item);\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 byte from item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\treturn body_shift_bytes;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_paste_left_shift(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tint body_shift_bytes = 0;\n\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_left_shift_dirent(tb, ih, body);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->lbytes <= 0,\n\t       \"PAP-12095: there is nothing to shift to L[0]. \"\n\t       \"lbytes=%d\", tb->lbytes);\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12100: incorrect position to paste: \"\n\t       \"item_len=%d, pos_in_item=%d\",\n\t       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);\n\n\t/* appended item will be in L[0] in whole */\n\tif (tb->lbytes >= tb->pos_in_item) {\n\t\tstruct item_head *tbS0_pos_ih, *tbL0_ih;\n\t\tstruct item_head *tbS0_0_ih;\n\t\tstruct reiserfs_key *left_delim_key;\n\t\tint ret, l_n, version, temp_l;\n\n\t\ttbS0_pos_ih = item_head(tbS0, tb->item_pos);\n\t\ttbS0_0_ih = item_head(tbS0, 0);\n\n\t\t/*\n\t\t * this bytes number must be appended\n\t\t * to the last item of L[h]\n\t\t */\n\t\tl_n = tb->lbytes - tb->pos_in_item;\n\n\t\t/* Calculate new insert_size[0] */\n\t\ttb->insert_size[0] -= l_n;\n\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12105: there is nothing to paste into \"\n\t\t       \"L[0]. insert_size=%d\", tb->insert_size[0]);\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0],\n\t\t\t\t      ih_item_len(tbS0_pos_ih));\n\n\t\ttbL0_ih = item_head(tb->L[0], n + tb->item_pos - ret);\n\n\t\t/* Append to body of item in L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     ih_item_len(tbL0_ih), l_n, body,\n\t\t\t\t     min_t(int, l_n, tb->zeroes_num));\n\n\t\t/*\n\t\t * 0-th item in S0 can be only of DIRECT type\n\t\t * when l_n != 0\n\t\t */\n\t\ttemp_l = l_n;\n\n\t\tRFALSE(ih_item_len(tbS0_0_ih),\n\t\t       \"PAP-12106: item length must be 0\");\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t       leaf_key(tb->L[0], n + tb->item_pos - ret)),\n\t\t       \"PAP-12107: items must be of the same file\");\n\n\t\tif (is_indirect_le_ih(tbL0_ih)) {\n\t\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\t\ttemp_l = l_n << shift;\n\t\t}\n\t\t/* update key of first item in S0 */\n\t\tversion = ih_version(tbS0_0_ih);\n\t\tadd_le_key_k_offset(version, &tbS0_0_ih->ih_key, temp_l);\n\n\t\t/* update left delimiting key */\n\t\tleft_delim_key = internal_key(tb->CFL[0], tb->lkey[0]);\n\t\tadd_le_key_k_offset(version, left_delim_key, temp_l);\n\n\t\t/*\n\t\t * Calculate new body, position in item and\n\t\t * insert_size[0]\n\t\t */\n\t\tif (l_n > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = l_n - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= l_n;\n\t\ttb->pos_in_item = 0;\n\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t\t\t\t  leaf_key(tb->L[0],\n\t\t\t\t\t\t B_NR_ITEMS(tb->L[0]) - 1)) ||\n\t\t       !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||\n\t\t       !op_is_left_mergeable(left_delim_key, tbS0->b_size),\n\t\t       \"PAP-12120: item must be merge-able with left \"\n\t\t       \"neighboring item\");\n\t} else {\n\t\t/* only part of the appended item will be in L[0] */\n\n\t\t/* Calculate position in item for append in S[0] */\n\t\ttb->pos_in_item -= tb->lbytes;\n\n\t\tRFALSE(tb->pos_in_item <= 0,\n\t\t       \"PAP-12125: no place for paste. pos_in_item=%d\",\n\t\t       tb->pos_in_item);\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 byte from item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\treturn body_shift_bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_paste_left(struct tree_balance *tb,\n\t\t\t\t\t    struct item_head * const ih,\n\t\t\t\t\t    const char * const body)\n{\n\t/* we must shift the part of the appended item */\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)\n\t\treturn balance_leaf_paste_left_shift(tb, ih, body);\n\telse\n\t\tbalance_leaf_paste_left_whole(tb, ih, body);\n\treturn 0;\n}"
  },
  {
    "function_name": "balance_leaf_paste_left_whole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "538-590",
    "snippet": "static void balance_leaf_paste_left_whole(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted;\n\tint ret;\n\n\t/* if we paste into first item of S[0] and it is left mergable */\n\tif (!tb->item_pos &&\n\t    op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {\n\t\t/*\n\t\t * then increment pos_in_item by the size of the\n\t\t * last item in L[0]\n\t\t */\n\t\tpasted = item_head(tb->L[0], n - 1);\n\t\tif (is_direntry_le_ih(pasted))\n\t\t\ttb->pos_in_item += ih_entry_count(pasted);\n\t\telse\n\t\t\ttb->pos_in_item += ih_item_len(pasted);\n\t}\n\n\t/*\n\t * Shift lnum[0] - 1 items in whole.\n\t * Shift lbytes - 1 byte from item number lnum[0]\n\t */\n\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\n\t/* Append to body of item in L[0] */\n\tbuffer_info_init_left(tb, &bi);\n\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret, tb->pos_in_item,\n\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t/* if appended item is directory, paste entry */\n\tpasted = item_head(tb->L[0], n + tb->item_pos - ret);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/*\n\t * if appended item is indirect item, put unformatted node\n\t * into un list\n\t */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->insert_size[0] = 0;\n\ttb->zeroes_num = 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ih_free_space",
          "args": [
            "pasted",
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "pasted"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "&bi",
            "n + tb->item_pos - ret",
            "tb->pos_in_item",
            "1",
            "(struct reiserfs_de_head *)body",
            "body + DEH_SIZE",
            "tb->insert_size[0]"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "pasted"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tb->L[0]",
            "n + tb->item_pos - ret"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "n + tb->item_pos - ret",
            "tb->pos_in_item",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_left",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "19-26",
          "snippet": "static inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_left",
          "args": [
            "tb",
            "tb->lnum[0]",
            "tb->lbytes"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "741-786",
          "snippet": "int leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "pasted"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "pasted"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "leaf_key(tbS0, 0)",
            "tbS0->b_size"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_key",
          "args": [
            "tbS0",
            "0"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2207-2211",
          "snippet": "static inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[0]"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_left_whole(struct tree_balance *tb,\n\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tstruct item_head *pasted;\n\tint ret;\n\n\t/* if we paste into first item of S[0] and it is left mergable */\n\tif (!tb->item_pos &&\n\t    op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size)) {\n\t\t/*\n\t\t * then increment pos_in_item by the size of the\n\t\t * last item in L[0]\n\t\t */\n\t\tpasted = item_head(tb->L[0], n - 1);\n\t\tif (is_direntry_le_ih(pasted))\n\t\t\ttb->pos_in_item += ih_entry_count(pasted);\n\t\telse\n\t\t\ttb->pos_in_item += ih_item_len(pasted);\n\t}\n\n\t/*\n\t * Shift lnum[0] - 1 items in whole.\n\t * Shift lbytes - 1 byte from item number lnum[0]\n\t */\n\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\n\t/* Append to body of item in L[0] */\n\tbuffer_info_init_left(tb, &bi);\n\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret, tb->pos_in_item,\n\t\t\t     tb->insert_size[0], body, tb->zeroes_num);\n\n\t/* if appended item is directory, paste entry */\n\tpasted = item_head(tb->L[0], n + tb->item_pos - ret);\n\tif (is_direntry_le_ih(pasted))\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   tb->pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *)body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\n\t/*\n\t * if appended item is indirect item, put unformatted node\n\t * into un list\n\t */\n\tif (is_indirect_le_ih(pasted))\n\t\tset_ih_free_space(pasted, 0);\n\n\ttb->insert_size[0] = 0;\n\ttb->zeroes_num = 0;\n}"
  },
  {
    "function_name": "balance_leaf_paste_left_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "419-534",
    "snippet": "static unsigned int balance_leaf_paste_left_shift(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tint body_shift_bytes = 0;\n\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_left_shift_dirent(tb, ih, body);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->lbytes <= 0,\n\t       \"PAP-12095: there is nothing to shift to L[0]. \"\n\t       \"lbytes=%d\", tb->lbytes);\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12100: incorrect position to paste: \"\n\t       \"item_len=%d, pos_in_item=%d\",\n\t       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);\n\n\t/* appended item will be in L[0] in whole */\n\tif (tb->lbytes >= tb->pos_in_item) {\n\t\tstruct item_head *tbS0_pos_ih, *tbL0_ih;\n\t\tstruct item_head *tbS0_0_ih;\n\t\tstruct reiserfs_key *left_delim_key;\n\t\tint ret, l_n, version, temp_l;\n\n\t\ttbS0_pos_ih = item_head(tbS0, tb->item_pos);\n\t\ttbS0_0_ih = item_head(tbS0, 0);\n\n\t\t/*\n\t\t * this bytes number must be appended\n\t\t * to the last item of L[h]\n\t\t */\n\t\tl_n = tb->lbytes - tb->pos_in_item;\n\n\t\t/* Calculate new insert_size[0] */\n\t\ttb->insert_size[0] -= l_n;\n\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12105: there is nothing to paste into \"\n\t\t       \"L[0]. insert_size=%d\", tb->insert_size[0]);\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0],\n\t\t\t\t      ih_item_len(tbS0_pos_ih));\n\n\t\ttbL0_ih = item_head(tb->L[0], n + tb->item_pos - ret);\n\n\t\t/* Append to body of item in L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     ih_item_len(tbL0_ih), l_n, body,\n\t\t\t\t     min_t(int, l_n, tb->zeroes_num));\n\n\t\t/*\n\t\t * 0-th item in S0 can be only of DIRECT type\n\t\t * when l_n != 0\n\t\t */\n\t\ttemp_l = l_n;\n\n\t\tRFALSE(ih_item_len(tbS0_0_ih),\n\t\t       \"PAP-12106: item length must be 0\");\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t       leaf_key(tb->L[0], n + tb->item_pos - ret)),\n\t\t       \"PAP-12107: items must be of the same file\");\n\n\t\tif (is_indirect_le_ih(tbL0_ih)) {\n\t\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\t\ttemp_l = l_n << shift;\n\t\t}\n\t\t/* update key of first item in S0 */\n\t\tversion = ih_version(tbS0_0_ih);\n\t\tadd_le_key_k_offset(version, &tbS0_0_ih->ih_key, temp_l);\n\n\t\t/* update left delimiting key */\n\t\tleft_delim_key = internal_key(tb->CFL[0], tb->lkey[0]);\n\t\tadd_le_key_k_offset(version, left_delim_key, temp_l);\n\n\t\t/*\n\t\t * Calculate new body, position in item and\n\t\t * insert_size[0]\n\t\t */\n\t\tif (l_n > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = l_n - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= l_n;\n\t\ttb->pos_in_item = 0;\n\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t\t\t\t  leaf_key(tb->L[0],\n\t\t\t\t\t\t B_NR_ITEMS(tb->L[0]) - 1)) ||\n\t\t       !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||\n\t\t       !op_is_left_mergeable(left_delim_key, tbS0->b_size),\n\t\t       \"PAP-12120: item must be merge-able with left \"\n\t\t       \"neighboring item\");\n\t} else {\n\t\t/* only part of the appended item will be in L[0] */\n\n\t\t/* Calculate position in item for append in S[0] */\n\t\ttb->pos_in_item -= tb->lbytes;\n\n\t\tRFALSE(tb->pos_in_item <= 0,\n\t\t       \"PAP-12125: no place for paste. pos_in_item=%d\",\n\t\t       tb->pos_in_item);\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 byte from item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\treturn body_shift_bytes;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_shift_left",
          "args": [
            "tb",
            "tb->lnum[0]",
            "tb->lbytes"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "741-786",
          "snippet": "int leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->pos_in_item <= 0",
            "\"PAP-12125: no place for paste. pos_in_item=%d\"",
            "tb->pos_in_item"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t\t\t\t  leaf_key(tb->L[0],\n\t\t\t\t\t\t B_NR_ITEMS(tb->L[0]) - 1)) ||\n\t\t       !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||\n\t\t       !op_is_left_mergeable(left_delim_key, tbS0->b_size)",
            "\"PAP-12120: item must be merge-able with left \"\n\t\t       \"neighboring item\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "left_delim_key",
            "tbS0->b_size"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op_is_left_mergeable",
          "args": [
            "leaf_key(tbS0, 0)",
            "tbS0->b_size"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_key",
          "args": [
            "tbS0",
            "0"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2207-2211",
          "snippet": "static inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *leaf_key(const struct buffer_head *bh,\n\t\t\t\t\t    int item_num)\n{\n\treturn &item_head(bh, item_num)->ih_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_short_le_keys",
          "args": [
            "&tbS0_0_ih->ih_key",
            "leaf_key(tb->L[0],\n\t\t\t\t\t\t B_NR_ITEMS(tb->L[0]) - 1)"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "comp_short_le_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/stree.c",
          "lines": "97-112",
          "snippet": "inline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/time.h>\n\ninline int comp_short_le_keys(const struct reiserfs_key *key1,\n\t\t\t      const struct reiserfs_key *key2)\n{\n\t__u32 *k1_u32, *k2_u32;\n\tint key_length = REISERFS_SHORT_KEY_LEN;\n\n\tk1_u32 = (__u32 *) key1;\n\tk2_u32 = (__u32 *) key2;\n\tfor (; key_length--; ++k1_u32, ++k2_u32) {\n\t\tif (le32_to_cpu(*k1_u32) < le32_to_cpu(*k2_u32))\n\t\t\treturn -1;\n\t\tif (le32_to_cpu(*k1_u32) > le32_to_cpu(*k2_u32))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[0]"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_le_key_k_offset",
          "args": [
            "version",
            "left_delim_key",
            "temp_l"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "add_le_key_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1509-1514",
          "snippet": "static inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void add_le_key_k_offset(int version, struct reiserfs_key *key,\n\t\t\t\t       loff_t offset)\n{\n\tset_le_key_k_offset(version, key,\n\t\t\t    le_key_k_offset(version, key) + offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFL[0]",
            "tb->lkey[0]"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "tbS0_0_ih"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "tbL0_ih"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t       leaf_key(tb->L[0], n + tb->item_pos - ret))",
            "\"PAP-12107: items must be of the same file\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_item_len(tbS0_0_ih)",
            "\"PAP-12106: item length must be 0\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "tbS0_0_ih"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "n + tb->item_pos - ret",
            "ih_item_len(tbL0_ih)",
            "l_n",
            "body",
            "min_t(int, l_n, tb->zeroes_num)"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "l_n",
            "tb->zeroes_num"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "tbL0_ih"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_info_init_left",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "19-26",
          "snippet": "static inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tb->L[0]",
            "n + tb->item_pos - ret"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "tbS0_pos_ih"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->insert_size[0] <= 0",
            "\"PAP-12105: there is nothing to paste into \"\n\t\t       \"L[0]. insert_size=%d\"",
            "tb->insert_size[0]"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos))",
            "\"PAP-12100: incorrect position to paste: \"\n\t       \"item_len=%d, pos_in_item=%d\"",
            "ih_item_len(item_head(tbS0, tb->item_pos))",
            "tb->pos_in_item"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->lbytes <= 0",
            "\"PAP-12095: there is nothing to shift to L[0]. \"\n\t       \"lbytes=%d\"",
            "tb->lbytes"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_leaf_paste_left_shift_dirent",
          "args": [
            "tb",
            "ih",
            "body"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_paste_left_shift_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "357-417",
          "snippet": "static void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t\t const char * const body)\n{\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12090: invalid parameter in case of a directory\");\n\n\t/* directory item */\n\tif (tb->lbytes > tb->pos_in_item) {\n\t\t/* new directory entry falls into L[0] */\n\t\tstruct item_head *pasted;\n\t\tint ret, l_pos_in_item = tb->pos_in_item;\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 entries from given directory item\n\t\t */\n\t\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);\n\t\tif (ret && !tb->item_pos) {\n\t\t\tpasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);\n\t\t\tl_pos_in_item += ih_entry_count(pasted) -\n\t\t\t\t\t (tb->lbytes - 1);\n\t\t}\n\n\t\t/* Append given directory entry to directory item */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     l_pos_in_item, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/*\n\t\t * previous string prepared space for pasting new entry,\n\t\t * following string pastes this entry\n\t\t */\n\n\t\t/*\n\t\t * when we have merge directory item, pos_in_item\n\t\t * has been changed too\n\t\t */\n\n\t\t/* paste new directory entry. 1 is entry number */\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   l_pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\t\ttb->insert_size[0] = 0;\n\t} else {\n\t\t/* new directory item doesn't fall into L[0] */\n\t\t/*\n\t\t * Shift lnum[0]-1 items in whole. Shift lbytes\n\t\t * directory entries from directory item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\n\t/* Calculate new position to append in item body */\n\ttb->pos_in_item -= tb->lbytes;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t\t const char * const body)\n{\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12090: invalid parameter in case of a directory\");\n\n\t/* directory item */\n\tif (tb->lbytes > tb->pos_in_item) {\n\t\t/* new directory entry falls into L[0] */\n\t\tstruct item_head *pasted;\n\t\tint ret, l_pos_in_item = tb->pos_in_item;\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 entries from given directory item\n\t\t */\n\t\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);\n\t\tif (ret && !tb->item_pos) {\n\t\t\tpasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);\n\t\t\tl_pos_in_item += ih_entry_count(pasted) -\n\t\t\t\t\t (tb->lbytes - 1);\n\t\t}\n\n\t\t/* Append given directory entry to directory item */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     l_pos_in_item, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/*\n\t\t * previous string prepared space for pasting new entry,\n\t\t * following string pastes this entry\n\t\t */\n\n\t\t/*\n\t\t * when we have merge directory item, pos_in_item\n\t\t * has been changed too\n\t\t */\n\n\t\t/* paste new directory entry. 1 is entry number */\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   l_pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\t\ttb->insert_size[0] = 0;\n\t} else {\n\t\t/* new directory item doesn't fall into L[0] */\n\t\t/*\n\t\t * Shift lnum[0]-1 items in whole. Shift lbytes\n\t\t * directory entries from directory item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\n\t/* Calculate new position to append in item body */\n\ttb->pos_in_item -= tb->lbytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "item_head(tbS0, tb->item_pos)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[0]"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_paste_left_shift(struct tree_balance *tb,\n\t\t\t\t\t\t  struct item_head * const ih,\n\t\t\t\t\t\t  const char * const body)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\tint body_shift_bytes = 0;\n\n\tif (is_direntry_le_ih(item_head(tbS0, tb->item_pos))) {\n\t\tbalance_leaf_paste_left_shift_dirent(tb, ih, body);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->lbytes <= 0,\n\t       \"PAP-12095: there is nothing to shift to L[0]. \"\n\t       \"lbytes=%d\", tb->lbytes);\n\tRFALSE(tb->pos_in_item != ih_item_len(item_head(tbS0, tb->item_pos)),\n\t       \"PAP-12100: incorrect position to paste: \"\n\t       \"item_len=%d, pos_in_item=%d\",\n\t       ih_item_len(item_head(tbS0, tb->item_pos)), tb->pos_in_item);\n\n\t/* appended item will be in L[0] in whole */\n\tif (tb->lbytes >= tb->pos_in_item) {\n\t\tstruct item_head *tbS0_pos_ih, *tbL0_ih;\n\t\tstruct item_head *tbS0_0_ih;\n\t\tstruct reiserfs_key *left_delim_key;\n\t\tint ret, l_n, version, temp_l;\n\n\t\ttbS0_pos_ih = item_head(tbS0, tb->item_pos);\n\t\ttbS0_0_ih = item_head(tbS0, 0);\n\n\t\t/*\n\t\t * this bytes number must be appended\n\t\t * to the last item of L[h]\n\t\t */\n\t\tl_n = tb->lbytes - tb->pos_in_item;\n\n\t\t/* Calculate new insert_size[0] */\n\t\ttb->insert_size[0] -= l_n;\n\n\t\tRFALSE(tb->insert_size[0] <= 0,\n\t\t       \"PAP-12105: there is nothing to paste into \"\n\t\t       \"L[0]. insert_size=%d\", tb->insert_size[0]);\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0],\n\t\t\t\t      ih_item_len(tbS0_pos_ih));\n\n\t\ttbL0_ih = item_head(tb->L[0], n + tb->item_pos - ret);\n\n\t\t/* Append to body of item in L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     ih_item_len(tbL0_ih), l_n, body,\n\t\t\t\t     min_t(int, l_n, tb->zeroes_num));\n\n\t\t/*\n\t\t * 0-th item in S0 can be only of DIRECT type\n\t\t * when l_n != 0\n\t\t */\n\t\ttemp_l = l_n;\n\n\t\tRFALSE(ih_item_len(tbS0_0_ih),\n\t\t       \"PAP-12106: item length must be 0\");\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t       leaf_key(tb->L[0], n + tb->item_pos - ret)),\n\t\t       \"PAP-12107: items must be of the same file\");\n\n\t\tif (is_indirect_le_ih(tbL0_ih)) {\n\t\t\tint shift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\t\t\ttemp_l = l_n << shift;\n\t\t}\n\t\t/* update key of first item in S0 */\n\t\tversion = ih_version(tbS0_0_ih);\n\t\tadd_le_key_k_offset(version, &tbS0_0_ih->ih_key, temp_l);\n\n\t\t/* update left delimiting key */\n\t\tleft_delim_key = internal_key(tb->CFL[0], tb->lkey[0]);\n\t\tadd_le_key_k_offset(version, left_delim_key, temp_l);\n\n\t\t/*\n\t\t * Calculate new body, position in item and\n\t\t * insert_size[0]\n\t\t */\n\t\tif (l_n > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = l_n - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= l_n;\n\t\ttb->pos_in_item = 0;\n\n\t\tRFALSE(comp_short_le_keys(&tbS0_0_ih->ih_key,\n\t\t\t\t\t  leaf_key(tb->L[0],\n\t\t\t\t\t\t B_NR_ITEMS(tb->L[0]) - 1)) ||\n\t\t       !op_is_left_mergeable(leaf_key(tbS0, 0), tbS0->b_size) ||\n\t\t       !op_is_left_mergeable(left_delim_key, tbS0->b_size),\n\t\t       \"PAP-12120: item must be merge-able with left \"\n\t\t       \"neighboring item\");\n\t} else {\n\t\t/* only part of the appended item will be in L[0] */\n\n\t\t/* Calculate position in item for append in S[0] */\n\t\ttb->pos_in_item -= tb->lbytes;\n\n\t\tRFALSE(tb->pos_in_item <= 0,\n\t\t       \"PAP-12125: no place for paste. pos_in_item=%d\",\n\t\t       tb->pos_in_item);\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 byte from item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\treturn body_shift_bytes;\n}"
  },
  {
    "function_name": "balance_leaf_paste_left_shift_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "357-417",
    "snippet": "static void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t\t const char * const body)\n{\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12090: invalid parameter in case of a directory\");\n\n\t/* directory item */\n\tif (tb->lbytes > tb->pos_in_item) {\n\t\t/* new directory entry falls into L[0] */\n\t\tstruct item_head *pasted;\n\t\tint ret, l_pos_in_item = tb->pos_in_item;\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 entries from given directory item\n\t\t */\n\t\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);\n\t\tif (ret && !tb->item_pos) {\n\t\t\tpasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);\n\t\t\tl_pos_in_item += ih_entry_count(pasted) -\n\t\t\t\t\t (tb->lbytes - 1);\n\t\t}\n\n\t\t/* Append given directory entry to directory item */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     l_pos_in_item, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/*\n\t\t * previous string prepared space for pasting new entry,\n\t\t * following string pastes this entry\n\t\t */\n\n\t\t/*\n\t\t * when we have merge directory item, pos_in_item\n\t\t * has been changed too\n\t\t */\n\n\t\t/* paste new directory entry. 1 is entry number */\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   l_pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\t\ttb->insert_size[0] = 0;\n\t} else {\n\t\t/* new directory item doesn't fall into L[0] */\n\t\t/*\n\t\t * Shift lnum[0]-1 items in whole. Shift lbytes\n\t\t * directory entries from directory item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\n\t/* Calculate new position to append in item body */\n\ttb->pos_in_item -= tb->lbytes;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_shift_left",
          "args": [
            "tb",
            "tb->lnum[0]",
            "tb->lbytes"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "741-786",
          "snippet": "int leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_entries",
          "args": [
            "&bi",
            "n + tb->item_pos - ret",
            "l_pos_in_item",
            "1",
            "(struct reiserfs_de_head *) body",
            "body + DEH_SIZE",
            "tb->insert_size[0]"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1314-1427",
          "snippet": "void leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_entries(struct buffer_info *bi,\n\t\t\tint item_num,\n\t\t\tint before,\n\t\t\tint new_entry_count,\n\t\t\tstruct reiserfs_de_head *new_dehs,\n\t\t\tconst char *records, int paste_size)\n{\n\tstruct item_head *ih;\n\tchar *item;\n\tstruct reiserfs_de_head *deh;\n\tchar *insert_point;\n\tint i, old_entry_num;\n\tstruct buffer_head *bh = bi->bi_bh;\n\n\tif (new_entry_count == 0)\n\t\treturn;\n\n\tih = item_head(bh, item_num);\n\n\t/*\n\t * make sure, that item is directory, and there are enough\n\t * records in it\n\t */\n\tRFALSE(!is_direntry_le_ih(ih), \"10225: item is not directory item\");\n\tRFALSE(ih_entry_count(ih) < before,\n\t       \"10230: there are no entry we paste entries before. entry_count = %d, before = %d\",\n\t       ih_entry_count(ih), before);\n\n\t/* first byte of dest item */\n\titem = bh->b_data + ih_location(ih);\n\n\t/* entry head array */\n\tdeh = B_I_DEH(bh, ih);\n\n\t/* new records will be pasted at this point */\n\tinsert_point =\n\t    item +\n\t    (before ? deh_location(&deh[before - 1])\n\t     : (ih_item_len(ih) - paste_size));\n\n\t/* adjust locations of records that will be AFTER new records */\n\tfor (i = ih_entry_count(ih) - 1; i >= before; i--)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (DEH_SIZE * new_entry_count));\n\n\t/* adjust locations of records that will be BEFORE new records */\n\tfor (i = 0; i < before; i++)\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) + paste_size);\n\n\told_entry_num = ih_entry_count(ih);\n\tput_ih_entry_count(ih, ih_entry_count(ih) + new_entry_count);\n\n\t/* prepare space for pasted records */\n\tmemmove(insert_point + paste_size, insert_point,\n\t\titem + (ih_item_len(ih) - paste_size) - insert_point);\n\n\t/* copy new records */\n\tmemcpy(insert_point + DEH_SIZE * new_entry_count, records,\n\t       paste_size - DEH_SIZE * new_entry_count);\n\n\t/* prepare space for new entry heads */\n\tdeh += before;\n\tmemmove((char *)(deh + new_entry_count), deh,\n\t\tinsert_point - (char *)deh);\n\n\t/* copy new entry heads */\n\tdeh = (struct reiserfs_de_head *)((char *)deh);\n\tmemcpy(deh, new_dehs, DEH_SIZE * new_entry_count);\n\n\t/* set locations of new records */\n\tfor (i = 0; i < new_entry_count; i++) {\n\t\tput_deh_location(&deh[i],\n\t\t\t\t deh_location(&deh[i]) +\n\t\t\t\t (-deh_location\n\t\t\t\t  (&new_dehs[new_entry_count - 1]) +\n\t\t\t\t  insert_point + DEH_SIZE * new_entry_count -\n\t\t\t\t  item));\n\t}\n\n\t/* change item key if necessary (when we paste before 0-th entry */\n\tif (!before) {\n\t\tset_le_ih_k_offset(ih, deh_offset(new_dehs));\n\t}\n#ifdef CONFIG_REISERFS_CHECK\n\t{\n\t\tint prev, next;\n\t\t/* check record locations */\n\t\tdeh = B_I_DEH(bh, ih);\n\t\tfor (i = 0; i < ih_entry_count(ih); i++) {\n\t\t\tnext =\n\t\t\t    (i <\n\t\t\t     ih_entry_count(ih) -\n\t\t\t     1) ? deh_location(&deh[i + 1]) : 0;\n\t\t\tprev = (i != 0) ? deh_location(&deh[i - 1]) : 0;\n\n\t\t\tif (prev && prev <= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10240\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (prev %a, \"\n\t\t\t\t\t       \"cur(%d) %a)\",\n\t\t\t\t\t       ih, deh + i - 1, i, deh + i);\n\t\t\tif (next && next >= deh_location(&deh[i]))\n\t\t\t\treiserfs_error(sb_from_bi(bi), \"vs-10250\",\n\t\t\t\t\t       \"directory item (%h) \"\n\t\t\t\t\t       \"corrupted (cur(%d) %a, \"\n\t\t\t\t\t       \"next %a)\",\n\t\t\t\t\t       ih, i, deh + i, deh + i + 1);\n\t\t}\n\t}\n#endif\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_paste_in_buffer",
          "args": [
            "&bi",
            "n + tb->item_pos - ret",
            "l_pos_in_item",
            "tb->insert_size[0]",
            "body",
            "tb->zeroes_num"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_paste_in_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "978-1064",
          "snippet": "void leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_paste_in_buffer(struct buffer_info *bi, int affected_item_num,\n\t\t\t  int pos_in_item, int paste_size,\n\t\t\t  const char *body, int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < paste_size,\n\t       \"vs-10175: not enough free space: needed %d, available %d\",\n\t       paste_size, free_space);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tif (zeros_number > paste_size) {\n\t\tstruct super_block *sb = NULL;\n\t\tif (bi && bi->tb)\n\t\t\tsb = bi->tb->tb_sb;\n\t\tprint_cur_tb(\"10177\");\n\t\treiserfs_panic(sb, \"vs-10177\",\n\t\t\t       \"zeros_number == %d, paste_size == %d\",\n\t\t\t       zeros_number, paste_size);\n\t}\n#endif\t\t\t\t/* CONFIG_REISERFS_CHECK */\n\n\t/* item to be appended */\n\tih = item_head(bh, affected_item_num);\n\n\tlast_loc = ih_location(&ih[nr - affected_item_num - 1]);\n\tunmoved_loc = affected_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* prepare space */\n\tmemmove(bh->b_data + last_loc - paste_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc);\n\n\t/* change locations */\n\tfor (i = affected_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - affected_item_num],\n\t\t\t\tih_location(&ih[i - affected_item_num]) -\n\t\t\t\tpaste_size);\n\n\tif (body) {\n\t\tif (!is_direntry_le_ih(ih)) {\n\t\t\tif (!pos_in_item) {\n\t\t\t\t/* shift data to right */\n\t\t\t\tmemmove(bh->b_data + ih_location(ih) +\n\t\t\t\t\tpaste_size,\n\t\t\t\t\tbh->b_data + ih_location(ih),\n\t\t\t\t\tih_item_len(ih));\n\t\t\t\t/* paste data in the head of item */\n\t\t\t\tmemset(bh->b_data + ih_location(ih), 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + ih_location(ih) +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t} else {\n\t\t\t\tmemset(bh->b_data + unmoved_loc - paste_size, 0,\n\t\t\t\t       zeros_number);\n\t\t\t\tmemcpy(bh->b_data + unmoved_loc - paste_size +\n\t\t\t\t       zeros_number, body,\n\t\t\t\t       paste_size - zeros_number);\n\t\t\t}\n\t\t}\n\t} else\n\t\tmemset(bh->b_data + unmoved_loc - paste_size, '\\0', paste_size);\n\n\tput_ih_item_len(ih, ih_item_len(ih) + paste_size);\n\n\t/* change free space */\n\tset_blkh_free_space(blkh, free_space - paste_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + paste_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_left",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "19-26",
          "snippet": "static inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_entry_count",
          "args": [
            "pasted"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tb->L[0]",
            "B_NR_ITEMS(tb->L[0]) - 1"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[0]"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->zeroes_num",
            "\"PAP-12090: invalid parameter in case of a directory\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[0]"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_paste_left_shift_dirent(struct tree_balance *tb,\n\t\t\t\t\t\t struct item_head * const ih,\n\t\t\t\t\t\t const char * const body)\n{\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tstruct buffer_info bi;\n\n\tRFALSE(tb->zeroes_num,\n\t       \"PAP-12090: invalid parameter in case of a directory\");\n\n\t/* directory item */\n\tif (tb->lbytes > tb->pos_in_item) {\n\t\t/* new directory entry falls into L[0] */\n\t\tstruct item_head *pasted;\n\t\tint ret, l_pos_in_item = tb->pos_in_item;\n\n\t\t/*\n\t\t * Shift lnum[0] - 1 items in whole.\n\t\t * Shift lbytes - 1 entries from given directory item\n\t\t */\n\t\tret = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);\n\t\tif (ret && !tb->item_pos) {\n\t\t\tpasted = item_head(tb->L[0], B_NR_ITEMS(tb->L[0]) - 1);\n\t\t\tl_pos_in_item += ih_entry_count(pasted) -\n\t\t\t\t\t (tb->lbytes - 1);\n\t\t}\n\n\t\t/* Append given directory entry to directory item */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_paste_in_buffer(&bi, n + tb->item_pos - ret,\n\t\t\t\t     l_pos_in_item, tb->insert_size[0],\n\t\t\t\t     body, tb->zeroes_num);\n\n\t\t/*\n\t\t * previous string prepared space for pasting new entry,\n\t\t * following string pastes this entry\n\t\t */\n\n\t\t/*\n\t\t * when we have merge directory item, pos_in_item\n\t\t * has been changed too\n\t\t */\n\n\t\t/* paste new directory entry. 1 is entry number */\n\t\tleaf_paste_entries(&bi, n + tb->item_pos - ret,\n\t\t\t\t   l_pos_in_item, 1,\n\t\t\t\t   (struct reiserfs_de_head *) body,\n\t\t\t\t   body + DEH_SIZE, tb->insert_size[0]);\n\t\ttb->insert_size[0] = 0;\n\t} else {\n\t\t/* new directory item doesn't fall into L[0] */\n\t\t/*\n\t\t * Shift lnum[0]-1 items in whole. Shift lbytes\n\t\t * directory entries from directory item number lnum[0]\n\t\t */\n\t\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\t}\n\n\t/* Calculate new position to append in item body */\n\ttb->pos_in_item -= tb->lbytes;\n}"
  },
  {
    "function_name": "balance_leaf_insert_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "289-355",
    "snippet": "static unsigned int balance_leaf_insert_left(struct tree_balance *tb,\n\t\t\t\t\t     struct item_head *const ih,\n\t\t\t\t\t     const char * const body)\n{\n\tint ret;\n\tstruct buffer_info bi;\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tunsigned body_shift_bytes = 0;\n\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {\n\t\t/* part of new item falls into L[0] */\n\t\tint new_item_len, shift;\n\t\tint version;\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);\n\n\t\t/* Calculate item length to insert to S[0] */\n\t\tnew_item_len = ih_item_len(ih) - tb->lbytes;\n\n\t\t/* Calculate and check item length to insert to L[0] */\n\t\tput_ih_item_len(ih, ih_item_len(ih) - new_item_len);\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12080: there is nothing to insert into L[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t     min_t(int, tb->zeroes_num, ih_item_len(ih)));\n\n\t\tversion = ih_version(ih);\n\n\t\t/*\n\t\t * Calculate key component, item length and body to\n\t\t * insert into S[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\n\t\tadd_le_ih_k_offset(ih, tb->lbytes << shift);\n\n\t\tput_ih_item_len(ih, new_item_len);\n\t\tif (tb->lbytes > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = tb->lbytes - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= tb->lbytes;\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12085: there is nothing to insert into S[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\t} else {\n\t\t/* new item in whole falls into L[0] */\n\t\t/* Shift lnum[0]-1 items to L[0] */\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t\t     tb->zeroes_num);\n\t\ttb->insert_size[0] = 0;\n\t\ttb->zeroes_num = 0;\n\t}\n\treturn body_shift_bytes;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leaf_insert_into_buf",
          "args": [
            "&bi",
            "n + tb->item_pos - ret",
            "ih",
            "body",
            "tb->zeroes_num"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_insert_into_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "901-972",
          "snippet": "void leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_insert_into_buf(struct buffer_info *bi, int before,\n\t\t\t  struct item_head * const inserted_item_ih,\n\t\t\t  const char * const inserted_item_body,\n\t\t\t  int zeros_number)\n{\n\tstruct buffer_head *bh = bi->bi_bh;\n\tint nr, free_space;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint i;\n\tint last_loc, unmoved_loc;\n\tchar *to;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\tfree_space = blkh_free_space(blkh);\n\n\t/* check free space */\n\tRFALSE(free_space < ih_item_len(inserted_item_ih) + IH_SIZE,\n\t       \"vs-10170: not enough free space in block %z, new item %h\",\n\t       bh, inserted_item_ih);\n\tRFALSE(zeros_number > ih_item_len(inserted_item_ih),\n\t       \"vs-10172: zero number == %d, item length == %d\",\n\t       zeros_number, ih_item_len(inserted_item_ih));\n\n\t/* get item new item must be inserted before */\n\tih = item_head(bh, before);\n\n\t/* prepare space for the body of new item */\n\tlast_loc = nr ? ih_location(&ih[nr - before - 1]) : bh->b_size;\n\tunmoved_loc = before ? ih_location(ih - 1) : bh->b_size;\n\n\tmemmove(bh->b_data + last_loc - ih_item_len(inserted_item_ih),\n\t\tbh->b_data + last_loc, unmoved_loc - last_loc);\n\n\tto = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);\n\tmemset(to, 0, zeros_number);\n\tto += zeros_number;\n\n\t/* copy body to prepared space */\n\tif (inserted_item_body)\n\t\tmemmove(to, inserted_item_body,\n\t\t\tih_item_len(inserted_item_ih) - zeros_number);\n\telse\n\t\tmemset(to, '\\0', ih_item_len(inserted_item_ih) - zeros_number);\n\n\t/* insert item header */\n\tmemmove(ih + 1, ih, IH_SIZE * (nr - before));\n\tmemmove(ih, inserted_item_ih, IH_SIZE);\n\n\t/* change locations */\n\tfor (i = before; i < nr + 1; i++) {\n\t\tunmoved_loc -= ih_item_len(&ih[i - before]);\n\t\tput_ih_location(&ih[i - before], unmoved_loc);\n\t}\n\n\t/* sizes, free space, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh,\n\t\t\t    free_space - (IH_SIZE +\n\t\t\t\t\t  ih_item_len(inserted_item_ih)));\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 1);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (IH_SIZE +\n\t\t\t\t\t     ih_item_len(inserted_item_ih)));\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_left",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "19-26",
          "snippet": "static inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_left",
          "args": [
            "tb",
            "tb->lnum[0] - 1",
            "tb->lbytes"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "741-786",
          "snippet": "int leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_item_len(ih) <= 0",
            "\"PAP-12085: there is nothing to insert into S[0]: \"\n\t\t       \"ih_item_len=%d\"",
            "ih_item_len(ih)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "new_item_len"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_le_ih_k_offset",
          "args": [
            "ih",
            "tb->lbytes << shift"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "add_le_ih_k_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1516-1519",
          "snippet": "static inline void add_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tadd_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);",
            "int indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint direct2indirect(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct treepath *, struct buffer_head *, loff_t);\nint indirect2direct(struct reiserfs_transaction_handle *, struct inode *,\n\t\t    struct page *, struct treepath *, const struct cpu_key *,\n\t\t    loff_t, char *);\n\nstatic inline void add_le_ih_k_offset(struct item_head *ih, loff_t offset)\n{\n\tadd_le_key_k_offset(ih_version(ih), &(ih->ih_key), offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_indirect_le_ih",
          "args": [
            "ih"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "is_indirect_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1572-1575",
          "snippet": "static inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_indirect_le_ih(struct item_head *ih)\n{\n\treturn is_indirect_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ih_version",
          "args": [
            "ih"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "tb->zeroes_num",
            "ih_item_len(ih)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_item_len(ih) <= 0",
            "\"PAP-12080: there is nothing to insert into L[0]: \"\n\t\t       \"ih_item_len=%d\"",
            "ih_item_len(ih)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ih_item_len",
          "args": [
            "ih",
            "ih_item_len(ih) - new_item_len"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[0]"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int balance_leaf_insert_left(struct tree_balance *tb,\n\t\t\t\t\t     struct item_head *const ih,\n\t\t\t\t\t     const char * const body)\n{\n\tint ret;\n\tstruct buffer_info bi;\n\tint n = B_NR_ITEMS(tb->L[0]);\n\tunsigned body_shift_bytes = 0;\n\n\tif (tb->item_pos == tb->lnum[0] - 1 && tb->lbytes != -1) {\n\t\t/* part of new item falls into L[0] */\n\t\tint new_item_len, shift;\n\t\tint version;\n\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, -1);\n\n\t\t/* Calculate item length to insert to S[0] */\n\t\tnew_item_len = ih_item_len(ih) - tb->lbytes;\n\n\t\t/* Calculate and check item length to insert to L[0] */\n\t\tput_ih_item_len(ih, ih_item_len(ih) - new_item_len);\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12080: there is nothing to insert into L[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t     min_t(int, tb->zeroes_num, ih_item_len(ih)));\n\n\t\tversion = ih_version(ih);\n\n\t\t/*\n\t\t * Calculate key component, item length and body to\n\t\t * insert into S[0]\n\t\t */\n\t\tshift = 0;\n\t\tif (is_indirect_le_ih(ih))\n\t\t\tshift = tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT;\n\n\t\tadd_le_ih_k_offset(ih, tb->lbytes << shift);\n\n\t\tput_ih_item_len(ih, new_item_len);\n\t\tif (tb->lbytes > tb->zeroes_num) {\n\t\t\tbody_shift_bytes = tb->lbytes - tb->zeroes_num;\n\t\t\ttb->zeroes_num = 0;\n\t\t} else\n\t\t\ttb->zeroes_num -= tb->lbytes;\n\n\t\tRFALSE(ih_item_len(ih) <= 0,\n\t\t       \"PAP-12085: there is nothing to insert into S[0]: \"\n\t\t       \"ih_item_len=%d\", ih_item_len(ih));\n\t} else {\n\t\t/* new item in whole falls into L[0] */\n\t\t/* Shift lnum[0]-1 items to L[0] */\n\t\tret = leaf_shift_left(tb, tb->lnum[0] - 1, tb->lbytes);\n\n\t\t/* Insert new item into L[0] */\n\t\tbuffer_info_init_left(tb, &bi);\n\t\tleaf_insert_into_buf(&bi, n + tb->item_pos - ret, ih, body,\n\t\t\t\t     tb->zeroes_num);\n\t\ttb->insert_size[0] = 0;\n\t\ttb->zeroes_num = 0;\n\t}\n\treturn body_shift_bytes;\n}"
  },
  {
    "function_name": "balance_leaf_when_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "239-287",
    "snippet": "static int balance_leaf_when_delete(struct tree_balance *tb, int flag)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n\tint n;\n\tstruct item_head *ih;\n\n\tRFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,\n\t       \"vs- 12000: level: wrong FR %z\", tb->FR[0]);\n\tRFALSE(tb->blknum[0] > 1,\n\t       \"PAP-12005: tb->blknum == %d, can not be > 1\", tb->blknum[0]);\n\tRFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"PAP-12010: tree can not be empty\");\n\n\tih = item_head(tbS0, item_pos);\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\t/* Delete or truncate the item */\n\n\tBUG_ON(flag != M_DELETE && flag != M_CUT);\n\tif (flag == M_DELETE)\n\t\tbalance_leaf_when_delete_del(tb);\n\telse /* M_CUT */\n\t\tbalance_leaf_when_delete_cut(tb);\n\n\n\t/*\n\t * the rule is that no shifting occurs unless by shifting\n\t * a node can be freed\n\t */\n\tn = B_NR_ITEMS(tbS0);\n\n\n\t/* L[0] takes part in balancing */\n\tif (tb->lnum[0])\n\t\treturn balance_leaf_when_delete_left(tb);\n\n\tif (tb->rnum[0] == -1) {\n\t\t/* all contents of R[0] and S[0] will be in R[0] */\n\t\tleaf_shift_right(tb, n, -1);\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->rnum[0],\n\t       \"PAP-12065: bad rnum parameter must be 0 (%d)\", tb->rnum[0]);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->rnum[0]",
            "\"PAP-12065: bad rnum parameter must be 0 (%d)\"",
            "tb->rnum[0]"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_invalidate_buffer",
          "args": [
            "tb",
            "tbS0"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_invalidate_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1551-1560",
          "snippet": "void reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_right",
          "args": [
            "tb",
            "n",
            "-1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "794-812",
          "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_when_delete_left",
          "args": [
            "tb"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_when_delete_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "146-228",
          "snippet": "static int balance_leaf_when_delete_left(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* L[0] must be joined with S[0] */\n\tif (tb->lnum[0] == -1) {\n\t\t/* R[0] must be also joined with S[0] */\n\t\tif (tb->rnum[0] == -1) {\n\t\t\tif (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {\n\t\t\t\t/*\n\t\t\t\t * all contents of all the\n\t\t\t\t * 3 buffers will be in L[0]\n\t\t\t\t */\n\t\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0 &&\n\t\t\t\t    1 < B_NR_ITEMS(tb->FR[0]))\n\t\t\t\t\treplace_key(tb, tb->CFL[0],\n\t\t\t\t\t\t    tb->lkey[0], tb->FR[0], 1);\n\n\t\t\t\tleaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1,\n\t\t\t\t\t\tNULL);\n\t\t\t\tleaf_move_items(LEAF_FROM_R_TO_L, tb,\n\t\t\t\t\t\tB_NR_ITEMS(tb->R[0]), -1,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\t\treiserfs_invalidate_buffer(tb, tb->R[0]);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* all contents of all the 3 buffers will be in R[0] */\n\t\t\tleaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);\n\t\t\tleaf_move_items(LEAF_FROM_L_TO_R, tb,\n\t\t\t\t\tB_NR_ITEMS(tb->L[0]), -1, NULL);\n\n\t\t\t/* right_delimiting_key is correct in R[0] */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\treiserfs_invalidate_buffer(tb, tb->L[0]);\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tRFALSE(tb->rnum[0] != 0,\n\t\t       \"PAP-12045: rnum must be 0 (%d)\", tb->rnum[0]);\n\t\t/* all contents of L[0] and S[0] will be in L[0] */\n\t\tleaf_shift_left(tb, n, -1);\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * a part of contents of S[0] will be in L[0] and\n\t * the rest part of S[0] will be in R[0]\n\t */\n\n\tRFALSE((tb->lnum[0] + tb->rnum[0] < n) ||\n\t       (tb->lnum[0] + tb->rnum[0] > n + 1),\n\t       \"PAP-12050: rnum(%d) and lnum(%d) and item \"\n\t       \"number(%d) in S[0] are not consistent\",\n\t       tb->rnum[0], tb->lnum[0], n);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n) &&\n\t       (tb->lbytes != -1 || tb->rbytes != -1),\n\t       \"PAP-12055: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are not split\",\n\t       tb->rbytes, tb->lbytes);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&\n\t       (tb->lbytes < 1 || tb->rbytes != -1),\n\t       \"PAP-12060: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are split\",\n\t       tb->rbytes, tb->lbytes);\n\n\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\treiserfs_invalidate_buffer(tb, tbS0);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int balance_leaf_when_delete_left(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* L[0] must be joined with S[0] */\n\tif (tb->lnum[0] == -1) {\n\t\t/* R[0] must be also joined with S[0] */\n\t\tif (tb->rnum[0] == -1) {\n\t\t\tif (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {\n\t\t\t\t/*\n\t\t\t\t * all contents of all the\n\t\t\t\t * 3 buffers will be in L[0]\n\t\t\t\t */\n\t\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0 &&\n\t\t\t\t    1 < B_NR_ITEMS(tb->FR[0]))\n\t\t\t\t\treplace_key(tb, tb->CFL[0],\n\t\t\t\t\t\t    tb->lkey[0], tb->FR[0], 1);\n\n\t\t\t\tleaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1,\n\t\t\t\t\t\tNULL);\n\t\t\t\tleaf_move_items(LEAF_FROM_R_TO_L, tb,\n\t\t\t\t\t\tB_NR_ITEMS(tb->R[0]), -1,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\t\treiserfs_invalidate_buffer(tb, tb->R[0]);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* all contents of all the 3 buffers will be in R[0] */\n\t\t\tleaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);\n\t\t\tleaf_move_items(LEAF_FROM_L_TO_R, tb,\n\t\t\t\t\tB_NR_ITEMS(tb->L[0]), -1, NULL);\n\n\t\t\t/* right_delimiting_key is correct in R[0] */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\treiserfs_invalidate_buffer(tb, tb->L[0]);\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tRFALSE(tb->rnum[0] != 0,\n\t\t       \"PAP-12045: rnum must be 0 (%d)\", tb->rnum[0]);\n\t\t/* all contents of L[0] and S[0] will be in L[0] */\n\t\tleaf_shift_left(tb, n, -1);\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * a part of contents of S[0] will be in L[0] and\n\t * the rest part of S[0] will be in R[0]\n\t */\n\n\tRFALSE((tb->lnum[0] + tb->rnum[0] < n) ||\n\t       (tb->lnum[0] + tb->rnum[0] > n + 1),\n\t       \"PAP-12050: rnum(%d) and lnum(%d) and item \"\n\t       \"number(%d) in S[0] are not consistent\",\n\t       tb->rnum[0], tb->lnum[0], n);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n) &&\n\t       (tb->lbytes != -1 || tb->rbytes != -1),\n\t       \"PAP-12055: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are not split\",\n\t       tb->rbytes, tb->lbytes);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&\n\t       (tb->lbytes < 1 || tb->rbytes != -1),\n\t       \"PAP-12060: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are split\",\n\t       tb->rbytes, tb->lbytes);\n\n\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\treiserfs_invalidate_buffer(tb, tbS0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_leaf_when_delete_cut",
          "args": [
            "tb"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_when_delete_cut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "109-144",
          "snippet": "static void balance_leaf_when_delete_cut(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n\tint pos_in_item = tb->tb_path->pos_in_item;\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * UFS unlink semantics are such that you can only\n\t\t * delete one directory entry at a time.\n\t\t *\n\t\t * when we cut a directory tb->insert_size[0] means\n\t\t * number of entries to be cut (always 1)\n\t\t */\n\t\ttb->insert_size[0] = -1;\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!item_pos && !pos_in_item && !tb->CFL[0],\n\t\t       \"PAP-12030: can not change delimiting key. CFL[0]=%p\",\n\t\t       tb->CFL[0]);\n\n\t\tif (!item_pos && !pos_in_item && tb->CFL[0])\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t} else {\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"PAP-12035: cut must leave non-zero dynamic \"\n\t\t       \"length of item\");\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_when_delete_cut(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n\tint pos_in_item = tb->tb_path->pos_in_item;\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * UFS unlink semantics are such that you can only\n\t\t * delete one directory entry at a time.\n\t\t *\n\t\t * when we cut a directory tb->insert_size[0] means\n\t\t * number of entries to be cut (always 1)\n\t\t */\n\t\ttb->insert_size[0] = -1;\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!item_pos && !pos_in_item && !tb->CFL[0],\n\t\t       \"PAP-12030: can not change delimiting key. CFL[0]=%p\",\n\t\t       tb->CFL[0]);\n\n\t\tif (!item_pos && !pos_in_item && tb->CFL[0])\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t} else {\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"PAP-12035: cut must leave non-zero dynamic \"\n\t\t       \"length of item\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_leaf_when_delete_del",
          "args": [
            "tb"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "balance_leaf_when_delete_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "77-106",
          "snippet": "static void balance_leaf_when_delete_del(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n#endif\n\n\tRFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],\n\t       \"vs-12013: mode Delete, insert size %d, ih to be deleted %h\",\n\t       -tb->insert_size[0], ih);\n\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_delete_items(&bi, 0, item_pos, 1, -1);\n\n\tif (!item_pos && tb->CFL[0]) {\n\t\tif (B_NR_ITEMS(tbS0)) {\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t\t} else {\n\t\t\tif (!PATH_H_POSITION(tb->tb_path, 1))\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\t\t}\n\t}\n\n\tRFALSE(!item_pos && !tb->CFL[0],\n\t       \"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p\", tb->CFL[0],\n\t       tb->L[0]);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_when_delete_del(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n#endif\n\n\tRFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],\n\t       \"vs-12013: mode Delete, insert size %d, ih to be deleted %h\",\n\t       -tb->insert_size[0], ih);\n\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_delete_items(&bi, 0, item_pos, 1, -1);\n\n\tif (!item_pos && tb->CFL[0]) {\n\t\tif (B_NR_ITEMS(tbS0)) {\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t\t} else {\n\t\t\tif (!PATH_H_POSITION(tb->tb_path, 1))\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\t\t}\n\t}\n\n\tRFALSE(!item_pos && !tb->CFL[0],\n\t       \"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p\", tb->CFL[0],\n\t       tb->L[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "flag != M_DELETE && flag != M_CUT"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_info_init_tbS0",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_tbS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "37-44",
          "snippet": "static inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "item_pos"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0)",
            "\"PAP-12010: tree can not be empty\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->blknum[0] > 1",
            "\"PAP-12005: tb->blknum == %d, can not be > 1\"",
            "tb->blknum[0]"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1",
            "\"vs- 12000: level: wrong FR %z\"",
            "tb->FR[0]"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_LEVEL",
          "args": [
            "tb->FR[0]"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "tb->tb_path"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int balance_leaf_when_delete(struct tree_balance *tb, int flag)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n\tint n;\n\tstruct item_head *ih;\n\n\tRFALSE(tb->FR[0] && B_LEVEL(tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,\n\t       \"vs- 12000: level: wrong FR %z\", tb->FR[0]);\n\tRFALSE(tb->blknum[0] > 1,\n\t       \"PAP-12005: tb->blknum == %d, can not be > 1\", tb->blknum[0]);\n\tRFALSE(!tb->blknum[0] && !PATH_H_PPARENT(tb->tb_path, 0),\n\t       \"PAP-12010: tree can not be empty\");\n\n\tih = item_head(tbS0, item_pos);\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\t/* Delete or truncate the item */\n\n\tBUG_ON(flag != M_DELETE && flag != M_CUT);\n\tif (flag == M_DELETE)\n\t\tbalance_leaf_when_delete_del(tb);\n\telse /* M_CUT */\n\t\tbalance_leaf_when_delete_cut(tb);\n\n\n\t/*\n\t * the rule is that no shifting occurs unless by shifting\n\t * a node can be freed\n\t */\n\tn = B_NR_ITEMS(tbS0);\n\n\n\t/* L[0] takes part in balancing */\n\tif (tb->lnum[0])\n\t\treturn balance_leaf_when_delete_left(tb);\n\n\tif (tb->rnum[0] == -1) {\n\t\t/* all contents of R[0] and S[0] will be in R[0] */\n\t\tleaf_shift_right(tb, n, -1);\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\treturn 0;\n\t}\n\n\tRFALSE(tb->rnum[0],\n\t       \"PAP-12065: bad rnum parameter must be 0 (%d)\", tb->rnum[0]);\n\treturn 0;\n}"
  },
  {
    "function_name": "balance_leaf_when_delete_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "146-228",
    "snippet": "static int balance_leaf_when_delete_left(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* L[0] must be joined with S[0] */\n\tif (tb->lnum[0] == -1) {\n\t\t/* R[0] must be also joined with S[0] */\n\t\tif (tb->rnum[0] == -1) {\n\t\t\tif (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {\n\t\t\t\t/*\n\t\t\t\t * all contents of all the\n\t\t\t\t * 3 buffers will be in L[0]\n\t\t\t\t */\n\t\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0 &&\n\t\t\t\t    1 < B_NR_ITEMS(tb->FR[0]))\n\t\t\t\t\treplace_key(tb, tb->CFL[0],\n\t\t\t\t\t\t    tb->lkey[0], tb->FR[0], 1);\n\n\t\t\t\tleaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1,\n\t\t\t\t\t\tNULL);\n\t\t\t\tleaf_move_items(LEAF_FROM_R_TO_L, tb,\n\t\t\t\t\t\tB_NR_ITEMS(tb->R[0]), -1,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\t\treiserfs_invalidate_buffer(tb, tb->R[0]);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* all contents of all the 3 buffers will be in R[0] */\n\t\t\tleaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);\n\t\t\tleaf_move_items(LEAF_FROM_L_TO_R, tb,\n\t\t\t\t\tB_NR_ITEMS(tb->L[0]), -1, NULL);\n\n\t\t\t/* right_delimiting_key is correct in R[0] */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\treiserfs_invalidate_buffer(tb, tb->L[0]);\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tRFALSE(tb->rnum[0] != 0,\n\t\t       \"PAP-12045: rnum must be 0 (%d)\", tb->rnum[0]);\n\t\t/* all contents of L[0] and S[0] will be in L[0] */\n\t\tleaf_shift_left(tb, n, -1);\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * a part of contents of S[0] will be in L[0] and\n\t * the rest part of S[0] will be in R[0]\n\t */\n\n\tRFALSE((tb->lnum[0] + tb->rnum[0] < n) ||\n\t       (tb->lnum[0] + tb->rnum[0] > n + 1),\n\t       \"PAP-12050: rnum(%d) and lnum(%d) and item \"\n\t       \"number(%d) in S[0] are not consistent\",\n\t       tb->rnum[0], tb->lnum[0], n);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n) &&\n\t       (tb->lbytes != -1 || tb->rbytes != -1),\n\t       \"PAP-12055: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are not split\",\n\t       tb->rbytes, tb->lbytes);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&\n\t       (tb->lbytes < 1 || tb->rbytes != -1),\n\t       \"PAP-12060: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are split\",\n\t       tb->rbytes, tb->lbytes);\n\n\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\treiserfs_invalidate_buffer(tb, tbS0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_invalidate_buffer",
          "args": [
            "tb",
            "tbS0"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_invalidate_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1551-1560",
          "snippet": "void reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_right",
          "args": [
            "tb",
            "tb->rnum[0]",
            "tb->rbytes"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "794-812",
          "snippet": "int leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_right(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tint ret_value;\n\n\t/*\n\t * move shift_num (and shift_bytes) items from S[0] to\n\t * right neighbor R[0]\n\t */\n\tret_value =\n\t    leaf_move_items(LEAF_FROM_S_TO_R, tb, shift_num, shift_bytes, NULL);\n\n\t/* replace rkey in CFR[0] by the 0-th key from R[0] */\n\tif (shift_num) {\n\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t}\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_shift_left",
          "args": [
            "tb",
            "tb->lnum[0]",
            "tb->lbytes"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "741-786",
          "snippet": "int leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_shift_left(struct tree_balance *tb, int shift_num, int shift_bytes)\n{\n\tstruct buffer_head *S0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint i;\n\n\t/*\n\t * move shift_num (and shift_bytes bytes) items from S[0]\n\t * to left neighbor L[0]\n\t */\n\ti = leaf_move_items(LEAF_FROM_S_TO_L, tb, shift_num, shift_bytes, NULL);\n\n\tif (shift_num) {\n\t\t/* number of items in S[0] == 0 */\n\t\tif (B_NR_ITEMS(S0) == 0) {\n\n\t\t\tRFALSE(shift_bytes != -1,\n\t\t\t       \"vs-10270: S0 is empty now, but shift_bytes != -1 (%d)\",\n\t\t\t       shift_bytes);\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\tif (tb->tb_mode == M_PASTE || tb->tb_mode == M_INSERT) {\n\t\t\t\tprint_cur_tb(\"vs-10275\");\n\t\t\t\treiserfs_panic(tb->tb_sb, \"vs-10275\",\n\t\t\t\t\t       \"balance condition corrupted \"\n\t\t\t\t\t       \"(%c)\", tb->tb_mode);\n\t\t\t}\n#endif\n\n\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0)\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\n\t\t} else {\n\t\t\t/* replace lkey in CFL[0] by 0-th key from S[0]; */\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], S0, 0);\n\n\t\t\tRFALSE((shift_bytes != -1 &&\n\t\t\t\t!(is_direntry_le_ih(item_head(S0, 0))\n\t\t\t\t  && !ih_entry_count(item_head(S0, 0)))) &&\n\t\t\t       (!op_is_left_mergeable\n\t\t\t\t(leaf_key(S0, 0), S0->b_size)),\n\t\t\t       \"vs-10280: item must be mergeable\");\n\t\t}\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "(tb->lnum[0] + tb->rnum[0] == n + 1) &&\n\t       (tb->lbytes < 1 || tb->rbytes != -1)",
            "\"PAP-12060: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are split\"",
            "tb->rbytes",
            "tb->lbytes"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "(tb->lnum[0] + tb->rnum[0] == n) &&\n\t       (tb->lbytes != -1 || tb->rbytes != -1)",
            "\"PAP-12055: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are not split\"",
            "tb->rbytes",
            "tb->lbytes"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "(tb->lnum[0] + tb->rnum[0] < n) ||\n\t       (tb->lnum[0] + tb->rnum[0] > n + 1)",
            "\"PAP-12050: rnum(%d) and lnum(%d) and item \"\n\t       \"number(%d) in S[0] are not consistent\"",
            "tb->rnum[0]",
            "tb->lnum[0]",
            "n"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->rnum[0] != 0",
            "\"PAP-12045: rnum must be 0 (%d)\"",
            "tb->rnum[0]"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFR[0]",
            "tb->rkey[0]",
            "tb->R[0]",
            "0"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_move_items",
          "args": [
            "LEAF_FROM_L_TO_R",
            "tb",
            "B_NR_ITEMS(tb->L[0])",
            "-1",
            "NULL"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_move_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "715-735",
          "snippet": "int leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint leaf_move_items(int shift_mode, struct tree_balance *tb, int mov_num,\n\t\t    int mov_bytes, struct buffer_head *Snew)\n{\n\tint ret_value;\n\tstruct buffer_info dest_bi, src_bi;\n\tint first_last;\n\n\tleaf_define_dest_src_infos(shift_mode, tb, &dest_bi, &src_bi,\n\t\t\t\t   &first_last, Snew);\n\n\tret_value =\n\t    leaf_copy_items(&dest_bi, src_bi.bi_bh, first_last, mov_num,\n\t\t\t    mov_bytes);\n\n\tleaf_delete_items(&src_bi, first_last,\n\t\t\t  (first_last ==\n\t\t\t   FIRST_TO_LAST) ? 0 : (B_NR_ITEMS(src_bi.bi_bh) -\n\t\t\t\t\t\t mov_num), mov_num, mov_bytes);\n\n\treturn ret_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[0]"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->R[0]"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->FR[0]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic int balance_leaf_when_delete_left(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint n = B_NR_ITEMS(tbS0);\n\n\t/* L[0] must be joined with S[0] */\n\tif (tb->lnum[0] == -1) {\n\t\t/* R[0] must be also joined with S[0] */\n\t\tif (tb->rnum[0] == -1) {\n\t\t\tif (tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0)) {\n\t\t\t\t/*\n\t\t\t\t * all contents of all the\n\t\t\t\t * 3 buffers will be in L[0]\n\t\t\t\t */\n\t\t\t\tif (PATH_H_POSITION(tb->tb_path, 1) == 0 &&\n\t\t\t\t    1 < B_NR_ITEMS(tb->FR[0]))\n\t\t\t\t\treplace_key(tb, tb->CFL[0],\n\t\t\t\t\t\t    tb->lkey[0], tb->FR[0], 1);\n\n\t\t\t\tleaf_move_items(LEAF_FROM_S_TO_L, tb, n, -1,\n\t\t\t\t\t\tNULL);\n\t\t\t\tleaf_move_items(LEAF_FROM_R_TO_L, tb,\n\t\t\t\t\t\tB_NR_ITEMS(tb->R[0]), -1,\n\t\t\t\t\t\tNULL);\n\n\t\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\t\treiserfs_invalidate_buffer(tb, tb->R[0]);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* all contents of all the 3 buffers will be in R[0] */\n\t\t\tleaf_move_items(LEAF_FROM_S_TO_R, tb, n, -1, NULL);\n\t\t\tleaf_move_items(LEAF_FROM_L_TO_R, tb,\n\t\t\t\t\tB_NR_ITEMS(tb->L[0]), -1, NULL);\n\n\t\t\t/* right_delimiting_key is correct in R[0] */\n\t\t\treplace_key(tb, tb->CFR[0], tb->rkey[0], tb->R[0], 0);\n\n\t\t\treiserfs_invalidate_buffer(tb, tbS0);\n\t\t\treiserfs_invalidate_buffer(tb, tb->L[0]);\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tRFALSE(tb->rnum[0] != 0,\n\t\t       \"PAP-12045: rnum must be 0 (%d)\", tb->rnum[0]);\n\t\t/* all contents of L[0] and S[0] will be in L[0] */\n\t\tleaf_shift_left(tb, n, -1);\n\n\t\treiserfs_invalidate_buffer(tb, tbS0);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * a part of contents of S[0] will be in L[0] and\n\t * the rest part of S[0] will be in R[0]\n\t */\n\n\tRFALSE((tb->lnum[0] + tb->rnum[0] < n) ||\n\t       (tb->lnum[0] + tb->rnum[0] > n + 1),\n\t       \"PAP-12050: rnum(%d) and lnum(%d) and item \"\n\t       \"number(%d) in S[0] are not consistent\",\n\t       tb->rnum[0], tb->lnum[0], n);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n) &&\n\t       (tb->lbytes != -1 || tb->rbytes != -1),\n\t       \"PAP-12055: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are not split\",\n\t       tb->rbytes, tb->lbytes);\n\tRFALSE((tb->lnum[0] + tb->rnum[0] == n + 1) &&\n\t       (tb->lbytes < 1 || tb->rbytes != -1),\n\t       \"PAP-12060: bad rbytes (%d)/lbytes (%d) \"\n\t       \"parameters when items are split\",\n\t       tb->rbytes, tb->lbytes);\n\n\tleaf_shift_left(tb, tb->lnum[0], tb->lbytes);\n\tleaf_shift_right(tb, tb->rnum[0], tb->rbytes);\n\n\treiserfs_invalidate_buffer(tb, tbS0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "balance_leaf_when_delete_cut",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "109-144",
    "snippet": "static void balance_leaf_when_delete_cut(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n\tint pos_in_item = tb->tb_path->pos_in_item;\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * UFS unlink semantics are such that you can only\n\t\t * delete one directory entry at a time.\n\t\t *\n\t\t * when we cut a directory tb->insert_size[0] means\n\t\t * number of entries to be cut (always 1)\n\t\t */\n\t\ttb->insert_size[0] = -1;\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!item_pos && !pos_in_item && !tb->CFL[0],\n\t\t       \"PAP-12030: can not change delimiting key. CFL[0]=%p\",\n\t\t       tb->CFL[0]);\n\n\t\tif (!item_pos && !pos_in_item && tb->CFL[0])\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t} else {\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"PAP-12035: cut must leave non-zero dynamic \"\n\t\t       \"length of item\");\n\t}\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!ih_item_len(ih)",
            "\"PAP-12035: cut must leave non-zero dynamic \"\n\t\t       \"length of item\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_cut_from_buffer",
          "args": [
            "&bi",
            "item_pos",
            "pos_in_item",
            "-tb->insert_size[0]"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_cut_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "1145-1237",
          "snippet": "void leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size)\n{\n\tint nr;\n\tstruct buffer_head *bh = bi->bi_bh;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint last_loc, unmoved_loc;\n\tint i;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\t/* item head of truncated item */\n\tih = item_head(bh, cut_item_num);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/* first cut entry () */\n\t\tcut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\n\t\tif (pos_in_item == 0) {\n\t\t\t/* change key */\n\t\t\tRFALSE(cut_item_num,\n\t\t\t       \"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\",\n\t\t\t       cut_item_num);\n\t\t\t/* change item key by key of first entry in the item */\n\t\t\tset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\n\t\t}\n\t} else {\n\t\t/* item is direct or indirect */\n\t\tRFALSE(is_statdata_le_ih(ih), \"10195: item is stat data\");\n\t\tRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\n\t\t       \"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\",\n\t\t       (long unsigned)pos_in_item, (long unsigned)cut_size,\n\t\t       (long unsigned)ih_item_len(ih));\n\n\t\t/* shift item body to left if cut is from the head of item */\n\t\tif (pos_in_item == 0) {\n\t\t\tmemmove(bh->b_data + ih_location(ih),\n\t\t\t\tbh->b_data + ih_location(ih) + cut_size,\n\t\t\t\tih_item_len(ih) - cut_size);\n\n\t\t\t/* change key of item */\n\t\t\tif (is_direct_le_ih(ih))\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   cut_size);\n\t\t\telse {\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size);\n\t\t\t\tRFALSE(ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"10205: invalid ih_free_space (%h)\", ih);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* location of the last item */\n\tlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\n\n\t/* location of the item, which is remaining at the same place */\n\tunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* shift */\n\tmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc - cut_size);\n\n\t/* change item length */\n\tput_ih_item_len(ih, ih_item_len(ih) - cut_size);\n\n\tif (is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item)\n\t\t\tset_ih_free_space(ih, 0);\n\t}\n\n\t/* change locations */\n\tfor (i = cut_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - cut_item_num],\n\t\t\t\tih_location(&ih[i - cut_item_num]) + cut_size);\n\n\t/* size, free space */\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) - cut_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nvoid leaf_cut_from_buffer(struct buffer_info *bi, int cut_item_num,\n\t\t\t  int pos_in_item, int cut_size)\n{\n\tint nr;\n\tstruct buffer_head *bh = bi->bi_bh;\n\tstruct block_head *blkh;\n\tstruct item_head *ih;\n\tint last_loc, unmoved_loc;\n\tint i;\n\n\tblkh = B_BLK_HEAD(bh);\n\tnr = blkh_nr_item(blkh);\n\n\t/* item head of truncated item */\n\tih = item_head(bh, cut_item_num);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/* first cut entry () */\n\t\tcut_size = leaf_cut_entries(bh, ih, pos_in_item, cut_size);\n\t\tif (pos_in_item == 0) {\n\t\t\t/* change key */\n\t\t\tRFALSE(cut_item_num,\n\t\t\t       \"when 0-th enrty of item is cut, that item must be first in the node, not %d-th\",\n\t\t\t       cut_item_num);\n\t\t\t/* change item key by key of first entry in the item */\n\t\t\tset_le_ih_k_offset(ih, deh_offset(B_I_DEH(bh, ih)));\n\t\t}\n\t} else {\n\t\t/* item is direct or indirect */\n\t\tRFALSE(is_statdata_le_ih(ih), \"10195: item is stat data\");\n\t\tRFALSE(pos_in_item && pos_in_item + cut_size != ih_item_len(ih),\n\t\t       \"10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)\",\n\t\t       (long unsigned)pos_in_item, (long unsigned)cut_size,\n\t\t       (long unsigned)ih_item_len(ih));\n\n\t\t/* shift item body to left if cut is from the head of item */\n\t\tif (pos_in_item == 0) {\n\t\t\tmemmove(bh->b_data + ih_location(ih),\n\t\t\t\tbh->b_data + ih_location(ih) + cut_size,\n\t\t\t\tih_item_len(ih) - cut_size);\n\n\t\t\t/* change key of item */\n\t\t\tif (is_direct_le_ih(ih))\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   cut_size);\n\t\t\telse {\n\t\t\t\tset_le_ih_k_offset(ih,\n\t\t\t\t\t\t   le_ih_k_offset(ih) +\n\t\t\t\t\t\t   (cut_size / UNFM_P_SIZE) *\n\t\t\t\t\t\t   bh->b_size);\n\t\t\t\tRFALSE(ih_item_len(ih) == cut_size\n\t\t\t\t       && get_ih_free_space(ih),\n\t\t\t\t       \"10205: invalid ih_free_space (%h)\", ih);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* location of the last item */\n\tlast_loc = ih_location(&ih[nr - cut_item_num - 1]);\n\n\t/* location of the item, which is remaining at the same place */\n\tunmoved_loc = cut_item_num ? ih_location(ih - 1) : bh->b_size;\n\n\t/* shift */\n\tmemmove(bh->b_data + last_loc + cut_size, bh->b_data + last_loc,\n\t\tunmoved_loc - last_loc - cut_size);\n\n\t/* change item length */\n\tput_ih_item_len(ih, ih_item_len(ih) - cut_size);\n\n\tif (is_indirect_le_ih(ih)) {\n\t\tif (pos_in_item)\n\t\t\tset_ih_free_space(ih, 0);\n\t}\n\n\t/* change locations */\n\tfor (i = cut_item_num; i < nr; i++)\n\t\tput_ih_location(&ih[i - cut_item_num],\n\t\t\t\tih_location(&ih[i - cut_item_num]) + cut_size);\n\n\t/* size, free space */\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);\n\n\tdo_balance_mark_leaf_dirty(bi->tb, bh, 0);\n\n\tif (bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(bi->bi_parent, bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) - cut_size);\n\t\tdo_balance_mark_internal_dirty(bi->tb, bi->bi_parent, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFL[0]",
            "tb->lkey[0]",
            "tbS0",
            "0"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!item_pos && !pos_in_item && !tb->CFL[0]",
            "\"PAP-12030: can not change delimiting key. CFL[0]=%p\"",
            "tb->CFL[0]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_direntry_le_ih",
          "args": [
            "ih"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "is_direntry_le_ih",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1562-1565",
          "snippet": "static inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int is_direntry_le_ih(struct item_head *ih)\n{\n\treturn is_direntry_le_key(ih_version(ih), &ih->ih_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_tbS0",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_tbS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "37-44",
          "snippet": "static inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "item_pos"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "tb->tb_path"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_when_delete_cut(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n\tint pos_in_item = tb->tb_path->pos_in_item;\n\tstruct buffer_info bi;\n\tbuffer_info_init_tbS0(tb, &bi);\n\n\tif (is_direntry_le_ih(ih)) {\n\t\t/*\n\t\t * UFS unlink semantics are such that you can only\n\t\t * delete one directory entry at a time.\n\t\t *\n\t\t * when we cut a directory tb->insert_size[0] means\n\t\t * number of entries to be cut (always 1)\n\t\t */\n\t\ttb->insert_size[0] = -1;\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!item_pos && !pos_in_item && !tb->CFL[0],\n\t\t       \"PAP-12030: can not change delimiting key. CFL[0]=%p\",\n\t\t       tb->CFL[0]);\n\n\t\tif (!item_pos && !pos_in_item && tb->CFL[0])\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t} else {\n\t\tleaf_cut_from_buffer(&bi, item_pos, pos_in_item,\n\t\t\t\t     -tb->insert_size[0]);\n\n\t\tRFALSE(!ih_item_len(ih),\n\t\t       \"PAP-12035: cut must leave non-zero dynamic \"\n\t\t       \"length of item\");\n\t}\n}"
  },
  {
    "function_name": "balance_leaf_when_delete_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "77-106",
    "snippet": "static void balance_leaf_when_delete_del(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n#endif\n\n\tRFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],\n\t       \"vs-12013: mode Delete, insert size %d, ih to be deleted %h\",\n\t       -tb->insert_size[0], ih);\n\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_delete_items(&bi, 0, item_pos, 1, -1);\n\n\tif (!item_pos && tb->CFL[0]) {\n\t\tif (B_NR_ITEMS(tbS0)) {\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t\t} else {\n\t\t\tif (!PATH_H_POSITION(tb->tb_path, 1))\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\t\t}\n\t}\n\n\tRFALSE(!item_pos && !tb->CFL[0],\n\t       \"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p\", tb->CFL[0],\n\t       tb->L[0]);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!item_pos && !tb->CFL[0]",
            "\"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p\"",
            "tb->CFL[0]",
            "tb->L[0]"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "tb->CFL[0]",
            "tb->lkey[0]",
            "PATH_H_PPARENT(tb->tb_path, 0)",
            "0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbS0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_delete_items",
          "args": [
            "&bi",
            "0",
            "item_pos",
            "1",
            "-1"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_delete_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lbalance.c",
          "lines": "827-898",
          "snippet": "void leaf_delete_items(struct buffer_info *cur_bi, int last_first,\n\t\t       int first, int del_num, int del_bytes)\n{\n\tstruct buffer_head *bh;\n\tint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\n\n\tRFALSE(!bh, \"10155: bh is not defined\");\n\tRFALSE(del_num < 0, \"10160: del_num can not be < 0. del_num==%d\",\n\t       del_num);\n\tRFALSE(first < 0\n\t       || first + del_num > item_amount,\n\t       \"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\", first,\n\t       first + del_num, item_amount);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tif (first == 0 && del_num == item_amount && del_bytes == -1) {\n\t\tmake_empty_node(cur_bi);\n\t\tdo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tif (del_bytes == -1)\n\t\t/* delete del_num items beginning from item in position first */\n\t\tleaf_delete_items_entirely(cur_bi, first, del_num);\n\telse {\n\t\tif (last_first == FIRST_TO_LAST) {\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first, del_num - 1);\n\n\t\t\t/*\n\t\t\t * delete the part of the first item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\n\t\t} else {\n\t\t\tstruct item_head *ih;\n\t\t\tint len;\n\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first+1\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first + 1,\n\t\t\t\t\t\t   del_num - 1);\n\n\t\t\tih = item_head(bh, B_NR_ITEMS(bh) - 1);\n\t\t\tif (is_direntry_le_ih(ih))\n\t\t\t\t/* the last item is directory  */\n\t\t\t\t/*\n\t\t\t\t * len = numbers of directory entries\n\t\t\t\t * in this item\n\t\t\t\t */\n\t\t\t\tlen = ih_entry_count(ih);\n\t\t\telse\n\t\t\t\t/* len = body len of item */\n\t\t\t\tlen = ih_item_len(ih);\n\n\t\t\t/*\n\t\t\t * delete the part of the last item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\n\t\t\t\t\t     len - del_bytes, del_bytes);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void leaf_delete_items_entirely(struct buffer_info *bi,\n\t\t\t\t       int first, int del_num);\n\nvoid leaf_delete_items(struct buffer_info *cur_bi, int last_first,\n\t\t       int first, int del_num, int del_bytes)\n{\n\tstruct buffer_head *bh;\n\tint item_amount = B_NR_ITEMS(bh = cur_bi->bi_bh);\n\n\tRFALSE(!bh, \"10155: bh is not defined\");\n\tRFALSE(del_num < 0, \"10160: del_num can not be < 0. del_num==%d\",\n\t       del_num);\n\tRFALSE(first < 0\n\t       || first + del_num > item_amount,\n\t       \"10165: invalid number of first item to be deleted (%d) or \"\n\t       \"no so much items (%d) to delete (only %d)\", first,\n\t       first + del_num, item_amount);\n\n\tif (del_num == 0)\n\t\treturn;\n\n\tif (first == 0 && del_num == item_amount && del_bytes == -1) {\n\t\tmake_empty_node(cur_bi);\n\t\tdo_balance_mark_leaf_dirty(cur_bi->tb, bh, 0);\n\t\treturn;\n\t}\n\n\tif (del_bytes == -1)\n\t\t/* delete del_num items beginning from item in position first */\n\t\tleaf_delete_items_entirely(cur_bi, first, del_num);\n\telse {\n\t\tif (last_first == FIRST_TO_LAST) {\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first, del_num - 1);\n\n\t\t\t/*\n\t\t\t * delete the part of the first item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, 0, 0, del_bytes);\n\t\t} else {\n\t\t\tstruct item_head *ih;\n\t\t\tint len;\n\n\t\t\t/*\n\t\t\t * delete del_num-1 items beginning from\n\t\t\t * item in position first+1\n\t\t\t */\n\t\t\tleaf_delete_items_entirely(cur_bi, first + 1,\n\t\t\t\t\t\t   del_num - 1);\n\n\t\t\tih = item_head(bh, B_NR_ITEMS(bh) - 1);\n\t\t\tif (is_direntry_le_ih(ih))\n\t\t\t\t/* the last item is directory  */\n\t\t\t\t/*\n\t\t\t\t * len = numbers of directory entries\n\t\t\t\t * in this item\n\t\t\t\t */\n\t\t\t\tlen = ih_entry_count(ih);\n\t\t\telse\n\t\t\t\t/* len = body len of item */\n\t\t\t\tlen = ih_item_len(ih);\n\n\t\t\t/*\n\t\t\t * delete the part of the last item of the bh\n\t\t\t * do not delete item header\n\t\t\t */\n\t\t\tleaf_cut_from_buffer(cur_bi, B_NR_ITEMS(bh) - 1,\n\t\t\t\t\t     len - del_bytes, del_bytes);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_info_init_tbS0",
          "args": [
            "tb",
            "&bi"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_info_init_tbS0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "37-44",
          "snippet": "static inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "ih_item_len(ih) + IH_SIZE != -tb->insert_size[0]",
            "\"vs-12013: mode Delete, insert size %d, ih to be deleted %h\"",
            "-tb->insert_size[0]",
            "ih"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ih_item_len",
          "args": [
            "ih"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item_head",
          "args": [
            "tbS0",
            "item_pos"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "item_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2198-2204",
          "snippet": "static inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct item_head *item_head(const struct buffer_head *bh,\n\t\t\t\t\t  int item_num)\n{\n\tstruct item_head *ih = reiserfs_node_data(bh);\n\n\treturn &ih[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_LAST_POSITION",
          "args": [
            "tb->tb_path"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic void balance_leaf_when_delete_del(struct tree_balance *tb)\n{\n\tstruct buffer_head *tbS0 = PATH_PLAST_BUFFER(tb->tb_path);\n\tint item_pos = PATH_LAST_POSITION(tb->tb_path);\n\tstruct buffer_info bi;\n#ifdef CONFIG_REISERFS_CHECK\n\tstruct item_head *ih = item_head(tbS0, item_pos);\n#endif\n\n\tRFALSE(ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],\n\t       \"vs-12013: mode Delete, insert size %d, ih to be deleted %h\",\n\t       -tb->insert_size[0], ih);\n\n\tbuffer_info_init_tbS0(tb, &bi);\n\tleaf_delete_items(&bi, 0, item_pos, 1, -1);\n\n\tif (!item_pos && tb->CFL[0]) {\n\t\tif (B_NR_ITEMS(tbS0)) {\n\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0], tbS0, 0);\n\t\t} else {\n\t\t\tif (!PATH_H_POSITION(tb->tb_path, 1))\n\t\t\t\treplace_key(tb, tb->CFL[0], tb->lkey[0],\n\t\t\t\t\t    PATH_H_PPARENT(tb->tb_path, 0), 0);\n\t\t}\n\t}\n\n\tRFALSE(!item_pos && !tb->CFL[0],\n\t       \"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p\", tb->CFL[0],\n\t       tb->L[0]);\n}"
  },
  {
    "function_name": "do_balance_mark_leaf_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "56-60",
    "snippet": "inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "tb->transaction_handle",
            "bh"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\ninline void do_balance_mark_leaf_dirty(struct tree_balance *tb,\n\t\t\t\t       struct buffer_head *bh, int flag)\n{\n\tjournal_mark_dirty(tb->transaction_handle, bh);\n}"
  },
  {
    "function_name": "buffer_info_init_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "46-54",
    "snippet": "static inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_bh(struct tree_balance *tb,\n                                       struct buffer_info *bi,\n                                       struct buffer_head *bh)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = bh;\n\tbi->bi_parent   = NULL;\n\tbi->bi_position = 0;\n}"
  },
  {
    "function_name": "buffer_info_init_tbS0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "37-44",
    "snippet": "static inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "1"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_PLAST_BUFFER",
          "args": [
            "tb->tb_path"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_tbS0(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh        = PATH_PLAST_BUFFER(tb->tb_path);\n\tbi->bi_parent   = PATH_H_PPARENT(tb->tb_path, 0);\n\tbi->bi_position = PATH_H_POSITION(tb->tb_path, 1);\n}"
  },
  {
    "function_name": "buffer_info_init_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "28-35",
    "snippet": "static inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_right_neighbor_position",
          "args": [
            "tb",
            "0"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "get_right_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1604-1616",
          "snippet": "int get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_right(struct tree_balance *tb,\n                                          struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->R[0];\n\tbi->bi_parent   = tb->FR[0];\n\tbi->bi_position = get_right_neighbor_position(tb, 0);\n}"
  },
  {
    "function_name": "buffer_info_init_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
    "lines": "19-26",
    "snippet": "static inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}",
    "includes": [
      "#include <linux/kernel.h>",
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_left_neighbor_position",
          "args": [
            "tb",
            "0"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "get_left_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1590-1602",
          "snippet": "int get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstatic inline void buffer_info_init_left(struct tree_balance *tb,\n                                         struct buffer_info *bi)\n{\n\tbi->tb          = tb;\n\tbi->bi_bh       = tb->L[0];\n\tbi->bi_parent   = tb->FL[0];\n\tbi->bi_position = get_left_neighbor_position(tb, 0);\n}"
  }
]