[
  {
    "function_name": "nilfs_ifile_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
    "lines": "192-227",
    "snippet": "int nilfs_ifile_read(struct super_block *sb, struct nilfs_root *root,\n\t\t     size_t inode_size, struct nilfs_inode *raw_inode,\n\t\t     struct inode **inodep)\n{\n\tstruct inode *ifile;\n\tint err;\n\n\tifile = nilfs_iget_locked(sb, root, NILFS_IFILE_INO);\n\tif (unlikely(!ifile))\n\t\treturn -ENOMEM;\n\tif (!(ifile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(ifile, NILFS_MDT_GFP,\n\t\t\t     sizeof(struct nilfs_ifile_info));\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_palloc_init_blockgroup(ifile, inode_size);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_palloc_setup_cache(ifile, &NILFS_IFILE_I(ifile)->palloc_cache);\n\n\terr = nilfs_read_inode_common(ifile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(ifile);\n out:\n\t*inodep = ifile;\n\treturn 0;\n failed:\n\tiget_failed(ifile);\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "ifile"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "ifile"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_read_inode_common",
          "args": [
            "ifile",
            "raw_inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_read_inode_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "463-502",
          "snippet": "int nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nint nilfs_read_inode_common(struct inode *inode,\n\t\t\t    struct nilfs_inode *raw_inode)\n{\n\tstruct nilfs_inode_info *ii = NILFS_I(inode);\n\tint err;\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid_write(inode, le32_to_cpu(raw_inode->i_uid));\n\ti_gid_write(inode, le32_to_cpu(raw_inode->i_gid));\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le64_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(raw_inode->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(raw_inode->i_mtime_nsec);\n\tif (inode->i_nlink == 0)\n\t\treturn -ESTALE; /* this inode is deleted */\n\n\tinode->i_blocks = le64_to_cpu(raw_inode->i_blocks);\n\tii->i_flags = le32_to_cpu(raw_inode->i_flags);\n#if 0\n\tii->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tii->i_dir_acl = S_ISREG(inode->i_mode) ?\n\t\t0 : le32_to_cpu(raw_inode->i_dir_acl);\n#endif\n\tii->i_dir_start_lookup = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t    S_ISLNK(inode->i_mode)) {\n\t\terr = nilfs_bmap_read(ii->i_bmap, raw_inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tset_bit(NILFS_I_BMAP, &ii->i_state);\n\t\t/* No lock is needed; iget() ensures it. */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_setup_cache",
          "args": [
            "ifile",
            "&NILFS_IFILE_I(ifile)->palloc_cache"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_setup_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "759-764",
          "snippet": "void nilfs_palloc_setup_cache(struct inode *inode,\n\t\t\t      struct nilfs_palloc_cache *cache)\n{\n\tNILFS_MDT(inode)->mi_palloc_cache = cache;\n\tspin_lock_init(&cache->lock);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_palloc_setup_cache(struct inode *inode,\n\t\t\t      struct nilfs_palloc_cache *cache)\n{\n\tNILFS_MDT(inode)->mi_palloc_cache = cache;\n\tspin_lock_init(&cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NILFS_IFILE_I",
          "args": [
            "ifile"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_IFILE_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "42-45",
          "snippet": "static inline struct nilfs_ifile_info *NILFS_IFILE_I(struct inode *ifile)\n{\n\treturn (struct nilfs_ifile_info *)NILFS_MDT(ifile);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline struct nilfs_ifile_info *NILFS_IFILE_I(struct inode *ifile)\n{\n\treturn (struct nilfs_ifile_info *)NILFS_MDT(ifile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_init_blockgroup",
          "args": [
            "ifile",
            "inode_size"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_init_blockgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "61-84",
          "snippet": "int nilfs_palloc_init_blockgroup(struct inode *inode, unsigned entry_size)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tmi->mi_bgl = kmalloc(sizeof(*mi->mi_bgl), GFP_NOFS);\n\tif (!mi->mi_bgl)\n\t\treturn -ENOMEM;\n\n\tbgl_lock_init(mi->mi_bgl);\n\n\tnilfs_mdt_set_entry_size(inode, entry_size, 0);\n\n\tmi->mi_blocks_per_group =\n\t\tDIV_ROUND_UP(nilfs_palloc_entries_per_group(inode),\n\t\t\t     mi->mi_entries_per_block) + 1;\n\t\t/* Number of blocks in a group including entry blocks and\n\t\t   a bitmap block */\n\tmi->mi_blocks_per_desc_block =\n\t\tnilfs_palloc_groups_per_desc_block(inode) *\n\t\tmi->mi_blocks_per_group + 1;\n\t\t/* Number of blocks per descriptor including the\n\t\t   descriptor block */\n\treturn 0;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_palloc_init_blockgroup(struct inode *inode, unsigned entry_size)\n{\n\tstruct nilfs_mdt_info *mi = NILFS_MDT(inode);\n\n\tmi->mi_bgl = kmalloc(sizeof(*mi->mi_bgl), GFP_NOFS);\n\tif (!mi->mi_bgl)\n\t\treturn -ENOMEM;\n\n\tbgl_lock_init(mi->mi_bgl);\n\n\tnilfs_mdt_set_entry_size(inode, entry_size, 0);\n\n\tmi->mi_blocks_per_group =\n\t\tDIV_ROUND_UP(nilfs_palloc_entries_per_group(inode),\n\t\t\t     mi->mi_entries_per_block) + 1;\n\t\t/* Number of blocks in a group including entry blocks and\n\t\t   a bitmap block */\n\tmi->mi_blocks_per_desc_block =\n\t\tnilfs_palloc_groups_per_desc_block(inode) *\n\t\tmi->mi_blocks_per_group + 1;\n\t\t/* Number of blocks per descriptor including the\n\t\t   descriptor block */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_mdt_init",
          "args": [
            "ifile",
            "NILFS_MDT_GFP",
            "sizeof(struct nilfs_ifile_info)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.c",
          "lines": "419-438",
          "snippet": "int nilfs_mdt_init(struct inode *inode, gfp_t gfp_mask, size_t objsz)\n{\n\tstruct nilfs_mdt_info *mi;\n\n\tmi = kzalloc(max(sizeof(*mi), objsz), GFP_NOFS);\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tinit_rwsem(&mi->mi_sem);\n\tinode->i_private = mi;\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, gfp_mask);\n\n\tinode->i_op = &def_mdt_iops;\n\tinode->i_fop = &def_mdt_fops;\n\tinode->i_mapping->a_ops = &def_mdt_aops;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mm.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations def_mdt_aops = {\n\t.writepage\t\t= nilfs_mdt_write_page,\n};",
            "static const struct inode_operations def_mdt_iops;",
            "static const struct file_operations def_mdt_fops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mm.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations def_mdt_aops = {\n\t.writepage\t\t= nilfs_mdt_write_page,\n};\nstatic const struct inode_operations def_mdt_iops;\nstatic const struct file_operations def_mdt_fops;\n\nint nilfs_mdt_init(struct inode *inode, gfp_t gfp_mask, size_t objsz)\n{\n\tstruct nilfs_mdt_info *mi;\n\n\tmi = kzalloc(max(sizeof(*mi), objsz), GFP_NOFS);\n\tif (!mi)\n\t\treturn -ENOMEM;\n\n\tinit_rwsem(&mi->mi_sem);\n\tinode->i_private = mi;\n\n\tinode->i_mode = S_IFREG;\n\tmapping_set_gfp_mask(inode->i_mapping, gfp_mask);\n\n\tinode->i_op = &def_mdt_iops;\n\tinode->i_fop = &def_mdt_fops;\n\tinode->i_mapping->a_ops = &def_mdt_aops;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ifile"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_iget_locked",
          "args": [
            "sb",
            "root",
            "NILFS_IFILE_INO"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/inode.c",
          "lines": "598-606",
          "snippet": "struct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"mdt.h\"",
            "#include \"page.h\"",
            "#include \"segment.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"mdt.h\"\n#include \"page.h\"\n#include \"segment.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/mpage.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n\nstruct inode *nilfs_iget_locked(struct super_block *sb, struct nilfs_root *root,\n\t\t\t\tunsigned long ino)\n{\n\tstruct nilfs_iget_args args = {\n\t\t.ino = ino, .root = root, .cno = 0, .for_gc = 0\n\t};\n\n\treturn iget5_locked(sb, ino, nilfs_iget_test, nilfs_iget_set, &args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_read(struct super_block *sb, struct nilfs_root *root,\n\t\t     size_t inode_size, struct nilfs_inode *raw_inode,\n\t\t     struct inode **inodep)\n{\n\tstruct inode *ifile;\n\tint err;\n\n\tifile = nilfs_iget_locked(sb, root, NILFS_IFILE_INO);\n\tif (unlikely(!ifile))\n\t\treturn -ENOMEM;\n\tif (!(ifile->i_state & I_NEW))\n\t\tgoto out;\n\n\terr = nilfs_mdt_init(ifile, NILFS_MDT_GFP,\n\t\t\t     sizeof(struct nilfs_ifile_info));\n\tif (err)\n\t\tgoto failed;\n\n\terr = nilfs_palloc_init_blockgroup(ifile, inode_size);\n\tif (err)\n\t\tgoto failed;\n\n\tnilfs_palloc_setup_cache(ifile, &NILFS_IFILE_I(ifile)->palloc_cache);\n\n\terr = nilfs_read_inode_common(ifile, raw_inode);\n\tif (err)\n\t\tgoto failed;\n\n\tunlock_new_inode(ifile);\n out:\n\t*inodep = ifile;\n\treturn 0;\n failed:\n\tiget_failed(ifile);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_ifile_count_free_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
    "lines": "168-182",
    "snippet": "int nilfs_ifile_count_free_inodes(struct inode *ifile,\n\t\t\t\t    u64 *nmaxinodes, u64 *nfreeinodes)\n{\n\tu64 nused;\n\tint err;\n\n\t*nmaxinodes = 0;\n\t*nfreeinodes = 0;\n\n\tnused = atomic64_read(&NILFS_I(ifile)->i_root->inodes_count);\n\terr = nilfs_palloc_count_max_entries(ifile, nused, nmaxinodes);\n\tif (likely(!err))\n\t\t*nfreeinodes = *nmaxinodes - nused;\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_count_max_entries",
          "args": [
            "ifile",
            "nused",
            "nmaxinodes"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_count_max_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "438-461",
          "snippet": "int nilfs_palloc_count_max_entries(struct inode *inode, u64 nused, u64 *nmaxp)\n{\n\tunsigned long desc_blocks = 0;\n\tu64 entries_per_desc_block, nmax;\n\tint err;\n\n\terr = nilfs_palloc_count_desc_blocks(inode, &desc_blocks);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tentries_per_desc_block = (u64)nilfs_palloc_entries_per_group(inode) *\n\t\t\t\tnilfs_palloc_groups_per_desc_block(inode);\n\tnmax = entries_per_desc_block * desc_blocks;\n\n\tif (nused == nmax &&\n\t\t\tnilfs_palloc_mdt_file_can_grow(inode, desc_blocks))\n\t\tnmax += entries_per_desc_block;\n\n\tif (nused > nmax)\n\t\treturn -ERANGE;\n\n\t*nmaxp = nmax;\n\treturn 0;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_palloc_count_max_entries(struct inode *inode, u64 nused, u64 *nmaxp)\n{\n\tunsigned long desc_blocks = 0;\n\tu64 entries_per_desc_block, nmax;\n\tint err;\n\n\terr = nilfs_palloc_count_desc_blocks(inode, &desc_blocks);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tentries_per_desc_block = (u64)nilfs_palloc_entries_per_group(inode) *\n\t\t\t\tnilfs_palloc_groups_per_desc_block(inode);\n\tnmax = entries_per_desc_block * desc_blocks;\n\n\tif (nused == nmax &&\n\t\t\tnilfs_palloc_mdt_file_can_grow(inode, desc_blocks))\n\t\tnmax += entries_per_desc_block;\n\n\tif (nused > nmax)\n\t\treturn -ERANGE;\n\n\t*nmaxp = nmax;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&NILFS_I(ifile)->i_root->inodes_count"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_I",
          "args": [
            "ifile"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_IFILE_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
          "lines": "42-45",
          "snippet": "static inline struct nilfs_ifile_info *NILFS_IFILE_I(struct inode *ifile)\n{\n\treturn (struct nilfs_ifile_info *)NILFS_MDT(ifile);\n}",
          "includes": [
            "#include \"ifile.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline struct nilfs_ifile_info *NILFS_IFILE_I(struct inode *ifile)\n{\n\treturn (struct nilfs_ifile_info *)NILFS_MDT(ifile);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_count_free_inodes(struct inode *ifile,\n\t\t\t\t    u64 *nmaxinodes, u64 *nfreeinodes)\n{\n\tu64 nused;\n\tint err;\n\n\t*nmaxinodes = 0;\n\t*nfreeinodes = 0;\n\n\tnused = atomic64_read(&NILFS_I(ifile)->i_root->inodes_count);\n\terr = nilfs_palloc_count_max_entries(ifile, nused, nmaxinodes);\n\tif (likely(!err))\n\t\t*nfreeinodes = *nmaxinodes - nused;\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_ifile_get_inode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
    "lines": "143-160",
    "snippet": "int nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_warning",
          "args": [
            "sb",
            "__func__",
            "\"unable to read inode: %lu\"",
            "(unsigned long) ino"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "140-155",
          "snippet": "void nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_warning(struct super_block *sb, const char *function,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"NILFS warning (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_get_entry_block",
          "args": [
            "ifile",
            "ino",
            "0",
            "out_bh"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_get_entry_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "287-296",
          "snippet": "int nilfs_palloc_get_entry_block(struct inode *inode, __u64 nr,\n\t\t\t\t int create, struct buffer_head **bhp)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\treturn nilfs_palloc_get_block(inode,\n\t\t\t\t      nilfs_palloc_entry_blkoff(inode, nr),\n\t\t\t\t      create, NULL, bhp,\n\t\t\t\t      &cache->prev_entry, &cache->lock);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_palloc_get_entry_block(struct inode *inode, __u64 nr,\n\t\t\t\t int create, struct buffer_head **bhp)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\treturn nilfs_palloc_get_block(inode,\n\t\t\t\t      nilfs_palloc_entry_blkoff(inode, nr),\n\t\t\t\t      create, NULL, bhp,\n\t\t\t\t      &cache->prev_entry, &cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_error",
          "args": [
            "sb",
            "__func__",
            "\"bad inode number: %lu\"",
            "(unsigned long) ino"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/super.c",
          "lines": "109-138",
          "snippet": "void nilfs_error(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"NILFS error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tnilfs_set_error(sb);\n\n\t\tif (nilfs_test_opt(nilfs, ERRORS_RO)) {\n\t\t\tprintk(KERN_CRIT \"Remounting filesystem read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t}\n\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tpanic(\"NILFS (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n}",
          "includes": [
            "#include \"segbuf.h\"",
            "#include \"segment.h\"",
            "#include \"dat.h\"",
            "#include \"ifile.h\"",
            "#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */",
            "#include \"cpfile.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"btree.h\"",
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include \"export.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"segbuf.h\"\n#include \"segment.h\"\n#include \"dat.h\"\n#include \"ifile.h\"\n#include \"sufile.h\" /* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */\n#include \"cpfile.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"btree.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"export.h\"\n#include \"nilfs.h\"\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid nilfs_error(struct super_block *sb, const char *function,\n\t\t const char *fmt, ...)\n{\n\tstruct the_nilfs *nilfs = sb->s_fs_info;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"NILFS error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tnilfs_set_error(sb);\n\n\t\tif (nilfs_test_opt(nilfs, ERRORS_RO)) {\n\t\t\tprintk(KERN_CRIT \"Remounting filesystem read-only\\n\");\n\t\t\tsb->s_flags |= MS_RDONLY;\n\t\t}\n\t}\n\n\tif (nilfs_test_opt(nilfs, ERRORS_PANIC))\n\t\tpanic(\"NILFS (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!NILFS_VALID_INODE(sb, ino)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NILFS_VALID_INODE",
          "args": [
            "sb",
            "ino"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_get_inode_block(struct inode *ifile, ino_t ino,\n\t\t\t\tstruct buffer_head **out_bh)\n{\n\tstruct super_block *sb = ifile->i_sb;\n\tint err;\n\n\tif (unlikely(!NILFS_VALID_INODE(sb, ino))) {\n\t\tnilfs_error(sb, __func__, \"bad inode number: %lu\",\n\t\t\t    (unsigned long) ino);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nilfs_palloc_get_entry_block(ifile, ino, 0, out_bh);\n\tif (unlikely(err))\n\t\tnilfs_warning(sb, __func__, \"unable to read inode: %lu\",\n\t\t\t      (unsigned long) ino);\n\treturn err;\n}"
  },
  {
    "function_name": "nilfs_ifile_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
    "lines": "108-141",
    "snippet": "int nilfs_ifile_delete_inode(struct inode *ifile, ino_t ino)\n{\n\tstruct nilfs_palloc_req req = {\n\t\t.pr_entry_nr = ino, .pr_entry_bh = NULL\n\t};\n\tstruct nilfs_inode *raw_inode;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_prepare_free_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 0,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_free_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\n\tkaddr = kmap_atomic(req.pr_entry_bh->b_page);\n\traw_inode = nilfs_palloc_block_get_entry(ifile, req.pr_entry_nr,\n\t\t\t\t\t\t req.pr_entry_bh, kaddr);\n\traw_inode->i_flags = 0;\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tbrelse(req.pr_entry_bh);\n\n\tnilfs_palloc_commit_free_entry(ifile, &req);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_palloc_commit_free_entry",
          "args": [
            "ifile",
            "&req"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_commit_free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "568-599",
          "snippet": "void nilfs_palloc_commit_free_entry(struct inode *inode,\n\t\t\t\t    struct nilfs_palloc_req *req)\n{\n\tstruct nilfs_palloc_group_desc *desc;\n\tunsigned long group, group_offset;\n\tunsigned char *bitmap;\n\tvoid *desc_kaddr, *bitmap_kaddr;\n\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tdesc_kaddr = kmap(req->pr_desc_bh->b_page);\n\tdesc = nilfs_palloc_block_get_group_desc(inode, group,\n\t\t\t\t\t\t req->pr_desc_bh, desc_kaddr);\n\tbitmap_kaddr = kmap(req->pr_bitmap_bh->b_page);\n\tbitmap = bitmap_kaddr + bh_offset(req->pr_bitmap_bh);\n\n\tif (!nilfs_clear_bit_atomic(nilfs_mdt_bgl_lock(inode, group),\n\t\t\t\t    group_offset, bitmap))\n\t\tprintk(KERN_WARNING \"%s: entry number %llu already freed\\n\",\n\t\t       __func__, (unsigned long long)req->pr_entry_nr);\n\telse\n\t\tnilfs_palloc_group_desc_add_entries(inode, group, desc, 1);\n\n\tkunmap(req->pr_bitmap_bh->b_page);\n\tkunmap(req->pr_desc_bh->b_page);\n\n\tmark_buffer_dirty(req->pr_desc_bh);\n\tmark_buffer_dirty(req->pr_bitmap_bh);\n\tnilfs_mdt_mark_dirty(inode);\n\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_palloc_commit_free_entry(struct inode *inode,\n\t\t\t\t    struct nilfs_palloc_req *req)\n{\n\tstruct nilfs_palloc_group_desc *desc;\n\tunsigned long group, group_offset;\n\tunsigned char *bitmap;\n\tvoid *desc_kaddr, *bitmap_kaddr;\n\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tdesc_kaddr = kmap(req->pr_desc_bh->b_page);\n\tdesc = nilfs_palloc_block_get_group_desc(inode, group,\n\t\t\t\t\t\t req->pr_desc_bh, desc_kaddr);\n\tbitmap_kaddr = kmap(req->pr_bitmap_bh->b_page);\n\tbitmap = bitmap_kaddr + bh_offset(req->pr_bitmap_bh);\n\n\tif (!nilfs_clear_bit_atomic(nilfs_mdt_bgl_lock(inode, group),\n\t\t\t\t    group_offset, bitmap))\n\t\tprintk(KERN_WARNING \"%s: entry number %llu already freed\\n\",\n\t\t       __func__, (unsigned long long)req->pr_entry_nr);\n\telse\n\t\tnilfs_palloc_group_desc_add_entries(inode, group, desc, 1);\n\n\tkunmap(req->pr_bitmap_bh->b_page);\n\tkunmap(req->pr_desc_bh->b_page);\n\n\tmark_buffer_dirty(req->pr_desc_bh);\n\tmark_buffer_dirty(req->pr_bitmap_bh);\n\tnilfs_mdt_mark_dirty(inode);\n\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "req.pr_entry_bh"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "req.pr_entry_bh"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_block_get_entry",
          "args": [
            "ifile",
            "req.pr_entry_nr",
            "req.pr_entry_bh",
            "kaddr"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_block_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "321-331",
          "snippet": "void *nilfs_palloc_block_get_entry(const struct inode *inode, __u64 nr,\n\t\t\t\t   const struct buffer_head *bh, void *kaddr)\n{\n\tunsigned long entry_offset, group_offset;\n\n\tnilfs_palloc_group(inode, nr, &group_offset);\n\tentry_offset = group_offset % NILFS_MDT(inode)->mi_entries_per_block;\n\n\treturn kaddr + bh_offset(bh) +\n\t\tentry_offset * NILFS_MDT(inode)->mi_entry_size;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid *nilfs_palloc_block_get_entry(const struct inode *inode, __u64 nr,\n\t\t\t\t   const struct buffer_head *bh, void *kaddr)\n{\n\tunsigned long entry_offset, group_offset;\n\n\tnilfs_palloc_group(inode, nr, &group_offset);\n\tentry_offset = group_offset % NILFS_MDT(inode)->mi_entries_per_block;\n\n\treturn kaddr + bh_offset(bh) +\n\t\tentry_offset * NILFS_MDT(inode)->mi_entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "req.pr_entry_bh->b_page"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_abort_free_entry",
          "args": [
            "ifile",
            "&req"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_abort_free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "670-679",
          "snippet": "void nilfs_palloc_abort_free_entry(struct inode *inode,\n\t\t\t\t   struct nilfs_palloc_req *req)\n{\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n\n\treq->pr_entry_nr = 0;\n\treq->pr_bitmap_bh = NULL;\n\treq->pr_desc_bh = NULL;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_palloc_abort_free_entry(struct inode *inode,\n\t\t\t\t   struct nilfs_palloc_req *req)\n{\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n\n\treq->pr_entry_nr = 0;\n\treq->pr_bitmap_bh = NULL;\n\treq->pr_desc_bh = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_get_entry_block",
          "args": [
            "ifile",
            "req.pr_entry_nr",
            "0",
            "&req.pr_entry_bh"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_get_entry_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "287-296",
          "snippet": "int nilfs_palloc_get_entry_block(struct inode *inode, __u64 nr,\n\t\t\t\t int create, struct buffer_head **bhp)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\treturn nilfs_palloc_get_block(inode,\n\t\t\t\t      nilfs_palloc_entry_blkoff(inode, nr),\n\t\t\t\t      create, NULL, bhp,\n\t\t\t\t      &cache->prev_entry, &cache->lock);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_palloc_get_entry_block(struct inode *inode, __u64 nr,\n\t\t\t\t int create, struct buffer_head **bhp)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\treturn nilfs_palloc_get_block(inode,\n\t\t\t\t      nilfs_palloc_entry_blkoff(inode, nr),\n\t\t\t\t      create, NULL, bhp,\n\t\t\t\t      &cache->prev_entry, &cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_prepare_free_entry",
          "args": [
            "ifile",
            "&req"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_prepare_free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "643-663",
          "snippet": "int nilfs_palloc_prepare_free_entry(struct inode *inode,\n\t\t\t\t    struct nilfs_palloc_req *req)\n{\n\tstruct buffer_head *desc_bh, *bitmap_bh;\n\tunsigned long group, group_offset;\n\tint ret;\n\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tret = nilfs_palloc_get_desc_block(inode, group, 1, &desc_bh);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = nilfs_palloc_get_bitmap_block(inode, group, 1, &bitmap_bh);\n\tif (ret < 0) {\n\t\tbrelse(desc_bh);\n\t\treturn ret;\n\t}\n\n\treq->pr_desc_bh = desc_bh;\n\treq->pr_bitmap_bh = bitmap_bh;\n\treturn 0;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_palloc_prepare_free_entry(struct inode *inode,\n\t\t\t\t    struct nilfs_palloc_req *req)\n{\n\tstruct buffer_head *desc_bh, *bitmap_bh;\n\tunsigned long group, group_offset;\n\tint ret;\n\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tret = nilfs_palloc_get_desc_block(inode, group, 1, &desc_bh);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = nilfs_palloc_get_bitmap_block(inode, group, 1, &bitmap_bh);\n\tif (ret < 0) {\n\t\tbrelse(desc_bh);\n\t\treturn ret;\n\t}\n\n\treq->pr_desc_bh = desc_bh;\n\treq->pr_bitmap_bh = bitmap_bh;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_delete_inode(struct inode *ifile, ino_t ino)\n{\n\tstruct nilfs_palloc_req req = {\n\t\t.pr_entry_nr = ino, .pr_entry_bh = NULL\n\t};\n\tstruct nilfs_inode *raw_inode;\n\tvoid *kaddr;\n\tint ret;\n\n\tret = nilfs_palloc_prepare_free_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 0,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_free_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\n\tkaddr = kmap_atomic(req.pr_entry_bh->b_page);\n\traw_inode = nilfs_palloc_block_get_entry(ifile, req.pr_entry_nr,\n\t\t\t\t\t\t req.pr_entry_bh, kaddr);\n\traw_inode->i_flags = 0;\n\tkunmap_atomic(kaddr);\n\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tbrelse(req.pr_entry_bh);\n\n\tnilfs_palloc_commit_free_entry(ifile, &req);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nilfs_ifile_create_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
    "lines": "65-92",
    "snippet": "int nilfs_ifile_create_inode(struct inode *ifile, ino_t *out_ino,\n\t\t\t     struct buffer_head **out_bh)\n{\n\tstruct nilfs_palloc_req req;\n\tint ret;\n\n\treq.pr_entry_nr = 0;  /* 0 says find free inode from beginning of\n\t\t\t\t a group. dull code!! */\n\treq.pr_entry_bh = NULL;\n\n\tret = nilfs_palloc_prepare_alloc_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 1,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_alloc_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\tnilfs_palloc_commit_alloc_entry(ifile, &req);\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tnilfs_mdt_mark_dirty(ifile);\n\t*out_ino = (ino_t)req.pr_entry_nr;\n\t*out_bh = req.pr_entry_bh;\n\treturn 0;\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nilfs_mdt_mark_dirty",
          "args": [
            "ifile"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mdt_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "98-102",
          "snippet": "static inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline void nilfs_mdt_mark_dirty(struct inode *inode)\n{\n\tif (!test_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state))\n\t\tset_bit(NILFS_I_DIRTY, &NILFS_I(inode)->i_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "req.pr_entry_bh"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_commit_alloc_entry",
          "args": [
            "ifile",
            "&req"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_commit_alloc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "552-561",
          "snippet": "void nilfs_palloc_commit_alloc_entry(struct inode *inode,\n\t\t\t\t     struct nilfs_palloc_req *req)\n{\n\tmark_buffer_dirty(req->pr_bitmap_bh);\n\tmark_buffer_dirty(req->pr_desc_bh);\n\tnilfs_mdt_mark_dirty(inode);\n\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_palloc_commit_alloc_entry(struct inode *inode,\n\t\t\t\t     struct nilfs_palloc_req *req)\n{\n\tmark_buffer_dirty(req->pr_bitmap_bh);\n\tmark_buffer_dirty(req->pr_desc_bh);\n\tnilfs_mdt_mark_dirty(inode);\n\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "req.pr_entry_bh"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_abort_alloc_entry",
          "args": [
            "ifile",
            "&req"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_abort_alloc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "606-636",
          "snippet": "void nilfs_palloc_abort_alloc_entry(struct inode *inode,\n\t\t\t\t    struct nilfs_palloc_req *req)\n{\n\tstruct nilfs_palloc_group_desc *desc;\n\tvoid *desc_kaddr, *bitmap_kaddr;\n\tunsigned char *bitmap;\n\tunsigned long group, group_offset;\n\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tdesc_kaddr = kmap(req->pr_desc_bh->b_page);\n\tdesc = nilfs_palloc_block_get_group_desc(inode, group,\n\t\t\t\t\t\t req->pr_desc_bh, desc_kaddr);\n\tbitmap_kaddr = kmap(req->pr_bitmap_bh->b_page);\n\tbitmap = bitmap_kaddr + bh_offset(req->pr_bitmap_bh);\n\tif (!nilfs_clear_bit_atomic(nilfs_mdt_bgl_lock(inode, group),\n\t\t\t\t    group_offset, bitmap))\n\t\tprintk(KERN_WARNING \"%s: entry number %llu already freed\\n\",\n\t\t       __func__, (unsigned long long)req->pr_entry_nr);\n\telse\n\t\tnilfs_palloc_group_desc_add_entries(inode, group, desc, 1);\n\n\tkunmap(req->pr_bitmap_bh->b_page);\n\tkunmap(req->pr_desc_bh->b_page);\n\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n\n\treq->pr_entry_nr = 0;\n\treq->pr_bitmap_bh = NULL;\n\treq->pr_desc_bh = NULL;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nvoid nilfs_palloc_abort_alloc_entry(struct inode *inode,\n\t\t\t\t    struct nilfs_palloc_req *req)\n{\n\tstruct nilfs_palloc_group_desc *desc;\n\tvoid *desc_kaddr, *bitmap_kaddr;\n\tunsigned char *bitmap;\n\tunsigned long group, group_offset;\n\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tdesc_kaddr = kmap(req->pr_desc_bh->b_page);\n\tdesc = nilfs_palloc_block_get_group_desc(inode, group,\n\t\t\t\t\t\t req->pr_desc_bh, desc_kaddr);\n\tbitmap_kaddr = kmap(req->pr_bitmap_bh->b_page);\n\tbitmap = bitmap_kaddr + bh_offset(req->pr_bitmap_bh);\n\tif (!nilfs_clear_bit_atomic(nilfs_mdt_bgl_lock(inode, group),\n\t\t\t\t    group_offset, bitmap))\n\t\tprintk(KERN_WARNING \"%s: entry number %llu already freed\\n\",\n\t\t       __func__, (unsigned long long)req->pr_entry_nr);\n\telse\n\t\tnilfs_palloc_group_desc_add_entries(inode, group, desc, 1);\n\n\tkunmap(req->pr_bitmap_bh->b_page);\n\tkunmap(req->pr_desc_bh->b_page);\n\n\tbrelse(req->pr_bitmap_bh);\n\tbrelse(req->pr_desc_bh);\n\n\treq->pr_entry_nr = 0;\n\treq->pr_bitmap_bh = NULL;\n\treq->pr_desc_bh = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_get_entry_block",
          "args": [
            "ifile",
            "req.pr_entry_nr",
            "1",
            "&req.pr_entry_bh"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_get_entry_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "287-296",
          "snippet": "int nilfs_palloc_get_entry_block(struct inode *inode, __u64 nr,\n\t\t\t\t int create, struct buffer_head **bhp)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\treturn nilfs_palloc_get_block(inode,\n\t\t\t\t      nilfs_palloc_entry_blkoff(inode, nr),\n\t\t\t\t      create, NULL, bhp,\n\t\t\t\t      &cache->prev_entry, &cache->lock);\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_palloc_get_entry_block(struct inode *inode, __u64 nr,\n\t\t\t\t int create, struct buffer_head **bhp)\n{\n\tstruct nilfs_palloc_cache *cache = NILFS_MDT(inode)->mi_palloc_cache;\n\n\treturn nilfs_palloc_get_block(inode,\n\t\t\t\t      nilfs_palloc_entry_blkoff(inode, nr),\n\t\t\t\t      create, NULL, bhp,\n\t\t\t\t      &cache->prev_entry, &cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nilfs_palloc_prepare_alloc_entry",
          "args": [
            "ifile",
            "&req"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_palloc_prepare_alloc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/alloc.c",
          "lines": "468-545",
          "snippet": "int nilfs_palloc_prepare_alloc_entry(struct inode *inode,\n\t\t\t\t     struct nilfs_palloc_req *req)\n{\n\tstruct buffer_head *desc_bh, *bitmap_bh;\n\tstruct nilfs_palloc_group_desc *desc;\n\tunsigned char *bitmap;\n\tvoid *desc_kaddr, *bitmap_kaddr;\n\tunsigned long group, maxgroup, ngroups;\n\tunsigned long group_offset, maxgroup_offset;\n\tunsigned long n, entries_per_group, groups_per_desc_block;\n\tunsigned long i, j;\n\tint pos, ret;\n\n\tngroups = nilfs_palloc_groups_count(inode);\n\tmaxgroup = ngroups - 1;\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tentries_per_group = nilfs_palloc_entries_per_group(inode);\n\tgroups_per_desc_block = nilfs_palloc_groups_per_desc_block(inode);\n\n\tfor (i = 0; i < ngroups; i += n) {\n\t\tif (group >= ngroups) {\n\t\t\t/* wrap around */\n\t\t\tgroup = 0;\n\t\t\tmaxgroup = nilfs_palloc_group(inode, req->pr_entry_nr,\n\t\t\t\t\t\t      &maxgroup_offset) - 1;\n\t\t}\n\t\tret = nilfs_palloc_get_desc_block(inode, group, 1, &desc_bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdesc_kaddr = kmap(desc_bh->b_page);\n\t\tdesc = nilfs_palloc_block_get_group_desc(\n\t\t\tinode, group, desc_bh, desc_kaddr);\n\t\tn = nilfs_palloc_rest_groups_in_desc_block(inode, group,\n\t\t\t\t\t\t\t   maxgroup);\n\t\tfor (j = 0; j < n; j++, desc++, group++) {\n\t\t\tif (nilfs_palloc_group_desc_nfrees(inode, group, desc)\n\t\t\t    > 0) {\n\t\t\t\tret = nilfs_palloc_get_bitmap_block(\n\t\t\t\t\tinode, group, 1, &bitmap_bh);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_desc;\n\t\t\t\tbitmap_kaddr = kmap(bitmap_bh->b_page);\n\t\t\t\tbitmap = bitmap_kaddr + bh_offset(bitmap_bh);\n\t\t\t\tpos = nilfs_palloc_find_available_slot(\n\t\t\t\t\tinode, group, group_offset, bitmap,\n\t\t\t\t\tentries_per_group);\n\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t/* found a free entry */\n\t\t\t\t\tnilfs_palloc_group_desc_add_entries(\n\t\t\t\t\t\tinode, group, desc, -1);\n\t\t\t\t\treq->pr_entry_nr =\n\t\t\t\t\t\tentries_per_group * group + pos;\n\t\t\t\t\tkunmap(desc_bh->b_page);\n\t\t\t\t\tkunmap(bitmap_bh->b_page);\n\n\t\t\t\t\treq->pr_desc_bh = desc_bh;\n\t\t\t\t\treq->pr_bitmap_bh = bitmap_bh;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tkunmap(bitmap_bh->b_page);\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t}\n\n\t\t\tgroup_offset = 0;\n\t\t}\n\n\t\tkunmap(desc_bh->b_page);\n\t\tbrelse(desc_bh);\n\t}\n\n\t/* no entries left */\n\treturn -ENOSPC;\n\n out_desc:\n\tkunmap(desc_bh->b_page);\n\tbrelse(desc_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"alloc.h\"",
            "#include \"mdt.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"alloc.h\"\n#include \"mdt.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_palloc_prepare_alloc_entry(struct inode *inode,\n\t\t\t\t     struct nilfs_palloc_req *req)\n{\n\tstruct buffer_head *desc_bh, *bitmap_bh;\n\tstruct nilfs_palloc_group_desc *desc;\n\tunsigned char *bitmap;\n\tvoid *desc_kaddr, *bitmap_kaddr;\n\tunsigned long group, maxgroup, ngroups;\n\tunsigned long group_offset, maxgroup_offset;\n\tunsigned long n, entries_per_group, groups_per_desc_block;\n\tunsigned long i, j;\n\tint pos, ret;\n\n\tngroups = nilfs_palloc_groups_count(inode);\n\tmaxgroup = ngroups - 1;\n\tgroup = nilfs_palloc_group(inode, req->pr_entry_nr, &group_offset);\n\tentries_per_group = nilfs_palloc_entries_per_group(inode);\n\tgroups_per_desc_block = nilfs_palloc_groups_per_desc_block(inode);\n\n\tfor (i = 0; i < ngroups; i += n) {\n\t\tif (group >= ngroups) {\n\t\t\t/* wrap around */\n\t\t\tgroup = 0;\n\t\t\tmaxgroup = nilfs_palloc_group(inode, req->pr_entry_nr,\n\t\t\t\t\t\t      &maxgroup_offset) - 1;\n\t\t}\n\t\tret = nilfs_palloc_get_desc_block(inode, group, 1, &desc_bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdesc_kaddr = kmap(desc_bh->b_page);\n\t\tdesc = nilfs_palloc_block_get_group_desc(\n\t\t\tinode, group, desc_bh, desc_kaddr);\n\t\tn = nilfs_palloc_rest_groups_in_desc_block(inode, group,\n\t\t\t\t\t\t\t   maxgroup);\n\t\tfor (j = 0; j < n; j++, desc++, group++) {\n\t\t\tif (nilfs_palloc_group_desc_nfrees(inode, group, desc)\n\t\t\t    > 0) {\n\t\t\t\tret = nilfs_palloc_get_bitmap_block(\n\t\t\t\t\tinode, group, 1, &bitmap_bh);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_desc;\n\t\t\t\tbitmap_kaddr = kmap(bitmap_bh->b_page);\n\t\t\t\tbitmap = bitmap_kaddr + bh_offset(bitmap_bh);\n\t\t\t\tpos = nilfs_palloc_find_available_slot(\n\t\t\t\t\tinode, group, group_offset, bitmap,\n\t\t\t\t\tentries_per_group);\n\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t/* found a free entry */\n\t\t\t\t\tnilfs_palloc_group_desc_add_entries(\n\t\t\t\t\t\tinode, group, desc, -1);\n\t\t\t\t\treq->pr_entry_nr =\n\t\t\t\t\t\tentries_per_group * group + pos;\n\t\t\t\t\tkunmap(desc_bh->b_page);\n\t\t\t\t\tkunmap(bitmap_bh->b_page);\n\n\t\t\t\t\treq->pr_desc_bh = desc_bh;\n\t\t\t\t\treq->pr_bitmap_bh = bitmap_bh;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tkunmap(bitmap_bh->b_page);\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t}\n\n\t\t\tgroup_offset = 0;\n\t\t}\n\n\t\tkunmap(desc_bh->b_page);\n\t\tbrelse(desc_bh);\n\t}\n\n\t/* no entries left */\n\treturn -ENOSPC;\n\n out_desc:\n\tkunmap(desc_bh->b_page);\n\tbrelse(desc_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nint nilfs_ifile_create_inode(struct inode *ifile, ino_t *out_ino,\n\t\t\t     struct buffer_head **out_bh)\n{\n\tstruct nilfs_palloc_req req;\n\tint ret;\n\n\treq.pr_entry_nr = 0;  /* 0 says find free inode from beginning of\n\t\t\t\t a group. dull code!! */\n\treq.pr_entry_bh = NULL;\n\n\tret = nilfs_palloc_prepare_alloc_entry(ifile, &req);\n\tif (!ret) {\n\t\tret = nilfs_palloc_get_entry_block(ifile, req.pr_entry_nr, 1,\n\t\t\t\t\t\t   &req.pr_entry_bh);\n\t\tif (ret < 0)\n\t\t\tnilfs_palloc_abort_alloc_entry(ifile, &req);\n\t}\n\tif (ret < 0) {\n\t\tbrelse(req.pr_entry_bh);\n\t\treturn ret;\n\t}\n\tnilfs_palloc_commit_alloc_entry(ifile, &req);\n\tmark_buffer_dirty(req.pr_entry_bh);\n\tnilfs_mdt_mark_dirty(ifile);\n\t*out_ino = (ino_t)req.pr_entry_nr;\n\t*out_bh = req.pr_entry_bh;\n\treturn 0;\n}"
  },
  {
    "function_name": "NILFS_IFILE_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/ifile.c",
    "lines": "42-45",
    "snippet": "static inline struct nilfs_ifile_info *NILFS_IFILE_I(struct inode *ifile)\n{\n\treturn (struct nilfs_ifile_info *)NILFS_MDT(ifile);\n}",
    "includes": [
      "#include \"ifile.h\"",
      "#include \"alloc.h\"",
      "#include \"mdt.h\"",
      "#include \"nilfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NILFS_MDT",
          "args": [
            "ifile"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "NILFS_MDT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/mdt.h",
          "lines": "69-72",
          "snippet": "static inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"page.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page.h\"\n#include \"nilfs.h\"\n#include <linux/blockgroup_lock.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct nilfs_mdt_info *NILFS_MDT(const struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ifile.h\"\n#include \"alloc.h\"\n#include \"mdt.h\"\n#include \"nilfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline struct nilfs_ifile_info *NILFS_IFILE_I(struct inode *ifile)\n{\n\treturn (struct nilfs_ifile_info *)NILFS_MDT(ifile);\n}"
  }
]