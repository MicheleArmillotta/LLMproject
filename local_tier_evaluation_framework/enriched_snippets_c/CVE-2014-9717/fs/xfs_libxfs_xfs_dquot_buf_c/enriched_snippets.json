[
  {
    "function_name": "xfs_dquot_buf_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
    "lines": "271-282",
    "snippet": "static void\nxfs_dquot_buf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (!xfs_dquot_buf_verify(mp, bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dquot_buf_verify",
          "args": [
            "mp",
            "bp"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_buf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "207-249",
          "snippet": "STATIC bool\nxfs_dquot_buf_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\txfs_dqid_t\t\tid = 0;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(bp->b_length);\n\n\t/*\n\t * On the first read of the buffer, verify that each dquot is valid.\n\t * We don't know what the id of the dquot is supposed to be, just that\n\t * they should be increasing monotonically within the buffer. If the\n\t * first id is corrupt, then it will fail on the second dquot in the\n\t * buffer so corruptions could point to the wrong dquot in this case.\n\t */\n\tfor (i = 0; i < ndquots; i++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\t\tint\t\t\terror;\n\n\t\tddq = &d[i].dd_diskdq;\n\n\t\tif (i == 0)\n\t\t\tid = be32_to_cpu(ddq->d_id);\n\n\t\terror = xfs_dqcheck(mp, ddq, id + i, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t       \"xfs_dquot_buf_verify\");\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_dquot_buf_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\txfs_dqid_t\t\tid = 0;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(bp->b_length);\n\n\t/*\n\t * On the first read of the buffer, verify that each dquot is valid.\n\t * We don't know what the id of the dquot is supposed to be, just that\n\t * they should be increasing monotonically within the buffer. If the\n\t * first id is corrupt, then it will fail on the second dquot in the\n\t * buffer so corruptions could point to the wrong dquot in this case.\n\t */\n\tfor (i = 0; i < ndquots; i++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\t\tint\t\t\terror;\n\n\t\tddq = &d[i].dd_diskdq;\n\n\t\tif (i == 0)\n\t\t\tid = be32_to_cpu(ddq->d_id);\n\n\t\terror = xfs_dqcheck(mp, ddq, id + i, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t       \"xfs_dquot_buf_verify\");\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dquot_buf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (!xfs_dquot_buf_verify(mp, bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "xfs_dquot_buf_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
    "lines": "251-264",
    "snippet": "static void\nxfs_dquot_buf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (!xfs_dquot_buf_verify_crc(mp, bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dquot_buf_verify(mp, bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dquot_buf_verify",
          "args": [
            "mp",
            "bp"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_buf_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "207-249",
          "snippet": "STATIC bool\nxfs_dquot_buf_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\txfs_dqid_t\t\tid = 0;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(bp->b_length);\n\n\t/*\n\t * On the first read of the buffer, verify that each dquot is valid.\n\t * We don't know what the id of the dquot is supposed to be, just that\n\t * they should be increasing monotonically within the buffer. If the\n\t * first id is corrupt, then it will fail on the second dquot in the\n\t * buffer so corruptions could point to the wrong dquot in this case.\n\t */\n\tfor (i = 0; i < ndquots; i++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\t\tint\t\t\terror;\n\n\t\tddq = &d[i].dd_diskdq;\n\n\t\tif (i == 0)\n\t\t\tid = be32_to_cpu(ddq->d_id);\n\n\t\terror = xfs_dqcheck(mp, ddq, id + i, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t       \"xfs_dquot_buf_verify\");\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_dquot_buf_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\txfs_dqid_t\t\tid = 0;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(bp->b_length);\n\n\t/*\n\t * On the first read of the buffer, verify that each dquot is valid.\n\t * We don't know what the id of the dquot is supposed to be, just that\n\t * they should be increasing monotonically within the buffer. If the\n\t * first id is corrupt, then it will fail on the second dquot in the\n\t * buffer so corruptions could point to the wrong dquot in this case.\n\t */\n\tfor (i = 0; i < ndquots; i++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\t\tint\t\t\terror;\n\n\t\tddq = &d[i].dd_diskdq;\n\n\t\tif (i == 0)\n\t\t\tid = be32_to_cpu(ddq->d_id);\n\n\t\terror = xfs_dqcheck(mp, ddq, id + i, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t       \"xfs_dquot_buf_verify\");\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dquot_buf_verify_crc",
          "args": [
            "mp",
            "bp"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_buf_verify_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "174-205",
          "snippet": "STATIC bool\nxfs_dquot_buf_verify_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn true;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(\n\t\t\t\t\tXFS_BB_TO_FSB(mp, bp->b_length));\n\n\tfor (i = 0; i < ndquots; i++, d++) {\n\t\tif (!xfs_verify_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&d->dd_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_dquot_buf_verify_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn true;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(\n\t\t\t\t\tXFS_BB_TO_FSB(mp, bp->b_length));\n\n\tfor (i = 0; i < ndquots; i++, d++) {\n\t\tif (!xfs_verify_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&d->dd_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dquot_buf_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (!xfs_dquot_buf_verify_crc(mp, bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dquot_buf_verify(mp, bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_dquot_buf_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
    "lines": "207-249",
    "snippet": "STATIC bool\nxfs_dquot_buf_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\txfs_dqid_t\t\tid = 0;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(bp->b_length);\n\n\t/*\n\t * On the first read of the buffer, verify that each dquot is valid.\n\t * We don't know what the id of the dquot is supposed to be, just that\n\t * they should be increasing monotonically within the buffer. If the\n\t * first id is corrupt, then it will fail on the second dquot in the\n\t * buffer so corruptions could point to the wrong dquot in this case.\n\t */\n\tfor (i = 0; i < ndquots; i++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\t\tint\t\t\terror;\n\n\t\tddq = &d[i].dd_diskdq;\n\n\t\tif (i == 0)\n\t\t\tid = be32_to_cpu(ddq->d_id);\n\n\t\terror = xfs_dqcheck(mp, ddq, id + i, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t       \"xfs_dquot_buf_verify\");\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqcheck",
          "args": [
            "mp",
            "ddq",
            "id + i",
            "0",
            "XFS_QMOPT_DOWARN",
            "\"xfs_dquot_buf_verify\""
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "50-172",
          "snippet": "int\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddq->d_id"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_calc_dquots_per_chunk",
          "args": [
            "bp->b_length"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_calc_dquots_per_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "34-45",
          "snippet": "int\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_dquot_buf_verify(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\txfs_dqid_t\t\tid = 0;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(bp->b_length);\n\n\t/*\n\t * On the first read of the buffer, verify that each dquot is valid.\n\t * We don't know what the id of the dquot is supposed to be, just that\n\t * they should be increasing monotonically within the buffer. If the\n\t * first id is corrupt, then it will fail on the second dquot in the\n\t * buffer so corruptions could point to the wrong dquot in this case.\n\t */\n\tfor (i = 0; i < ndquots; i++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\t\tint\t\t\terror;\n\n\t\tddq = &d[i].dd_diskdq;\n\n\t\tif (i == 0)\n\t\t\tid = be32_to_cpu(ddq->d_id);\n\n\t\terror = xfs_dqcheck(mp, ddq, id + i, 0, XFS_QMOPT_DOWARN,\n\t\t\t\t       \"xfs_dquot_buf_verify\");\n\t\tif (error)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_dquot_buf_verify_crc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
    "lines": "174-205",
    "snippet": "STATIC bool\nxfs_dquot_buf_verify_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn true;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(\n\t\t\t\t\tXFS_BB_TO_FSB(mp, bp->b_length));\n\n\tfor (i = 0; i < ndquots; i++, d++) {\n\t\tif (!xfs_verify_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&d->dd_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&d->dd_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verify_cksum",
          "args": [
            "(char *)d",
            "sizeof(struct xfs_dqblk)",
            "XFS_DQUOT_CRC_OFF"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "55-61",
          "snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_calc_dquots_per_chunk",
          "args": [
            "XFS_BB_TO_FSB(mp, bp->b_length)"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_calc_dquots_per_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "34-45",
          "snippet": "int\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "bp->b_length"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_dquot_buf_verify_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dqblk\t*d = (struct xfs_dqblk *)bp->b_addr;\n\tint\t\t\tndquots;\n\tint\t\t\ti;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn true;\n\n\t/*\n\t * if we are in log recovery, the quota subsystem has not been\n\t * initialised so we have no quotainfo structure. In that case, we need\n\t * to manually calculate the number of dquots in the buffer.\n\t */\n\tif (mp->m_quotainfo)\n\t\tndquots = mp->m_quotainfo->qi_dqperchunk;\n\telse\n\t\tndquots = xfs_calc_dquots_per_chunk(\n\t\t\t\t\tXFS_BB_TO_FSB(mp, bp->b_length));\n\n\tfor (i = 0; i < ndquots; i++, d++) {\n\t\tif (!xfs_verify_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&d->dd_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_dqcheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
    "lines": "50-172",
    "snippet": "int\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_update_cksum",
          "args": [
            "(char *)d",
            "sizeof(struct xfs_dqblk)",
            "XFS_DQUOT_CRC_OFF"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "44-50",
          "snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&d->dd_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "id"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DQUOT_MAGIC"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d",
            "0",
            "sizeof(xfs_dqblk_t)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flags & XFS_QMOPT_DQREPAIR"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "id != -1"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Re-initializing dquot ID 0x%x\"",
            "id"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\"",
            "str",
            "(int)be32_to_cpu(ddq->d_id)",
            "ddq"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddq->d_id"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_rtb_softlimit"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_rtbcount"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddq->d_id"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_ino_softlimit"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_icount"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddq->d_id"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_blk_softlimit"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddq->d_bcount"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddq->d_id"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddq->d_id"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ddq->d_magic"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DQUOT_MAGIC"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}"
  },
  {
    "function_name": "xfs_calc_dquots_per_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
    "lines": "34-45",
    "snippet": "int\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ndquots",
            "sizeof(xfs_dqblk_t)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "nbblks"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nbblks > 0"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}"
  }
]