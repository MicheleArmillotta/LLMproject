[
  {
    "function_name": "ntfs_collate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/collate.c",
    "lines": "101-124",
    "snippet": "int ntfs_collate(ntfs_volume *vol, COLLATION_RULE cr,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len) {\n\tint i;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we BUG() for everything else for now.\n\t */\n\tBUG_ON(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG);\n\ti = le32_to_cpu(cr);\n\tBUG_ON(i < 0);\n\tif (i <= 0x02)\n\t\treturn ntfs_do_collate0x0[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG_ON(i < 0x10);\n\ti -= 0x10;\n\tif (likely(i <= 3))\n\t\treturn ntfs_do_collate0x1[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"collate.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ntfs_collate_func_t ntfs_do_collate0x0[3] = {\n\tntfs_collate_binary,\n\tNULL/*ntfs_collate_file_name*/,\n\tNULL/*ntfs_collate_unicode_string*/,\n};",
      "static ntfs_collate_func_t ntfs_do_collate0x1[4] = {\n\tntfs_collate_ntofs_ulong,\n\tNULL/*ntfs_collate_ntofs_sid*/,\n\tNULL/*ntfs_collate_ntofs_security_hash*/,\n\tNULL/*ntfs_collate_ntofs_ulongs*/,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_do_collate0x1[i]",
          "args": [
            "vol",
            "data1",
            "data1_len",
            "data2",
            "data2_len"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "i <= 3"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i < 0x10"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_do_collate0x0[i]",
          "args": [
            "vol",
            "data1",
            "data1_len",
            "data2",
            "data2_len"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i < 0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "cr"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n\nstatic ntfs_collate_func_t ntfs_do_collate0x0[3] = {\n\tntfs_collate_binary,\n\tNULL/*ntfs_collate_file_name*/,\n\tNULL/*ntfs_collate_unicode_string*/,\n};\nstatic ntfs_collate_func_t ntfs_do_collate0x1[4] = {\n\tntfs_collate_ntofs_ulong,\n\tNULL/*ntfs_collate_ntofs_sid*/,\n\tNULL/*ntfs_collate_ntofs_security_hash*/,\n\tNULL/*ntfs_collate_ntofs_ulongs*/,\n};\n\nint ntfs_collate(ntfs_volume *vol, COLLATION_RULE cr,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len) {\n\tint i;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * FIXME:  At the moment we only support COLLATION_BINARY and\n\t * COLLATION_NTOFS_ULONG, so we BUG() for everything else for now.\n\t */\n\tBUG_ON(cr != COLLATION_BINARY && cr != COLLATION_NTOFS_ULONG);\n\ti = le32_to_cpu(cr);\n\tBUG_ON(i < 0);\n\tif (i <= 0x02)\n\t\treturn ntfs_do_collate0x0[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG_ON(i < 0x10);\n\ti -= 0x10;\n\tif (likely(i <= 3))\n\t\treturn ntfs_do_collate0x1[i](vol, data1, data1_len,\n\t\t\t\tdata2, data2_len);\n\tBUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "ntfs_collate_ntofs_ulong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/collate.c",
    "lines": "44-67",
    "snippet": "static int ntfs_collate_ntofs_ulong(ntfs_volume *vol,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len)\n{\n\tint rc;\n\tu32 d1, d2;\n\n\tntfs_debug(\"Entering.\");\n\t// FIXME:  We don't really want to bug here.\n\tBUG_ON(data1_len != data2_len);\n\tBUG_ON(data1_len != 4);\n\td1 = le32_to_cpup(data1);\n\td2 = le32_to_cpup(data2);\n\tif (d1 < d2)\n\t\trc = -1;\n\telse {\n\t\tif (d1 == d2)\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = 1;\n\t}\n\tntfs_debug(\"Done, returning %i\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"collate.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done, returning %i\"",
            "rc"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpup",
          "args": [
            "data2"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "data1_len != 4"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "data1_len != data2_len"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n\nstatic int ntfs_collate_ntofs_ulong(ntfs_volume *vol,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len)\n{\n\tint rc;\n\tu32 d1, d2;\n\n\tntfs_debug(\"Entering.\");\n\t// FIXME:  We don't really want to bug here.\n\tBUG_ON(data1_len != data2_len);\n\tBUG_ON(data1_len != 4);\n\td1 = le32_to_cpup(data1);\n\td2 = le32_to_cpup(data2);\n\tif (d1 < d2)\n\t\trc = -1;\n\telse {\n\t\tif (d1 == d2)\n\t\t\trc = 0;\n\t\telse\n\t\t\trc = 1;\n\t}\n\tntfs_debug(\"Done, returning %i\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "ntfs_collate_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/collate.c",
    "lines": "26-42",
    "snippet": "static int ntfs_collate_binary(ntfs_volume *vol,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len)\n{\n\tint rc;\n\n\tntfs_debug(\"Entering.\");\n\trc = memcmp(data1, data2, min(data1_len, data2_len));\n\tif (!rc && (data1_len != data2_len)) {\n\t\tif (data1_len < data2_len)\n\t\t\trc = -1;\n\t\telse\n\t\t\trc = 1;\n\t}\n\tntfs_debug(\"Done, returning %i\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"debug.h\"",
      "#include \"collate.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done, returning %i\"",
            "rc"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "data1",
            "data2",
            "min(data1_len, data2_len)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "data1_len",
            "data2_len"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering.\""
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"debug.h\"\n#include \"collate.h\"\n\nstatic int ntfs_collate_binary(ntfs_volume *vol,\n\t\tconst void *data1, const int data1_len,\n\t\tconst void *data2, const int data2_len)\n{\n\tint rc;\n\n\tntfs_debug(\"Entering.\");\n\trc = memcmp(data1, data2, min(data1_len, data2_len));\n\tif (!rc && (data1_len != data2_len)) {\n\t\tif (data1_len < data2_len)\n\t\t\trc = -1;\n\t\telse\n\t\t\trc = 1;\n\t}\n\tntfs_debug(\"Done, returning %i\", rc);\n\treturn rc;\n}"
  }
]