[
  {
    "function_name": "proc_thread_self_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/thread_self.c",
    "lines": "82-85",
    "snippet": "void __init proc_thread_self_init(void)\n{\n\tproc_alloc_inum(&thread_self_inum);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/pid_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned thread_self_inum;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_alloc_inum",
          "args": [
            "&thread_self_inum"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "proc_alloc_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "190-215",
          "snippet": "int proc_alloc_inum(unsigned int *inum)\n{\n\tunsigned int i;\n\tint error;\n\nretry:\n\tif (!ida_pre_get(&proc_inum_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&proc_inum_lock);\n\terror = ida_get_new(&proc_inum_ida, &i);\n\tspin_unlock_irq(&proc_inum_lock);\n\tif (error == -EAGAIN)\n\t\tgoto retry;\n\telse if (error)\n\t\treturn error;\n\n\tif (i > UINT_MAX - PROC_DYNAMIC_FIRST) {\n\t\tspin_lock_irq(&proc_inum_lock);\n\t\tida_remove(&proc_inum_ida, i);\n\t\tspin_unlock_irq(&proc_inum_lock);\n\t\treturn -ENOSPC;\n\t}\n\t*inum = PROC_DYNAMIC_FIRST + i;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define PROC_DYNAMIC_FIRST 0xF0000000U"
          ],
          "globals_used": [
            "static DEFINE_IDA(proc_inum_ida);",
            "static DEFINE_SPINLOCK(proc_inum_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\n#define PROC_DYNAMIC_FIRST 0xF0000000U\n\nstatic DEFINE_IDA(proc_inum_ida);\nstatic DEFINE_SPINLOCK(proc_inum_lock);\n\nint proc_alloc_inum(unsigned int *inum)\n{\n\tunsigned int i;\n\tint error;\n\nretry:\n\tif (!ida_pre_get(&proc_inum_ida, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&proc_inum_lock);\n\terror = ida_get_new(&proc_inum_ida, &i);\n\tspin_unlock_irq(&proc_inum_lock);\n\tif (error == -EAGAIN)\n\t\tgoto retry;\n\telse if (error)\n\t\treturn error;\n\n\tif (i > UINT_MAX - PROC_DYNAMIC_FIRST) {\n\t\tspin_lock_irq(&proc_inum_lock);\n\t\tida_remove(&proc_inum_ida, i);\n\t\tspin_unlock_irq(&proc_inum_lock);\n\t\treturn -ENOSPC;\n\t}\n\t*inum = PROC_DYNAMIC_FIRST + i;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n\nstatic unsigned thread_self_inum;\n\nvoid __init proc_thread_self_init(void)\n{\n\tproc_alloc_inum(&thread_self_inum);\n}"
  },
  {
    "function_name": "proc_setup_thread_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/thread_self.c",
    "lines": "48-80",
    "snippet": "int proc_setup_thread_self(struct super_block *s)\n{\n\tstruct inode *root_inode = s->s_root->d_inode;\n\tstruct pid_namespace *ns = s->s_fs_info;\n\tstruct dentry *thread_self;\n\n\tmutex_lock(&root_inode->i_mutex);\n\tthread_self = d_alloc_name(s->s_root, \"thread-self\");\n\tif (thread_self) {\n\t\tstruct inode *inode = new_inode_pseudo(s);\n\t\tif (inode) {\n\t\t\tinode->i_ino = thread_self_inum;\n\t\t\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\t\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\tinode->i_op = &proc_thread_self_inode_operations;\n\t\t\td_add(thread_self, inode);\n\t\t} else {\n\t\t\tdput(thread_self);\n\t\t\tthread_self = ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\tthread_self = ERR_PTR(-ENOMEM);\n\t}\n\tmutex_unlock(&root_inode->i_mutex);\n\tif (IS_ERR(thread_self)) {\n\t\tpr_err(\"proc_fill_super: can't allocate /proc/thread_self\\n\");\n\t\treturn PTR_ERR(thread_self);\n\t}\n\tns->proc_thread_self = thread_self;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/pid_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations proc_thread_self_inode_operations = {\n\t.readlink\t= proc_thread_self_readlink,\n\t.follow_link\t= proc_thread_self_follow_link,\n\t.put_link\t= kfree_put_link,\n};",
      "static unsigned thread_self_inum;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "thread_self"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"proc_fill_super: can't allocate /proc/thread_self\\n\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "thread_self"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root_inode->i_mutex"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "thread_self"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "thread_self",
            "inode"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_pseudo",
          "args": [
            "s"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "858-869",
          "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "s->s_root",
            "\"thread-self\""
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root_inode->i_mutex"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n\nstatic const struct inode_operations proc_thread_self_inode_operations = {\n\t.readlink\t= proc_thread_self_readlink,\n\t.follow_link\t= proc_thread_self_follow_link,\n\t.put_link\t= kfree_put_link,\n};\nstatic unsigned thread_self_inum;\n\nint proc_setup_thread_self(struct super_block *s)\n{\n\tstruct inode *root_inode = s->s_root->d_inode;\n\tstruct pid_namespace *ns = s->s_fs_info;\n\tstruct dentry *thread_self;\n\n\tmutex_lock(&root_inode->i_mutex);\n\tthread_self = d_alloc_name(s->s_root, \"thread-self\");\n\tif (thread_self) {\n\t\tstruct inode *inode = new_inode_pseudo(s);\n\t\tif (inode) {\n\t\t\tinode->i_ino = thread_self_inum;\n\t\t\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\t\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t\tinode->i_op = &proc_thread_self_inode_operations;\n\t\t\td_add(thread_self, inode);\n\t\t} else {\n\t\t\tdput(thread_self);\n\t\t\tthread_self = ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\tthread_self = ERR_PTR(-ENOMEM);\n\t}\n\tmutex_unlock(&root_inode->i_mutex);\n\tif (IS_ERR(thread_self)) {\n\t\tpr_err(\"proc_fill_super: can't allocate /proc/thread_self\\n\");\n\t\treturn PTR_ERR(thread_self);\n\t}\n\tns->proc_thread_self = thread_self;\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_thread_self_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/thread_self.c",
    "lines": "23-38",
    "snippet": "static void *proc_thread_self_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tpid_t pid = task_pid_nr_ns(current, ns);\n\tchar *name = ERR_PTR(-ENOENT);\n\tif (pid) {\n\t\tname = kmalloc(PROC_NUMBUF + 6 + PROC_NUMBUF, GFP_KERNEL);\n\t\tif (!name)\n\t\t\tname = ERR_PTR(-ENOMEM);\n\t\telse\n\t\t\tsprintf(name, \"%d/task/%d\", tgid, pid);\n\t}\n\tnd_set_link(nd, name);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/pid_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "name"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%d/task/%d\"",
            "tgid",
            "pid"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PROC_NUMBUF + 6 + PROC_NUMBUF",
            "GFP_KERNEL"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "ns"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "current",
            "ns"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n\nstatic void *proc_thread_self_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tpid_t pid = task_pid_nr_ns(current, ns);\n\tchar *name = ERR_PTR(-ENOENT);\n\tif (pid) {\n\t\tname = kmalloc(PROC_NUMBUF + 6 + PROC_NUMBUF, GFP_KERNEL);\n\t\tif (!name)\n\t\t\tname = ERR_PTR(-ENOMEM);\n\t\telse\n\t\t\tsprintf(name, \"%d/task/%d\", tgid, pid);\n\t}\n\tnd_set_link(nd, name);\n\treturn NULL;\n}"
  },
  {
    "function_name": "proc_thread_self_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/thread_self.c",
    "lines": "10-21",
    "snippet": "static int proc_thread_self_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t      int buflen)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tpid_t pid = task_pid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF + 6 + PROC_NUMBUF];\n\tif (!pid)\n\t\treturn -ENOENT;\n\tsprintf(tmp, \"%d/task/%d\", tgid, pid);\n\treturn readlink_copy(buffer, buflen, tmp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/pid_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readlink_copy",
          "args": [
            "buffer",
            "buflen",
            "tmp"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "readlink_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4409-4422",
          "snippet": "int readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint readlink_copy(char __user *buffer, int buflen, const char *link)\n{\n\tint len = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%d/task/%d\"",
            "tgid",
            "pid"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sprintf_system_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1609-1628",
          "snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_sprintf_system_inode_name(char *buf, int len,\n\t\t\t\t\t\t  int type, int slot)\n{\n\tint chars;\n\n        /*\n         * Global system inodes can only have one copy.  Everything\n         * after OCFS2_LAST_GLOBAL_SYSTEM_INODE in the system inode\n         * list has a copy per slot.\n         */\n\tif (type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE)\n\t\tchars = snprintf(buf, len, \"%s\",\n\t\t\t\t ocfs2_system_inodes[type].si_name);\n\telse\n\t\tchars = snprintf(buf, len,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t slot);\n\n\treturn chars;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "ns"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "current",
            "ns"
          ],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n\nstatic int proc_thread_self_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t      int buflen)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tpid_t pid = task_pid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF + 6 + PROC_NUMBUF];\n\tif (!pid)\n\t\treturn -ENOENT;\n\tsprintf(tmp, \"%d/task/%d\", tgid, pid);\n\treturn readlink_copy(buffer, buflen, tmp);\n}"
  }
]