[
  {
    "function_name": "ceph_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "1253-1329",
    "snippet": "static long ceph_fallocate(struct file *file, int mode,\n\t\t\t\tloff_t offset, loff_t length)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint want, got = 0;\n\tint dirty;\n\tint ret = 0;\n\tloff_t endoff = 0;\n\tloff_t size;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP) {\n\t\tret = -EROFS;\n\t\tgoto unlock;\n\t}\n\n\tif (ceph_osdmap_flag(osdc->osdmap, CEPH_OSDMAP_FULL) &&\n\t\t!(mode & FALLOC_FL_PUNCH_HOLE)) {\n\t\tret = -ENOSPC;\n\t\tgoto unlock;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\tret = ceph_uninline_data(file, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tsize = i_size_read(inode);\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tendoff = offset + length;\n\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_BUFFER;\n\n\tret = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, endoff, &got, NULL);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tif (offset < size)\n\t\t\tceph_zero_pagecache_range(inode, offset, length);\n\t\tret = ceph_zero_objects(inode, offset, length);\n\t} else if (endoff > size) {\n\t\ttruncate_pagecache_range(inode, size, -1);\n\t\tif (ceph_inode_set_size(inode, endoff))\n\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\tCHECK_CAPS_AUTHONLY, NULL);\n\t}\n\n\tif (!ret) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_inline_version = CEPH_INLINE_NONE;\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t}\n\n\tceph_put_cap_refs(ci, got);\nunlock:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ci",
            "got"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "dirty"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mark_dirty_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mark_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1389-1423",
          "snippet": "int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ceph_inode(inode)",
            "CHECK_CAPS_AUTHONLY",
            "NULL"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_set_size",
          "args": [
            "inode",
            "endoff"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1482-1499",
          "snippet": "int ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "size",
            "-1"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_zero_objects",
          "args": [
            "inode",
            "offset",
            "length"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_zero_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "1207-1251",
          "snippet": "static int ceph_zero_objects(struct inode *inode, loff_t offset, loff_t length)\n{\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\ts32 stripe_unit = ceph_file_layout_su(ci->i_layout);\n\ts32 stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\ts32 object_size = ceph_file_layout_object_size(ci->i_layout);\n\tu64 object_set_size = object_size * stripe_count;\n\tu64 nearly, t;\n\n\t/* round offset up to next period boundary */\n\tnearly = offset + object_set_size - 1;\n\tt = nearly;\n\tnearly -= do_div(t, object_set_size);\n\n\twhile (length && offset < nearly) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\twhile (length >= object_set_size) {\n\t\tint i;\n\t\tloff_t pos = offset;\n\t\tfor (i = 0; i < stripe_count; ++i) {\n\t\t\tret = ceph_zero_partial_object(inode, pos, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpos += stripe_unit;\n\t\t}\n\t\toffset += object_set_size;\n\t\tlength -= object_set_size;\n\t}\n\twhile (length) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_zero_objects(struct inode *inode, loff_t offset, loff_t length)\n{\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\ts32 stripe_unit = ceph_file_layout_su(ci->i_layout);\n\ts32 stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\ts32 object_size = ceph_file_layout_object_size(ci->i_layout);\n\tu64 object_set_size = object_size * stripe_count;\n\tu64 nearly, t;\n\n\t/* round offset up to next period boundary */\n\tnearly = offset + object_set_size - 1;\n\tt = nearly;\n\tnearly -= do_div(t, object_set_size);\n\n\twhile (length && offset < nearly) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\twhile (length >= object_set_size) {\n\t\tint i;\n\t\tloff_t pos = offset;\n\t\tfor (i = 0; i < stripe_count; ++i) {\n\t\t\tret = ceph_zero_partial_object(inode, pos, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpos += stripe_unit;\n\t\t}\n\t\toffset += object_set_size;\n\t\tlength -= object_set_size;\n\t}\n\twhile (length) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_zero_pagecache_range",
          "args": [
            "inode",
            "offset",
            "length"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_zero_pagecache_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "1141-1161",
          "snippet": "static void ceph_zero_pagecache_range(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t length)\n{\n\tloff_t nearly = round_up(offset, PAGE_CACHE_SIZE);\n\tif (offset < nearly) {\n\t\tloff_t size = nearly - offset;\n\t\tif (length < size)\n\t\t\tsize = length;\n\t\tceph_zero_partial_page(inode, offset, size);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length >= PAGE_CACHE_SIZE) {\n\t\tloff_t size = round_down(length, PAGE_CACHE_SIZE);\n\t\ttruncate_pagecache_range(inode, offset, offset + size - 1);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length)\n\t\tceph_zero_partial_page(inode, offset, length);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_zero_pagecache_range(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t length)\n{\n\tloff_t nearly = round_up(offset, PAGE_CACHE_SIZE);\n\tif (offset < nearly) {\n\t\tloff_t size = nearly - offset;\n\t\tif (length < size)\n\t\t\tsize = length;\n\t\tceph_zero_partial_page(inode, offset, size);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length >= PAGE_CACHE_SIZE) {\n\t\tloff_t size = round_down(length, PAGE_CACHE_SIZE);\n\t\ttruncate_pagecache_range(inode, offset, offset + size - 1);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length)\n\t\tceph_zero_partial_page(inode, offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR",
            "want",
            "endoff",
            "&got",
            "NULL"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2203-2252",
          "snippet": "int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_uninline_data",
          "args": [
            "file",
            "NULL"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_uninline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1445-1572",
          "snippet": "int ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_osdmap_flag",
          "args": [
            "osdc->osdmap",
            "CEPH_OSDMAP_FULL"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_fallocate(struct file *file, int mode,\n\t\t\t\tloff_t offset, loff_t length)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_inode_to_client(inode)->client->osdc;\n\tint want, got = 0;\n\tint dirty;\n\tint ret = 0;\n\tloff_t endoff = 0;\n\tloff_t size;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP) {\n\t\tret = -EROFS;\n\t\tgoto unlock;\n\t}\n\n\tif (ceph_osdmap_flag(osdc->osdmap, CEPH_OSDMAP_FULL) &&\n\t\t!(mode & FALLOC_FL_PUNCH_HOLE)) {\n\t\tret = -ENOSPC;\n\t\tgoto unlock;\n\t}\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\tret = ceph_uninline_data(file, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tsize = i_size_read(inode);\n\tif (!(mode & FALLOC_FL_KEEP_SIZE))\n\t\tendoff = offset + length;\n\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_BUFFER;\n\n\tret = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, endoff, &got, NULL);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tif (offset < size)\n\t\t\tceph_zero_pagecache_range(inode, offset, length);\n\t\tret = ceph_zero_objects(inode, offset, length);\n\t} else if (endoff > size) {\n\t\ttruncate_pagecache_range(inode, size, -1);\n\t\tif (ceph_inode_set_size(inode, endoff))\n\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\tCHECK_CAPS_AUTHONLY, NULL);\n\t}\n\n\tif (!ret) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_inline_version = CEPH_INLINE_NONE;\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t}\n\n\tceph_put_cap_refs(ci, got);\nunlock:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_zero_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "1207-1251",
    "snippet": "static int ceph_zero_objects(struct inode *inode, loff_t offset, loff_t length)\n{\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\ts32 stripe_unit = ceph_file_layout_su(ci->i_layout);\n\ts32 stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\ts32 object_size = ceph_file_layout_object_size(ci->i_layout);\n\tu64 object_set_size = object_size * stripe_count;\n\tu64 nearly, t;\n\n\t/* round offset up to next period boundary */\n\tnearly = offset + object_set_size - 1;\n\tt = nearly;\n\tnearly -= do_div(t, object_set_size);\n\n\twhile (length && offset < nearly) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\twhile (length >= object_set_size) {\n\t\tint i;\n\t\tloff_t pos = offset;\n\t\tfor (i = 0; i < stripe_count; ++i) {\n\t\t\tret = ceph_zero_partial_object(inode, pos, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpos += stripe_unit;\n\t\t}\n\t\toffset += object_set_size;\n\t\tlength -= object_set_size;\n\t}\n\twhile (length) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_zero_partial_object",
          "args": [
            "inode",
            "offset",
            "&size"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_zero_partial_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "1163-1205",
          "snippet": "static int ceph_zero_partial_object(struct inode *inode,\n\t\t\t\t    loff_t offset, loff_t *length)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tint ret = 0;\n\tloff_t zero = 0;\n\tint op;\n\n\tif (!length) {\n\t\top = offset ? CEPH_OSD_OP_DELETE : CEPH_OSD_OP_TRUNCATE;\n\t\tlength = &zero;\n\t} else {\n\t\top = CEPH_OSD_OP_ZERO;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\tceph_vino(inode),\n\t\t\t\t\toffset, length,\n\t\t\t\t\t0, 1, op,\n\t\t\t\t\tCEPH_OSD_FLAG_WRITE |\n\t\t\t\t\tCEPH_OSD_FLAG_ONDISK,\n\t\t\t\t\tNULL, 0, 0, false);\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, offset, NULL, ceph_vino(inode).snap,\n\t\t\t\t&inode->i_mtime);\n\n\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!ret) {\n\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t}\n\tceph_osdc_put_request(req);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_zero_partial_object(struct inode *inode,\n\t\t\t\t    loff_t offset, loff_t *length)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tint ret = 0;\n\tloff_t zero = 0;\n\tint op;\n\n\tif (!length) {\n\t\top = offset ? CEPH_OSD_OP_DELETE : CEPH_OSD_OP_TRUNCATE;\n\t\tlength = &zero;\n\t} else {\n\t\top = CEPH_OSD_OP_ZERO;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\tceph_vino(inode),\n\t\t\t\t\toffset, length,\n\t\t\t\t\t0, 1, op,\n\t\t\t\t\tCEPH_OSD_FLAG_WRITE |\n\t\t\t\t\tCEPH_OSD_FLAG_ONDISK,\n\t\t\t\t\tNULL, 0, 0, false);\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, offset, NULL, ceph_vino(inode).snap,\n\t\t\t\t&inode->i_mtime);\n\n\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!ret) {\n\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t}\n\tceph_osdc_put_request(req);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "object_set_size"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_object_size",
          "args": [
            "ci->i_layout"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_stripe_count",
          "args": [
            "ci->i_layout"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_su",
          "args": [
            "ci->i_layout"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_zero_objects(struct inode *inode, loff_t offset, loff_t length)\n{\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\ts32 stripe_unit = ceph_file_layout_su(ci->i_layout);\n\ts32 stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\ts32 object_size = ceph_file_layout_object_size(ci->i_layout);\n\tu64 object_set_size = object_size * stripe_count;\n\tu64 nearly, t;\n\n\t/* round offset up to next period boundary */\n\tnearly = offset + object_set_size - 1;\n\tt = nearly;\n\tnearly -= do_div(t, object_set_size);\n\n\twhile (length && offset < nearly) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\twhile (length >= object_set_size) {\n\t\tint i;\n\t\tloff_t pos = offset;\n\t\tfor (i = 0; i < stripe_count; ++i) {\n\t\t\tret = ceph_zero_partial_object(inode, pos, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpos += stripe_unit;\n\t\t}\n\t\toffset += object_set_size;\n\t\tlength -= object_set_size;\n\t}\n\twhile (length) {\n\t\tloff_t size = length;\n\t\tret = ceph_zero_partial_object(inode, offset, &size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_zero_partial_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "1163-1205",
    "snippet": "static int ceph_zero_partial_object(struct inode *inode,\n\t\t\t\t    loff_t offset, loff_t *length)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tint ret = 0;\n\tloff_t zero = 0;\n\tint op;\n\n\tif (!length) {\n\t\top = offset ? CEPH_OSD_OP_DELETE : CEPH_OSD_OP_TRUNCATE;\n\t\tlength = &zero;\n\t} else {\n\t\top = CEPH_OSD_OP_ZERO;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\tceph_vino(inode),\n\t\t\t\t\toffset, length,\n\t\t\t\t\t0, 1, op,\n\t\t\t\t\tCEPH_OSD_FLAG_WRITE |\n\t\t\t\t\tCEPH_OSD_FLAG_ONDISK,\n\t\t\t\t\tNULL, 0, 0, false);\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, offset, NULL, ceph_vino(inode).snap,\n\t\t\t\t&inode->i_mtime);\n\n\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!ret) {\n\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t}\n\tceph_osdc_put_request(req);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_wait_request",
          "args": [
            "&fsc->client->osdc",
            "req"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_start_request",
          "args": [
            "&fsc->client->osdc",
            "req",
            "false"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_build_request",
          "args": [
            "req",
            "offset",
            "NULL",
            "ceph_vino(inode).snap",
            "&inode->i_mtime"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_new_request",
          "args": [
            "&fsc->client->osdc",
            "&ci->i_layout",
            "ceph_vino(inode)",
            "offset",
            "length",
            "0",
            "1",
            "op",
            "CEPH_OSD_FLAG_WRITE |\n\t\t\t\t\tCEPH_OSD_FLAG_ONDISK",
            "NULL",
            "0",
            "0",
            "false"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode_to_client",
          "args": [
            "inode"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_zero_partial_object(struct inode *inode,\n\t\t\t\t    loff_t offset, loff_t *length)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tint ret = 0;\n\tloff_t zero = 0;\n\tint op;\n\n\tif (!length) {\n\t\top = offset ? CEPH_OSD_OP_DELETE : CEPH_OSD_OP_TRUNCATE;\n\t\tlength = &zero;\n\t} else {\n\t\top = CEPH_OSD_OP_ZERO;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\tceph_vino(inode),\n\t\t\t\t\toffset, length,\n\t\t\t\t\t0, 1, op,\n\t\t\t\t\tCEPH_OSD_FLAG_WRITE |\n\t\t\t\t\tCEPH_OSD_FLAG_ONDISK,\n\t\t\t\t\tNULL, 0, 0, false);\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, offset, NULL, ceph_vino(inode).snap,\n\t\t\t\t&inode->i_mtime);\n\n\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!ret) {\n\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t}\n\tceph_osdc_put_request(req);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_zero_pagecache_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "1141-1161",
    "snippet": "static void ceph_zero_pagecache_range(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t length)\n{\n\tloff_t nearly = round_up(offset, PAGE_CACHE_SIZE);\n\tif (offset < nearly) {\n\t\tloff_t size = nearly - offset;\n\t\tif (length < size)\n\t\t\tsize = length;\n\t\tceph_zero_partial_page(inode, offset, size);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length >= PAGE_CACHE_SIZE) {\n\t\tloff_t size = round_down(length, PAGE_CACHE_SIZE);\n\t\ttruncate_pagecache_range(inode, offset, offset + size - 1);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length)\n\t\tceph_zero_partial_page(inode, offset, length);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_zero_partial_page",
          "args": [
            "inode",
            "offset",
            "length"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_zero_partial_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "1126-1139",
          "snippet": "static inline void ceph_zero_partial_page(\n\tstruct inode *inode, loff_t offset, unsigned size)\n{\n\tstruct page *page;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (page) {\n\t\twait_on_page_writeback(page);\n\t\tzero_user(page, offset & (PAGE_CACHE_SIZE - 1), size);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_zero_partial_page(\n\tstruct inode *inode, loff_t offset, unsigned size)\n{\n\tstruct page *page;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (page) {\n\t\twait_on_page_writeback(page);\n\t\tzero_user(page, offset & (PAGE_CACHE_SIZE - 1), size);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "offset",
            "offset + size - 1"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "length",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_zero_pagecache_range(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t length)\n{\n\tloff_t nearly = round_up(offset, PAGE_CACHE_SIZE);\n\tif (offset < nearly) {\n\t\tloff_t size = nearly - offset;\n\t\tif (length < size)\n\t\t\tsize = length;\n\t\tceph_zero_partial_page(inode, offset, size);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length >= PAGE_CACHE_SIZE) {\n\t\tloff_t size = round_down(length, PAGE_CACHE_SIZE);\n\t\ttruncate_pagecache_range(inode, offset, offset + size - 1);\n\t\toffset += size;\n\t\tlength -= size;\n\t}\n\tif (length)\n\t\tceph_zero_partial_page(inode, offset, length);\n}"
  },
  {
    "function_name": "ceph_zero_partial_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "1126-1139",
    "snippet": "static inline void ceph_zero_partial_page(\n\tstruct inode *inode, loff_t offset, unsigned size)\n{\n\tstruct page *page;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (page) {\n\t\twait_on_page_writeback(page);\n\t\tzero_user(page, offset & (PAGE_CACHE_SIZE - 1), size);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset & (PAGE_CACHE_SIZE - 1)",
            "size"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_zero_partial_page(\n\tstruct inode *inode, loff_t offset, unsigned size)\n{\n\tstruct page *page;\n\tpgoff_t index = offset >> PAGE_CACHE_SHIFT;\n\n\tpage = find_lock_page(inode->i_mapping, index);\n\tif (page) {\n\t\twait_on_page_writeback(page);\n\t\tzero_user(page, offset & (PAGE_CACHE_SIZE - 1), size);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}"
  },
  {
    "function_name": "ceph_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "1072-1124",
    "snippet": "static loff_t ceph_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (whence == SEEK_END || whence == SEEK_DATA || whence == SEEK_HOLE) {\n\t\tret = ceph_do_getattr(inode, CEPH_STAT_CAP_SIZE, false);\n\t\tif (ret < 0) {\n\t\t\toffset = ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += inode->i_size;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0) {\n\t\t\toffset = file->f_pos;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_DATA:\n\t\tif (offset >= inode->i_size) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\tif (offset >= inode->i_size) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\toffset = inode->i_size;\n\t\tbreak;\n\t}\n\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn offset;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "offset",
            "inode->i_sb->s_maxbytes"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_do_getattr",
          "args": [
            "inode",
            "CEPH_STAT_CAP_SIZE",
            "false"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "751-754",
          "snippet": "static inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic loff_t ceph_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tif (whence == SEEK_END || whence == SEEK_DATA || whence == SEEK_HOLE) {\n\t\tret = ceph_do_getattr(inode, CEPH_STAT_CAP_SIZE, false);\n\t\tif (ret < 0) {\n\t\t\toffset = ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += inode->i_size;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0) {\n\t\t\toffset = file->f_pos;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_DATA:\n\t\tif (offset >= inode->i_size) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\tif (offset >= inode->i_size) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\toffset = inode->i_size;\n\t\tbreak;\n\t}\n\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn offset;\n}"
  },
  {
    "function_name": "ceph_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "937-1067",
    "snippet": "static ssize_t ceph_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_sb_to_client(inode->i_sb)->client->osdc;\n\tssize_t count = iov_iter_count(from), written = 0;\n\tint err, want, got;\n\tloff_t pos = iocb->ki_pos;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\n\tif (count == 0)\n\t\tgoto out;\n\tiov_iter_truncate(from, count);\n\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\terr = ceph_uninline_data(file, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\nretry_snap:\n\tif (ceph_osdmap_flag(osdc->osdmap, CEPH_OSDMAP_FULL)) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tdout(\"aio_write %p %llx.%llx %llu~%zd getting caps. i_size %llu\\n\",\n\t     inode, ceph_vinop(inode), pos, count, inode->i_size);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_BUFFER;\n\tgot = 0;\n\terr = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, pos + count,\n\t\t\t    &got, NULL);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdout(\"aio_write %p %llx.%llx %llu~%zd got cap refs on %s\\n\",\n\t     inode, ceph_vinop(inode), pos, count, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_BUFFER|CEPH_CAP_FILE_LAZYIO)) == 0 ||\n\t    (file->f_flags & O_DIRECT) || (fi->flags & CEPH_F_SYNC)) {\n\t\tstruct iov_iter data;\n\t\tmutex_unlock(&inode->i_mutex);\n\t\t/* we might need to revert back to that point */\n\t\tdata = *from;\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\twritten = ceph_sync_direct_write(iocb, &data, pos);\n\t\telse\n\t\t\twritten = ceph_sync_write(iocb, &data, pos);\n\t\tif (written == -EOLDSNAPC) {\n\t\t\tdout(\"aio_write %p %llx.%llx %llu~%u\"\n\t\t\t\t\"got EOLDSNAPC, retrying\\n\",\n\t\t\t\tinode, ceph_vinop(inode),\n\t\t\t\tpos, (unsigned)count);\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\tgoto retry_snap;\n\t\t}\n\t\tif (written > 0)\n\t\t\tiov_iter_advance(from, written);\n\t} else {\n\t\tloff_t old_size = inode->i_size;\n\t\t/*\n\t\t * No need to acquire the i_truncate_mutex. Because\n\t\t * the MDS revokes Fwb caps before sending truncate\n\t\t * message to us. We can't get Fwb cap while there\n\t\t * are pending vmtruncate. So write and vmtruncate\n\t\t * can not run at the same time\n\t\t */\n\t\twritten = generic_perform_write(file, from, pos);\n\t\tif (likely(written >= 0))\n\t\t\tiocb->ki_pos = pos + written;\n\t\tif (inode->i_size > old_size)\n\t\t\tceph_fscache_update_objectsize(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (written >= 0) {\n\t\tint dirty;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_inline_version = CEPH_INLINE_NONE;\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t}\n\n\tdout(\"aio_write %p %llx.%llx %llu~%u  dropping cap refs on %s\\n\",\n\t     inode, ceph_vinop(inode), pos, (unsigned)count,\n\t     ceph_cap_string(got));\n\tceph_put_cap_refs(ci, got);\n\n\tif (written >= 0 &&\n\t    ((file->f_flags & O_SYNC) || IS_SYNC(file->f_mapping->host) ||\n\t     ceph_osdmap_flag(osdc->osdmap, CEPH_OSDMAP_NEARFULL))) {\n\t\terr = vfs_fsync_range(file, pos, pos + written - 1, 1);\n\t\tif (err < 0)\n\t\t\twritten = err;\n\t}\n\n\tgoto out_unlocked;\n\nout:\n\tmutex_unlock(&inode->i_mutex);\nout_unlocked:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fsync_range",
          "args": [
            "file",
            "pos",
            "pos + written - 1",
            "1"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "178-191",
          "snippet": "int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tspin_unlock(&inode->i_lock);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n\treturn file->f_op->fsync(file, start, end, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\n\tif (!file->f_op->fsync)\n\t\treturn -EINVAL;\n\tif (!datasync && (inode->i_state & I_DIRTY_TIME)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tspin_unlock(&inode->i_lock);\n\t\tmark_inode_dirty_sync(inode);\n\t}\n\treturn file->f_op->fsync(file, start, end, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_osdmap_flag",
          "args": [
            "osdc->osdmap",
            "CEPH_OSDMAP_NEARFULL"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ci",
            "got"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_write %p %llx.%llx %llu~%u  dropping cap refs on %s\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "pos",
            "(unsigned)count",
            "ceph_cap_string(got)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "got"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "dirty"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mark_dirty_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mark_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1389-1423",
          "snippet": "int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fscache_update_objectsize",
          "args": [
            "inode"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_update_objectsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "144-146",
          "snippet": "static inline void ceph_fscache_update_objectsize(struct inode *inode)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_update_objectsize(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "written >= 0"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_perform_write",
          "args": [
            "file",
            "from",
            "pos"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "from",
            "written"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_write %p %llx.%llx %llu~%u\"\n\t\t\t\t\"got EOLDSNAPC, retrying\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "pos",
            "(unsigned)count"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sync_write",
          "args": [
            "iocb",
            "&data",
            "pos"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sync_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "677-798",
          "snippet": "static ssize_t\nceph_sync_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tu64 len;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_write on file %p %lld~%u\\n\", file, pos, (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE |\n\t\tCEPH_OSD_FLAG_ACK;\n\n\twhile ((len = iov_iter_count(from)) > 0) {\n\t\tsize_t left;\n\t\tint n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0, 1,\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * write from beginning of first page,\n\t\t * regardless of io alignment\n\t\t */\n\t\tnum_pages = (len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages)) {\n\t\t\tret = PTR_ERR(pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft = len;\n\t\tfor (n = 0; n < num_pages; n++) {\n\t\t\tsize_t plen = min_t(size_t, left, PAGE_SIZE);\n\t\t\tret = copy_page_from_iter(pages[n], 0, plen, from);\n\t\t\tif (ret != plen) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft -= ret;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get a second commit callback */\n\t\treq->r_unsafe_callback = ceph_sync_write_unsafe;\n\t\treq->r_inode = inode;\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0,\n\t\t\t\t\t\tfalse, true);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\nout:\n\t\tceph_osdc_put_request(req);\n\t\tif (ret == 0) {\n\t\t\tpos += len;\n\t\t\twritten += len;\n\n\t\t\tif (pos > i_size_read(inode)) {\n\t\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\t\tif (check_caps)\n\t\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tret = written;\n\t\tiocb->ki_pos = pos;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t\nceph_sync_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tu64 len;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_write on file %p %lld~%u\\n\", file, pos, (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE |\n\t\tCEPH_OSD_FLAG_ACK;\n\n\twhile ((len = iov_iter_count(from)) > 0) {\n\t\tsize_t left;\n\t\tint n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0, 1,\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * write from beginning of first page,\n\t\t * regardless of io alignment\n\t\t */\n\t\tnum_pages = (len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages)) {\n\t\t\tret = PTR_ERR(pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft = len;\n\t\tfor (n = 0; n < num_pages; n++) {\n\t\t\tsize_t plen = min_t(size_t, left, PAGE_SIZE);\n\t\t\tret = copy_page_from_iter(pages[n], 0, plen, from);\n\t\t\tif (ret != plen) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft -= ret;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get a second commit callback */\n\t\treq->r_unsafe_callback = ceph_sync_write_unsafe;\n\t\treq->r_inode = inode;\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0,\n\t\t\t\t\t\tfalse, true);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\nout:\n\t\tceph_osdc_put_request(req);\n\t\tif (ret == 0) {\n\t\t\tpos += len;\n\t\t\twritten += len;\n\n\t\t\tif (pos > i_size_read(inode)) {\n\t\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\t\tif (check_caps)\n\t\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tret = written;\n\t\tiocb->ki_pos = pos;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sync_direct_write",
          "args": [
            "iocb",
            "&data",
            "pos"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sync_direct_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "560-667",
          "snippet": "static ssize_t\nceph_sync_direct_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_direct_write on file %p %lld~%u\\n\", file, pos,\n\t     (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE;\n\n\twhile (iov_iter_count(from) > 0) {\n\t\tu64 len = iov_iter_single_seg_count(from);\n\t\tsize_t start;\n\t\tssize_t n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0,\n\t\t\t\t\t    2,/*include a 'startsync' command*/\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tosd_req_op_init(req, 1, CEPH_OSD_OP_STARTSYNC);\n\n\t\tn = iov_iter_get_pages_alloc(from, &pages, len, &start);\n\t\tif (unlikely(n < 0)) {\n\t\t\tret = n;\n\t\t\tceph_osdc_put_request(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\t/*\n\t\t * throw out any page cache pages in this range. this\n\t\t * may block.\n\t\t */\n\t\ttruncate_inode_pages_range(inode->i_mapping, pos,\n\t\t\t\t   (pos+n) | (PAGE_CACHE_SIZE-1));\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, n, start,\n\t\t\t\t\t\tfalse, false);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\n\t\tceph_put_page_vector(pages, num_pages, false);\n\n\t\tceph_osdc_put_request(req);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tpos += n;\n\t\twritten += n;\n\t\tiov_iter_advance(from, n);\n\n\t\tif (pos > i_size_read(inode)) {\n\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\tif (check_caps)\n\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tiocb->ki_pos = pos;\n\t\tret = written;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t\nceph_sync_direct_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_direct_write on file %p %lld~%u\\n\", file, pos,\n\t     (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE;\n\n\twhile (iov_iter_count(from) > 0) {\n\t\tu64 len = iov_iter_single_seg_count(from);\n\t\tsize_t start;\n\t\tssize_t n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0,\n\t\t\t\t\t    2,/*include a 'startsync' command*/\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tosd_req_op_init(req, 1, CEPH_OSD_OP_STARTSYNC);\n\n\t\tn = iov_iter_get_pages_alloc(from, &pages, len, &start);\n\t\tif (unlikely(n < 0)) {\n\t\t\tret = n;\n\t\t\tceph_osdc_put_request(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\t/*\n\t\t * throw out any page cache pages in this range. this\n\t\t * may block.\n\t\t */\n\t\ttruncate_inode_pages_range(inode->i_mapping, pos,\n\t\t\t\t   (pos+n) | (PAGE_CACHE_SIZE-1));\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, n, start,\n\t\t\t\t\t\tfalse, false);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\n\t\tceph_put_page_vector(pages, num_pages, false);\n\n\t\tceph_osdc_put_request(req);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tpos += n;\n\t\twritten += n;\n\t\tiov_iter_advance(from, n);\n\n\t\tif (pos > i_size_read(inode)) {\n\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\tif (check_caps)\n\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tiocb->ki_pos = pos;\n\t\tret = written;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_write %p %llx.%llx %llu~%zd got cap refs on %s\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "pos",
            "count",
            "ceph_cap_string(got)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR",
            "want",
            "pos + count",
            "&got",
            "NULL"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2203-2252",
          "snippet": "int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_write %p %llx.%llx %llu~%zd getting caps. i_size %llu\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "pos",
            "count",
            "inode->i_size"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdmap_flag",
          "args": [
            "osdc->osdmap",
            "CEPH_OSDMAP_FULL"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_uninline_data",
          "args": [
            "file",
            "NULL"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_uninline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1445-1572",
          "snippet": "int ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_uninline_data(struct file *filp, struct page *locked_page)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_osd_request *req;\n\tstruct page *page = NULL;\n\tu64 len, inline_version;\n\tint err = 0;\n\tbool from_pagecache = false;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tinline_version = ci->i_inline_version;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu\\n\",\n\t     inode, ceph_vinop(inode), inline_version);\n\n\tif (inline_version == 1 || /* initial version, no data */\n\t    inline_version == CEPH_INLINE_NONE)\n\t\tgoto out;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t\tWARN_ON(!PageUptodate(page));\n\t} else if (ceph_caps_issued(ci) &\n\t\t   (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) {\n\t\tpage = find_get_page(inode->i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tfrom_pagecache = true;\n\t\t\t\tlock_page(page);\n\t\t\t} else {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tpage = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (page) {\n\t\tlen = i_size_read(inode);\n\t\tif (len > PAGE_CACHE_SIZE)\n\t\t\tlen = PAGE_CACHE_SIZE;\n\t} else {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __ceph_do_getattr(inode, page,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (err < 0) {\n\t\t\t/* no inline data */\n\t\t\tif (err == -ENODATA)\n\t\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = err;\n\t}\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 0, 1,\n\t\t\t\t    CEPH_OSD_OP_CREATE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    0, 0, false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\tceph_osdc_put_request(req);\n\tif (err < 0)\n\t\tgoto out;\n\n\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t    ceph_vino(inode), 0, &len, 1, 3,\n\t\t\t\t    CEPH_OSD_OP_WRITE,\n\t\t\t\t    CEPH_OSD_FLAG_ONDISK | CEPH_OSD_FLAG_WRITE,\n\t\t\t\t    ci->i_snap_realm->cached_context,\n\t\t\t\t    ci->i_truncate_seq, ci->i_truncate_size,\n\t\t\t\t    false);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\n\tosd_req_op_extent_osd_data_pages(req, 1, &page, len, 0, false, false);\n\n\terr = osd_req_op_xattr_init(req, 0, CEPH_OSD_OP_CMPXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version),\n\t\t\t\t    CEPH_OSD_CMPXATTR_OP_GT,\n\t\t\t\t    CEPH_OSD_CMPXATTR_MODE_U64);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = osd_req_op_xattr_init(req, 2, CEPH_OSD_OP_SETXATTR,\n\t\t\t\t    \"inline_version\", &inline_version,\n\t\t\t\t    sizeof(inline_version), 0, 0);\n\tif (err)\n\t\tgoto out_put;\n\n\tceph_osdc_build_request(req, 0, NULL, CEPH_NOSNAP, &inode->i_mtime);\n\terr = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\tif (!err)\n\t\terr = ceph_osdc_wait_request(&fsc->client->osdc, req);\nout_put:\n\tceph_osdc_put_request(req);\n\tif (err == -ECANCELED)\n\t\terr = 0;\nout:\n\tif (page && page != locked_page) {\n\t\tif (from_pagecache) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t} else\n\t\t\t__free_pages(page, 0);\n\t}\n\n\tdout(\"uninline_data %p %llx.%llx inline_version %llu = %d\\n\",\n\t     inode, ceph_vinop(inode), inline_version, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_remove_suid",
          "args": [
            "file"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "file_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1675-1700",
          "snippet": "int file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "count"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "&pos",
            "&count",
            "S_ISBLK(inode->i_mode)"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t ceph_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_sb_to_client(inode->i_sb)->client->osdc;\n\tssize_t count = iov_iter_count(from), written = 0;\n\tint err, want, got;\n\tloff_t pos = iocb->ki_pos;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* We can write back this queue in page reclaim */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\n\tif (count == 0)\n\t\tgoto out;\n\tiov_iter_truncate(from, count);\n\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE) {\n\t\terr = ceph_uninline_data(file, NULL);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\nretry_snap:\n\tif (ceph_osdmap_flag(osdc->osdmap, CEPH_OSDMAP_FULL)) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tdout(\"aio_write %p %llx.%llx %llu~%zd getting caps. i_size %llu\\n\",\n\t     inode, ceph_vinop(inode), pos, count, inode->i_size);\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_BUFFER | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_BUFFER;\n\tgot = 0;\n\terr = ceph_get_caps(ci, CEPH_CAP_FILE_WR, want, pos + count,\n\t\t\t    &got, NULL);\n\tif (err < 0)\n\t\tgoto out;\n\n\tdout(\"aio_write %p %llx.%llx %llu~%zd got cap refs on %s\\n\",\n\t     inode, ceph_vinop(inode), pos, count, ceph_cap_string(got));\n\n\tif ((got & (CEPH_CAP_FILE_BUFFER|CEPH_CAP_FILE_LAZYIO)) == 0 ||\n\t    (file->f_flags & O_DIRECT) || (fi->flags & CEPH_F_SYNC)) {\n\t\tstruct iov_iter data;\n\t\tmutex_unlock(&inode->i_mutex);\n\t\t/* we might need to revert back to that point */\n\t\tdata = *from;\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\twritten = ceph_sync_direct_write(iocb, &data, pos);\n\t\telse\n\t\t\twritten = ceph_sync_write(iocb, &data, pos);\n\t\tif (written == -EOLDSNAPC) {\n\t\t\tdout(\"aio_write %p %llx.%llx %llu~%u\"\n\t\t\t\t\"got EOLDSNAPC, retrying\\n\",\n\t\t\t\tinode, ceph_vinop(inode),\n\t\t\t\tpos, (unsigned)count);\n\t\t\tmutex_lock(&inode->i_mutex);\n\t\t\tgoto retry_snap;\n\t\t}\n\t\tif (written > 0)\n\t\t\tiov_iter_advance(from, written);\n\t} else {\n\t\tloff_t old_size = inode->i_size;\n\t\t/*\n\t\t * No need to acquire the i_truncate_mutex. Because\n\t\t * the MDS revokes Fwb caps before sending truncate\n\t\t * message to us. We can't get Fwb cap while there\n\t\t * are pending vmtruncate. So write and vmtruncate\n\t\t * can not run at the same time\n\t\t */\n\t\twritten = generic_perform_write(file, from, pos);\n\t\tif (likely(written >= 0))\n\t\t\tiocb->ki_pos = pos + written;\n\t\tif (inode->i_size > old_size)\n\t\t\tceph_fscache_update_objectsize(inode);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (written >= 0) {\n\t\tint dirty;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_inline_version = CEPH_INLINE_NONE;\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_FILE_WR);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tif (dirty)\n\t\t\t__mark_inode_dirty(inode, dirty);\n\t}\n\n\tdout(\"aio_write %p %llx.%llx %llu~%u  dropping cap refs on %s\\n\",\n\t     inode, ceph_vinop(inode), pos, (unsigned)count,\n\t     ceph_cap_string(got));\n\tceph_put_cap_refs(ci, got);\n\n\tif (written >= 0 &&\n\t    ((file->f_flags & O_SYNC) || IS_SYNC(file->f_mapping->host) ||\n\t     ceph_osdmap_flag(osdc->osdmap, CEPH_OSDMAP_NEARFULL))) {\n\t\terr = vfs_fsync_range(file, pos, pos + written - 1, 1);\n\t\tif (err < 0)\n\t\t\twritten = err;\n\t}\n\n\tgoto out_unlocked;\n\nout:\n\tmutex_unlock(&inode->i_mutex);\nout_unlocked:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}"
  },
  {
    "function_name": "ceph_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "807-925",
    "snippet": "static ssize_t ceph_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct ceph_file_info *fi = filp->private_data;\n\tsize_t len = iocb->ki_nbytes;\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct page *pinned_page = NULL;\n\tssize_t ret;\n\tint want, got = 0;\n\tint retry_op = 0, read = 0;\n\nagain:\n\tdout(\"aio_read %p %llx.%llx %llu~%u trying to get caps on %p\\n\",\n\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len, inode);\n\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_CACHE;\n\tret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want, -1, &got, &pinned_page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0 ||\n\t    (iocb->ki_filp->f_flags & O_DIRECT) ||\n\t    (fi->flags & CEPH_F_SYNC)) {\n\n\t\tdout(\"aio_sync_read %p %llx.%llx %llu~%u got cap refs on %s\\n\",\n\t\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len,\n\t\t     ceph_cap_string(got));\n\n\t\tif (ci->i_inline_version == CEPH_INLINE_NONE) {\n\t\t\t/* hmm, this isn't really async... */\n\t\t\tret = ceph_sync_read(iocb, to, &retry_op);\n\t\t} else {\n\t\t\tretry_op = READ_INLINE;\n\t\t}\n\t} else {\n\t\tdout(\"aio_read %p %llx.%llx %llu~%u got cap refs on %s\\n\",\n\t\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len,\n\t\t     ceph_cap_string(got));\n\n\t\tret = generic_file_read_iter(iocb, to);\n\t}\n\tdout(\"aio_read %p %llx.%llx dropping cap refs on %s = %d\\n\",\n\t     inode, ceph_vinop(inode), ceph_cap_string(got), (int)ret);\n\tif (pinned_page) {\n\t\tpage_cache_release(pinned_page);\n\t\tpinned_page = NULL;\n\t}\n\tceph_put_cap_refs(ci, got);\n\tif (retry_op && ret >= 0) {\n\t\tint statret;\n\t\tstruct page *page = NULL;\n\t\tloff_t i_size;\n\t\tif (retry_op == READ_INLINE) {\n\t\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tstatret = __ceph_do_getattr(inode, page,\n\t\t\t\t\t    CEPH_STAT_CAP_INLINE_DATA, !!page);\n\t\tif (statret < 0) {\n\t\t\t __free_page(page);\n\t\t\tif (statret == -ENODATA) {\n\t\t\t\tBUG_ON(retry_op != READ_INLINE);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\treturn statret;\n\t\t}\n\n\t\ti_size = i_size_read(inode);\n\t\tif (retry_op == READ_INLINE) {\n\t\t\tBUG_ON(ret > 0 || read > 0);\n\t\t\tif (iocb->ki_pos < i_size &&\n\t\t\t    iocb->ki_pos < PAGE_CACHE_SIZE) {\n\t\t\t\tloff_t end = min_t(loff_t, i_size,\n\t\t\t\t\t\t   iocb->ki_pos + len);\n\t\t\t\tend = min_t(loff_t, end, PAGE_CACHE_SIZE);\n\t\t\t\tif (statret < end)\n\t\t\t\t\tzero_user_segment(page, statret, end);\n\t\t\t\tret = copy_page_to_iter(page,\n\t\t\t\t\t\tiocb->ki_pos & ~PAGE_MASK,\n\t\t\t\t\t\tend - iocb->ki_pos, to);\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t\tread += ret;\n\t\t\t}\n\t\t\tif (iocb->ki_pos < i_size && read < len) {\n\t\t\t\tsize_t zlen = min_t(size_t, len - read,\n\t\t\t\t\t\t    i_size - iocb->ki_pos);\n\t\t\t\tret = iov_iter_zero(zlen, to);\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t\tread += ret;\n\t\t\t}\n\t\t\t__free_pages(page, 0);\n\t\t\treturn read;\n\t\t}\n\n\t\t/* hit EOF or hole? */\n\t\tif (retry_op == CHECK_EOF && iocb->ki_pos < i_size &&\n\t\t    ret < len) {\n\t\t\tdout(\"sync_read hit hole, ppos %lld < size %lld\"\n\t\t\t     \", reading more\\n\", iocb->ki_pos,\n\t\t\t     inode->i_size);\n\n\t\t\tread += ret;\n\t\t\tlen -= ret;\n\t\t\tretry_op = 0;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (ret >= 0)\n\t\tret += read;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_read hit hole, ppos %lld < size %lld\"\n\t\t\t     \", reading more\\n\"",
            "iocb->ki_pos",
            "inode->i_size"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "page",
            "0"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_zero",
          "args": [
            "zlen",
            "to"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "len - read",
            "i_size - iocb->ki_pos"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "page",
            "iocb->ki_pos & ~PAGE_MASK",
            "end - iocb->ki_pos",
            "to"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "statret",
            "end"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "end",
            "PAGE_CACHE_SIZE"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "i_size",
            "iocb->ki_pos + len"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret > 0 || read > 0"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "retry_op != READ_INLINE"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_do_getattr",
          "args": [
            "inode",
            "page",
            "CEPH_STAT_CAP_INLINE_DATA",
            "!!page"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1924-1965",
          "snippet": "int __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ci",
            "got"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pinned_page"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_read %p %llx.%llx dropping cap refs on %s = %d\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "ceph_cap_string(got)",
            "(int)ret"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "got"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_read %p %llx.%llx %llu~%u got cap refs on %s\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "iocb->ki_pos",
            "(unsigned)len",
            "ceph_cap_string(got)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sync_read",
          "args": [
            "iocb",
            "to",
            "&retry_op"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sync_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "434-518",
          "snippet": "static ssize_t ceph_sync_read(struct kiocb *iocb, struct iov_iter *i,\n\t\t\t\tint *checkeof)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages;\n\tu64 off = iocb->ki_pos;\n\tint num_pages, ret;\n\tsize_t len = iov_iter_count(i);\n\n\tdout(\"sync_read on file %p %llu~%u %s\\n\", file, off,\n\t     (unsigned)len,\n\t     (file->f_flags & O_DIRECT) ? \"O_DIRECT\" : \"\");\n\n\tif (!len)\n\t\treturn 0;\n\t/*\n\t * flush any page cache pages in this range.  this\n\t * will make concurrent normal and sync io slow,\n\t * but it will at least behave sensibly when they are\n\t * in sequence.\n\t */\n\tret = filemap_write_and_wait_range(inode->i_mapping, off,\n\t\t\t\t\t\toff + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_flags & O_DIRECT) {\n\t\twhile (iov_iter_count(i)) {\n\t\t\tsize_t start;\n\t\t\tssize_t n;\n\n\t\t\tn = iov_iter_get_pages_alloc(i, &pages, INT_MAX, &start);\n\t\t\tif (n < 0)\n\t\t\t\treturn n;\n\n\t\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\t\tret = striped_read(inode, off, n,\n\t\t\t\t\t   pages, num_pages, checkeof,\n\t\t\t\t\t   1, start);\n\n\t\t\tceph_put_page_vector(pages, num_pages, true);\n\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\toff += ret;\n\t\t\tiov_iter_advance(i, ret);\n\t\t\tif (ret < n)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tnum_pages = calc_pages_for(off, len);\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages))\n\t\t\treturn PTR_ERR(pages);\n\t\tret = striped_read(inode, off, len, pages,\n\t\t\t\t\tnum_pages, checkeof, 0, 0);\n\t\tif (ret > 0) {\n\t\t\tint l, k = 0;\n\t\t\tsize_t left = ret;\n\n\t\t\twhile (left) {\n\t\t\t\tsize_t page_off = off & ~PAGE_MASK;\n\t\t\t\tsize_t copy = min_t(size_t,\n\t\t\t\t\t\t    PAGE_SIZE - page_off, left);\n\t\t\t\tl = copy_page_to_iter(pages[k++], page_off,\n\t\t\t\t\t\t      copy, i);\n\t\t\t\toff += l;\n\t\t\t\tleft -= l;\n\t\t\t\tif (l < copy)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tceph_release_page_vector(pages, num_pages);\n\t}\n\n\tif (off > iocb->ki_pos) {\n\t\tret = off - iocb->ki_pos;\n\t\tiocb->ki_pos = off;\n\t}\n\n\tdout(\"sync_read result %d\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t ceph_sync_read(struct kiocb *iocb, struct iov_iter *i,\n\t\t\t\tint *checkeof)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages;\n\tu64 off = iocb->ki_pos;\n\tint num_pages, ret;\n\tsize_t len = iov_iter_count(i);\n\n\tdout(\"sync_read on file %p %llu~%u %s\\n\", file, off,\n\t     (unsigned)len,\n\t     (file->f_flags & O_DIRECT) ? \"O_DIRECT\" : \"\");\n\n\tif (!len)\n\t\treturn 0;\n\t/*\n\t * flush any page cache pages in this range.  this\n\t * will make concurrent normal and sync io slow,\n\t * but it will at least behave sensibly when they are\n\t * in sequence.\n\t */\n\tret = filemap_write_and_wait_range(inode->i_mapping, off,\n\t\t\t\t\t\toff + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_flags & O_DIRECT) {\n\t\twhile (iov_iter_count(i)) {\n\t\t\tsize_t start;\n\t\t\tssize_t n;\n\n\t\t\tn = iov_iter_get_pages_alloc(i, &pages, INT_MAX, &start);\n\t\t\tif (n < 0)\n\t\t\t\treturn n;\n\n\t\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\t\tret = striped_read(inode, off, n,\n\t\t\t\t\t   pages, num_pages, checkeof,\n\t\t\t\t\t   1, start);\n\n\t\t\tceph_put_page_vector(pages, num_pages, true);\n\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\toff += ret;\n\t\t\tiov_iter_advance(i, ret);\n\t\t\tif (ret < n)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tnum_pages = calc_pages_for(off, len);\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages))\n\t\t\treturn PTR_ERR(pages);\n\t\tret = striped_read(inode, off, len, pages,\n\t\t\t\t\tnum_pages, checkeof, 0, 0);\n\t\tif (ret > 0) {\n\t\t\tint l, k = 0;\n\t\t\tsize_t left = ret;\n\n\t\t\twhile (left) {\n\t\t\t\tsize_t page_off = off & ~PAGE_MASK;\n\t\t\t\tsize_t copy = min_t(size_t,\n\t\t\t\t\t\t    PAGE_SIZE - page_off, left);\n\t\t\t\tl = copy_page_to_iter(pages[k++], page_off,\n\t\t\t\t\t\t      copy, i);\n\t\t\t\toff += l;\n\t\t\t\tleft -= l;\n\t\t\t\tif (l < copy)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tceph_release_page_vector(pages, num_pages);\n\t}\n\n\tif (off > iocb->ki_pos) {\n\t\tret = off - iocb->ki_pos;\n\t\tiocb->ki_pos = off;\n\t}\n\n\tdout(\"sync_read result %d\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_sync_read %p %llx.%llx %llu~%u got cap refs on %s\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "iocb->ki_pos",
            "(unsigned)len",
            "ceph_cap_string(got)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_caps",
          "args": [
            "ci",
            "CEPH_CAP_FILE_RD",
            "want",
            "-1",
            "&got",
            "&pinned_page"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2203-2252",
          "snippet": "int ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_get_caps(struct ceph_inode_info *ci, int need, int want,\n\t\t  loff_t endoff, int *got, struct page **pinned_page)\n{\n\tint _got, check_max, ret, err = 0;\n\nretry:\n\tif (endoff > 0)\n\t\tcheck_max_size(&ci->vfs_inode, endoff);\n\t_got = 0;\n\tcheck_max = 0;\n\tret = wait_event_interruptible(ci->i_cap_wq,\n\t\t\t\ttry_get_cap_refs(ci, need, want, endoff,\n\t\t\t\t\t\t &_got, &check_max, &err));\n\tif (err)\n\t\tret = err;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (check_max)\n\t\tgoto retry;\n\n\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t    (_got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) &&\n\t    i_size_read(&ci->vfs_inode) > 0) {\n\t\tstruct page *page = find_get_page(ci->vfs_inode.i_mapping, 0);\n\t\tif (page) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\t*pinned_page = page;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\t/*\n\t\t * drop cap refs first because getattr while holding\n\t\t * caps refs can cause deadlock.\n\t\t */\n\t\tceph_put_cap_refs(ci, _got);\n\t\t_got = 0;\n\n\t\t/* getattr request will bring inline data into page cache */\n\t\tret = __ceph_do_getattr(&ci->vfs_inode, NULL,\n\t\t\t\t\tCEPH_STAT_CAP_INLINE_DATA, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto retry;\n\t}\nout:\n\t*got = _got;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"aio_read %p %llx.%llx %llu~%u trying to get caps on %p\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "iocb->ki_pos",
            "(unsigned)len",
            "inode"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t ceph_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct ceph_file_info *fi = filp->private_data;\n\tsize_t len = iocb->ki_nbytes;\n\tstruct inode *inode = file_inode(filp);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct page *pinned_page = NULL;\n\tssize_t ret;\n\tint want, got = 0;\n\tint retry_op = 0, read = 0;\n\nagain:\n\tdout(\"aio_read %p %llx.%llx %llu~%u trying to get caps on %p\\n\",\n\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len, inode);\n\n\tif (fi->fmode & CEPH_FILE_MODE_LAZY)\n\t\twant = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\telse\n\t\twant = CEPH_CAP_FILE_CACHE;\n\tret = ceph_get_caps(ci, CEPH_CAP_FILE_RD, want, -1, &got, &pinned_page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((got & (CEPH_CAP_FILE_CACHE|CEPH_CAP_FILE_LAZYIO)) == 0 ||\n\t    (iocb->ki_filp->f_flags & O_DIRECT) ||\n\t    (fi->flags & CEPH_F_SYNC)) {\n\n\t\tdout(\"aio_sync_read %p %llx.%llx %llu~%u got cap refs on %s\\n\",\n\t\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len,\n\t\t     ceph_cap_string(got));\n\n\t\tif (ci->i_inline_version == CEPH_INLINE_NONE) {\n\t\t\t/* hmm, this isn't really async... */\n\t\t\tret = ceph_sync_read(iocb, to, &retry_op);\n\t\t} else {\n\t\t\tretry_op = READ_INLINE;\n\t\t}\n\t} else {\n\t\tdout(\"aio_read %p %llx.%llx %llu~%u got cap refs on %s\\n\",\n\t\t     inode, ceph_vinop(inode), iocb->ki_pos, (unsigned)len,\n\t\t     ceph_cap_string(got));\n\n\t\tret = generic_file_read_iter(iocb, to);\n\t}\n\tdout(\"aio_read %p %llx.%llx dropping cap refs on %s = %d\\n\",\n\t     inode, ceph_vinop(inode), ceph_cap_string(got), (int)ret);\n\tif (pinned_page) {\n\t\tpage_cache_release(pinned_page);\n\t\tpinned_page = NULL;\n\t}\n\tceph_put_cap_refs(ci, got);\n\tif (retry_op && ret >= 0) {\n\t\tint statret;\n\t\tstruct page *page = NULL;\n\t\tloff_t i_size;\n\t\tif (retry_op == READ_INLINE) {\n\t\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tstatret = __ceph_do_getattr(inode, page,\n\t\t\t\t\t    CEPH_STAT_CAP_INLINE_DATA, !!page);\n\t\tif (statret < 0) {\n\t\t\t __free_page(page);\n\t\t\tif (statret == -ENODATA) {\n\t\t\t\tBUG_ON(retry_op != READ_INLINE);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\treturn statret;\n\t\t}\n\n\t\ti_size = i_size_read(inode);\n\t\tif (retry_op == READ_INLINE) {\n\t\t\tBUG_ON(ret > 0 || read > 0);\n\t\t\tif (iocb->ki_pos < i_size &&\n\t\t\t    iocb->ki_pos < PAGE_CACHE_SIZE) {\n\t\t\t\tloff_t end = min_t(loff_t, i_size,\n\t\t\t\t\t\t   iocb->ki_pos + len);\n\t\t\t\tend = min_t(loff_t, end, PAGE_CACHE_SIZE);\n\t\t\t\tif (statret < end)\n\t\t\t\t\tzero_user_segment(page, statret, end);\n\t\t\t\tret = copy_page_to_iter(page,\n\t\t\t\t\t\tiocb->ki_pos & ~PAGE_MASK,\n\t\t\t\t\t\tend - iocb->ki_pos, to);\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t\tread += ret;\n\t\t\t}\n\t\t\tif (iocb->ki_pos < i_size && read < len) {\n\t\t\t\tsize_t zlen = min_t(size_t, len - read,\n\t\t\t\t\t\t    i_size - iocb->ki_pos);\n\t\t\t\tret = iov_iter_zero(zlen, to);\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t\tread += ret;\n\t\t\t}\n\t\t\t__free_pages(page, 0);\n\t\t\treturn read;\n\t\t}\n\n\t\t/* hit EOF or hole? */\n\t\tif (retry_op == CHECK_EOF && iocb->ki_pos < i_size &&\n\t\t    ret < len) {\n\t\t\tdout(\"sync_read hit hole, ppos %lld < size %lld\"\n\t\t\t     \", reading more\\n\", iocb->ki_pos,\n\t\t\t     inode->i_size);\n\n\t\t\tread += ret;\n\t\t\tlen -= ret;\n\t\t\tretry_op = 0;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (ret >= 0)\n\t\tret += read;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_sync_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "677-798",
    "snippet": "static ssize_t\nceph_sync_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tu64 len;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_write on file %p %lld~%u\\n\", file, pos, (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE |\n\t\tCEPH_OSD_FLAG_ACK;\n\n\twhile ((len = iov_iter_count(from)) > 0) {\n\t\tsize_t left;\n\t\tint n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0, 1,\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * write from beginning of first page,\n\t\t * regardless of io alignment\n\t\t */\n\t\tnum_pages = (len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages)) {\n\t\t\tret = PTR_ERR(pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft = len;\n\t\tfor (n = 0; n < num_pages; n++) {\n\t\t\tsize_t plen = min_t(size_t, left, PAGE_SIZE);\n\t\t\tret = copy_page_from_iter(pages[n], 0, plen, from);\n\t\t\tif (ret != plen) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft -= ret;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get a second commit callback */\n\t\treq->r_unsafe_callback = ceph_sync_write_unsafe;\n\t\treq->r_inode = inode;\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0,\n\t\t\t\t\t\tfalse, true);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\nout:\n\t\tceph_osdc_put_request(req);\n\t\tif (ret == 0) {\n\t\t\tpos += len;\n\t\t\twritten += len;\n\n\t\t\tif (pos > i_size_read(inode)) {\n\t\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\t\tif (check_caps)\n\t\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tret = written;\n\t\tiocb->ki_pos = pos;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ceph_inode(inode)",
            "CHECK_CAPS_AUTHONLY",
            "NULL"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_set_size",
          "args": [
            "inode",
            "pos"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1482-1499",
          "snippet": "int ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_wait_request",
          "args": [
            "&fsc->client->osdc",
            "req"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_start_request",
          "args": [
            "&fsc->client->osdc",
            "req",
            "false"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_build_request",
          "args": [
            "req",
            "pos",
            "snapc",
            "vino.snap",
            "&mtime"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_osd_data_pages",
          "args": [
            "req",
            "0",
            "pages",
            "len",
            "0",
            "false",
            "true"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_release_page_vector",
          "args": [
            "pages",
            "num_pages"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_from_iter",
          "args": [
            "pages[n]",
            "0",
            "plen",
            "from"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "left",
            "PAGE_SIZE"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pages"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pages"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_alloc_page_vector",
          "args": [
            "num_pages",
            "GFP_NOFS"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_new_request",
          "args": [
            "&fsc->client->osdc",
            "&ci->i_layout",
            "vino",
            "pos",
            "&len",
            "0",
            "1",
            "CEPH_OSD_OP_WRITE",
            "flags",
            "snapc",
            "ci->i_truncate_seq",
            "ci->i_truncate_size",
            "false"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"invalidate_inode_pages2_range returned %d\\n\"",
            "ret"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "pos >> PAGE_CACHE_SHIFT",
            "(pos + count) >> PAGE_CACHE_SHIFT"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "pos",
            "pos + count"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_write on file %p %lld~%u\\n\"",
            "file",
            "pos",
            "(unsigned)count"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "file_inode(file)"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t\nceph_sync_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tu64 len;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_write on file %p %lld~%u\\n\", file, pos, (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE |\n\t\tCEPH_OSD_FLAG_ACK;\n\n\twhile ((len = iov_iter_count(from)) > 0) {\n\t\tsize_t left;\n\t\tint n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0, 1,\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * write from beginning of first page,\n\t\t * regardless of io alignment\n\t\t */\n\t\tnum_pages = (len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages)) {\n\t\t\tret = PTR_ERR(pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\tleft = len;\n\t\tfor (n = 0; n < num_pages; n++) {\n\t\t\tsize_t plen = min_t(size_t, left, PAGE_SIZE);\n\t\t\tret = copy_page_from_iter(pages[n], 0, plen, from);\n\t\t\tif (ret != plen) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleft -= ret;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tceph_release_page_vector(pages, num_pages);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get a second commit callback */\n\t\treq->r_unsafe_callback = ceph_sync_write_unsafe;\n\t\treq->r_inode = inode;\n\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, len, 0,\n\t\t\t\t\t\tfalse, true);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\nout:\n\t\tceph_osdc_put_request(req);\n\t\tif (ret == 0) {\n\t\t\tpos += len;\n\t\t\twritten += len;\n\n\t\t\tif (pos > i_size_read(inode)) {\n\t\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\t\tif (check_caps)\n\t\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tret = written;\n\t\tiocb->ki_pos = pos;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_sync_direct_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "560-667",
    "snippet": "static ssize_t\nceph_sync_direct_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_direct_write on file %p %lld~%u\\n\", file, pos,\n\t     (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE;\n\n\twhile (iov_iter_count(from) > 0) {\n\t\tu64 len = iov_iter_single_seg_count(from);\n\t\tsize_t start;\n\t\tssize_t n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0,\n\t\t\t\t\t    2,/*include a 'startsync' command*/\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tosd_req_op_init(req, 1, CEPH_OSD_OP_STARTSYNC);\n\n\t\tn = iov_iter_get_pages_alloc(from, &pages, len, &start);\n\t\tif (unlikely(n < 0)) {\n\t\t\tret = n;\n\t\t\tceph_osdc_put_request(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\t/*\n\t\t * throw out any page cache pages in this range. this\n\t\t * may block.\n\t\t */\n\t\ttruncate_inode_pages_range(inode->i_mapping, pos,\n\t\t\t\t   (pos+n) | (PAGE_CACHE_SIZE-1));\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, n, start,\n\t\t\t\t\t\tfalse, false);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\n\t\tceph_put_page_vector(pages, num_pages, false);\n\n\t\tceph_osdc_put_request(req);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tpos += n;\n\t\twritten += n;\n\t\tiov_iter_advance(from, n);\n\n\t\tif (pos > i_size_read(inode)) {\n\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\tif (check_caps)\n\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tiocb->ki_pos = pos;\n\t\tret = written;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ceph_inode(inode)",
            "CHECK_CAPS_AUTHONLY",
            "NULL"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode_set_size",
          "args": [
            "inode",
            "pos"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1482-1499",
          "snippet": "int ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "from",
            "n"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_page_vector",
          "args": [
            "pages",
            "num_pages",
            "false"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_wait_request",
          "args": [
            "&fsc->client->osdc",
            "req"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_start_request",
          "args": [
            "&fsc->client->osdc",
            "req",
            "false"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_build_request",
          "args": [
            "req",
            "pos",
            "snapc",
            "vino.snap",
            "&mtime"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_extent_osd_data_pages",
          "args": [
            "req",
            "0",
            "pages",
            "n",
            "start",
            "false",
            "false"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "inode->i_mapping",
            "pos",
            "(pos+n) | (PAGE_CACHE_SIZE-1)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_put_request",
          "args": [
            "req"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "n < 0"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_get_pages_alloc",
          "args": [
            "from",
            "&pages",
            "len",
            "&start"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_op_init",
          "args": [
            "req",
            "1",
            "CEPH_OSD_OP_STARTSYNC"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_new_request",
          "args": [
            "&fsc->client->osdc",
            "&ci->i_layout",
            "vino",
            "pos",
            "&len",
            "0",
            "2",
            "/*include a 'startsync' command*/CEPH_OSD_OP_WRITE",
            "flags",
            "snapc",
            "ci->i_truncate_seq",
            "ci->i_truncate_size",
            "false"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_single_seg_count",
          "args": [
            "from"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"invalidate_inode_pages2_range returned %d\\n\"",
            "ret"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "pos >> PAGE_CACHE_SHIFT",
            "(pos + count) >> PAGE_CACHE_SHIFT"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "pos",
            "pos + count"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_direct_write on file %p %lld~%u\\n\"",
            "file",
            "pos",
            "(unsigned)count"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "file_inode(file)"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t\nceph_sync_direct_write(struct kiocb *iocb, struct iov_iter *from, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_snap_context *snapc;\n\tstruct ceph_vino vino;\n\tstruct ceph_osd_request *req;\n\tstruct page **pages;\n\tint num_pages;\n\tint written = 0;\n\tint flags;\n\tint check_caps = 0;\n\tint ret;\n\tstruct timespec mtime = CURRENT_TIME;\n\tsize_t count = iov_iter_count(from);\n\n\tif (ceph_snap(file_inode(file)) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\tdout(\"sync_direct_write on file %p %lld~%u\\n\", file, pos,\n\t     (unsigned)count);\n\n\tret = filemap_write_and_wait_range(inode->i_mapping, pos, pos + count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = invalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t    pos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\t    (pos + count) >> PAGE_CACHE_SHIFT);\n\tif (ret < 0)\n\t\tdout(\"invalidate_inode_pages2_range returned %d\\n\", ret);\n\n\tflags = CEPH_OSD_FLAG_ORDERSNAP |\n\t\tCEPH_OSD_FLAG_ONDISK |\n\t\tCEPH_OSD_FLAG_WRITE;\n\n\twhile (iov_iter_count(from) > 0) {\n\t\tu64 len = iov_iter_single_seg_count(from);\n\t\tsize_t start;\n\t\tssize_t n;\n\n\t\tsnapc = ci->i_snap_realm->cached_context;\n\t\tvino = ceph_vino(inode);\n\t\treq = ceph_osdc_new_request(&fsc->client->osdc, &ci->i_layout,\n\t\t\t\t\t    vino, pos, &len, 0,\n\t\t\t\t\t    2,/*include a 'startsync' command*/\n\t\t\t\t\t    CEPH_OSD_OP_WRITE, flags, snapc,\n\t\t\t\t\t    ci->i_truncate_seq,\n\t\t\t\t\t    ci->i_truncate_size,\n\t\t\t\t\t    false);\n\t\tif (IS_ERR(req)) {\n\t\t\tret = PTR_ERR(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tosd_req_op_init(req, 1, CEPH_OSD_OP_STARTSYNC);\n\n\t\tn = iov_iter_get_pages_alloc(from, &pages, len, &start);\n\t\tif (unlikely(n < 0)) {\n\t\t\tret = n;\n\t\t\tceph_osdc_put_request(req);\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\t/*\n\t\t * throw out any page cache pages in this range. this\n\t\t * may block.\n\t\t */\n\t\ttruncate_inode_pages_range(inode->i_mapping, pos,\n\t\t\t\t   (pos+n) | (PAGE_CACHE_SIZE-1));\n\t\tosd_req_op_extent_osd_data_pages(req, 0, pages, n, start,\n\t\t\t\t\t\tfalse, false);\n\n\t\t/* BUG_ON(vino.snap != CEPH_NOSNAP); */\n\t\tceph_osdc_build_request(req, pos, snapc, vino.snap, &mtime);\n\n\t\tret = ceph_osdc_start_request(&fsc->client->osdc, req, false);\n\t\tif (!ret)\n\t\t\tret = ceph_osdc_wait_request(&fsc->client->osdc, req);\n\n\t\tceph_put_page_vector(pages, num_pages, false);\n\n\t\tceph_osdc_put_request(req);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tpos += n;\n\t\twritten += n;\n\t\tiov_iter_advance(from, n);\n\n\t\tif (pos > i_size_read(inode)) {\n\t\t\tcheck_caps = ceph_inode_set_size(inode, pos);\n\t\t\tif (check_caps)\n\t\t\t\tceph_check_caps(ceph_inode(inode),\n\t\t\t\t\t\tCHECK_CAPS_AUTHONLY,\n\t\t\t\t\t\tNULL);\n\t\t}\n\t}\n\n\tif (ret != -EOLDSNAPC && written > 0) {\n\t\tiocb->ki_pos = pos;\n\t\tret = written;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_sync_write_unsafe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "532-550",
    "snippet": "static void ceph_sync_write_unsafe(struct ceph_osd_request *req, bool unsafe)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(req->r_inode);\n\n\tdout(\"%s %p tid %llu %ssafe\\n\", __func__, req, req->r_tid,\n\t\tunsafe ? \"un\" : \"\");\n\tif (unsafe) {\n\t\tceph_get_cap_refs(ci, CEPH_CAP_FILE_WR);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_add_tail(&req->r_unsafe_item,\n\t\t\t      &ci->i_unsafe_writes);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t} else {\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t\tceph_put_cap_refs(ci, CEPH_CAP_FILE_WR);\n\t}\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_put_cap_refs",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&req->r_unsafe_item"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&req->r_unsafe_item",
            "&ci->i_unsafe_writes"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_cap_refs",
          "args": [
            "ci",
            "CEPH_CAP_FILE_WR"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2258-2263",
          "snippet": "void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%s %p tid %llu %ssafe\\n\"",
            "__func__",
            "req",
            "req->r_tid",
            "unsafe ? \"un\" : \"\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "req->r_inode"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_sync_write_unsafe(struct ceph_osd_request *req, bool unsafe)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(req->r_inode);\n\n\tdout(\"%s %p tid %llu %ssafe\\n\", __func__, req, req->r_tid,\n\t\tunsafe ? \"un\" : \"\");\n\tif (unsafe) {\n\t\tceph_get_cap_refs(ci, CEPH_CAP_FILE_WR);\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_add_tail(&req->r_unsafe_item,\n\t\t\t      &ci->i_unsafe_writes);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t} else {\n\t\tspin_lock(&ci->i_unsafe_lock);\n\t\tlist_del_init(&req->r_unsafe_item);\n\t\tspin_unlock(&ci->i_unsafe_lock);\n\t\tceph_put_cap_refs(ci, CEPH_CAP_FILE_WR);\n\t}\n}"
  },
  {
    "function_name": "ceph_sync_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "434-518",
    "snippet": "static ssize_t ceph_sync_read(struct kiocb *iocb, struct iov_iter *i,\n\t\t\t\tint *checkeof)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages;\n\tu64 off = iocb->ki_pos;\n\tint num_pages, ret;\n\tsize_t len = iov_iter_count(i);\n\n\tdout(\"sync_read on file %p %llu~%u %s\\n\", file, off,\n\t     (unsigned)len,\n\t     (file->f_flags & O_DIRECT) ? \"O_DIRECT\" : \"\");\n\n\tif (!len)\n\t\treturn 0;\n\t/*\n\t * flush any page cache pages in this range.  this\n\t * will make concurrent normal and sync io slow,\n\t * but it will at least behave sensibly when they are\n\t * in sequence.\n\t */\n\tret = filemap_write_and_wait_range(inode->i_mapping, off,\n\t\t\t\t\t\toff + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_flags & O_DIRECT) {\n\t\twhile (iov_iter_count(i)) {\n\t\t\tsize_t start;\n\t\t\tssize_t n;\n\n\t\t\tn = iov_iter_get_pages_alloc(i, &pages, INT_MAX, &start);\n\t\t\tif (n < 0)\n\t\t\t\treturn n;\n\n\t\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\t\tret = striped_read(inode, off, n,\n\t\t\t\t\t   pages, num_pages, checkeof,\n\t\t\t\t\t   1, start);\n\n\t\t\tceph_put_page_vector(pages, num_pages, true);\n\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\toff += ret;\n\t\t\tiov_iter_advance(i, ret);\n\t\t\tif (ret < n)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tnum_pages = calc_pages_for(off, len);\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages))\n\t\t\treturn PTR_ERR(pages);\n\t\tret = striped_read(inode, off, len, pages,\n\t\t\t\t\tnum_pages, checkeof, 0, 0);\n\t\tif (ret > 0) {\n\t\t\tint l, k = 0;\n\t\t\tsize_t left = ret;\n\n\t\t\twhile (left) {\n\t\t\t\tsize_t page_off = off & ~PAGE_MASK;\n\t\t\t\tsize_t copy = min_t(size_t,\n\t\t\t\t\t\t    PAGE_SIZE - page_off, left);\n\t\t\t\tl = copy_page_to_iter(pages[k++], page_off,\n\t\t\t\t\t\t      copy, i);\n\t\t\t\toff += l;\n\t\t\t\tleft -= l;\n\t\t\t\tif (l < copy)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tceph_release_page_vector(pages, num_pages);\n\t}\n\n\tif (off > iocb->ki_pos) {\n\t\tret = off - iocb->ki_pos;\n\t\tiocb->ki_pos = off;\n\t}\n\n\tdout(\"sync_read result %d\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_read result %d\\n\"",
            "ret"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_release_page_vector",
          "args": [
            "pages",
            "num_pages"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "pages[k++]",
            "page_off",
            "copy",
            "i"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE - page_off",
            "left"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "striped_read",
          "args": [
            "inode",
            "off",
            "len",
            "pages",
            "num_pages",
            "checkeof",
            "0",
            "0"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "striped_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "348-426",
          "snippet": "static int striped_read(struct inode *inode,\n\t\t\tu64 off, u64 len,\n\t\t\tstruct page **pages, int num_pages,\n\t\t\tint *checkeof, bool o_direct,\n\t\t\tunsigned long buf_align)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 pos, this_len, left;\n\tint io_align, page_align;\n\tint pages_left;\n\tint read;\n\tstruct page **page_pos;\n\tint ret;\n\tbool hit_stripe, was_short;\n\n\t/*\n\t * we may need to do multiple reads.  not atomic, unfortunately.\n\t */\n\tpos = off;\n\tleft = len;\n\tpage_pos = pages;\n\tpages_left = num_pages;\n\tread = 0;\n\tio_align = off & ~PAGE_MASK;\n\nmore:\n\tif (o_direct)\n\t\tpage_align = (pos - io_align + buf_align) & ~PAGE_MASK;\n\telse\n\t\tpage_align = pos & ~PAGE_MASK;\n\tthis_len = left;\n\tret = ceph_osdc_readpages(&fsc->client->osdc, ceph_vino(inode),\n\t\t\t\t  &ci->i_layout, pos, &this_len,\n\t\t\t\t  ci->i_truncate_seq,\n\t\t\t\t  ci->i_truncate_size,\n\t\t\t\t  page_pos, pages_left, page_align);\n\tif (ret == -ENOENT)\n\t\tret = 0;\n\thit_stripe = this_len < left;\n\twas_short = ret >= 0 && ret < this_len;\n\tdout(\"striped_read %llu~%llu (read %u) got %d%s%s\\n\", pos, left, read,\n\t     ret, hit_stripe ? \" HITSTRIPE\" : \"\", was_short ? \" SHORT\" : \"\");\n\n\tif (ret >= 0) {\n\t\tint didpages;\n\t\tif (was_short && (pos + ret < inode->i_size)) {\n\t\t\tint zlen = min(this_len - ret,\n\t\t\t\t       inode->i_size - pos - ret);\n\t\t\tint zoff = (o_direct ? buf_align : io_align) +\n\t\t\t\t    read + ret;\n\t\t\tdout(\" zero gap %llu to %llu\\n\",\n\t\t\t\tpos + ret, pos + ret + zlen);\n\t\t\tceph_zero_page_vector_range(zoff, zlen, pages);\n\t\t\tret += zlen;\n\t\t}\n\n\t\tdidpages = (page_align + ret) >> PAGE_CACHE_SHIFT;\n\t\tpos += ret;\n\t\tread = pos - off;\n\t\tleft -= ret;\n\t\tpage_pos += didpages;\n\t\tpages_left -= didpages;\n\n\t\t/* hit stripe and need continue*/\n\t\tif (left && hit_stripe && pos < inode->i_size)\n\t\t\tgoto more;\n\t}\n\n\tif (read > 0) {\n\t\tret = read;\n\t\t/* did we bounce off eof? */\n\t\tif (pos + left > inode->i_size)\n\t\t\t*checkeof = CHECK_EOF;\n\t}\n\n\tdout(\"striped_read returns %d\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int striped_read(struct inode *inode,\n\t\t\tu64 off, u64 len,\n\t\t\tstruct page **pages, int num_pages,\n\t\t\tint *checkeof, bool o_direct,\n\t\t\tunsigned long buf_align)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 pos, this_len, left;\n\tint io_align, page_align;\n\tint pages_left;\n\tint read;\n\tstruct page **page_pos;\n\tint ret;\n\tbool hit_stripe, was_short;\n\n\t/*\n\t * we may need to do multiple reads.  not atomic, unfortunately.\n\t */\n\tpos = off;\n\tleft = len;\n\tpage_pos = pages;\n\tpages_left = num_pages;\n\tread = 0;\n\tio_align = off & ~PAGE_MASK;\n\nmore:\n\tif (o_direct)\n\t\tpage_align = (pos - io_align + buf_align) & ~PAGE_MASK;\n\telse\n\t\tpage_align = pos & ~PAGE_MASK;\n\tthis_len = left;\n\tret = ceph_osdc_readpages(&fsc->client->osdc, ceph_vino(inode),\n\t\t\t\t  &ci->i_layout, pos, &this_len,\n\t\t\t\t  ci->i_truncate_seq,\n\t\t\t\t  ci->i_truncate_size,\n\t\t\t\t  page_pos, pages_left, page_align);\n\tif (ret == -ENOENT)\n\t\tret = 0;\n\thit_stripe = this_len < left;\n\twas_short = ret >= 0 && ret < this_len;\n\tdout(\"striped_read %llu~%llu (read %u) got %d%s%s\\n\", pos, left, read,\n\t     ret, hit_stripe ? \" HITSTRIPE\" : \"\", was_short ? \" SHORT\" : \"\");\n\n\tif (ret >= 0) {\n\t\tint didpages;\n\t\tif (was_short && (pos + ret < inode->i_size)) {\n\t\t\tint zlen = min(this_len - ret,\n\t\t\t\t       inode->i_size - pos - ret);\n\t\t\tint zoff = (o_direct ? buf_align : io_align) +\n\t\t\t\t    read + ret;\n\t\t\tdout(\" zero gap %llu to %llu\\n\",\n\t\t\t\tpos + ret, pos + ret + zlen);\n\t\t\tceph_zero_page_vector_range(zoff, zlen, pages);\n\t\t\tret += zlen;\n\t\t}\n\n\t\tdidpages = (page_align + ret) >> PAGE_CACHE_SHIFT;\n\t\tpos += ret;\n\t\tread = pos - off;\n\t\tleft -= ret;\n\t\tpage_pos += didpages;\n\t\tpages_left -= didpages;\n\n\t\t/* hit stripe and need continue*/\n\t\tif (left && hit_stripe && pos < inode->i_size)\n\t\t\tgoto more;\n\t}\n\n\tif (read > 0) {\n\t\tret = read;\n\t\t/* did we bounce off eof? */\n\t\tif (pos + left > inode->i_size)\n\t\t\t*checkeof = CHECK_EOF;\n\t}\n\n\tdout(\"striped_read returns %d\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pages"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pages"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_alloc_page_vector",
          "args": [
            "num_pages",
            "GFP_NOFS"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_pages_for",
          "args": [
            "off",
            "len"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_advance",
          "args": [
            "i",
            "ret"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_page_vector",
          "args": [
            "pages",
            "num_pages",
            "true"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_get_pages_alloc",
          "args": [
            "i",
            "&pages",
            "INT_MAX",
            "&start"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "off",
            "off + len"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"sync_read on file %p %llu~%u %s\\n\"",
            "file",
            "off",
            "(unsigned)len",
            "(file->f_flags & O_DIRECT) ? \"O_DIRECT\" : \"\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "i"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic ssize_t ceph_sync_read(struct kiocb *iocb, struct iov_iter *i,\n\t\t\t\tint *checkeof)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages;\n\tu64 off = iocb->ki_pos;\n\tint num_pages, ret;\n\tsize_t len = iov_iter_count(i);\n\n\tdout(\"sync_read on file %p %llu~%u %s\\n\", file, off,\n\t     (unsigned)len,\n\t     (file->f_flags & O_DIRECT) ? \"O_DIRECT\" : \"\");\n\n\tif (!len)\n\t\treturn 0;\n\t/*\n\t * flush any page cache pages in this range.  this\n\t * will make concurrent normal and sync io slow,\n\t * but it will at least behave sensibly when they are\n\t * in sequence.\n\t */\n\tret = filemap_write_and_wait_range(inode->i_mapping, off,\n\t\t\t\t\t\toff + len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (file->f_flags & O_DIRECT) {\n\t\twhile (iov_iter_count(i)) {\n\t\t\tsize_t start;\n\t\t\tssize_t n;\n\n\t\t\tn = iov_iter_get_pages_alloc(i, &pages, INT_MAX, &start);\n\t\t\tif (n < 0)\n\t\t\t\treturn n;\n\n\t\t\tnum_pages = (n + start + PAGE_SIZE - 1) / PAGE_SIZE;\n\n\t\t\tret = striped_read(inode, off, n,\n\t\t\t\t\t   pages, num_pages, checkeof,\n\t\t\t\t\t   1, start);\n\n\t\t\tceph_put_page_vector(pages, num_pages, true);\n\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\toff += ret;\n\t\t\tiov_iter_advance(i, ret);\n\t\t\tif (ret < n)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tnum_pages = calc_pages_for(off, len);\n\t\tpages = ceph_alloc_page_vector(num_pages, GFP_NOFS);\n\t\tif (IS_ERR(pages))\n\t\t\treturn PTR_ERR(pages);\n\t\tret = striped_read(inode, off, len, pages,\n\t\t\t\t\tnum_pages, checkeof, 0, 0);\n\t\tif (ret > 0) {\n\t\t\tint l, k = 0;\n\t\t\tsize_t left = ret;\n\n\t\t\twhile (left) {\n\t\t\t\tsize_t page_off = off & ~PAGE_MASK;\n\t\t\t\tsize_t copy = min_t(size_t,\n\t\t\t\t\t\t    PAGE_SIZE - page_off, left);\n\t\t\t\tl = copy_page_to_iter(pages[k++], page_off,\n\t\t\t\t\t\t      copy, i);\n\t\t\t\toff += l;\n\t\t\t\tleft -= l;\n\t\t\t\tif (l < copy)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tceph_release_page_vector(pages, num_pages);\n\t}\n\n\tif (off > iocb->ki_pos) {\n\t\tret = off - iocb->ki_pos;\n\t\tiocb->ki_pos = off;\n\t}\n\n\tdout(\"sync_read result %d\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "striped_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "348-426",
    "snippet": "static int striped_read(struct inode *inode,\n\t\t\tu64 off, u64 len,\n\t\t\tstruct page **pages, int num_pages,\n\t\t\tint *checkeof, bool o_direct,\n\t\t\tunsigned long buf_align)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 pos, this_len, left;\n\tint io_align, page_align;\n\tint pages_left;\n\tint read;\n\tstruct page **page_pos;\n\tint ret;\n\tbool hit_stripe, was_short;\n\n\t/*\n\t * we may need to do multiple reads.  not atomic, unfortunately.\n\t */\n\tpos = off;\n\tleft = len;\n\tpage_pos = pages;\n\tpages_left = num_pages;\n\tread = 0;\n\tio_align = off & ~PAGE_MASK;\n\nmore:\n\tif (o_direct)\n\t\tpage_align = (pos - io_align + buf_align) & ~PAGE_MASK;\n\telse\n\t\tpage_align = pos & ~PAGE_MASK;\n\tthis_len = left;\n\tret = ceph_osdc_readpages(&fsc->client->osdc, ceph_vino(inode),\n\t\t\t\t  &ci->i_layout, pos, &this_len,\n\t\t\t\t  ci->i_truncate_seq,\n\t\t\t\t  ci->i_truncate_size,\n\t\t\t\t  page_pos, pages_left, page_align);\n\tif (ret == -ENOENT)\n\t\tret = 0;\n\thit_stripe = this_len < left;\n\twas_short = ret >= 0 && ret < this_len;\n\tdout(\"striped_read %llu~%llu (read %u) got %d%s%s\\n\", pos, left, read,\n\t     ret, hit_stripe ? \" HITSTRIPE\" : \"\", was_short ? \" SHORT\" : \"\");\n\n\tif (ret >= 0) {\n\t\tint didpages;\n\t\tif (was_short && (pos + ret < inode->i_size)) {\n\t\t\tint zlen = min(this_len - ret,\n\t\t\t\t       inode->i_size - pos - ret);\n\t\t\tint zoff = (o_direct ? buf_align : io_align) +\n\t\t\t\t    read + ret;\n\t\t\tdout(\" zero gap %llu to %llu\\n\",\n\t\t\t\tpos + ret, pos + ret + zlen);\n\t\t\tceph_zero_page_vector_range(zoff, zlen, pages);\n\t\t\tret += zlen;\n\t\t}\n\n\t\tdidpages = (page_align + ret) >> PAGE_CACHE_SHIFT;\n\t\tpos += ret;\n\t\tread = pos - off;\n\t\tleft -= ret;\n\t\tpage_pos += didpages;\n\t\tpages_left -= didpages;\n\n\t\t/* hit stripe and need continue*/\n\t\tif (left && hit_stripe && pos < inode->i_size)\n\t\t\tgoto more;\n\t}\n\n\tif (read > 0) {\n\t\tret = read;\n\t\t/* did we bounce off eof? */\n\t\tif (pos + left > inode->i_size)\n\t\t\t*checkeof = CHECK_EOF;\n\t}\n\n\tdout(\"striped_read returns %d\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"striped_read returns %d\\n\"",
            "ret"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_zero_page_vector_range",
          "args": [
            "zoff",
            "zlen",
            "pages"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" zero gap %llu to %llu\\n\"",
            "pos + ret",
            "pos + ret + zlen"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "this_len - ret",
            "inode->i_size - pos - ret"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"striped_read %llu~%llu (read %u) got %d%s%s\\n\"",
            "pos",
            "left",
            "read",
            "ret",
            "hit_stripe ? \" HITSTRIPE\" : \"\"",
            "was_short ? \" SHORT\" : \"\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osdc_readpages",
          "args": [
            "&fsc->client->osdc",
            "ceph_vino(inode)",
            "&ci->i_layout",
            "pos",
            "&this_len",
            "ci->i_truncate_seq",
            "ci->i_truncate_size",
            "page_pos",
            "pages_left",
            "page_align"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vino",
          "args": [
            "inode"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int striped_read(struct inode *inode,\n\t\t\tu64 off, u64 len,\n\t\t\tstruct page **pages, int num_pages,\n\t\t\tint *checkeof, bool o_direct,\n\t\t\tunsigned long buf_align)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(inode);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 pos, this_len, left;\n\tint io_align, page_align;\n\tint pages_left;\n\tint read;\n\tstruct page **page_pos;\n\tint ret;\n\tbool hit_stripe, was_short;\n\n\t/*\n\t * we may need to do multiple reads.  not atomic, unfortunately.\n\t */\n\tpos = off;\n\tleft = len;\n\tpage_pos = pages;\n\tpages_left = num_pages;\n\tread = 0;\n\tio_align = off & ~PAGE_MASK;\n\nmore:\n\tif (o_direct)\n\t\tpage_align = (pos - io_align + buf_align) & ~PAGE_MASK;\n\telse\n\t\tpage_align = pos & ~PAGE_MASK;\n\tthis_len = left;\n\tret = ceph_osdc_readpages(&fsc->client->osdc, ceph_vino(inode),\n\t\t\t\t  &ci->i_layout, pos, &this_len,\n\t\t\t\t  ci->i_truncate_seq,\n\t\t\t\t  ci->i_truncate_size,\n\t\t\t\t  page_pos, pages_left, page_align);\n\tif (ret == -ENOENT)\n\t\tret = 0;\n\thit_stripe = this_len < left;\n\twas_short = ret >= 0 && ret < this_len;\n\tdout(\"striped_read %llu~%llu (read %u) got %d%s%s\\n\", pos, left, read,\n\t     ret, hit_stripe ? \" HITSTRIPE\" : \"\", was_short ? \" SHORT\" : \"\");\n\n\tif (ret >= 0) {\n\t\tint didpages;\n\t\tif (was_short && (pos + ret < inode->i_size)) {\n\t\t\tint zlen = min(this_len - ret,\n\t\t\t\t       inode->i_size - pos - ret);\n\t\t\tint zoff = (o_direct ? buf_align : io_align) +\n\t\t\t\t    read + ret;\n\t\t\tdout(\" zero gap %llu to %llu\\n\",\n\t\t\t\tpos + ret, pos + ret + zlen);\n\t\t\tceph_zero_page_vector_range(zoff, zlen, pages);\n\t\t\tret += zlen;\n\t\t}\n\n\t\tdidpages = (page_align + ret) >> PAGE_CACHE_SHIFT;\n\t\tpos += ret;\n\t\tread = pos - off;\n\t\tleft -= ret;\n\t\tpage_pos += didpages;\n\t\tpages_left -= didpages;\n\n\t\t/* hit stripe and need continue*/\n\t\tif (left && hit_stripe && pos < inode->i_size)\n\t\t\tgoto more;\n\t}\n\n\tif (read > 0) {\n\t\tret = read;\n\t\t/* did we bounce off eof? */\n\t\tif (pos + left > inode->i_size)\n\t\t\t*checkeof = CHECK_EOF;\n\t}\n\n\tdout(\"striped_read returns %d\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "317-334",
    "snippet": "int ceph_release(struct inode *inode, struct file *file)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *cf = file->private_data;\n\n\tdout(\"release inode %p file %p\\n\", inode, file);\n\tceph_put_fmode(ci, cf->fmode);\n\tif (cf->last_readdir)\n\t\tceph_mdsc_put_request(cf->last_readdir);\n\tkfree(cf->last_name);\n\tkfree(cf->dir_info);\n\tdput(cf->dentry);\n\tkmem_cache_free(ceph_file_cachep, cf);\n\n\t/* wake up anyone waiting for caps on this inode */\n\twake_up_all(&ci->i_cap_wq);\n\treturn 0;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ceph_file_cachep",
            "cf"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "cf->dentry"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cf->dir_info"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cf->last_name"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "cf->last_readdir"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_fmode",
          "args": [
            "ci",
            "cf->fmode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_fmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3300-3315",
          "snippet": "void ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"release inode %p file %p\\n\"",
            "inode",
            "file"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_release(struct inode *inode, struct file *file)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_file_info *cf = file->private_data;\n\n\tdout(\"release inode %p file %p\\n\", inode, file);\n\tceph_put_fmode(ci, cf->fmode);\n\tif (cf->last_readdir)\n\t\tceph_mdsc_put_request(cf->last_readdir);\n\tkfree(cf->last_name);\n\tkfree(cf->dir_info);\n\tdput(cf->dentry);\n\tkmem_cache_free(ceph_file_cachep, cf);\n\n\t/* wake up anyone waiting for caps on this inode */\n\twake_up_all(&ci->i_cap_wq);\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_atomic_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "230-315",
    "snippet": "int ceph_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t     struct file *file, unsigned flags, umode_t mode,\n\t\t     int *opened)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dir->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct dentry *dn;\n\tstruct ceph_acls_info acls = {};\n\tint err;\n\n\tdout(\"atomic_open %p dentry %p '%pd' %s flags %d mode 0%o\\n\",\n\t     dir, dentry, dentry,\n\t     d_unhashed(dentry) ? \"unhashed\" : \"hashed\", flags, mode);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (flags & O_CREAT) {\n\t\terr = ceph_pre_init_acls(dir, &mode, &acls);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* do the open */\n\treq = prepare_open_request(dir->i_sb, flags, mode);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out_acl;\n\t}\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\tif (flags & O_CREAT) {\n\t\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED;\n\t\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\t\tif (acls.pagelist) {\n\t\t\treq->r_pagelist = acls.pagelist;\n\t\t\tacls.pagelist = NULL;\n\t\t}\n\t}\n\treq->r_locked_dir = dir;           /* caller holds dir->i_mutex */\n\terr = ceph_mdsc_do_request(mdsc,\n\t\t\t\t   (flags & (O_CREAT|O_TRUNC)) ? dir : NULL,\n\t\t\t\t   req);\n\terr = ceph_handle_snapdir(req, dentry, err);\n\tif (err)\n\t\tgoto out_req;\n\n\tif (err == 0 && (flags & O_CREAT) && !req->r_reply_info.head->is_dentry)\n\t\terr = ceph_handle_notrace_create(dir, dentry);\n\n\tif (d_unhashed(dentry)) {\n\t\tdn = ceph_finish_lookup(req, dentry, err);\n\t\tif (IS_ERR(dn))\n\t\t\terr = PTR_ERR(dn);\n\t} else {\n\t\t/* we were given a hashed negative dentry */\n\t\tdn = NULL;\n\t}\n\tif (err)\n\t\tgoto out_req;\n\tif (dn || dentry->d_inode == NULL || d_is_symlink(dentry)) {\n\t\t/* make vfs retry on splice, ENOENT, or symlink */\n\t\tdout(\"atomic_open finish_no_open on dn %p\\n\", dn);\n\t\terr = finish_no_open(file, dn);\n\t} else {\n\t\tdout(\"atomic_open finish_open on dn %p\\n\", dn);\n\t\tif (req->r_op == CEPH_MDS_OP_CREATE && req->r_reply_info.has_create_ino) {\n\t\t\tceph_init_inode_acls(dentry->d_inode, &acls);\n\t\t\t*opened |= FILE_CREATED;\n\t\t}\n\t\terr = finish_open(file, dentry, ceph_open, opened);\n\t}\nout_req:\n\tif (!req->r_err && req->r_target_inode)\n\t\tceph_put_fmode(ceph_inode(req->r_target_inode), req->r_fmode);\n\tceph_mdsc_put_request(req);\nout_acl:\n\tceph_release_acls_info(&acls);\n\tdout(\"atomic_open result=%d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"atomic_open result=%d\\n\"",
            "err"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_release_acls_info",
          "args": [
            "&acls"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_release_acls_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "810-812",
          "snippet": "static inline void ceph_release_acls_info(struct ceph_acls_info *info)\n{\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_release_acls_info(struct ceph_acls_info *info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_put_fmode",
          "args": [
            "ceph_inode(req->r_target_inode)",
            "req->r_fmode"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_fmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3300-3315",
          "snippet": "void ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "req->r_target_inode"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "dentry",
            "ceph_open",
            "opened"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_init_inode_acls",
          "args": [
            "dentry->d_inode",
            "&acls"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_inode_acls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "806-809",
          "snippet": "static inline void ceph_init_inode_acls(struct inode *inode,\n\t\t\t\t\tstruct ceph_acls_info *info)\n{\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_init_inode_acls(struct inode *inode,\n\t\t\t\t\tstruct ceph_acls_info *info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"atomic_open finish_open on dn %p\\n\"",
            "dn"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "dn"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"atomic_open finish_no_open on dn %p\\n\"",
            "dn"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dn"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dn"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_finish_lookup",
          "args": [
            "req",
            "dentry",
            "err"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_finish_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "566-590",
          "snippet": "struct dentry *ceph_finish_lookup(struct ceph_mds_request *req,\n\t\t\t\t  struct dentry *dentry, int err)\n{\n\tif (err == -ENOENT) {\n\t\t/* no trace? */\n\t\terr = 0;\n\t\tif (!req->r_reply_info.head->is_dentry) {\n\t\t\tdout(\"ENOENT and no trace, dentry %p inode %p\\n\",\n\t\t\t     dentry, dentry->d_inode);\n\t\t\tif (dentry->d_inode) {\n\t\t\t\td_drop(dentry);\n\t\t\t\terr = -ENOENT;\n\t\t\t} else {\n\t\t\t\td_add(dentry, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (err)\n\t\tdentry = ERR_PTR(err);\n\telse if (dentry != req->r_dentry)\n\t\tdentry = dget(req->r_dentry);   /* we got spliced */\n\telse\n\t\tdentry = NULL;\n\treturn dentry;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct dentry *ceph_finish_lookup(struct ceph_mds_request *req,\n\t\t\t\t  struct dentry *dentry, int err)\n{\n\tif (err == -ENOENT) {\n\t\t/* no trace? */\n\t\terr = 0;\n\t\tif (!req->r_reply_info.head->is_dentry) {\n\t\t\tdout(\"ENOENT and no trace, dentry %p inode %p\\n\",\n\t\t\t     dentry, dentry->d_inode);\n\t\t\tif (dentry->d_inode) {\n\t\t\t\td_drop(dentry);\n\t\t\t\terr = -ENOENT;\n\t\t\t} else {\n\t\t\t\td_add(dentry, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (err)\n\t\tdentry = ERR_PTR(err);\n\telse if (dentry != req->r_dentry)\n\t\tdentry = dget(req->r_dentry);   /* we got spliced */\n\telse\n\t\tdentry = NULL;\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_handle_notrace_create",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_handle_notrace_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "665-686",
          "snippet": "int ceph_handle_notrace_create(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *result = ceph_lookup(dir, dentry, 0);\n\n\tif (result && !IS_ERR(result)) {\n\t\t/*\n\t\t * We created the item, then did a lookup, and found\n\t\t * it was already linked to another inode we already\n\t\t * had in our cache (and thus got spliced). To not\n\t\t * confuse VFS (especially when inode is a directory),\n\t\t * we don't link our dentry to that inode, return an\n\t\t * error instead.\n\t\t *\n\t\t * This event should be rare and it happens only when\n\t\t * we talk to old MDS. Recent MDS does not send traceless\n\t\t * reply for request that creates new inode.\n\t\t */\n\t\td_drop(result);\n\t\treturn -ESTALE;\n\t}\n\treturn PTR_ERR(result);\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_handle_notrace_create(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *result = ceph_lookup(dir, dentry, 0);\n\n\tif (result && !IS_ERR(result)) {\n\t\t/*\n\t\t * We created the item, then did a lookup, and found\n\t\t * it was already linked to another inode we already\n\t\t * had in our cache (and thus got spliced). To not\n\t\t * confuse VFS (especially when inode is a directory),\n\t\t * we don't link our dentry to that inode, return an\n\t\t * error instead.\n\t\t *\n\t\t * This event should be rare and it happens only when\n\t\t * we talk to old MDS. Recent MDS does not send traceless\n\t\t * reply for request that creates new inode.\n\t\t */\n\t\td_drop(result);\n\t\treturn -ESTALE;\n\t}\n\treturn PTR_ERR(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_handle_snapdir",
          "args": [
            "req",
            "dentry",
            "err"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_handle_snapdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "534-553",
          "snippet": "int ceph_handle_snapdir(struct ceph_mds_request *req,\n\t\t\tstruct dentry *dentry, int err)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct inode *parent = dentry->d_parent->d_inode; /* we hold i_mutex */\n\n\t/* .snap dir? */\n\tif (err == -ENOENT &&\n\t    ceph_snap(parent) == CEPH_NOSNAP &&\n\t    strcmp(dentry->d_name.name,\n\t\t   fsc->mount_options->snapdir_name) == 0) {\n\t\tstruct inode *inode = ceph_get_snapdir(parent);\n\t\tdout(\"ENOENT on snapdir %p '%pd', linking to snapdir %p\\n\",\n\t\t     dentry, dentry, inode);\n\t\tBUG_ON(!d_unhashed(dentry));\n\t\td_add(dentry, inode);\n\t\terr = 0;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_handle_snapdir(struct ceph_mds_request *req,\n\t\t\tstruct dentry *dentry, int err)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dentry->d_sb);\n\tstruct inode *parent = dentry->d_parent->d_inode; /* we hold i_mutex */\n\n\t/* .snap dir? */\n\tif (err == -ENOENT &&\n\t    ceph_snap(parent) == CEPH_NOSNAP &&\n\t    strcmp(dentry->d_name.name,\n\t\t   fsc->mount_options->snapdir_name) == 0) {\n\t\tstruct inode *inode = ceph_get_snapdir(parent);\n\t\tdout(\"ENOENT on snapdir %p '%pd', linking to snapdir %p\\n\",\n\t\t     dentry, dentry, inode);\n\t\tBUG_ON(!d_unhashed(dentry));\n\t\td_add(dentry, inode);\n\t\terr = 0;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "(flags & (O_CREAT|O_TRUNC)) ? dir : NULL",
            "req"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "706-718",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_open_request",
          "args": [
            "dir->i_sb",
            "flags",
            "mode"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_open_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "43-63",
          "snippet": "static struct ceph_mds_request *\nprepare_open_request(struct super_block *sb, int flags, int create_mode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint want_auth = USE_ANY_MDS;\n\tint op = (flags & O_CREAT) ? CEPH_MDS_OP_CREATE : CEPH_MDS_OP_OPEN;\n\n\tif (flags & (O_WRONLY|O_RDWR|O_CREAT|O_TRUNC))\n\t\twant_auth = USE_AUTH_MDS;\n\n\treq = ceph_mdsc_create_request(mdsc, op, want_auth);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\treq->r_fmode = ceph_flags_to_mode(flags);\n\treq->r_args.open.flags = cpu_to_le32(flags);\n\treq->r_args.open.mode = cpu_to_le32(create_mode);\nout:\n\treturn req;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *\nprepare_open_request(struct super_block *sb, int flags, int create_mode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint want_auth = USE_ANY_MDS;\n\tint op = (flags & O_CREAT) ? CEPH_MDS_OP_CREATE : CEPH_MDS_OP_OPEN;\n\n\tif (flags & (O_WRONLY|O_RDWR|O_CREAT|O_TRUNC))\n\t\twant_auth = USE_AUTH_MDS;\n\n\treq = ceph_mdsc_create_request(mdsc, op, want_auth);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\treq->r_fmode = ceph_flags_to_mode(flags);\n\treq->r_args.open.flags = cpu_to_le32(flags);\n\treq->r_args.open.mode = cpu_to_le32(create_mode);\nout:\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pre_init_acls",
          "args": [
            "dir",
            "&mode",
            "&acls"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_pre_init_acls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "801-805",
          "snippet": "static inline int ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t\t\t     struct ceph_acls_info *info)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t\t\t     struct ceph_acls_info *info)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_init_dentry",
          "args": [
            "dentry"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "34-69",
          "snippet": "int ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations ceph_dentry_ops;",
            "const struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};",
            "const struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};",
            "const struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst struct dentry_operations ceph_dentry_ops;\nconst struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\nconst struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};\nconst struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\n\nint ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"atomic_open %p dentry %p '%pd' %s flags %d mode 0%o\\n\"",
            "dir",
            "dentry",
            "dentry",
            "d_unhashed(dentry) ? \"unhashed\" : \"hashed\"",
            "flags",
            "mode"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "dir->i_sb"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t     struct file *file, unsigned flags, umode_t mode,\n\t\t     int *opened)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(dir->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct dentry *dn;\n\tstruct ceph_acls_info acls = {};\n\tint err;\n\n\tdout(\"atomic_open %p dentry %p '%pd' %s flags %d mode 0%o\\n\",\n\t     dir, dentry, dentry,\n\t     d_unhashed(dentry) ? \"unhashed\" : \"hashed\", flags, mode);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\terr = ceph_init_dentry(dentry);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (flags & O_CREAT) {\n\t\terr = ceph_pre_init_acls(dir, &mode, &acls);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* do the open */\n\treq = prepare_open_request(dir->i_sb, flags, mode);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out_acl;\n\t}\n\treq->r_dentry = dget(dentry);\n\treq->r_num_caps = 2;\n\tif (flags & O_CREAT) {\n\t\treq->r_dentry_drop = CEPH_CAP_FILE_SHARED;\n\t\treq->r_dentry_unless = CEPH_CAP_FILE_EXCL;\n\t\tif (acls.pagelist) {\n\t\t\treq->r_pagelist = acls.pagelist;\n\t\t\tacls.pagelist = NULL;\n\t\t}\n\t}\n\treq->r_locked_dir = dir;           /* caller holds dir->i_mutex */\n\terr = ceph_mdsc_do_request(mdsc,\n\t\t\t\t   (flags & (O_CREAT|O_TRUNC)) ? dir : NULL,\n\t\t\t\t   req);\n\terr = ceph_handle_snapdir(req, dentry, err);\n\tif (err)\n\t\tgoto out_req;\n\n\tif (err == 0 && (flags & O_CREAT) && !req->r_reply_info.head->is_dentry)\n\t\terr = ceph_handle_notrace_create(dir, dentry);\n\n\tif (d_unhashed(dentry)) {\n\t\tdn = ceph_finish_lookup(req, dentry, err);\n\t\tif (IS_ERR(dn))\n\t\t\terr = PTR_ERR(dn);\n\t} else {\n\t\t/* we were given a hashed negative dentry */\n\t\tdn = NULL;\n\t}\n\tif (err)\n\t\tgoto out_req;\n\tif (dn || dentry->d_inode == NULL || d_is_symlink(dentry)) {\n\t\t/* make vfs retry on splice, ENOENT, or symlink */\n\t\tdout(\"atomic_open finish_no_open on dn %p\\n\", dn);\n\t\terr = finish_no_open(file, dn);\n\t} else {\n\t\tdout(\"atomic_open finish_open on dn %p\\n\", dn);\n\t\tif (req->r_op == CEPH_MDS_OP_CREATE && req->r_reply_info.has_create_ino) {\n\t\t\tceph_init_inode_acls(dentry->d_inode, &acls);\n\t\t\t*opened |= FILE_CREATED;\n\t\t}\n\t\terr = finish_open(file, dentry, ceph_open, opened);\n\t}\nout_req:\n\tif (!req->r_err && req->r_target_inode)\n\t\tceph_put_fmode(ceph_inode(req->r_target_inode), req->r_fmode);\n\tceph_mdsc_put_request(req);\nout_acl:\n\tceph_release_acls_info(&acls);\n\tdout(\"atomic_open result=%d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "132-223",
    "snippet": "int ceph_open(struct inode *inode, struct file *file)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_file_info *cf = file->private_data;\n\tstruct inode *parent_inode = NULL;\n\tint err;\n\tint flags, fmode, wanted;\n\n\tif (cf) {\n\t\tdout(\"open file %p is already opened\\n\", file);\n\t\treturn 0;\n\t}\n\n\t/* filter out O_CREAT|O_EXCL; vfs did that already.  yuck. */\n\tflags = file->f_flags & ~(O_CREAT|O_EXCL);\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = O_DIRECTORY;  /* mds likes to know */\n\n\tdout(\"open inode %p ino %llx.%llx file %p flags %d (%d)\\n\", inode,\n\t     ceph_vinop(inode), file, flags, file->f_flags);\n\tfmode = ceph_flags_to_mode(flags);\n\twanted = ceph_caps_for_mode(fmode);\n\n\t/* snapped files are read-only */\n\tif (ceph_snap(inode) != CEPH_NOSNAP && (file->f_mode & FMODE_WRITE))\n\t\treturn -EROFS;\n\n\t/* trivially open snapdir */\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__ceph_get_fmode(ci, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\treturn ceph_init_file(inode, file, fmode);\n\t}\n\n\t/*\n\t * No need to block if we have caps on the auth MDS (for\n\t * write) or any MDS (for read).  Update wanted set\n\t * asynchronously.\n\t */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_is_any_real_caps(ci) &&\n\t    (((fmode & CEPH_FILE_MODE_WR) == 0) || ci->i_auth_cap)) {\n\t\tint mds_wanted = __ceph_caps_mds_wanted(ci);\n\t\tint issued = __ceph_caps_issued(ci, NULL);\n\n\t\tdout(\"open %p fmode %d want %s issued %s using existing\\n\",\n\t\t     inode, fmode, ceph_cap_string(wanted),\n\t\t     ceph_cap_string(issued));\n\t\t__ceph_get_fmode(ci, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t/* adjust wanted? */\n\t\tif ((issued & wanted) != wanted &&\n\t\t    (mds_wanted & wanted) != wanted &&\n\t\t    ceph_snap(inode) != CEPH_SNAPDIR)\n\t\t\tceph_check_caps(ci, 0, NULL);\n\n\t\treturn ceph_init_file(inode, file, fmode);\n\t} else if (ceph_snap(inode) != CEPH_NOSNAP &&\n\t\t   (ci->i_snap_caps & wanted) == wanted) {\n\t\t__ceph_get_fmode(ci, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\treturn ceph_init_file(inode, file, fmode);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"open fmode %d wants %s\\n\", fmode, ceph_cap_string(wanted));\n\treq = prepare_open_request(inode->i_sb, flags, 0);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_inode = inode;\n\tihold(inode);\n\n\treq->r_num_caps = 1;\n\tif (flags & O_CREAT)\n\t\tparent_inode = ceph_get_dentry_parent_inode(file->f_path.dentry);\n\terr = ceph_mdsc_do_request(mdsc, parent_inode, req);\n\tiput(parent_inode);\n\tif (!err)\n\t\terr = ceph_init_file(inode, file, req->r_fmode);\n\tceph_mdsc_put_request(req);\n\tdout(\"open result=%d on %llx.%llx\\n\", err, ceph_vinop(inode));\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open result=%d on %llx.%llx\\n\"",
            "err",
            "ceph_vinop(inode)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_init_file",
          "args": [
            "inode",
            "file",
            "req->r_fmode"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "69-124",
          "snippet": "static int ceph_init_file(struct inode *inode, struct file *file, int fmode)\n{\n\tstruct ceph_file_info *cf;\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\t/* First file open request creates the cookie, we want to keep\n\t\t * this cookie around for the filetime of the inode as not to\n\t\t * have to worry about fscache register / revoke / operation\n\t\t * races.\n\t\t *\n\t\t * Also, if we know the operation is going to invalidate data\n\t\t * (non readonly) just nuke the cache right away.\n\t\t */\n\t\tceph_fscache_register_inode_cookie(mdsc->fsc, ci);\n\t\tif ((fmode & CEPH_FILE_MODE_WR))\n\t\t\tceph_fscache_invalidate(inode);\n\tcase S_IFDIR:\n\t\tdout(\"init_file %p %p 0%o (regular)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tcf = kmem_cache_alloc(ceph_file_cachep, GFP_NOFS | __GFP_ZERO);\n\t\tif (cf == NULL) {\n\t\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcf->fmode = fmode;\n\t\tcf->next_offset = 2;\n\t\tfile->private_data = cf;\n\t\tBUG_ON(inode->i_fop->release != ceph_release);\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tdout(\"init_file %p %p 0%o (symlink)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tbreak;\n\n\tdefault:\n\t\tdout(\"init_file %p %p 0%o (special)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\t/*\n\t\t * we need to drop the open ref now, since we don't\n\t\t * have .release set to ceph_release.\n\t\t */\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tBUG_ON(inode->i_fop->release == ceph_release);\n\n\t\t/* call the proper open fop */\n\t\tret = inode->i_fop->open(inode, file);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_init_file(struct inode *inode, struct file *file, int fmode)\n{\n\tstruct ceph_file_info *cf;\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\t/* First file open request creates the cookie, we want to keep\n\t\t * this cookie around for the filetime of the inode as not to\n\t\t * have to worry about fscache register / revoke / operation\n\t\t * races.\n\t\t *\n\t\t * Also, if we know the operation is going to invalidate data\n\t\t * (non readonly) just nuke the cache right away.\n\t\t */\n\t\tceph_fscache_register_inode_cookie(mdsc->fsc, ci);\n\t\tif ((fmode & CEPH_FILE_MODE_WR))\n\t\t\tceph_fscache_invalidate(inode);\n\tcase S_IFDIR:\n\t\tdout(\"init_file %p %p 0%o (regular)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tcf = kmem_cache_alloc(ceph_file_cachep, GFP_NOFS | __GFP_ZERO);\n\t\tif (cf == NULL) {\n\t\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcf->fmode = fmode;\n\t\tcf->next_offset = 2;\n\t\tfile->private_data = cf;\n\t\tBUG_ON(inode->i_fop->release != ceph_release);\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tdout(\"init_file %p %p 0%o (symlink)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tbreak;\n\n\tdefault:\n\t\tdout(\"init_file %p %p 0%o (special)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\t/*\n\t\t * we need to drop the open ref now, since we don't\n\t\t * have .release set to ceph_release.\n\t\t */\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tBUG_ON(inode->i_fop->release == ceph_release);\n\n\t\t/* call the proper open fop */\n\t\tret = inode->i_fop->open(inode, file);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "parent_inode"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "parent_inode",
            "req"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_dentry_parent_inode",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_dentry_parent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "71-85",
          "snippet": "struct inode *ceph_get_dentry_parent_inode(struct dentry *dentry)\n{\n\tstruct inode *inode = NULL;\n\n\tif (!dentry)\n\t\treturn NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!IS_ROOT(dentry)) {\n\t\tinode = dentry->d_parent->d_inode;\n\t\tihold(inode);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\treturn inode;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_dentry_parent_inode(struct dentry *dentry)\n{\n\tstruct inode *inode = NULL;\n\n\tif (!dentry)\n\t\treturn NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!IS_ROOT(dentry)) {\n\t\tinode = dentry->d_parent->d_inode;\n\t\tihold(inode);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_open_request",
          "args": [
            "inode->i_sb",
            "flags",
            "0"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_open_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
          "lines": "43-63",
          "snippet": "static struct ceph_mds_request *\nprepare_open_request(struct super_block *sb, int flags, int create_mode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint want_auth = USE_ANY_MDS;\n\tint op = (flags & O_CREAT) ? CEPH_MDS_OP_CREATE : CEPH_MDS_OP_OPEN;\n\n\tif (flags & (O_WRONLY|O_RDWR|O_CREAT|O_TRUNC))\n\t\twant_auth = USE_AUTH_MDS;\n\n\treq = ceph_mdsc_create_request(mdsc, op, want_auth);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\treq->r_fmode = ceph_flags_to_mode(flags);\n\treq->r_args.open.flags = cpu_to_le32(flags);\n\treq->r_args.open.mode = cpu_to_le32(create_mode);\nout:\n\treturn req;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *\nprepare_open_request(struct super_block *sb, int flags, int create_mode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint want_auth = USE_ANY_MDS;\n\tint op = (flags & O_CREAT) ? CEPH_MDS_OP_CREATE : CEPH_MDS_OP_OPEN;\n\n\tif (flags & (O_WRONLY|O_RDWR|O_CREAT|O_TRUNC))\n\t\twant_auth = USE_AUTH_MDS;\n\n\treq = ceph_mdsc_create_request(mdsc, op, want_auth);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\treq->r_fmode = ceph_flags_to_mode(flags);\n\treq->r_args.open.flags = cpu_to_le32(flags);\n\treq->r_args.open.mode = cpu_to_le32(create_mode);\nout:\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open fmode %d wants %s\\n\"",
            "fmode",
            "ceph_cap_string(wanted)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "wanted"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_get_fmode",
          "args": [
            "ci",
            "fmode"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_get_fmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "872-875",
          "snippet": "static inline void __ceph_get_fmode(struct ceph_inode_info *ci, int mode)\n{\n\tci->i_nr_by_mode[mode]++;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void __ceph_get_fmode(struct ceph_inode_info *ci, int mode)\n{\n\tci->i_nr_by_mode[mode]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "0",
            "NULL"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open %p fmode %d want %s issued %s using existing\\n\"",
            "inode",
            "fmode",
            "ceph_cap_string(wanted)",
            "ceph_cap_string(issued)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "NULL"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_mds_wanted",
          "args": [
            "ci"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_mds_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "861-877",
          "snippet": "int __ceph_caps_mds_wanted(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint mds_wanted = 0;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif (cap == ci->i_auth_cap)\n\t\t\tmds_wanted |= cap->mds_wanted;\n\t\telse\n\t\t\tmds_wanted |= (cap->mds_wanted & ~CEPH_CAP_ANY_FILE_WR);\n\t}\n\treturn mds_wanted;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_mds_wanted(struct ceph_inode_info *ci)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint mds_wanted = 0;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif (cap == ci->i_auth_cap)\n\t\t\tmds_wanted |= cap->mds_wanted;\n\t\telse\n\t\t\tmds_wanted |= (cap->mds_wanted & ~CEPH_CAP_ANY_FILE_WR);\n\t}\n\treturn mds_wanted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_is_any_real_caps",
          "args": [
            "ci"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_is_any_real_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "521-524",
          "snippet": "static inline bool __ceph_is_any_real_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline bool __ceph_is_any_real_caps(struct ceph_inode_info *ci)\n{\n\treturn !RB_EMPTY_ROOT(&ci->i_caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_caps_for_mode",
          "args": [
            "fmode"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_flags_to_mode",
          "args": [
            "flags"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open inode %p ino %llx.%llx file %p flags %d (%d)\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "file",
            "flags",
            "file->f_flags"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"open file %p is already opened\\n\"",
            "file"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_open(struct inode *inode, struct file *file)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_file_info *cf = file->private_data;\n\tstruct inode *parent_inode = NULL;\n\tint err;\n\tint flags, fmode, wanted;\n\n\tif (cf) {\n\t\tdout(\"open file %p is already opened\\n\", file);\n\t\treturn 0;\n\t}\n\n\t/* filter out O_CREAT|O_EXCL; vfs did that already.  yuck. */\n\tflags = file->f_flags & ~(O_CREAT|O_EXCL);\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = O_DIRECTORY;  /* mds likes to know */\n\n\tdout(\"open inode %p ino %llx.%llx file %p flags %d (%d)\\n\", inode,\n\t     ceph_vinop(inode), file, flags, file->f_flags);\n\tfmode = ceph_flags_to_mode(flags);\n\twanted = ceph_caps_for_mode(fmode);\n\n\t/* snapped files are read-only */\n\tif (ceph_snap(inode) != CEPH_NOSNAP && (file->f_mode & FMODE_WRITE))\n\t\treturn -EROFS;\n\n\t/* trivially open snapdir */\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\t__ceph_get_fmode(ci, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\treturn ceph_init_file(inode, file, fmode);\n\t}\n\n\t/*\n\t * No need to block if we have caps on the auth MDS (for\n\t * write) or any MDS (for read).  Update wanted set\n\t * asynchronously.\n\t */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_is_any_real_caps(ci) &&\n\t    (((fmode & CEPH_FILE_MODE_WR) == 0) || ci->i_auth_cap)) {\n\t\tint mds_wanted = __ceph_caps_mds_wanted(ci);\n\t\tint issued = __ceph_caps_issued(ci, NULL);\n\n\t\tdout(\"open %p fmode %d want %s issued %s using existing\\n\",\n\t\t     inode, fmode, ceph_cap_string(wanted),\n\t\t     ceph_cap_string(issued));\n\t\t__ceph_get_fmode(ci, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t/* adjust wanted? */\n\t\tif ((issued & wanted) != wanted &&\n\t\t    (mds_wanted & wanted) != wanted &&\n\t\t    ceph_snap(inode) != CEPH_SNAPDIR)\n\t\t\tceph_check_caps(ci, 0, NULL);\n\n\t\treturn ceph_init_file(inode, file, fmode);\n\t} else if (ceph_snap(inode) != CEPH_NOSNAP &&\n\t\t   (ci->i_snap_caps & wanted) == wanted) {\n\t\t__ceph_get_fmode(ci, fmode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\treturn ceph_init_file(inode, file, fmode);\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"open fmode %d wants %s\\n\", fmode, ceph_cap_string(wanted));\n\treq = prepare_open_request(inode->i_sb, flags, 0);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\tgoto out;\n\t}\n\treq->r_inode = inode;\n\tihold(inode);\n\n\treq->r_num_caps = 1;\n\tif (flags & O_CREAT)\n\t\tparent_inode = ceph_get_dentry_parent_inode(file->f_path.dentry);\n\terr = ceph_mdsc_do_request(mdsc, parent_inode, req);\n\tiput(parent_inode);\n\tif (!err)\n\t\terr = ceph_init_file(inode, file, req->r_fmode);\n\tceph_mdsc_put_request(req);\n\tdout(\"open result=%d on %llx.%llx\\n\", err, ceph_vinop(inode));\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_init_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "69-124",
    "snippet": "static int ceph_init_file(struct inode *inode, struct file *file, int fmode)\n{\n\tstruct ceph_file_info *cf;\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\t/* First file open request creates the cookie, we want to keep\n\t\t * this cookie around for the filetime of the inode as not to\n\t\t * have to worry about fscache register / revoke / operation\n\t\t * races.\n\t\t *\n\t\t * Also, if we know the operation is going to invalidate data\n\t\t * (non readonly) just nuke the cache right away.\n\t\t */\n\t\tceph_fscache_register_inode_cookie(mdsc->fsc, ci);\n\t\tif ((fmode & CEPH_FILE_MODE_WR))\n\t\t\tceph_fscache_invalidate(inode);\n\tcase S_IFDIR:\n\t\tdout(\"init_file %p %p 0%o (regular)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tcf = kmem_cache_alloc(ceph_file_cachep, GFP_NOFS | __GFP_ZERO);\n\t\tif (cf == NULL) {\n\t\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcf->fmode = fmode;\n\t\tcf->next_offset = 2;\n\t\tfile->private_data = cf;\n\t\tBUG_ON(inode->i_fop->release != ceph_release);\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tdout(\"init_file %p %p 0%o (symlink)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tbreak;\n\n\tdefault:\n\t\tdout(\"init_file %p %p 0%o (special)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\t/*\n\t\t * we need to drop the open ref now, since we don't\n\t\t * have .release set to ceph_release.\n\t\t */\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tBUG_ON(inode->i_fop->release == ceph_release);\n\n\t\t/* call the proper open fop */\n\t\tret = inode->i_fop->open(inode, file);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode->i_fop->open",
          "args": [
            "inode",
            "file"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_fop->release == ceph_release"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_fmode",
          "args": [
            "ceph_inode(inode)",
            "fmode"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_fmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "3300-3315",
          "snippet": "void ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_fmode(struct ceph_inode_info *ci, int fmode)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"put_fmode %p fmode %d %d -> %d\\n\", inode, fmode,\n\t     ci->i_nr_by_mode[fmode], ci->i_nr_by_mode[fmode]-1);\n\tBUG_ON(ci->i_nr_by_mode[fmode] == 0);\n\tif (--ci->i_nr_by_mode[fmode] == 0)\n\t\tlast++;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (last && ci->i_vino.snap == CEPH_NOSNAP)\n\t\tceph_check_caps(ci, 0, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"init_file %p %p 0%o (special)\\n\"",
            "inode",
            "file",
            "inode->i_mode"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"init_file %p %p 0%o (symlink)\\n\"",
            "inode",
            "file",
            "inode->i_mode"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_fop->release != ceph_release"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ceph_file_cachep",
            "GFP_NOFS | __GFP_ZERO"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"init_file %p %p 0%o (regular)\\n\"",
            "inode",
            "file",
            "inode->i_mode"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fscache_invalidate",
          "args": [
            "inode"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "148-150",
          "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fscache_register_inode_cookie",
          "args": [
            "mdsc->fsc",
            "ci"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_register_inode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "186-212",
          "snippet": "void ceph_fscache_register_inode_cookie(struct ceph_fs_client* fsc,\n\t\t\t\t\tstruct ceph_inode_info* ci)\n{\n\tstruct inode* inode = &ci->vfs_inode;\n\n\t/* No caching for filesystem */\n\tif (fsc->fscache == NULL)\n\t\treturn;\n\n\t/* Only cache for regular files that are read only */\n\tif ((ci->vfs_inode.i_mode & S_IFREG) == 0)\n\t\treturn;\n\n\t/* Avoid multiple racing open requests */\n\tmutex_lock(&inode->i_mutex);\n\n\tif (ci->fscache)\n\t\tgoto done;\n\n\tci->fscache = fscache_acquire_cookie(fsc->fscache,\n\t\t\t\t\t     &ceph_fscache_inode_object_def,\n\t\t\t\t\t     ci, true);\n\tfscache_check_consistency(ci->fscache);\ndone:\n\tmutex_unlock(&inode->i_mutex);\n\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_cookie_def ceph_fscache_inode_object_def = {\n\t.name\t\t= \"CEPH.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= ceph_fscache_inode_get_key,\n\t.get_attr\t= ceph_fscache_inode_get_attr,\n\t.get_aux\t= ceph_fscache_inode_get_aux,\n\t.check_aux\t= ceph_fscache_inode_check_aux,\n\t.now_uncached\t= ceph_fscache_inode_now_uncached,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nstatic const struct fscache_cookie_def ceph_fscache_inode_object_def = {\n\t.name\t\t= \"CEPH.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= ceph_fscache_inode_get_key,\n\t.get_attr\t= ceph_fscache_inode_get_attr,\n\t.get_aux\t= ceph_fscache_inode_get_aux,\n\t.check_aux\t= ceph_fscache_inode_check_aux,\n\t.now_uncached\t= ceph_fscache_inode_now_uncached,\n};\n\nvoid ceph_fscache_register_inode_cookie(struct ceph_fs_client* fsc,\n\t\t\t\t\tstruct ceph_inode_info* ci)\n{\n\tstruct inode* inode = &ci->vfs_inode;\n\n\t/* No caching for filesystem */\n\tif (fsc->fscache == NULL)\n\t\treturn;\n\n\t/* Only cache for regular files that are read only */\n\tif ((ci->vfs_inode.i_mode & S_IFREG) == 0)\n\t\treturn;\n\n\t/* Avoid multiple racing open requests */\n\tmutex_lock(&inode->i_mutex);\n\n\tif (ci->fscache)\n\t\tgoto done;\n\n\tci->fscache = fscache_acquire_cookie(fsc->fscache,\n\t\t\t\t\t     &ceph_fscache_inode_object_def,\n\t\t\t\t\t     ci, true);\n\tfscache_check_consistency(ci->fscache);\ndone:\n\tmutex_unlock(&inode->i_mutex);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_init_file(struct inode *inode, struct file *file, int fmode)\n{\n\tstruct ceph_file_info *cf;\n\tint ret = 0;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\t/* First file open request creates the cookie, we want to keep\n\t\t * this cookie around for the filetime of the inode as not to\n\t\t * have to worry about fscache register / revoke / operation\n\t\t * races.\n\t\t *\n\t\t * Also, if we know the operation is going to invalidate data\n\t\t * (non readonly) just nuke the cache right away.\n\t\t */\n\t\tceph_fscache_register_inode_cookie(mdsc->fsc, ci);\n\t\tif ((fmode & CEPH_FILE_MODE_WR))\n\t\t\tceph_fscache_invalidate(inode);\n\tcase S_IFDIR:\n\t\tdout(\"init_file %p %p 0%o (regular)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tcf = kmem_cache_alloc(ceph_file_cachep, GFP_NOFS | __GFP_ZERO);\n\t\tif (cf == NULL) {\n\t\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcf->fmode = fmode;\n\t\tcf->next_offset = 2;\n\t\tfile->private_data = cf;\n\t\tBUG_ON(inode->i_fop->release != ceph_release);\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tdout(\"init_file %p %p 0%o (symlink)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tbreak;\n\n\tdefault:\n\t\tdout(\"init_file %p %p 0%o (special)\\n\", inode, file,\n\t\t     inode->i_mode);\n\t\t/*\n\t\t * we need to drop the open ref now, since we don't\n\t\t * have .release set to ceph_release.\n\t\t */\n\t\tceph_put_fmode(ceph_inode(inode), fmode); /* clean up */\n\t\tBUG_ON(inode->i_fop->release == ceph_release);\n\n\t\t/* call the proper open fop */\n\t\tret = inode->i_fop->open(inode, file);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "prepare_open_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/file.c",
    "lines": "43-63",
    "snippet": "static struct ceph_mds_request *\nprepare_open_request(struct super_block *sb, int flags, int create_mode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint want_auth = USE_ANY_MDS;\n\tint op = (flags & O_CREAT) ? CEPH_MDS_OP_CREATE : CEPH_MDS_OP_OPEN;\n\n\tif (flags & (O_WRONLY|O_RDWR|O_CREAT|O_TRUNC))\n\t\twant_auth = USE_AUTH_MDS;\n\n\treq = ceph_mdsc_create_request(mdsc, op, want_auth);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\treq->r_fmode = ceph_flags_to_mode(flags);\n\treq->r_args.open.flags = cpu_to_le32(flags);\n\treq->r_args.open.mode = cpu_to_le32(create_mode);\nout:\n\treturn req;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/falloc.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "create_mode"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_flags_to_mode",
          "args": [
            "flags"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "op",
            "want_auth"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_mds_request *\nprepare_open_request(struct super_block *sb, int flags, int create_mode)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint want_auth = USE_ANY_MDS;\n\tint op = (flags & O_CREAT) ? CEPH_MDS_OP_CREATE : CEPH_MDS_OP_OPEN;\n\n\tif (flags & (O_WRONLY|O_RDWR|O_CREAT|O_TRUNC))\n\t\twant_auth = USE_AUTH_MDS;\n\n\treq = ceph_mdsc_create_request(mdsc, op, want_auth);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\treq->r_fmode = ceph_flags_to_mode(flags);\n\treq->r_args.open.flags = cpu_to_le32(flags);\n\treq->r_args.open.mode = cpu_to_le32(create_mode);\nout:\n\treturn req;\n}"
  }
]