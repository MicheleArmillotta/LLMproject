[
  {
    "function_name": "nfs_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2446-2509",
    "snippet": "int nfs_permission(struct inode *inode, int mask)\n{\n\tstruct rpc_cred *cred;\n\tint res = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSACCESS);\n\n\tif ((mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)\n\t\tgoto out;\n\t/* Is this sys_access() ? */\n\tif (mask & (MAY_ACCESS | MAY_CHDIR))\n\t\tgoto force_lookup;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFLNK:\n\t\t\tgoto out;\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\t/*\n\t\t\t * Optimize away all write operations, since the server\n\t\t\t * will check permissions when we perform the op.\n\t\t\t */\n\t\t\tif ((mask & MAY_WRITE) && !(mask & MAY_READ))\n\t\t\t\tgoto out;\n\t}\n\nforce_lookup:\n\tif (!NFS_PROTO(inode)->access)\n\t\tgoto out_notsup;\n\n\t/* Always try fast lookups first */\n\trcu_read_lock();\n\tcred = rpc_lookup_cred_nonblock();\n\tif (!IS_ERR(cred))\n\t\tres = nfs_do_access(inode, cred, mask|MAY_NOT_BLOCK);\n\telse\n\t\tres = PTR_ERR(cred);\n\trcu_read_unlock();\n\tif (res == -ECHILD && !(mask & MAY_NOT_BLOCK)) {\n\t\t/* Fast lookup failed, try the slow way */\n\t\tcred = rpc_lookup_cred();\n\t\tif (!IS_ERR(cred)) {\n\t\t\tres = nfs_do_access(inode, cred, mask);\n\t\t\tput_rpccred(cred);\n\t\t} else\n\t\t\tres = PTR_ERR(cred);\n\t}\nout:\n\tif (!res && (mask & MAY_EXEC) && !execute_ok(inode))\n\t\tres = -EACCES;\n\n\tdfprintk(VFS, \"NFS: permission(%s/%lu), mask=0x%x, res=%d\\n\",\n\t\tinode->i_sb->s_id, inode->i_ino, mask, res);\n\treturn res;\nout_notsup:\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tres = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tif (res == 0)\n\t\tres = generic_permission(inode, mask);\n\tgoto out;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_inode",
          "args": [
            "NFS_SERVER(inode)",
            "inode"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_inode_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1022-1029",
          "snippet": "int nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: permission(%s/%lu), mask=0x%x, res=%d\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "mask",
            "res"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute_ok",
          "args": [
            "inode"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cred"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_do_access",
          "args": [
            "inode",
            "cred",
            "mask"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2384-2421",
          "snippet": "static int nfs_do_access(struct inode *inode, struct rpc_cred *cred, int mask)\n{\n\tstruct nfs_access_entry cache;\n\tint status;\n\n\ttrace_nfs_access_enter(inode);\n\n\tstatus = nfs_access_get_cached_rcu(inode, cred, &cache);\n\tif (status != 0)\n\t\tstatus = nfs_access_get_cached(inode, cred, &cache);\n\tif (status == 0)\n\t\tgoto out_cached;\n\n\tstatus = -ECHILD;\n\tif (mask & MAY_NOT_BLOCK)\n\t\tgoto out;\n\n\t/* Be clever: ask server to check for all possible rights */\n\tcache.mask = MAY_EXEC | MAY_WRITE | MAY_READ;\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tstatus = NFS_PROTO(inode)->access(inode, &cache);\n\tif (status != 0) {\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\tnfs_access_add_cache(inode, &cache);\nout_cached:\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) != 0)\n\t\tstatus = -EACCES;\nout:\n\ttrace_nfs_access_exit(inode, status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_do_access(struct inode *inode, struct rpc_cred *cred, int mask)\n{\n\tstruct nfs_access_entry cache;\n\tint status;\n\n\ttrace_nfs_access_enter(inode);\n\n\tstatus = nfs_access_get_cached_rcu(inode, cred, &cache);\n\tif (status != 0)\n\t\tstatus = nfs_access_get_cached(inode, cred, &cache);\n\tif (status == 0)\n\t\tgoto out_cached;\n\n\tstatus = -ECHILD;\n\tif (mask & MAY_NOT_BLOCK)\n\t\tgoto out;\n\n\t/* Be clever: ask server to check for all possible rights */\n\tcache.mask = MAY_EXEC | MAY_WRITE | MAY_READ;\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tstatus = NFS_PROTO(inode)->access(inode, &cache);\n\tif (status != 0) {\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\tnfs_access_add_cache(inode, &cache);\nout_cached:\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) != 0)\n\t\tstatus = -EACCES;\nout:\n\ttrace_nfs_access_exit(inode, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cred"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_lookup_cred",
          "args": [],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cred"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cred"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_lookup_cred_nonblock",
          "args": [],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSACCESS"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_permission(struct inode *inode, int mask)\n{\n\tstruct rpc_cred *cred;\n\tint res = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSACCESS);\n\n\tif ((mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)\n\t\tgoto out;\n\t/* Is this sys_access() ? */\n\tif (mask & (MAY_ACCESS | MAY_CHDIR))\n\t\tgoto force_lookup;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFLNK:\n\t\t\tgoto out;\n\t\tcase S_IFREG:\n\t\t\tbreak;\n\t\tcase S_IFDIR:\n\t\t\t/*\n\t\t\t * Optimize away all write operations, since the server\n\t\t\t * will check permissions when we perform the op.\n\t\t\t */\n\t\t\tif ((mask & MAY_WRITE) && !(mask & MAY_READ))\n\t\t\t\tgoto out;\n\t}\n\nforce_lookup:\n\tif (!NFS_PROTO(inode)->access)\n\t\tgoto out_notsup;\n\n\t/* Always try fast lookups first */\n\trcu_read_lock();\n\tcred = rpc_lookup_cred_nonblock();\n\tif (!IS_ERR(cred))\n\t\tres = nfs_do_access(inode, cred, mask|MAY_NOT_BLOCK);\n\telse\n\t\tres = PTR_ERR(cred);\n\trcu_read_unlock();\n\tif (res == -ECHILD && !(mask & MAY_NOT_BLOCK)) {\n\t\t/* Fast lookup failed, try the slow way */\n\t\tcred = rpc_lookup_cred();\n\t\tif (!IS_ERR(cred)) {\n\t\t\tres = nfs_do_access(inode, cred, mask);\n\t\t\tput_rpccred(cred);\n\t\t} else\n\t\t\tres = PTR_ERR(cred);\n\t}\nout:\n\tif (!res && (mask & MAY_EXEC) && !execute_ok(inode))\n\t\tres = -EACCES;\n\n\tdfprintk(VFS, \"NFS: permission(%s/%lu), mask=0x%x, res=%d\\n\",\n\t\tinode->i_sb->s_id, inode->i_ino, mask, res);\n\treturn res;\nout_notsup:\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tres = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tif (res == 0)\n\t\tres = generic_permission(inode, mask);\n\tgoto out;\n}"
  },
  {
    "function_name": "nfs_may_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2440-2443",
    "snippet": "int nfs_may_open(struct inode *inode, struct rpc_cred *cred, int openflags)\n{\n\treturn nfs_do_access(inode, cred, nfs_open_permission_mask(openflags));\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_do_access",
          "args": [
            "inode",
            "cred",
            "nfs_open_permission_mask(openflags)"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2384-2421",
          "snippet": "static int nfs_do_access(struct inode *inode, struct rpc_cred *cred, int mask)\n{\n\tstruct nfs_access_entry cache;\n\tint status;\n\n\ttrace_nfs_access_enter(inode);\n\n\tstatus = nfs_access_get_cached_rcu(inode, cred, &cache);\n\tif (status != 0)\n\t\tstatus = nfs_access_get_cached(inode, cred, &cache);\n\tif (status == 0)\n\t\tgoto out_cached;\n\n\tstatus = -ECHILD;\n\tif (mask & MAY_NOT_BLOCK)\n\t\tgoto out;\n\n\t/* Be clever: ask server to check for all possible rights */\n\tcache.mask = MAY_EXEC | MAY_WRITE | MAY_READ;\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tstatus = NFS_PROTO(inode)->access(inode, &cache);\n\tif (status != 0) {\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\tnfs_access_add_cache(inode, &cache);\nout_cached:\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) != 0)\n\t\tstatus = -EACCES;\nout:\n\ttrace_nfs_access_exit(inode, status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_do_access(struct inode *inode, struct rpc_cred *cred, int mask)\n{\n\tstruct nfs_access_entry cache;\n\tint status;\n\n\ttrace_nfs_access_enter(inode);\n\n\tstatus = nfs_access_get_cached_rcu(inode, cred, &cache);\n\tif (status != 0)\n\t\tstatus = nfs_access_get_cached(inode, cred, &cache);\n\tif (status == 0)\n\t\tgoto out_cached;\n\n\tstatus = -ECHILD;\n\tif (mask & MAY_NOT_BLOCK)\n\t\tgoto out;\n\n\t/* Be clever: ask server to check for all possible rights */\n\tcache.mask = MAY_EXEC | MAY_WRITE | MAY_READ;\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tstatus = NFS_PROTO(inode)->access(inode, &cache);\n\tif (status != 0) {\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\tnfs_access_add_cache(inode, &cache);\nout_cached:\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) != 0)\n\t\tstatus = -EACCES;\nout:\n\ttrace_nfs_access_exit(inode, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_open_permission_mask",
          "args": [
            "openflags"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_open_permission_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2423-2438",
          "snippet": "static int nfs_open_permission_mask(int openflags)\n{\n\tint mask = 0;\n\n\tif (openflags & __FMODE_EXEC) {\n\t\t/* ONLY check exec rights */\n\t\tmask = MAY_EXEC;\n\t} else {\n\t\tif ((openflags & O_ACCMODE) != O_WRONLY)\n\t\t\tmask |= MAY_READ;\n\t\tif ((openflags & O_ACCMODE) != O_RDONLY)\n\t\t\tmask |= MAY_WRITE;\n\t}\n\n\treturn mask;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_open_permission_mask(int openflags)\n{\n\tint mask = 0;\n\n\tif (openflags & __FMODE_EXEC) {\n\t\t/* ONLY check exec rights */\n\t\tmask = MAY_EXEC;\n\t} else {\n\t\tif ((openflags & O_ACCMODE) != O_WRONLY)\n\t\t\tmask |= MAY_READ;\n\t\tif ((openflags & O_ACCMODE) != O_RDONLY)\n\t\t\tmask |= MAY_WRITE;\n\t}\n\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_may_open(struct inode *inode, struct rpc_cred *cred, int openflags)\n{\n\treturn nfs_do_access(inode, cred, nfs_open_permission_mask(openflags));\n}"
  },
  {
    "function_name": "nfs_open_permission_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2423-2438",
    "snippet": "static int nfs_open_permission_mask(int openflags)\n{\n\tint mask = 0;\n\n\tif (openflags & __FMODE_EXEC) {\n\t\t/* ONLY check exec rights */\n\t\tmask = MAY_EXEC;\n\t} else {\n\t\tif ((openflags & O_ACCMODE) != O_WRONLY)\n\t\t\tmask |= MAY_READ;\n\t\tif ((openflags & O_ACCMODE) != O_RDONLY)\n\t\t\tmask |= MAY_WRITE;\n\t}\n\n\treturn mask;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_open_permission_mask(int openflags)\n{\n\tint mask = 0;\n\n\tif (openflags & __FMODE_EXEC) {\n\t\t/* ONLY check exec rights */\n\t\tmask = MAY_EXEC;\n\t} else {\n\t\tif ((openflags & O_ACCMODE) != O_WRONLY)\n\t\t\tmask |= MAY_READ;\n\t\tif ((openflags & O_ACCMODE) != O_RDONLY)\n\t\t\tmask |= MAY_WRITE;\n\t}\n\n\treturn mask;\n}"
  },
  {
    "function_name": "nfs_do_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2384-2421",
    "snippet": "static int nfs_do_access(struct inode *inode, struct rpc_cred *cred, int mask)\n{\n\tstruct nfs_access_entry cache;\n\tint status;\n\n\ttrace_nfs_access_enter(inode);\n\n\tstatus = nfs_access_get_cached_rcu(inode, cred, &cache);\n\tif (status != 0)\n\t\tstatus = nfs_access_get_cached(inode, cred, &cache);\n\tif (status == 0)\n\t\tgoto out_cached;\n\n\tstatus = -ECHILD;\n\tif (mask & MAY_NOT_BLOCK)\n\t\tgoto out;\n\n\t/* Be clever: ask server to check for all possible rights */\n\tcache.mask = MAY_EXEC | MAY_WRITE | MAY_READ;\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tstatus = NFS_PROTO(inode)->access(inode, &cache);\n\tif (status != 0) {\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\tnfs_access_add_cache(inode, &cache);\nout_cached:\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) != 0)\n\t\tstatus = -EACCES;\nout:\n\ttrace_nfs_access_exit(inode, status);\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_access_exit",
          "args": [
            "inode",
            "status"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_access_add_cache",
          "args": [
            "inode",
            "&cache"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_add_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2337-2368",
          "snippet": "void nfs_access_add_cache(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_access_entry *cache = kmalloc(sizeof(*cache), GFP_KERNEL);\n\tif (cache == NULL)\n\t\treturn;\n\tRB_CLEAR_NODE(&cache->rb_node);\n\tcache->jiffies = set->jiffies;\n\tcache->cred = get_rpccred(set->cred);\n\tcache->mask = set->mask;\n\n\t/* The above field assignments must be visible\n\t * before this item appears on the lru.  We cannot easily\n\t * use rcu_assign_pointer, so just force the memory barrier.\n\t */\n\tsmp_wmb();\n\tnfs_access_add_rbtree(inode, cache);\n\n\t/* Update accounting */\n\tsmp_mb__before_atomic();\n\tatomic_long_inc(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n\n\t/* Add inode to global LRU list */\n\tif (!test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags)) {\n\t\tspin_lock(&nfs_access_lru_lock);\n\t\tif (!test_and_set_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\t\tlist_add_tail(&NFS_I(inode)->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\tspin_unlock(&nfs_access_lru_lock);\n\t}\n\tnfs_access_cache_enforce_limit();\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs_access_lru_lock);",
            "static LIST_HEAD(nfs_access_lru_list);",
            "static atomic_long_t nfs_access_nr_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\nstatic LIST_HEAD(nfs_access_lru_list);\nstatic atomic_long_t nfs_access_nr_entries;\n\nvoid nfs_access_add_cache(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_access_entry *cache = kmalloc(sizeof(*cache), GFP_KERNEL);\n\tif (cache == NULL)\n\t\treturn;\n\tRB_CLEAR_NODE(&cache->rb_node);\n\tcache->jiffies = set->jiffies;\n\tcache->cred = get_rpccred(set->cred);\n\tcache->mask = set->mask;\n\n\t/* The above field assignments must be visible\n\t * before this item appears on the lru.  We cannot easily\n\t * use rcu_assign_pointer, so just force the memory barrier.\n\t */\n\tsmp_wmb();\n\tnfs_access_add_rbtree(inode, cache);\n\n\t/* Update accounting */\n\tsmp_mb__before_atomic();\n\tatomic_long_inc(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n\n\t/* Add inode to global LRU list */\n\tif (!test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags)) {\n\t\tspin_lock(&nfs_access_lru_lock);\n\t\tif (!test_and_set_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\t\tlist_add_tail(&NFS_I(inode)->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\tspin_unlock(&nfs_access_lru_lock);\n\t}\n\tnfs_access_cache_enforce_limit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_INO_STALE",
            "&NFS_I(inode)->flags"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_zap_caches",
          "args": [
            "inode"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "189-194",
          "snippet": "void nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "&cache"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_access_get_cached",
          "args": [
            "inode",
            "cred",
            "&cache"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_get_cached_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2272-2302",
          "snippet": "static int nfs_access_get_cached_rcu(struct inode *inode, struct rpc_cred *cred, struct nfs_access_entry *res)\n{\n\t/* Only check the most recently returned cache entry,\n\t * but do it without locking.\n\t */\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_access_entry *cache;\n\tint err = -ECHILD;\n\tstruct list_head *lh;\n\n\trcu_read_lock();\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tgoto out;\n\tlh = rcu_dereference(nfsi->access_cache_entry_lru.prev);\n\tcache = list_entry(lh, struct nfs_access_entry, lru);\n\tif (lh == &nfsi->access_cache_entry_lru ||\n\t    cred != cache->cred)\n\t\tcache = NULL;\n\tif (cache == NULL)\n\t\tgoto out;\n\tif (!nfs_have_delegated_attributes(inode) &&\n\t    !time_in_range_open(jiffies, cache->jiffies, cache->jiffies + nfsi->attrtimeo))\n\t\tgoto out;\n\tres->jiffies = cache->jiffies;\n\tres->cred = cache->cred;\n\tres->mask = cache->mask;\n\terr = 0;\nout:\n\trcu_read_unlock();\n\treturn err;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_access_get_cached_rcu(struct inode *inode, struct rpc_cred *cred, struct nfs_access_entry *res)\n{\n\t/* Only check the most recently returned cache entry,\n\t * but do it without locking.\n\t */\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_access_entry *cache;\n\tint err = -ECHILD;\n\tstruct list_head *lh;\n\n\trcu_read_lock();\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tgoto out;\n\tlh = rcu_dereference(nfsi->access_cache_entry_lru.prev);\n\tcache = list_entry(lh, struct nfs_access_entry, lru);\n\tif (lh == &nfsi->access_cache_entry_lru ||\n\t    cred != cache->cred)\n\t\tcache = NULL;\n\tif (cache == NULL)\n\t\tgoto out;\n\tif (!nfs_have_delegated_attributes(inode) &&\n\t    !time_in_range_open(jiffies, cache->jiffies, cache->jiffies + nfsi->attrtimeo))\n\t\tgoto out;\n\tres->jiffies = cache->jiffies;\n\tres->cred = cache->cred;\n\tres->mask = cache->mask;\n\terr = 0;\nout:\n\trcu_read_unlock();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_access_enter",
          "args": [
            "inode"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_do_access(struct inode *inode, struct rpc_cred *cred, int mask)\n{\n\tstruct nfs_access_entry cache;\n\tint status;\n\n\ttrace_nfs_access_enter(inode);\n\n\tstatus = nfs_access_get_cached_rcu(inode, cred, &cache);\n\tif (status != 0)\n\t\tstatus = nfs_access_get_cached(inode, cred, &cache);\n\tif (status == 0)\n\t\tgoto out_cached;\n\n\tstatus = -ECHILD;\n\tif (mask & MAY_NOT_BLOCK)\n\t\tgoto out;\n\n\t/* Be clever: ask server to check for all possible rights */\n\tcache.mask = MAY_EXEC | MAY_WRITE | MAY_READ;\n\tcache.cred = cred;\n\tcache.jiffies = jiffies;\n\tstatus = NFS_PROTO(inode)->access(inode, &cache);\n\tif (status != 0) {\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto out;\n\t}\n\tnfs_access_add_cache(inode, &cache);\nout_cached:\n\tif ((mask & ~cache.mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) != 0)\n\t\tstatus = -EACCES;\nout:\n\ttrace_nfs_access_exit(inode, status);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_access_set_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2371-2381",
    "snippet": "void nfs_access_set_mask(struct nfs_access_entry *entry, u32 access_result)\n{\n\tentry->mask = 0;\n\tif (access_result & NFS4_ACCESS_READ)\n\t\tentry->mask |= MAY_READ;\n\tif (access_result &\n\t    (NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE))\n\t\tentry->mask |= MAY_WRITE;\n\tif (access_result & (NFS4_ACCESS_LOOKUP|NFS4_ACCESS_EXECUTE))\n\t\tentry->mask |= MAY_EXEC;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid nfs_access_set_mask(struct nfs_access_entry *entry, u32 access_result)\n{\n\tentry->mask = 0;\n\tif (access_result & NFS4_ACCESS_READ)\n\t\tentry->mask |= MAY_READ;\n\tif (access_result &\n\t    (NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE))\n\t\tentry->mask |= MAY_WRITE;\n\tif (access_result & (NFS4_ACCESS_LOOKUP|NFS4_ACCESS_EXECUTE))\n\t\tentry->mask |= MAY_EXEC;\n}"
  },
  {
    "function_name": "nfs_access_add_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2337-2368",
    "snippet": "void nfs_access_add_cache(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_access_entry *cache = kmalloc(sizeof(*cache), GFP_KERNEL);\n\tif (cache == NULL)\n\t\treturn;\n\tRB_CLEAR_NODE(&cache->rb_node);\n\tcache->jiffies = set->jiffies;\n\tcache->cred = get_rpccred(set->cred);\n\tcache->mask = set->mask;\n\n\t/* The above field assignments must be visible\n\t * before this item appears on the lru.  We cannot easily\n\t * use rcu_assign_pointer, so just force the memory barrier.\n\t */\n\tsmp_wmb();\n\tnfs_access_add_rbtree(inode, cache);\n\n\t/* Update accounting */\n\tsmp_mb__before_atomic();\n\tatomic_long_inc(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n\n\t/* Add inode to global LRU list */\n\tif (!test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags)) {\n\t\tspin_lock(&nfs_access_lru_lock);\n\t\tif (!test_and_set_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\t\tlist_add_tail(&NFS_I(inode)->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\tspin_unlock(&nfs_access_lru_lock);\n\t}\n\tnfs_access_cache_enforce_limit();\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(nfs_access_lru_lock);",
      "static LIST_HEAD(nfs_access_lru_list);",
      "static atomic_long_t nfs_access_nr_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_access_cache_enforce_limit",
          "args": [],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_cache_enforce_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2169-2183",
          "snippet": "static void\nnfs_access_cache_enforce_limit(void)\n{\n\tlong nr_entries = atomic_long_read(&nfs_access_nr_entries);\n\tunsigned long diff;\n\tunsigned int nr_to_scan;\n\n\tif (nr_entries < 0 || nr_entries <= nfs_access_max_cachesize)\n\t\treturn;\n\tnr_to_scan = 100;\n\tdiff = nr_entries - nfs_access_max_cachesize;\n\tif (diff < nr_to_scan)\n\t\tnr_to_scan = diff;\n\tnfs_do_access_cache_scan(nr_to_scan);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_long_t nfs_access_nr_entries;",
            "static unsigned long nfs_access_max_cachesize = ULONG_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_access_nr_entries;\nstatic unsigned long nfs_access_max_cachesize = ULONG_MAX;\n\nstatic void\nnfs_access_cache_enforce_limit(void)\n{\n\tlong nr_entries = atomic_long_read(&nfs_access_nr_entries);\n\tunsigned long diff;\n\tunsigned int nr_to_scan;\n\n\tif (nr_entries < 0 || nr_entries <= nfs_access_max_cachesize)\n\t\treturn;\n\tnr_to_scan = 100;\n\tdiff = nr_entries - nfs_access_max_cachesize;\n\tif (diff < nr_to_scan)\n\t\tnr_to_scan = diff;\n\tnfs_do_access_cache_scan(nr_to_scan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs_access_lru_lock"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&NFS_I(inode)->access_cache_inode_lru",
            "&nfs_access_lru_list"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_INO_ACL_LRU_SET",
            "&NFS_I(inode)->flags"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfs_access_lru_lock"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_INO_ACL_LRU_SET",
            "&NFS_I(inode)->flags"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&nfs_access_nr_entries"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_access_add_rbtree",
          "args": [
            "inode",
            "cache"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_add_rbtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2304-2335",
          "snippet": "static void nfs_access_add_rbtree(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node **p = &root_node->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct nfs_access_entry *entry;\n\n\tspin_lock(&inode->i_lock);\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct nfs_access_entry, rb_node);\n\n\t\tif (set->cred < entry->cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (set->cred > entry->cred)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\trb_link_node(&set->rb_node, parent, p);\n\trb_insert_color(&set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tspin_unlock(&inode->i_lock);\n\treturn;\nfound:\n\trb_replace_node(parent, &set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tlist_del(&entry->lru);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_free_entry(entry);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_access_add_rbtree(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node **p = &root_node->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct nfs_access_entry *entry;\n\n\tspin_lock(&inode->i_lock);\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct nfs_access_entry, rb_node);\n\n\t\tif (set->cred < entry->cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (set->cred > entry->cred)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\trb_link_node(&set->rb_node, parent, p);\n\trb_insert_color(&set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tspin_unlock(&inode->i_lock);\n\treturn;\nfound:\n\trb_replace_node(parent, &set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tlist_del(&entry->lru);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_free_entry(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "set->cred"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&cache->rb_node"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*cache)",
            "GFP_KERNEL"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\nstatic LIST_HEAD(nfs_access_lru_list);\nstatic atomic_long_t nfs_access_nr_entries;\n\nvoid nfs_access_add_cache(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_access_entry *cache = kmalloc(sizeof(*cache), GFP_KERNEL);\n\tif (cache == NULL)\n\t\treturn;\n\tRB_CLEAR_NODE(&cache->rb_node);\n\tcache->jiffies = set->jiffies;\n\tcache->cred = get_rpccred(set->cred);\n\tcache->mask = set->mask;\n\n\t/* The above field assignments must be visible\n\t * before this item appears on the lru.  We cannot easily\n\t * use rcu_assign_pointer, so just force the memory barrier.\n\t */\n\tsmp_wmb();\n\tnfs_access_add_rbtree(inode, cache);\n\n\t/* Update accounting */\n\tsmp_mb__before_atomic();\n\tatomic_long_inc(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n\n\t/* Add inode to global LRU list */\n\tif (!test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags)) {\n\t\tspin_lock(&nfs_access_lru_lock);\n\t\tif (!test_and_set_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\t\tlist_add_tail(&NFS_I(inode)->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\tspin_unlock(&nfs_access_lru_lock);\n\t}\n\tnfs_access_cache_enforce_limit();\n}"
  },
  {
    "function_name": "nfs_access_add_rbtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2304-2335",
    "snippet": "static void nfs_access_add_rbtree(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node **p = &root_node->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct nfs_access_entry *entry;\n\n\tspin_lock(&inode->i_lock);\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct nfs_access_entry, rb_node);\n\n\t\tif (set->cred < entry->cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (set->cred > entry->cred)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\trb_link_node(&set->rb_node, parent, p);\n\trb_insert_color(&set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tspin_unlock(&inode->i_lock);\n\treturn;\nfound:\n\trb_replace_node(parent, &set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tlist_del(&entry->lru);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_free_entry(entry);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_access_free_entry",
          "args": [
            "entry"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2091-2098",
          "snippet": "static void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_long_t nfs_access_nr_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_access_nr_entries;\n\nstatic void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->lru"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&set->lru",
            "&nfsi->access_cache_entry_lru"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_replace_node",
          "args": [
            "parent",
            "&set->rb_node",
            "root_node"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&set->lru",
            "&nfsi->access_cache_entry_lru"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&set->rb_node",
            "root_node"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&set->rb_node",
            "parent",
            "p"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structnfs_access_entry",
            "rb_node"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_access_add_rbtree(struct inode *inode, struct nfs_access_entry *set)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node **p = &root_node->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct nfs_access_entry *entry;\n\n\tspin_lock(&inode->i_lock);\n\twhile (*p != NULL) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct nfs_access_entry, rb_node);\n\n\t\tif (set->cred < entry->cred)\n\t\t\tp = &parent->rb_left;\n\t\telse if (set->cred > entry->cred)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\trb_link_node(&set->rb_node, parent, p);\n\trb_insert_color(&set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tspin_unlock(&inode->i_lock);\n\treturn;\nfound:\n\trb_replace_node(parent, &set->rb_node, root_node);\n\tlist_add_tail(&set->lru, &nfsi->access_cache_entry_lru);\n\tlist_del(&entry->lru);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_free_entry(entry);\n}"
  },
  {
    "function_name": "nfs_access_get_cached_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2272-2302",
    "snippet": "static int nfs_access_get_cached_rcu(struct inode *inode, struct rpc_cred *cred, struct nfs_access_entry *res)\n{\n\t/* Only check the most recently returned cache entry,\n\t * but do it without locking.\n\t */\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_access_entry *cache;\n\tint err = -ECHILD;\n\tstruct list_head *lh;\n\n\trcu_read_lock();\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tgoto out;\n\tlh = rcu_dereference(nfsi->access_cache_entry_lru.prev);\n\tcache = list_entry(lh, struct nfs_access_entry, lru);\n\tif (lh == &nfsi->access_cache_entry_lru ||\n\t    cred != cache->cred)\n\t\tcache = NULL;\n\tif (cache == NULL)\n\t\tgoto out;\n\tif (!nfs_have_delegated_attributes(inode) &&\n\t    !time_in_range_open(jiffies, cache->jiffies, cache->jiffies + nfsi->attrtimeo))\n\t\tgoto out;\n\tres->jiffies = cache->jiffies;\n\tres->cred = cache->cred;\n\tres->mask = cache->mask;\n\terr = 0;\nout:\n\trcu_read_unlock();\n\treturn err;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_in_range_open",
          "args": [
            "jiffies",
            "cache->jiffies",
            "cache->jiffies + nfsi->attrtimeo"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_have_delegated_attributes",
          "args": [
            "inode"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_have_delegated_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.h",
          "lines": "67-71",
          "snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "lh",
            "structnfs_access_entry",
            "lru"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "nfsi->access_cache_entry_lru.prev"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_access_get_cached_rcu(struct inode *inode, struct rpc_cred *cred, struct nfs_access_entry *res)\n{\n\t/* Only check the most recently returned cache entry,\n\t * but do it without locking.\n\t */\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_access_entry *cache;\n\tint err = -ECHILD;\n\tstruct list_head *lh;\n\n\trcu_read_lock();\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tgoto out;\n\tlh = rcu_dereference(nfsi->access_cache_entry_lru.prev);\n\tcache = list_entry(lh, struct nfs_access_entry, lru);\n\tif (lh == &nfsi->access_cache_entry_lru ||\n\t    cred != cache->cred)\n\t\tcache = NULL;\n\tif (cache == NULL)\n\t\tgoto out;\n\tif (!nfs_have_delegated_attributes(inode) &&\n\t    !time_in_range_open(jiffies, cache->jiffies, cache->jiffies + nfsi->attrtimeo))\n\t\tgoto out;\n\tres->jiffies = cache->jiffies;\n\tres->cred = cache->cred;\n\tres->mask = cache->mask;\n\terr = 0;\nout:\n\trcu_read_unlock();\n\treturn err;\n}"
  },
  {
    "function_name": "nfs_access_get_cached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2237-2270",
    "snippet": "static int nfs_access_get_cached(struct inode *inode, struct rpc_cred *cred, struct nfs_access_entry *res)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_access_entry *cache;\n\tint err = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tgoto out_zap;\n\tcache = nfs_access_search_rbtree(inode, cred);\n\tif (cache == NULL)\n\t\tgoto out;\n\tif (!nfs_have_delegated_attributes(inode) &&\n\t    !time_in_range_open(jiffies, cache->jiffies, cache->jiffies + nfsi->attrtimeo))\n\t\tgoto out_stale;\n\tres->jiffies = cache->jiffies;\n\tres->cred = cache->cred;\n\tres->mask = cache->mask;\n\tlist_move_tail(&cache->lru, &nfsi->access_cache_entry_lru);\n\terr = 0;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn err;\nout_stale:\n\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\tlist_del(&cache->lru);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_free_entry(cache);\n\treturn -ENOENT;\nout_zap:\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_zap_cache(inode);\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_access_zap_cache",
          "args": [
            "inode"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_zap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2200-2216",
          "snippet": "void nfs_access_zap_cache(struct inode *inode)\n{\n\tLIST_HEAD(head);\n\n\tif (test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags) == 0)\n\t\treturn;\n\t/* Remove from global LRU init */\n\tspin_lock(&nfs_access_lru_lock);\n\tif (test_and_clear_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\tlist_del_init(&NFS_I(inode)->access_cache_inode_lru);\n\n\tspin_lock(&inode->i_lock);\n\t__nfs_access_zap_cache(NFS_I(inode), &head);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs_access_lru_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\n\nvoid nfs_access_zap_cache(struct inode *inode)\n{\n\tLIST_HEAD(head);\n\n\tif (test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags) == 0)\n\t\treturn;\n\t/* Remove from global LRU init */\n\tspin_lock(&nfs_access_lru_lock);\n\tif (test_and_clear_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\tlist_del_init(&NFS_I(inode)->access_cache_inode_lru);\n\n\tspin_lock(&inode->i_lock);\n\t__nfs_access_zap_cache(NFS_I(inode), &head);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_access_free_entry",
          "args": [
            "cache"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2091-2098",
          "snippet": "static void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_long_t nfs_access_nr_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_access_nr_entries;\n\nstatic void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cache->lru"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&cache->rb_node",
            "&nfsi->access_cache"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&cache->lru",
            "&nfsi->access_cache_entry_lru"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_in_range_open",
          "args": [
            "jiffies",
            "cache->jiffies",
            "cache->jiffies + nfsi->attrtimeo"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_have_delegated_attributes",
          "args": [
            "inode"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_have_delegated_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.h",
          "lines": "67-71",
          "snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_access_search_rbtree",
          "args": [
            "inode",
            "cred"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_search_rbtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2219-2235",
          "snippet": "static struct nfs_access_entry *nfs_access_search_rbtree(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct rb_node *n = NFS_I(inode)->access_cache.rb_node;\n\tstruct nfs_access_entry *entry;\n\n\twhile (n != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\n\t\tif (cred < entry->cred)\n\t\t\tn = n->rb_left;\n\t\telse if (cred > entry->cred)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct nfs_access_entry *nfs_access_search_rbtree(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct rb_node *n = NFS_I(inode)->access_cache.rb_node;\n\tstruct nfs_access_entry *entry;\n\n\twhile (n != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\n\t\tif (cred < entry->cred)\n\t\t\tn = n->rb_left;\n\t\telse if (cred > entry->cred)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_access_get_cached(struct inode *inode, struct rpc_cred *cred, struct nfs_access_entry *res)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_access_entry *cache;\n\tint err = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tgoto out_zap;\n\tcache = nfs_access_search_rbtree(inode, cred);\n\tif (cache == NULL)\n\t\tgoto out;\n\tif (!nfs_have_delegated_attributes(inode) &&\n\t    !time_in_range_open(jiffies, cache->jiffies, cache->jiffies + nfsi->attrtimeo))\n\t\tgoto out_stale;\n\tres->jiffies = cache->jiffies;\n\tres->cred = cache->cred;\n\tres->mask = cache->mask;\n\tlist_move_tail(&cache->lru, &nfsi->access_cache_entry_lru);\n\terr = 0;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn err;\nout_stale:\n\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\tlist_del(&cache->lru);\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_free_entry(cache);\n\treturn -ENOENT;\nout_zap:\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_zap_cache(inode);\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "nfs_access_search_rbtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2219-2235",
    "snippet": "static struct nfs_access_entry *nfs_access_search_rbtree(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct rb_node *n = NFS_I(inode)->access_cache.rb_node;\n\tstruct nfs_access_entry *entry;\n\n\twhile (n != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\n\t\tif (cred < entry->cred)\n\t\t\tn = n->rb_left;\n\t\telse if (cred > entry->cred)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structnfs_access_entry",
            "rb_node"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct nfs_access_entry *nfs_access_search_rbtree(struct inode *inode, struct rpc_cred *cred)\n{\n\tstruct rb_node *n = NFS_I(inode)->access_cache.rb_node;\n\tstruct nfs_access_entry *entry;\n\n\twhile (n != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\n\t\tif (cred < entry->cred)\n\t\t\tn = n->rb_left;\n\t\telse if (cred > entry->cred)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs_access_zap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2200-2216",
    "snippet": "void nfs_access_zap_cache(struct inode *inode)\n{\n\tLIST_HEAD(head);\n\n\tif (test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags) == 0)\n\t\treturn;\n\t/* Remove from global LRU init */\n\tspin_lock(&nfs_access_lru_lock);\n\tif (test_and_clear_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\tlist_del_init(&NFS_I(inode)->access_cache_inode_lru);\n\n\tspin_lock(&inode->i_lock);\n\t__nfs_access_zap_cache(NFS_I(inode), &head);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(nfs_access_lru_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_access_free_list",
          "args": [
            "&head"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2100-2109",
          "snippet": "static void nfs_access_free_list(struct list_head *head)\n{\n\tstruct nfs_access_entry *cache;\n\n\twhile (!list_empty(head)) {\n\t\tcache = list_entry(head->next, struct nfs_access_entry, lru);\n\t\tlist_del(&cache->lru);\n\t\tnfs_access_free_entry(cache);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_access_free_list(struct list_head *head)\n{\n\tstruct nfs_access_entry *cache;\n\n\twhile (!list_empty(head)) {\n\t\tcache = list_entry(head->next, struct nfs_access_entry, lru);\n\t\tlist_del(&cache->lru);\n\t\tnfs_access_free_entry(cache);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs_access_lru_lock"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfs_access_zap_cache",
          "args": [
            "NFS_I(inode)",
            "&head"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_access_zap_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2185-2198",
          "snippet": "static void __nfs_access_zap_cache(struct nfs_inode *nfsi, struct list_head *head)\n{\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node *n;\n\tstruct nfs_access_entry *entry;\n\n\t/* Unhook entries from the cache */\n\twhile ((n = rb_first(root_node)) != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\t\trb_erase(n, root_node);\n\t\tlist_move(&entry->lru, head);\n\t}\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_ACCESS;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __nfs_access_zap_cache(struct nfs_inode *nfsi, struct list_head *head)\n{\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node *n;\n\tstruct nfs_access_entry *entry;\n\n\t/* Unhook entries from the cache */\n\twhile ((n = rb_first(root_node)) != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\t\trb_erase(n, root_node);\n\t\tlist_move(&entry->lru, head);\n\t}\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_ACCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&NFS_I(inode)->access_cache_inode_lru"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_INO_ACL_LRU_SET",
            "&NFS_I(inode)->flags"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_INO_ACL_LRU_SET",
            "&NFS_I(inode)->flags"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\n\nvoid nfs_access_zap_cache(struct inode *inode)\n{\n\tLIST_HEAD(head);\n\n\tif (test_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags) == 0)\n\t\treturn;\n\t/* Remove from global LRU init */\n\tspin_lock(&nfs_access_lru_lock);\n\tif (test_and_clear_bit(NFS_INO_ACL_LRU_SET, &NFS_I(inode)->flags))\n\t\tlist_del_init(&NFS_I(inode)->access_cache_inode_lru);\n\n\tspin_lock(&inode->i_lock);\n\t__nfs_access_zap_cache(NFS_I(inode), &head);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n}"
  },
  {
    "function_name": "__nfs_access_zap_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2185-2198",
    "snippet": "static void __nfs_access_zap_cache(struct nfs_inode *nfsi, struct list_head *head)\n{\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node *n;\n\tstruct nfs_access_entry *entry;\n\n\t/* Unhook entries from the cache */\n\twhile ((n = rb_first(root_node)) != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\t\trb_erase(n, root_node);\n\t\tlist_move(&entry->lru, head);\n\t}\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_ACCESS;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&entry->lru",
            "head"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "root_node"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structnfs_access_entry",
            "rb_node"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root_node"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __nfs_access_zap_cache(struct nfs_inode *nfsi, struct list_head *head)\n{\n\tstruct rb_root *root_node = &nfsi->access_cache;\n\tstruct rb_node *n;\n\tstruct nfs_access_entry *entry;\n\n\t/* Unhook entries from the cache */\n\twhile ((n = rb_first(root_node)) != NULL) {\n\t\tentry = rb_entry(n, struct nfs_access_entry, rb_node);\n\t\trb_erase(n, root_node);\n\t\tlist_move(&entry->lru, head);\n\t}\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_ACCESS;\n}"
  },
  {
    "function_name": "nfs_access_cache_enforce_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2169-2183",
    "snippet": "static void\nnfs_access_cache_enforce_limit(void)\n{\n\tlong nr_entries = atomic_long_read(&nfs_access_nr_entries);\n\tunsigned long diff;\n\tunsigned int nr_to_scan;\n\n\tif (nr_entries < 0 || nr_entries <= nfs_access_max_cachesize)\n\t\treturn;\n\tnr_to_scan = 100;\n\tdiff = nr_entries - nfs_access_max_cachesize;\n\tif (diff < nr_to_scan)\n\t\tnr_to_scan = diff;\n\tnfs_do_access_cache_scan(nr_to_scan);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t nfs_access_nr_entries;",
      "static unsigned long nfs_access_max_cachesize = ULONG_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_do_access_cache_scan",
          "args": [
            "nr_to_scan"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_access_cache_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2111-2149",
          "snippet": "static unsigned long\nnfs_do_access_cache_scan(unsigned int nr_to_scan)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_inode *nfsi, *next;\n\tstruct nfs_access_entry *cache;\n\tlong freed = 0;\n\n\tspin_lock(&nfs_access_lru_lock);\n\tlist_for_each_entry_safe(nfsi, next, &nfs_access_lru_list, access_cache_inode_lru) {\n\t\tstruct inode *inode;\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tinode = &nfsi->vfs_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tgoto remove_lru_entry;\n\t\tcache = list_entry(nfsi->access_cache_entry_lru.next,\n\t\t\t\tstruct nfs_access_entry, lru);\n\t\tlist_move(&cache->lru, &head);\n\t\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\t\tfreed++;\n\t\tif (!list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tlist_move_tail(&nfsi->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\telse {\nremove_lru_entry:\n\t\t\tlist_del_init(&nfsi->access_cache_inode_lru);\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(NFS_INO_ACL_LRU_SET, &nfsi->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n\treturn freed;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs_access_lru_lock);",
            "static LIST_HEAD(nfs_access_lru_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\nstatic LIST_HEAD(nfs_access_lru_list);\n\nstatic unsigned long\nnfs_do_access_cache_scan(unsigned int nr_to_scan)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_inode *nfsi, *next;\n\tstruct nfs_access_entry *cache;\n\tlong freed = 0;\n\n\tspin_lock(&nfs_access_lru_lock);\n\tlist_for_each_entry_safe(nfsi, next, &nfs_access_lru_list, access_cache_inode_lru) {\n\t\tstruct inode *inode;\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tinode = &nfsi->vfs_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tgoto remove_lru_entry;\n\t\tcache = list_entry(nfsi->access_cache_entry_lru.next,\n\t\t\t\tstruct nfs_access_entry, lru);\n\t\tlist_move(&cache->lru, &head);\n\t\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\t\tfreed++;\n\t\tif (!list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tlist_move_tail(&nfsi->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\telse {\nremove_lru_entry:\n\t\t\tlist_del_init(&nfsi->access_cache_inode_lru);\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(NFS_INO_ACL_LRU_SET, &nfsi->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&nfs_access_nr_entries"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_access_nr_entries;\nstatic unsigned long nfs_access_max_cachesize = ULONG_MAX;\n\nstatic void\nnfs_access_cache_enforce_limit(void)\n{\n\tlong nr_entries = atomic_long_read(&nfs_access_nr_entries);\n\tunsigned long diff;\n\tunsigned int nr_to_scan;\n\n\tif (nr_entries < 0 || nr_entries <= nfs_access_max_cachesize)\n\t\treturn;\n\tnr_to_scan = 100;\n\tdiff = nr_entries - nfs_access_max_cachesize;\n\tif (diff < nr_to_scan)\n\t\tnr_to_scan = diff;\n\tnfs_do_access_cache_scan(nr_to_scan);\n}"
  },
  {
    "function_name": "nfs_access_cache_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2163-2167",
    "snippet": "unsigned long\nnfs_access_cache_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(atomic_long_read(&nfs_access_nr_entries));\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t nfs_access_nr_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_pressure_ratio",
          "args": [
            "atomic_long_read(&nfs_access_nr_entries)"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&nfs_access_nr_entries"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_access_nr_entries;\n\nunsigned long\nnfs_access_cache_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn vfs_pressure_ratio(atomic_long_read(&nfs_access_nr_entries));\n}"
  },
  {
    "function_name": "nfs_access_cache_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2151-2160",
    "snippet": "unsigned long\nnfs_access_cache_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint nr_to_scan = sc->nr_to_scan;\n\tgfp_t gfp_mask = sc->gfp_mask;\n\n\tif ((gfp_mask & GFP_KERNEL) != GFP_KERNEL)\n\t\treturn SHRINK_STOP;\n\treturn nfs_do_access_cache_scan(nr_to_scan);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_do_access_cache_scan",
          "args": [
            "nr_to_scan"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_access_cache_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2111-2149",
          "snippet": "static unsigned long\nnfs_do_access_cache_scan(unsigned int nr_to_scan)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_inode *nfsi, *next;\n\tstruct nfs_access_entry *cache;\n\tlong freed = 0;\n\n\tspin_lock(&nfs_access_lru_lock);\n\tlist_for_each_entry_safe(nfsi, next, &nfs_access_lru_list, access_cache_inode_lru) {\n\t\tstruct inode *inode;\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tinode = &nfsi->vfs_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tgoto remove_lru_entry;\n\t\tcache = list_entry(nfsi->access_cache_entry_lru.next,\n\t\t\t\tstruct nfs_access_entry, lru);\n\t\tlist_move(&cache->lru, &head);\n\t\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\t\tfreed++;\n\t\tif (!list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tlist_move_tail(&nfsi->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\telse {\nremove_lru_entry:\n\t\t\tlist_del_init(&nfsi->access_cache_inode_lru);\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(NFS_INO_ACL_LRU_SET, &nfsi->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n\treturn freed;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(nfs_access_lru_lock);",
            "static LIST_HEAD(nfs_access_lru_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\nstatic LIST_HEAD(nfs_access_lru_list);\n\nstatic unsigned long\nnfs_do_access_cache_scan(unsigned int nr_to_scan)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_inode *nfsi, *next;\n\tstruct nfs_access_entry *cache;\n\tlong freed = 0;\n\n\tspin_lock(&nfs_access_lru_lock);\n\tlist_for_each_entry_safe(nfsi, next, &nfs_access_lru_list, access_cache_inode_lru) {\n\t\tstruct inode *inode;\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tinode = &nfsi->vfs_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tgoto remove_lru_entry;\n\t\tcache = list_entry(nfsi->access_cache_entry_lru.next,\n\t\t\t\tstruct nfs_access_entry, lru);\n\t\tlist_move(&cache->lru, &head);\n\t\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\t\tfreed++;\n\t\tif (!list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tlist_move_tail(&nfsi->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\telse {\nremove_lru_entry:\n\t\t\tlist_del_init(&nfsi->access_cache_inode_lru);\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(NFS_INO_ACL_LRU_SET, &nfsi->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n\treturn freed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nunsigned long\nnfs_access_cache_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint nr_to_scan = sc->nr_to_scan;\n\tgfp_t gfp_mask = sc->gfp_mask;\n\n\tif ((gfp_mask & GFP_KERNEL) != GFP_KERNEL)\n\t\treturn SHRINK_STOP;\n\treturn nfs_do_access_cache_scan(nr_to_scan);\n}"
  },
  {
    "function_name": "nfs_do_access_cache_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2111-2149",
    "snippet": "static unsigned long\nnfs_do_access_cache_scan(unsigned int nr_to_scan)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_inode *nfsi, *next;\n\tstruct nfs_access_entry *cache;\n\tlong freed = 0;\n\n\tspin_lock(&nfs_access_lru_lock);\n\tlist_for_each_entry_safe(nfsi, next, &nfs_access_lru_list, access_cache_inode_lru) {\n\t\tstruct inode *inode;\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tinode = &nfsi->vfs_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tgoto remove_lru_entry;\n\t\tcache = list_entry(nfsi->access_cache_entry_lru.next,\n\t\t\t\tstruct nfs_access_entry, lru);\n\t\tlist_move(&cache->lru, &head);\n\t\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\t\tfreed++;\n\t\tif (!list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tlist_move_tail(&nfsi->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\telse {\nremove_lru_entry:\n\t\t\tlist_del_init(&nfsi->access_cache_inode_lru);\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(NFS_INO_ACL_LRU_SET, &nfsi->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n\treturn freed;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(nfs_access_lru_lock);",
      "static LIST_HEAD(nfs_access_lru_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_access_free_list",
          "args": [
            "&head"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_free_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2100-2109",
          "snippet": "static void nfs_access_free_list(struct list_head *head)\n{\n\tstruct nfs_access_entry *cache;\n\n\twhile (!list_empty(head)) {\n\t\tcache = list_entry(head->next, struct nfs_access_entry, lru);\n\t\tlist_del(&cache->lru);\n\t\tnfs_access_free_entry(cache);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_access_free_list(struct list_head *head)\n{\n\tstruct nfs_access_entry *cache;\n\n\twhile (!list_empty(head)) {\n\t\tcache = list_entry(head->next, struct nfs_access_entry, lru);\n\t\tlist_del(&cache->lru);\n\t\tnfs_access_free_entry(cache);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfs_access_lru_lock"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_INO_ACL_LRU_SET",
            "&nfsi->flags"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&nfsi->access_cache_inode_lru"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&nfsi->access_cache_inode_lru",
            "&nfs_access_lru_list"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nfsi->access_cache_entry_lru"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&cache->rb_node",
            "&nfsi->access_cache"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&cache->lru",
            "&head"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nfsi->access_cache_entry_lru.next",
            "structnfs_access_entry",
            "lru"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "nfsi",
            "next",
            "&nfs_access_lru_list",
            "access_cache_inode_lru"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(nfs_access_lru_lock);\nstatic LIST_HEAD(nfs_access_lru_list);\n\nstatic unsigned long\nnfs_do_access_cache_scan(unsigned int nr_to_scan)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_inode *nfsi, *next;\n\tstruct nfs_access_entry *cache;\n\tlong freed = 0;\n\n\tspin_lock(&nfs_access_lru_lock);\n\tlist_for_each_entry_safe(nfsi, next, &nfs_access_lru_list, access_cache_inode_lru) {\n\t\tstruct inode *inode;\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tinode = &nfsi->vfs_inode;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tgoto remove_lru_entry;\n\t\tcache = list_entry(nfsi->access_cache_entry_lru.next,\n\t\t\t\tstruct nfs_access_entry, lru);\n\t\tlist_move(&cache->lru, &head);\n\t\trb_erase(&cache->rb_node, &nfsi->access_cache);\n\t\tfreed++;\n\t\tif (!list_empty(&nfsi->access_cache_entry_lru))\n\t\t\tlist_move_tail(&nfsi->access_cache_inode_lru,\n\t\t\t\t\t&nfs_access_lru_list);\n\t\telse {\nremove_lru_entry:\n\t\t\tlist_del_init(&nfsi->access_cache_inode_lru);\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(NFS_INO_ACL_LRU_SET, &nfsi->flags);\n\t\t\tsmp_mb__after_atomic();\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tspin_unlock(&nfs_access_lru_lock);\n\tnfs_access_free_list(&head);\n\treturn freed;\n}"
  },
  {
    "function_name": "nfs_access_free_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2100-2109",
    "snippet": "static void nfs_access_free_list(struct list_head *head)\n{\n\tstruct nfs_access_entry *cache;\n\n\twhile (!list_empty(head)) {\n\t\tcache = list_entry(head->next, struct nfs_access_entry, lru);\n\t\tlist_del(&cache->lru);\n\t\tnfs_access_free_entry(cache);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_access_free_entry",
          "args": [
            "cache"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_access_free_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "2091-2098",
          "snippet": "static void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_long_t nfs_access_nr_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_access_nr_entries;\n\nstatic void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cache->lru"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head->next",
            "structnfs_access_entry",
            "lru"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_access_free_list(struct list_head *head)\n{\n\tstruct nfs_access_entry *cache;\n\n\twhile (!list_empty(head)) {\n\t\tcache = list_entry(head->next, struct nfs_access_entry, lru);\n\t\tlist_del(&cache->lru);\n\t\tnfs_access_free_entry(cache);\n\t}\n}"
  },
  {
    "function_name": "nfs_access_free_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "2091-2098",
    "snippet": "static void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_long_t nfs_access_nr_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&nfs_access_nr_entries"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "entry",
            "rcu_head"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "entry->cred"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_access_nr_entries;\n\nstatic void nfs_access_free_entry(struct nfs_access_entry *entry)\n{\n\tput_rpccred(entry->cred);\n\tkfree_rcu(entry, rcu_head);\n\tsmp_mb__before_atomic();\n\tatomic_long_dec(&nfs_access_nr_entries);\n\tsmp_mb__after_atomic();\n}"
  },
  {
    "function_name": "nfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1997-2080",
    "snippet": "int nfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct dentry *dentry = NULL, *rehash = NULL;\n\tstruct rpc_task *task;\n\tint error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: rename(%pd2 -> %pd2, ct=%d)\\n\",\n\t\t old_dentry, new_dentry,\n\t\t d_count(new_dentry));\n\n\ttrace_nfs_rename_enter(old_dir, old_dentry, new_dir, new_dentry);\n\t/*\n\t * For non-directories, check whether the target is busy and if so,\n\t * make a copy of the dentry and then do a silly-rename. If the\n\t * silly-rename succeeds, the copied dentry is hashed and becomes\n\t * the new target.\n\t */\n\tif (new_inode && !S_ISDIR(new_inode->i_mode)) {\n\t\t/*\n\t\t * To prevent any new references to the target during the\n\t\t * rename, we unhash the dentry in advance.\n\t\t */\n\t\tif (!d_unhashed(new_dentry)) {\n\t\t\td_drop(new_dentry);\n\t\t\trehash = new_dentry;\n\t\t}\n\n\t\tif (d_count(new_dentry) > 2) {\n\t\t\tint err;\n\n\t\t\t/* copy the target dentry's name */\n\t\t\tdentry = d_alloc(new_dentry->d_parent,\n\t\t\t\t\t &new_dentry->d_name);\n\t\t\tif (!dentry)\n\t\t\t\tgoto out;\n\n\t\t\t/* silly-rename the existing target ... */\n\t\t\terr = nfs_sillyrename(new_dir, new_dentry);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tnew_dentry = dentry;\n\t\t\trehash = NULL;\n\t\t\tnew_inode = NULL;\n\t\t}\n\t}\n\n\tNFS_PROTO(old_inode)->return_delegation(old_inode);\n\tif (new_inode != NULL)\n\t\tNFS_PROTO(new_inode)->return_delegation(new_inode);\n\n\ttask = nfs_async_rename(old_dir, new_dir, old_dentry, new_dentry, NULL);\n\tif (IS_ERR(task)) {\n\t\terror = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\trpc_put_task(task);\n\tnfs_mark_for_revalidate(old_inode);\nout:\n\tif (rehash)\n\t\td_rehash(rehash);\n\ttrace_nfs_rename_exit(old_dir, old_dentry,\n\t\t\tnew_dir, new_dentry, error);\n\tif (!error) {\n\t\tif (new_inode != NULL)\n\t\t\tnfs_drop_nlink(new_inode);\n\t\td_move(old_dentry, new_dentry);\n\t\tnfs_set_verifier(new_dentry,\n\t\t\t\t\tnfs_save_change_attribute(new_dir));\n\t} else if (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(old_dentry);\n\n\t/* new dentry created? */\n\tif (dentry)\n\t\tdput(dentry);\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_dentry_handle_enoent",
          "args": [
            "old_dentry"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dentry_handle_enoent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1769-1773",
          "snippet": "static void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "new_dentry",
            "nfs_save_change_attribute(new_dir)"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "new_dir"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "old_dentry",
            "new_dentry"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1307-1315",
          "snippet": "static void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_rename_exit",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry",
            "error"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "rehash"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_for_revalidate",
          "args": [
            "old_inode"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_put_task",
          "args": [
            "task"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wait_for_completion_task",
          "args": [
            "task"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_async_rename",
          "args": [
            "old_dir",
            "new_dir",
            "old_dentry",
            "new_dentry",
            "NULL"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_async_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "403-460",
          "snippet": "struct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *))\n{\n\tstruct nfs_renamedata *data;\n\tstruct rpc_message msg = { };\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_rename_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.rpc_client = NFS_CLIENT(old_dir),\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttask_setup_data.callback_data = data;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstruct rpc_task *task = ERR_CAST(data->cred);\n\t\tkfree(data);\n\t\treturn task;\n\t}\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tmsg.rpc_cred = data->cred;\n\n\t/* set up nfs_renamedata */\n\tdata->old_dir = old_dir;\n\tihold(old_dir);\n\tdata->new_dir = new_dir;\n\tihold(new_dir);\n\tdata->old_dentry = dget(old_dentry);\n\tdata->new_dentry = dget(new_dentry);\n\tnfs_fattr_init(&data->old_fattr);\n\tnfs_fattr_init(&data->new_fattr);\n\tdata->complete = complete;\n\n\t/* set up nfs_renameargs */\n\tdata->args.old_dir = NFS_FH(old_dir);\n\tdata->args.old_name = &old_dentry->d_name;\n\tdata->args.new_dir = NFS_FH(new_dir);\n\tdata->args.new_name = &new_dentry->d_name;\n\n\t/* set up nfs_renameres */\n\tdata->res.old_fattr = &data->old_fattr;\n\tdata->res.new_fattr = &data->new_fattr;\n\n\tnfs_sb_active(old_dir->i_sb);\n\n\tNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\n\n\treturn rpc_run_task(&task_setup_data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_rename_ops = {\n\t.rpc_call_done = nfs_async_rename_done,\n\t.rpc_release = nfs_async_rename_release,\n\t.rpc_call_prepare = nfs_rename_prepare,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic const struct rpc_call_ops nfs_rename_ops = {\n\t.rpc_call_done = nfs_async_rename_done,\n\t.rpc_release = nfs_async_rename_release,\n\t.rpc_call_prepare = nfs_rename_prepare,\n};\n\nstruct rpc_task *\nnfs_async_rename(struct inode *old_dir, struct inode *new_dir,\n\t\t struct dentry *old_dentry, struct dentry *new_dentry,\n\t\t void (*complete)(struct rpc_task *, struct nfs_renamedata *))\n{\n\tstruct nfs_renamedata *data;\n\tstruct rpc_message msg = { };\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs_rename_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.rpc_client = NFS_CLIENT(old_dir),\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\ttask_setup_data.callback_data = data;\n\n\tdata->cred = rpc_lookup_cred();\n\tif (IS_ERR(data->cred)) {\n\t\tstruct rpc_task *task = ERR_CAST(data->cred);\n\t\tkfree(data);\n\t\treturn task;\n\t}\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tmsg.rpc_cred = data->cred;\n\n\t/* set up nfs_renamedata */\n\tdata->old_dir = old_dir;\n\tihold(old_dir);\n\tdata->new_dir = new_dir;\n\tihold(new_dir);\n\tdata->old_dentry = dget(old_dentry);\n\tdata->new_dentry = dget(new_dentry);\n\tnfs_fattr_init(&data->old_fattr);\n\tnfs_fattr_init(&data->new_fattr);\n\tdata->complete = complete;\n\n\t/* set up nfs_renameargs */\n\tdata->args.old_dir = NFS_FH(old_dir);\n\tdata->args.old_name = &old_dentry->d_name;\n\tdata->args.new_dir = NFS_FH(new_dir);\n\tdata->args.new_name = &new_dentry->d_name;\n\n\t/* set up nfs_renameres */\n\tdata->res.old_fattr = &data->old_fattr;\n\tdata->res.new_fattr = &data->new_fattr;\n\n\tnfs_sb_active(old_dir->i_sb);\n\n\tNFS_PROTO(data->old_dir)->rename_setup(&msg, old_dir);\n\n\treturn rpc_run_task(&task_setup_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "new_inode"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "new_inode"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "old_inode"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "old_inode"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_sillyrename",
          "args": [
            "new_dir",
            "new_dentry"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "512-604",
          "snippet": "int\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\n{\n\tstatic unsigned int sillycounter;\n\tunsigned char silly[SILLYNAME_LEN + 1];\n\tunsigned long long fileid;\n\tstruct dentry *sdentry;\n\tstruct rpc_task *task;\n\tint            error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: silly-rename(%pd2, ct=%d)\\n\",\n\t\tdentry, d_count(dentry));\n\tnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\n\n\t/*\n\t * We don't allow a dentry to be silly-renamed twice.\n\t */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out;\n\n\tfileid = NFS_FILEID(dentry->d_inode);\n\n\t/* Return delegation in anticipation of the rename */\n\tNFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\t\tslen = scnprintf(silly, sizeof(silly),\n\t\t\t\tSILLYNAME_PREFIX \"%0*llx%0*x\",\n\t\t\t\tSILLYNAME_FILEID_LEN, fileid,\n\t\t\t\tSILLYNAME_COUNTER_LEN, sillycounter);\n\n\t\tdfprintk(VFS, \"NFS: trying to rename %pd to %s\\n\",\n\t\t\t\tdentry, silly);\n\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\t\t/*\n\t\t * N.B. Better to return EBUSY here ... it could be\n\t\t * dangerous to delete the file while it's in use.\n\t\t */\n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (sdentry->d_inode != NULL); /* need negative lookup */\n\n\t/* queue unlink first. Can't do this from rpc_release as it\n\t * has to allocate memory\n\t */\n\terror = nfs_async_unlink(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/* populate unlinkdata with the right dname */\n\terror = nfs_copy_dname(sdentry,\n\t\t\t\t(struct nfs_unlinkdata *)dentry->d_fsdata);\n\tif (error) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* run the rename task, undo unlink if it fails */\n\ttask = nfs_async_rename(dir, dir, dentry, sdentry,\n\t\t\t\t\tnfs_complete_sillyrename);\n\tif (IS_ERR(task)) {\n\t\terror = -EBUSY;\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* wait for the RPC task to complete, unless a SIGKILL intervenes */\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\tswitch (error) {\n\tcase 0:\n\t\t/* The rename succeeded */\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t/* The result of the rename is unknown. Play it safe by\n\t\t * forcing a new lookup */\n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\trpc_put_task(task);\nout_dput:\n\tdput(sdentry);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SILLYNAME_LEN (SILLYNAME_PREFIX_LEN + \\\n\t\tSILLYNAME_FILEID_LEN + \\\n\t\tSILLYNAME_COUNTER_LEN)",
            "#define SILLYNAME_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)",
            "#define SILLYNAME_FILEID_LEN ((unsigned)sizeof(u64) << 1)",
            "#define SILLYNAME_PREFIX \".nfs\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#define SILLYNAME_LEN (SILLYNAME_PREFIX_LEN + \\\n\t\tSILLYNAME_FILEID_LEN + \\\n\t\tSILLYNAME_COUNTER_LEN)\n#define SILLYNAME_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n#define SILLYNAME_FILEID_LEN ((unsigned)sizeof(u64) << 1)\n#define SILLYNAME_PREFIX \".nfs\"\n\nint\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\n{\n\tstatic unsigned int sillycounter;\n\tunsigned char silly[SILLYNAME_LEN + 1];\n\tunsigned long long fileid;\n\tstruct dentry *sdentry;\n\tstruct rpc_task *task;\n\tint            error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: silly-rename(%pd2, ct=%d)\\n\",\n\t\tdentry, d_count(dentry));\n\tnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\n\n\t/*\n\t * We don't allow a dentry to be silly-renamed twice.\n\t */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out;\n\n\tfileid = NFS_FILEID(dentry->d_inode);\n\n\t/* Return delegation in anticipation of the rename */\n\tNFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\t\tslen = scnprintf(silly, sizeof(silly),\n\t\t\t\tSILLYNAME_PREFIX \"%0*llx%0*x\",\n\t\t\t\tSILLYNAME_FILEID_LEN, fileid,\n\t\t\t\tSILLYNAME_COUNTER_LEN, sillycounter);\n\n\t\tdfprintk(VFS, \"NFS: trying to rename %pd to %s\\n\",\n\t\t\t\tdentry, silly);\n\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\t\t/*\n\t\t * N.B. Better to return EBUSY here ... it could be\n\t\t * dangerous to delete the file while it's in use.\n\t\t */\n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (sdentry->d_inode != NULL); /* need negative lookup */\n\n\t/* queue unlink first. Can't do this from rpc_release as it\n\t * has to allocate memory\n\t */\n\terror = nfs_async_unlink(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/* populate unlinkdata with the right dname */\n\terror = nfs_copy_dname(sdentry,\n\t\t\t\t(struct nfs_unlinkdata *)dentry->d_fsdata);\n\tif (error) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* run the rename task, undo unlink if it fails */\n\ttask = nfs_async_rename(dir, dir, dentry, sdentry,\n\t\t\t\t\tnfs_complete_sillyrename);\n\tif (IS_ERR(task)) {\n\t\terror = -EBUSY;\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* wait for the RPC task to complete, unless a SIGKILL intervenes */\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\tswitch (error) {\n\tcase 0:\n\t\t/* The rename succeeded */\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t/* The result of the rename is unknown. Play it safe by\n\t\t * forcing a new lookup */\n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\trpc_put_task(task);\nout_dput:\n\tdput(sdentry);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "new_dentry->d_parent",
            "&new_dentry->d_name"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "new_dentry"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "new_dentry"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "new_dentry"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_rename_enter",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: rename(%pd2 -> %pd2, ct=%d)\\n\"",
            "old_dentry",
            "new_dentry",
            "d_count(new_dentry)"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct dentry *dentry = NULL, *rehash = NULL;\n\tstruct rpc_task *task;\n\tint error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: rename(%pd2 -> %pd2, ct=%d)\\n\",\n\t\t old_dentry, new_dentry,\n\t\t d_count(new_dentry));\n\n\ttrace_nfs_rename_enter(old_dir, old_dentry, new_dir, new_dentry);\n\t/*\n\t * For non-directories, check whether the target is busy and if so,\n\t * make a copy of the dentry and then do a silly-rename. If the\n\t * silly-rename succeeds, the copied dentry is hashed and becomes\n\t * the new target.\n\t */\n\tif (new_inode && !S_ISDIR(new_inode->i_mode)) {\n\t\t/*\n\t\t * To prevent any new references to the target during the\n\t\t * rename, we unhash the dentry in advance.\n\t\t */\n\t\tif (!d_unhashed(new_dentry)) {\n\t\t\td_drop(new_dentry);\n\t\t\trehash = new_dentry;\n\t\t}\n\n\t\tif (d_count(new_dentry) > 2) {\n\t\t\tint err;\n\n\t\t\t/* copy the target dentry's name */\n\t\t\tdentry = d_alloc(new_dentry->d_parent,\n\t\t\t\t\t &new_dentry->d_name);\n\t\t\tif (!dentry)\n\t\t\t\tgoto out;\n\n\t\t\t/* silly-rename the existing target ... */\n\t\t\terr = nfs_sillyrename(new_dir, new_dentry);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tnew_dentry = dentry;\n\t\t\trehash = NULL;\n\t\t\tnew_inode = NULL;\n\t\t}\n\t}\n\n\tNFS_PROTO(old_inode)->return_delegation(old_inode);\n\tif (new_inode != NULL)\n\t\tNFS_PROTO(new_inode)->return_delegation(new_inode);\n\n\ttask = nfs_async_rename(old_dir, new_dir, old_dentry, new_dentry, NULL);\n\tif (IS_ERR(task)) {\n\t\terror = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\trpc_put_task(task);\n\tnfs_mark_for_revalidate(old_inode);\nout:\n\tif (rehash)\n\t\td_rehash(rehash);\n\ttrace_nfs_rename_exit(old_dir, old_dentry,\n\t\t\tnew_dir, new_dentry, error);\n\tif (!error) {\n\t\tif (new_inode != NULL)\n\t\t\tnfs_drop_nlink(new_inode);\n\t\td_move(old_dentry, new_dentry);\n\t\tnfs_set_verifier(new_dentry,\n\t\t\t\t\tnfs_save_change_attribute(new_dir));\n\t} else if (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(old_dentry);\n\n\t/* new dentry created? */\n\tif (dentry)\n\t\tdput(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1950-1970",
    "snippet": "int\nnfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: link(%pd2 -> %pd2)\\n\",\n\t\told_dentry, dentry);\n\n\ttrace_nfs_link_enter(inode, dir, dentry);\n\tNFS_PROTO(inode)->return_delegation(inode);\n\n\td_drop(dentry);\n\terror = NFS_PROTO(dir)->link(inode, dir, &dentry->d_name);\n\tif (error == 0) {\n\t\tihold(inode);\n\t\td_add(dentry, inode);\n\t}\n\ttrace_nfs_link_exit(inode, dir, dentry, error);\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_link_exit",
          "args": [
            "inode",
            "dir",
            "dentry",
            "error"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "dir",
            "&dentry->d_name"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_link_enter",
          "args": [
            "inode",
            "dir",
            "dentry"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: link(%pd2 -> %pd2)\\n\"",
            "old_dentry",
            "dentry"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint\nnfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: link(%pd2 -> %pd2)\\n\",\n\t\told_dentry, dentry);\n\n\ttrace_nfs_link_enter(inode, dir, dentry);\n\tNFS_PROTO(inode)->return_delegation(inode);\n\n\td_drop(dentry);\n\terror = NFS_PROTO(dir)->link(inode, dir, &dentry->d_name);\n\tif (error == 0) {\n\t\tihold(inode);\n\t\td_add(dentry, inode);\n\t}\n\ttrace_nfs_link_exit(inode, dir, dentry, error);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1891-1947",
    "snippet": "int nfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct iattr attr;\n\tunsigned int pathlen = strlen(symname);\n\tint error;\n\n\tdfprintk(VFS, \"NFS: symlink(%s/%lu, %pd, %s)\\n\", dir->i_sb->s_id,\n\t\tdir->i_ino, dentry, symname);\n\n\tif (pathlen > PAGE_SIZE)\n\t\treturn -ENAMETOOLONG;\n\n\tattr.ia_mode = S_IFLNK | S_IRWXUGO;\n\tattr.ia_valid = ATTR_MODE;\n\n\tpage = alloc_page(GFP_HIGHUSER);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, pathlen);\n\tif (pathlen < PAGE_SIZE)\n\t\tmemset(kaddr + pathlen, 0, PAGE_SIZE - pathlen);\n\tkunmap_atomic(kaddr);\n\n\ttrace_nfs_symlink_enter(dir, dentry);\n\terror = NFS_PROTO(dir)->symlink(dir, dentry, page, pathlen, &attr);\n\ttrace_nfs_symlink_exit(dir, dentry, error);\n\tif (error != 0) {\n\t\tdfprintk(VFS, \"NFS: symlink(%s/%lu, %pd, %s) error %d\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino,\n\t\t\tdentry, symname, error);\n\t\td_drop(dentry);\n\t\t__free_page(page);\n\t\treturn error;\n\t}\n\n\t/*\n\t * No big deal if we can't add this page to the page cache here.\n\t * READLINK will get the missing page from the server if needed.\n\t */\n\tif (!add_to_page_cache_lru(page, dentry->d_inode->i_mapping, 0,\n\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\t/*\n\t\t * add_to_page_cache_lru() grabs an extra page refcount.\n\t\t * Drop it here to avoid leaking this page later.\n\t\t */\n\t\tpage_cache_release(page);\n\t} else\n\t\t__free_page(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "dentry->d_inode->i_mapping",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: symlink(%s/%lu, %pd, %s) error %d\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry",
            "symname",
            "error"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_symlink_exit",
          "args": [
            "dir",
            "dentry",
            "error"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "dentry",
            "page",
            "pathlen",
            "&attr"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_symlink_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + pathlen",
            "0",
            "PAGE_SIZE - pathlen"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "symname",
            "pathlen"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: symlink(%s/%lu, %pd, %s)\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry",
            "symname"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nint nfs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct iattr attr;\n\tunsigned int pathlen = strlen(symname);\n\tint error;\n\n\tdfprintk(VFS, \"NFS: symlink(%s/%lu, %pd, %s)\\n\", dir->i_sb->s_id,\n\t\tdir->i_ino, dentry, symname);\n\n\tif (pathlen > PAGE_SIZE)\n\t\treturn -ENAMETOOLONG;\n\n\tattr.ia_mode = S_IFLNK | S_IRWXUGO;\n\tattr.ia_valid = ATTR_MODE;\n\n\tpage = alloc_page(GFP_HIGHUSER);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tkaddr = kmap_atomic(page);\n\tmemcpy(kaddr, symname, pathlen);\n\tif (pathlen < PAGE_SIZE)\n\t\tmemset(kaddr + pathlen, 0, PAGE_SIZE - pathlen);\n\tkunmap_atomic(kaddr);\n\n\ttrace_nfs_symlink_enter(dir, dentry);\n\terror = NFS_PROTO(dir)->symlink(dir, dentry, page, pathlen, &attr);\n\ttrace_nfs_symlink_exit(dir, dentry, error);\n\tif (error != 0) {\n\t\tdfprintk(VFS, \"NFS: symlink(%s/%lu, %pd, %s) error %d\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino,\n\t\t\tdentry, symname, error);\n\t\td_drop(dentry);\n\t\t__free_page(page);\n\t\treturn error;\n\t}\n\n\t/*\n\t * No big deal if we can't add this page to the page cache here.\n\t * READLINK will get the missing page from the server if needed.\n\t */\n\tif (!add_to_page_cache_lru(page, dentry->d_inode->i_mapping, 0,\n\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\t/*\n\t\t * add_to_page_cache_lru() grabs an extra page refcount.\n\t\t * Drop it here to avoid leaking this page later.\n\t\t */\n\t\tpage_cache_release(page);\n\t} else\n\t\t__free_page(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1843-1873",
    "snippet": "int nfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\tint need_rehash = 0;\n\n\tdfprintk(VFS, \"NFS: unlink(%s/%lu, %pd)\\n\", dir->i_sb->s_id,\n\t\tdir->i_ino, dentry);\n\n\ttrace_nfs_unlink_enter(dir, dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (d_count(dentry) > 1) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\t/* Start asynchronous writeout of the inode */\n\t\twrite_inode_now(dentry->d_inode, 0);\n\t\terror = nfs_sillyrename(dir, dentry);\n\t\tgoto out;\n\t}\n\tif (!d_unhashed(dentry)) {\n\t\t__d_drop(dentry);\n\t\tneed_rehash = 1;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\terror = nfs_safe_remove(dentry);\n\tif (!error || error == -ENOENT) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t} else if (need_rehash)\n\t\td_rehash(dentry);\nout:\n\ttrace_nfs_unlink_exit(dir, dentry, error);\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_unlink_exit",
          "args": [
            "dir",
            "dentry",
            "error"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dentry"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_safe_remove",
          "args": [
            "dentry"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_safe_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1809-1836",
          "snippet": "static int nfs_safe_remove(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EBUSY;\n\t\t\n\tdfprintk(VFS, \"NFS: safe_remove(%pd2)\\n\", dentry);\n\n\t/* If the dentry was sillyrenamed, we simply call d_delete() */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_nfs_remove_enter(dir, dentry);\n\tif (inode != NULL) {\n\t\tNFS_PROTO(inode)->return_delegation(inode);\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\t\tif (error == 0)\n\t\t\tnfs_drop_nlink(inode);\n\t} else\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\tif (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(dentry);\n\ttrace_nfs_remove_exit(dir, dentry, error);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_safe_remove(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EBUSY;\n\t\t\n\tdfprintk(VFS, \"NFS: safe_remove(%pd2)\\n\", dentry);\n\n\t/* If the dentry was sillyrenamed, we simply call d_delete() */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_nfs_remove_enter(dir, dentry);\n\tif (inode != NULL) {\n\t\tNFS_PROTO(inode)->return_delegation(inode);\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\t\tif (error == 0)\n\t\t\tnfs_drop_nlink(inode);\n\t} else\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\tif (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(dentry);\n\ttrace_nfs_remove_exit(dir, dentry, error);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_drop",
          "args": [
            "dentry"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "__d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "445-465",
          "snippet": "void __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\tstruct hlist_bl_head *b;\n\t\t/*\n\t\t * Hashed dentries are normally on the dentry hashtable,\n\t\t * with the exception of those newly allocated by\n\t\t * d_obtain_alias, which are always IS_ROOT:\n\t\t */\n\t\tif (unlikely(IS_ROOT(dentry)))\n\t\t\tb = &dentry->d_sb->s_anon;\n\t\telse\n\t\t\tb = d_hash(dentry->d_parent, dentry->d_name.hash);\n\n\t\thlist_bl_lock(b);\n\t\t__hlist_bl_del(&dentry->d_hash);\n\t\tdentry->d_hash.pprev = NULL;\n\t\thlist_bl_unlock(b);\n\t\tdentry_rcuwalk_barrier(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\tstruct hlist_bl_head *b;\n\t\t/*\n\t\t * Hashed dentries are normally on the dentry hashtable,\n\t\t * with the exception of those newly allocated by\n\t\t * d_obtain_alias, which are always IS_ROOT:\n\t\t */\n\t\tif (unlikely(IS_ROOT(dentry)))\n\t\t\tb = &dentry->d_sb->s_anon;\n\t\telse\n\t\t\tb = d_hash(dentry->d_parent, dentry->d_name.hash);\n\n\t\thlist_bl_lock(b);\n\t\t__hlist_bl_del(&dentry->d_hash);\n\t\tdentry->d_hash.pprev = NULL;\n\t\thlist_bl_unlock(b);\n\t\tdentry_rcuwalk_barrier(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_sillyrename",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "512-604",
          "snippet": "int\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\n{\n\tstatic unsigned int sillycounter;\n\tunsigned char silly[SILLYNAME_LEN + 1];\n\tunsigned long long fileid;\n\tstruct dentry *sdentry;\n\tstruct rpc_task *task;\n\tint            error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: silly-rename(%pd2, ct=%d)\\n\",\n\t\tdentry, d_count(dentry));\n\tnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\n\n\t/*\n\t * We don't allow a dentry to be silly-renamed twice.\n\t */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out;\n\n\tfileid = NFS_FILEID(dentry->d_inode);\n\n\t/* Return delegation in anticipation of the rename */\n\tNFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\t\tslen = scnprintf(silly, sizeof(silly),\n\t\t\t\tSILLYNAME_PREFIX \"%0*llx%0*x\",\n\t\t\t\tSILLYNAME_FILEID_LEN, fileid,\n\t\t\t\tSILLYNAME_COUNTER_LEN, sillycounter);\n\n\t\tdfprintk(VFS, \"NFS: trying to rename %pd to %s\\n\",\n\t\t\t\tdentry, silly);\n\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\t\t/*\n\t\t * N.B. Better to return EBUSY here ... it could be\n\t\t * dangerous to delete the file while it's in use.\n\t\t */\n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (sdentry->d_inode != NULL); /* need negative lookup */\n\n\t/* queue unlink first. Can't do this from rpc_release as it\n\t * has to allocate memory\n\t */\n\terror = nfs_async_unlink(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/* populate unlinkdata with the right dname */\n\terror = nfs_copy_dname(sdentry,\n\t\t\t\t(struct nfs_unlinkdata *)dentry->d_fsdata);\n\tif (error) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* run the rename task, undo unlink if it fails */\n\ttask = nfs_async_rename(dir, dir, dentry, sdentry,\n\t\t\t\t\tnfs_complete_sillyrename);\n\tif (IS_ERR(task)) {\n\t\terror = -EBUSY;\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* wait for the RPC task to complete, unless a SIGKILL intervenes */\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\tswitch (error) {\n\tcase 0:\n\t\t/* The rename succeeded */\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t/* The result of the rename is unknown. Play it safe by\n\t\t * forcing a new lookup */\n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\trpc_put_task(task);\nout_dput:\n\tdput(sdentry);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SILLYNAME_LEN (SILLYNAME_PREFIX_LEN + \\\n\t\tSILLYNAME_FILEID_LEN + \\\n\t\tSILLYNAME_COUNTER_LEN)",
            "#define SILLYNAME_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)",
            "#define SILLYNAME_FILEID_LEN ((unsigned)sizeof(u64) << 1)",
            "#define SILLYNAME_PREFIX \".nfs\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#define SILLYNAME_LEN (SILLYNAME_PREFIX_LEN + \\\n\t\tSILLYNAME_FILEID_LEN + \\\n\t\tSILLYNAME_COUNTER_LEN)\n#define SILLYNAME_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n#define SILLYNAME_FILEID_LEN ((unsigned)sizeof(u64) << 1)\n#define SILLYNAME_PREFIX \".nfs\"\n\nint\nnfs_sillyrename(struct inode *dir, struct dentry *dentry)\n{\n\tstatic unsigned int sillycounter;\n\tunsigned char silly[SILLYNAME_LEN + 1];\n\tunsigned long long fileid;\n\tstruct dentry *sdentry;\n\tstruct rpc_task *task;\n\tint            error = -EBUSY;\n\n\tdfprintk(VFS, \"NFS: silly-rename(%pd2, ct=%d)\\n\",\n\t\tdentry, d_count(dentry));\n\tnfs_inc_stats(dir, NFSIOS_SILLYRENAME);\n\n\t/*\n\t * We don't allow a dentry to be silly-renamed twice.\n\t */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto out;\n\n\tfileid = NFS_FILEID(dentry->d_inode);\n\n\t/* Return delegation in anticipation of the rename */\n\tNFS_PROTO(dentry->d_inode)->return_delegation(dentry->d_inode);\n\n\tsdentry = NULL;\n\tdo {\n\t\tint slen;\n\t\tdput(sdentry);\n\t\tsillycounter++;\n\t\tslen = scnprintf(silly, sizeof(silly),\n\t\t\t\tSILLYNAME_PREFIX \"%0*llx%0*x\",\n\t\t\t\tSILLYNAME_FILEID_LEN, fileid,\n\t\t\t\tSILLYNAME_COUNTER_LEN, sillycounter);\n\n\t\tdfprintk(VFS, \"NFS: trying to rename %pd to %s\\n\",\n\t\t\t\tdentry, silly);\n\n\t\tsdentry = lookup_one_len(silly, dentry->d_parent, slen);\n\t\t/*\n\t\t * N.B. Better to return EBUSY here ... it could be\n\t\t * dangerous to delete the file while it's in use.\n\t\t */\n\t\tif (IS_ERR(sdentry))\n\t\t\tgoto out;\n\t} while (sdentry->d_inode != NULL); /* need negative lookup */\n\n\t/* queue unlink first. Can't do this from rpc_release as it\n\t * has to allocate memory\n\t */\n\terror = nfs_async_unlink(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\n\t/* populate unlinkdata with the right dname */\n\terror = nfs_copy_dname(sdentry,\n\t\t\t\t(struct nfs_unlinkdata *)dentry->d_fsdata);\n\tif (error) {\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* run the rename task, undo unlink if it fails */\n\ttask = nfs_async_rename(dir, dir, dentry, sdentry,\n\t\t\t\t\tnfs_complete_sillyrename);\n\tif (IS_ERR(task)) {\n\t\terror = -EBUSY;\n\t\tnfs_cancel_async_unlink(dentry);\n\t\tgoto out_dput;\n\t}\n\n\t/* wait for the RPC task to complete, unless a SIGKILL intervenes */\n\terror = rpc_wait_for_completion_task(task);\n\tif (error == 0)\n\t\terror = task->tk_status;\n\tswitch (error) {\n\tcase 0:\n\t\t/* The rename succeeded */\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\td_move(dentry, sdentry);\n\t\tbreak;\n\tcase -ERESTARTSYS:\n\t\t/* The result of the rename is unknown. Play it safe by\n\t\t * forcing a new lookup */\n\t\td_drop(dentry);\n\t\td_drop(sdentry);\n\t}\n\trpc_put_task(task);\nout_dput:\n\tdput(sdentry);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "dentry->d_inode",
            "0"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "dentry"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_unlink_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: unlink(%s/%lu, %pd)\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\tint need_rehash = 0;\n\n\tdfprintk(VFS, \"NFS: unlink(%s/%lu, %pd)\\n\", dir->i_sb->s_id,\n\t\tdir->i_ino, dentry);\n\n\ttrace_nfs_unlink_enter(dir, dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (d_count(dentry) > 1) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\t/* Start asynchronous writeout of the inode */\n\t\twrite_inode_now(dentry->d_inode, 0);\n\t\terror = nfs_sillyrename(dir, dentry);\n\t\tgoto out;\n\t}\n\tif (!d_unhashed(dentry)) {\n\t\t__d_drop(dentry);\n\t\tneed_rehash = 1;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\terror = nfs_safe_remove(dentry);\n\tif (!error || error == -ENOENT) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t} else if (need_rehash)\n\t\td_rehash(dentry);\nout:\n\ttrace_nfs_unlink_exit(dir, dentry, error);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_safe_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1809-1836",
    "snippet": "static int nfs_safe_remove(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EBUSY;\n\t\t\n\tdfprintk(VFS, \"NFS: safe_remove(%pd2)\\n\", dentry);\n\n\t/* If the dentry was sillyrenamed, we simply call d_delete() */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_nfs_remove_enter(dir, dentry);\n\tif (inode != NULL) {\n\t\tNFS_PROTO(inode)->return_delegation(inode);\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\t\tif (error == 0)\n\t\t\tnfs_drop_nlink(inode);\n\t} else\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\tif (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(dentry);\n\ttrace_nfs_remove_exit(dir, dentry, error);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_remove_exit",
          "args": [
            "dir",
            "dentry",
            "error"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_dentry_handle_enoent",
          "args": [
            "dentry"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dentry_handle_enoent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1769-1773",
          "snippet": "static void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "&dentry->d_name"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1307-1315",
          "snippet": "static void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "&dentry->d_name"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_remove_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: safe_remove(%pd2)\\n\"",
            "dentry"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_safe_remove(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EBUSY;\n\t\t\n\tdfprintk(VFS, \"NFS: safe_remove(%pd2)\\n\", dentry);\n\n\t/* If the dentry was sillyrenamed, we simply call d_delete() */\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\ttrace_nfs_remove_enter(dir, dentry);\n\tif (inode != NULL) {\n\t\tNFS_PROTO(inode)->return_delegation(inode);\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\t\tif (error == 0)\n\t\t\tnfs_drop_nlink(inode);\n\t} else\n\t\terror = NFS_PROTO(dir)->remove(dir, &dentry->d_name);\n\tif (error == -ENOENT)\n\t\tnfs_dentry_handle_enoent(dentry);\n\ttrace_nfs_remove_exit(dir, dentry, error);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1775-1799",
    "snippet": "int nfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tdfprintk(VFS, \"NFS: rmdir(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\ttrace_nfs_rmdir_enter(dir, dentry);\n\tif (dentry->d_inode) {\n\t\tnfs_wait_on_sillyrename(dentry);\n\t\terror = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);\n\t\t/* Ensure the VFS deletes this inode */\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tclear_nlink(dentry->d_inode);\n\t\t\tbreak;\n\t\tcase -ENOENT:\n\t\t\tnfs_dentry_handle_enoent(dentry);\n\t\t}\n\t} else\n\t\terror = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);\n\ttrace_nfs_rmdir_exit(dir, dentry, error);\n\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_rmdir_exit",
          "args": [
            "dir",
            "dentry",
            "error"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "&dentry->d_name"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_dentry_handle_enoent",
          "args": [
            "dentry"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dentry_handle_enoent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1769-1773",
          "snippet": "static void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "&dentry->d_name"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_wait_on_sillyrename",
          "args": [
            "dentry"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wait_on_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "211-216",
          "snippet": "void nfs_wait_on_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_read(&nfsi->silly_count) <= 1);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_wait_on_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_read(&nfsi->silly_count) <= 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_rmdir_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: rmdir(%s/%lu), %pd\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tdfprintk(VFS, \"NFS: rmdir(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\ttrace_nfs_rmdir_enter(dir, dentry);\n\tif (dentry->d_inode) {\n\t\tnfs_wait_on_sillyrename(dentry);\n\t\terror = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);\n\t\t/* Ensure the VFS deletes this inode */\n\t\tswitch (error) {\n\t\tcase 0:\n\t\t\tclear_nlink(dentry->d_inode);\n\t\t\tbreak;\n\t\tcase -ENOENT:\n\t\t\tnfs_dentry_handle_enoent(dentry);\n\t\t}\n\t} else\n\t\terror = NFS_PROTO(dir)->rmdir(dir, &dentry->d_name);\n\ttrace_nfs_rmdir_exit(dir, dentry, error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_dentry_handle_enoent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1769-1773",
    "snippet": "static void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "afs_d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "699-717",
          "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_dentry_handle_enoent(struct dentry *dentry)\n{\n\tif (dentry->d_inode != NULL && !d_unhashed(dentry))\n\t\td_delete(dentry);\n}"
  },
  {
    "function_name": "nfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1746-1766",
    "snippet": "int nfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct iattr attr;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: mkdir(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tattr.ia_valid = ATTR_MODE;\n\tattr.ia_mode = mode | S_IFDIR;\n\n\ttrace_nfs_mkdir_enter(dir, dentry);\n\terror = NFS_PROTO(dir)->mkdir(dir, dentry, &attr);\n\ttrace_nfs_mkdir_exit(dir, dentry, error);\n\tif (error != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_mkdir_exit",
          "args": [
            "dir",
            "dentry",
            "error"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "dentry",
            "&attr"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_mkdir_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: mkdir(%s/%lu), %pd\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct iattr attr;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: mkdir(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tattr.ia_valid = ATTR_MODE;\n\tattr.ia_mode = mode | S_IFDIR;\n\n\ttrace_nfs_mkdir_enter(dir, dentry);\n\terror = NFS_PROTO(dir)->mkdir(dir, dentry, &attr);\n\ttrace_nfs_mkdir_exit(dir, dentry, error);\n\tif (error != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1716-1740",
    "snippet": "int\nnfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct iattr attr;\n\tint status;\n\n\tdfprintk(VFS, \"NFS: mknod(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tattr.ia_mode = mode;\n\tattr.ia_valid = ATTR_MODE;\n\n\ttrace_nfs_mknod_enter(dir, dentry);\n\tstatus = NFS_PROTO(dir)->mknod(dir, dentry, &attr, rdev);\n\ttrace_nfs_mknod_exit(dir, dentry, status);\n\tif (status != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_mknod_exit",
          "args": [
            "dir",
            "dentry",
            "status"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "dentry",
            "&attr",
            "rdev"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_mknod_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: mknod(%s/%lu), %pd\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint\nnfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tstruct iattr attr;\n\tint status;\n\n\tdfprintk(VFS, \"NFS: mknod(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tattr.ia_mode = mode;\n\tattr.ia_valid = ATTR_MODE;\n\n\ttrace_nfs_mknod_enter(dir, dentry);\n\tstatus = NFS_PROTO(dir)->mknod(dir, dentry, &attr, rdev);\n\ttrace_nfs_mknod_exit(dir, dentry, status);\n\tif (status != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1688-1710",
    "snippet": "int nfs_create(struct inode *dir, struct dentry *dentry,\n\t\tumode_t mode, bool excl)\n{\n\tstruct iattr attr;\n\tint open_flags = excl ? O_CREAT | O_EXCL : O_CREAT;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: create(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tattr.ia_mode = mode;\n\tattr.ia_valid = ATTR_MODE;\n\n\ttrace_nfs_create_enter(dir, dentry, open_flags);\n\terror = NFS_PROTO(dir)->create(dir, dentry, &attr, open_flags);\n\ttrace_nfs_create_exit(dir, dentry, open_flags, error);\n\tif (error != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_create_exit",
          "args": [
            "dir",
            "dentry",
            "open_flags",
            "error"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "dentry",
            "&attr",
            "open_flags"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_create_enter",
          "args": [
            "dir",
            "dentry",
            "open_flags"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: create(%s/%lu), %pd\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_create(struct inode *dir, struct dentry *dentry,\n\t\tumode_t mode, bool excl)\n{\n\tstruct iattr attr;\n\tint open_flags = excl ? O_CREAT | O_EXCL : O_CREAT;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: create(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\tattr.ia_mode = mode;\n\tattr.ia_valid = ATTR_MODE;\n\n\ttrace_nfs_create_enter(dir, dentry, open_flags);\n\terror = NFS_PROTO(dir)->create(dir, dentry, &attr, open_flags);\n\ttrace_nfs_create_exit(dir, dentry, open_flags, error);\n\tif (error != 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\td_drop(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1641-1679",
    "snippet": "int nfs_instantiate(struct dentry *dentry, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr,\n\t\t\t\tstruct nfs4_label *label)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tint error = -EACCES;\n\n\td_drop(dentry);\n\n\t/* We may have been initialized further down */\n\tif (dentry->d_inode)\n\t\tgoto out;\n\tif (fhandle->size == 0) {\n\t\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, NULL);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (!(fattr->valid & NFS_ATTR_FATTR)) {\n\t\tstruct nfs_server *server = NFS_SB(dentry->d_sb);\n\t\terror = server->nfs_client->rpc_ops->getattr(server, fhandle, fattr, NULL);\n\t\tif (error < 0)\n\t\t\tgoto out_error;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr, label);\n\terror = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_error;\n\td_add(dentry, inode);\nout:\n\tdput(parent);\n\treturn 0;\nout_error:\n\tnfs_mark_for_revalidate(dir);\n\tdput(parent);\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_for_revalidate",
          "args": [
            "dir"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fhget",
          "args": [
            "dentry->d_sb",
            "fhandle",
            "fattr",
            "label"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fhget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "343-490",
          "snippet": "struct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->nfs_client->rpc_ops->getattr",
          "args": [
            "server",
            "fhandle",
            "fattr",
            "NULL"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "&dentry->d_name",
            "fhandle",
            "fattr",
            "NULL"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_instantiate(struct dentry *dentry, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr,\n\t\t\t\tstruct nfs4_label *label)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tint error = -EACCES;\n\n\td_drop(dentry);\n\n\t/* We may have been initialized further down */\n\tif (dentry->d_inode)\n\t\tgoto out;\n\tif (fhandle->size == 0) {\n\t\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, NULL);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (!(fattr->valid & NFS_ATTR_FATTR)) {\n\t\tstruct nfs_server *server = NFS_SB(dentry->d_sb);\n\t\terror = server->nfs_client->rpc_ops->getattr(server, fhandle, fattr, NULL);\n\t\tif (error < 0)\n\t\t\tgoto out_error;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr, label);\n\terror = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto out_error;\n\td_add(dentry, inode);\nout:\n\tdput(parent);\n\treturn 0;\nout_error:\n\tnfs_mark_for_revalidate(dir);\n\tdput(parent);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs4_lookup_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1578-1634",
    "snippet": "static int nfs4_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tif (!(flags & LOOKUP_OPEN) || (flags & LOOKUP_DIRECTORY))\n\t\tgoto no_open;\n\tif (d_mountpoint(dentry))\n\t\tgoto no_open;\n\tif (NFS_SB(dentry->d_sb)->caps & NFS_CAP_ATOMIC_OPEN_V1)\n\t\tgoto no_open;\n\n\tinode = dentry->d_inode;\n\n\t/* We can't create new files in nfs_open_revalidate(), so we\n\t * optimize away revalidation of negative dentries.\n\t */\n\tif (inode == NULL) {\n\t\tstruct dentry *parent;\n\t\tstruct inode *dir;\n\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tparent = ACCESS_ONCE(dentry->d_parent);\n\t\t\tdir = ACCESS_ONCE(parent->d_inode);\n\t\t\tif (!dir)\n\t\t\t\treturn -ECHILD;\n\t\t} else {\n\t\t\tparent = dget_parent(dentry);\n\t\t\tdir = parent->d_inode;\n\t\t}\n\t\tif (!nfs_neg_need_reval(dir, dentry, flags))\n\t\t\tret = 1;\n\t\telse if (flags & LOOKUP_RCU)\n\t\t\tret = -ECHILD;\n\t\tif (!(flags & LOOKUP_RCU))\n\t\t\tdput(parent);\n\t\telse if (parent != ACCESS_ONCE(dentry->d_parent))\n\t\t\treturn -ECHILD;\n\t\tgoto out;\n\t}\n\n\t/* NFS only supports OPEN on regular files */\n\tif (!S_ISREG(inode->i_mode))\n\t\tgoto no_open;\n\t/* We cannot do exclusive creation on a positive dentry */\n\tif (flags & LOOKUP_EXCL)\n\t\tgoto no_open;\n\n\t/* Let f_op->open() actually open (and revalidate) the file */\n\tret = 1;\n\nout:\n\treturn ret;\n\nno_open:\n\treturn nfs_lookup_revalidate(dentry, flags);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_lookup_revalidate",
          "args": [
            "dentry",
            "flags"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_lookup_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1109-1242",
          "snippet": "static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *dir;\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tif (flags & LOOKUP_RCU) {\n\t\tparent = ACCESS_ONCE(dentry->d_parent);\n\t\tdir = ACCESS_ONCE(parent->d_inode);\n\t\tif (!dir)\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tparent = dget_parent(dentry);\n\t\tdir = parent->d_inode;\n\t}\n\tnfs_inc_stats(dir, NFSIOS_DENTRYREVALIDATE);\n\tinode = dentry->d_inode;\n\n\tif (!inode) {\n\t\tif (nfs_neg_need_reval(dir, dentry, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_bad;\n\t\t}\n\t\tgoto out_valid_noent;\n\t}\n\n\tif (is_bad_inode(inode)) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\treturn -ECHILD;\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\tgoto out_bad;\n\t}\n\n\tif (NFS_PROTO(dir)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_set_verifier;\n\n\t/* Force a full look up iff the parent directory has changed */\n\tif (!nfs_is_exclusive_create(dir, flags) &&\n\t    nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU)) {\n\n\t\tif (nfs_lookup_verify_inode(inode, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_zap_parent;\n\t\t}\n\t\tgoto out_valid;\n\t}\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (NFS_STALE(inode))\n\t\tgoto out_bad;\n\n\terror = -ENOMEM;\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out_error;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out_error;\n\n\ttrace_nfs_lookup_revalidate_enter(dir, dentry, flags);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\ttrace_nfs_lookup_revalidate_exit(dir, dentry, flags, error);\n\tif (error)\n\t\tgoto out_bad;\n\tif (nfs_compare_fh(NFS_FH(inode), fhandle))\n\t\tgoto out_bad;\n\tif ((error = nfs_refresh_inode(inode, fattr)) != 0)\n\t\tgoto out_bad;\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\nout_set_verifier:\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n out_valid:\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n out_valid_noent:\n\tif (flags & LOOKUP_RCU) {\n\t\tif (parent != ACCESS_ONCE(dentry->d_parent))\n\t\t\treturn -ECHILD;\n\t} else\n\t\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is valid\\n\",\n\t\t\t__func__, dentry);\n\treturn 1;\nout_zap_parent:\n\tnfs_zap_caches(dir);\n out_bad:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tnfs_mark_for_revalidate(dir);\n\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t/* Purge readdir caches. */\n\t\tnfs_zap_caches(inode);\n\t\t/*\n\t\t * We can't d_drop the root of a disconnected tree:\n\t\t * its d_hash is on the s_anon list and d_drop() would hide\n\t\t * it from shrink_dcache_for_unmount(), leading to busy\n\t\t * inodes on unmount and further oopses.\n\t\t */\n\t\tif (IS_ROOT(dentry))\n\t\t\tgoto out_valid;\n\t}\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is invalid\\n\",\n\t\t\t__func__, dentry);\n\treturn 0;\nout_error:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) lookup returned error %d\\n\",\n\t\t\t__func__, dentry, error);\n\treturn error;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *dir;\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tif (flags & LOOKUP_RCU) {\n\t\tparent = ACCESS_ONCE(dentry->d_parent);\n\t\tdir = ACCESS_ONCE(parent->d_inode);\n\t\tif (!dir)\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tparent = dget_parent(dentry);\n\t\tdir = parent->d_inode;\n\t}\n\tnfs_inc_stats(dir, NFSIOS_DENTRYREVALIDATE);\n\tinode = dentry->d_inode;\n\n\tif (!inode) {\n\t\tif (nfs_neg_need_reval(dir, dentry, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_bad;\n\t\t}\n\t\tgoto out_valid_noent;\n\t}\n\n\tif (is_bad_inode(inode)) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\treturn -ECHILD;\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\tgoto out_bad;\n\t}\n\n\tif (NFS_PROTO(dir)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_set_verifier;\n\n\t/* Force a full look up iff the parent directory has changed */\n\tif (!nfs_is_exclusive_create(dir, flags) &&\n\t    nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU)) {\n\n\t\tif (nfs_lookup_verify_inode(inode, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_zap_parent;\n\t\t}\n\t\tgoto out_valid;\n\t}\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (NFS_STALE(inode))\n\t\tgoto out_bad;\n\n\terror = -ENOMEM;\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out_error;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out_error;\n\n\ttrace_nfs_lookup_revalidate_enter(dir, dentry, flags);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\ttrace_nfs_lookup_revalidate_exit(dir, dentry, flags, error);\n\tif (error)\n\t\tgoto out_bad;\n\tif (nfs_compare_fh(NFS_FH(inode), fhandle))\n\t\tgoto out_bad;\n\tif ((error = nfs_refresh_inode(inode, fattr)) != 0)\n\t\tgoto out_bad;\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\nout_set_verifier:\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n out_valid:\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n out_valid_noent:\n\tif (flags & LOOKUP_RCU) {\n\t\tif (parent != ACCESS_ONCE(dentry->d_parent))\n\t\t\treturn -ECHILD;\n\t} else\n\t\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is valid\\n\",\n\t\t\t__func__, dentry);\n\treturn 1;\nout_zap_parent:\n\tnfs_zap_caches(dir);\n out_bad:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tnfs_mark_for_revalidate(dir);\n\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t/* Purge readdir caches. */\n\t\tnfs_zap_caches(inode);\n\t\t/*\n\t\t * We can't d_drop the root of a disconnected tree:\n\t\t * its d_hash is on the s_anon list and d_drop() would hide\n\t\t * it from shrink_dcache_for_unmount(), leading to busy\n\t\t * inodes on unmount and further oopses.\n\t\t */\n\t\tif (IS_ROOT(dentry))\n\t\t\tgoto out_valid;\n\t}\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is invalid\\n\",\n\t\t\t__func__, dentry);\n\treturn 0;\nout_error:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) lookup returned error %d\\n\",\n\t\t\t__func__, dentry, error);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "dentry->d_parent"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_neg_need_reval",
          "args": [
            "dir",
            "dentry",
            "flags"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_neg_need_reval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1086-1096",
          "snippet": "static inline\nint nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,\n\t\t       unsigned int flags)\n{\n\t/* Don't revalidate a negative dentry if we're creating a new file */\n\tif (flags & LOOKUP_CREATE)\n\t\treturn 0;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG)\n\t\treturn 1;\n\treturn !nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic inline\nint nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,\n\t\t       unsigned int flags)\n{\n\t/* Don't revalidate a negative dentry if we're creating a new file */\n\tif (flags & LOOKUP_CREATE)\n\t\treturn 0;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG)\n\t\treturn 1;\n\treturn !nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "parent->d_inode"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "dentry->d_parent"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic int nfs4_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tif (!(flags & LOOKUP_OPEN) || (flags & LOOKUP_DIRECTORY))\n\t\tgoto no_open;\n\tif (d_mountpoint(dentry))\n\t\tgoto no_open;\n\tif (NFS_SB(dentry->d_sb)->caps & NFS_CAP_ATOMIC_OPEN_V1)\n\t\tgoto no_open;\n\n\tinode = dentry->d_inode;\n\n\t/* We can't create new files in nfs_open_revalidate(), so we\n\t * optimize away revalidation of negative dentries.\n\t */\n\tif (inode == NULL) {\n\t\tstruct dentry *parent;\n\t\tstruct inode *dir;\n\n\t\tif (flags & LOOKUP_RCU) {\n\t\t\tparent = ACCESS_ONCE(dentry->d_parent);\n\t\t\tdir = ACCESS_ONCE(parent->d_inode);\n\t\t\tif (!dir)\n\t\t\t\treturn -ECHILD;\n\t\t} else {\n\t\t\tparent = dget_parent(dentry);\n\t\t\tdir = parent->d_inode;\n\t\t}\n\t\tif (!nfs_neg_need_reval(dir, dentry, flags))\n\t\t\tret = 1;\n\t\telse if (flags & LOOKUP_RCU)\n\t\t\tret = -ECHILD;\n\t\tif (!(flags & LOOKUP_RCU))\n\t\t\tdput(parent);\n\t\telse if (parent != ACCESS_ONCE(dentry->d_parent))\n\t\t\treturn -ECHILD;\n\t\tgoto out;\n\t}\n\n\t/* NFS only supports OPEN on regular files */\n\tif (!S_ISREG(inode->i_mode))\n\t\tgoto no_open;\n\t/* We cannot do exclusive creation on a positive dentry */\n\tif (flags & LOOKUP_EXCL)\n\t\tgoto no_open;\n\n\t/* Let f_op->open() actually open (and revalidate) the file */\n\tret = 1;\n\nout:\n\treturn ret;\n\nno_open:\n\treturn nfs_lookup_revalidate(dentry, flags);\n}"
  },
  {
    "function_name": "nfs_atomic_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1482-1575",
    "snippet": "int nfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t    struct file *file, unsigned open_flags,\n\t\t    umode_t mode, int *opened)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *res;\n\tstruct iattr attr = { .ia_valid = ATTR_OPEN };\n\tstruct inode *inode;\n\tunsigned int lookup_flags = 0;\n\tint err;\n\n\t/* Expect a negative dentry */\n\tBUG_ON(dentry->d_inode);\n\n\tdfprintk(VFS, \"NFS: atomic_open(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\terr = nfs_check_flags(open_flags);\n\tif (err)\n\t\treturn err;\n\n\t/* NFS only supports OPEN on regular files */\n\tif ((open_flags & O_DIRECTORY)) {\n\t\tif (!d_unhashed(dentry)) {\n\t\t\t/*\n\t\t\t * Hashed negative dentry with O_DIRECTORY: dentry was\n\t\t\t * revalidated and is fine, no need to perform lookup\n\t\t\t * again\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tlookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY;\n\t\tgoto no_open;\n\t}\n\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\treturn -ENAMETOOLONG;\n\n\tif (open_flags & O_CREAT) {\n\t\tattr.ia_valid |= ATTR_MODE;\n\t\tattr.ia_mode = mode & ~current_umask();\n\t}\n\tif (open_flags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t}\n\n\tctx = create_nfs_open_context(dentry, open_flags);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\ttrace_nfs_atomic_open_enter(dir, ctx, open_flags);\n\tnfs_block_sillyrename(dentry->d_parent);\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr, opened);\n\tnfs_unblock_sillyrename(dentry->d_parent);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\t\tput_nfs_open_context(ctx);\n\t\tswitch (err) {\n\t\tcase -ENOENT:\n\t\t\td_drop(dentry);\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t\tbreak;\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\t\tgoto no_open;\n\t\tcase -ELOOP:\n\t\t\tif (!(open_flags & O_NOFOLLOW))\n\t\t\t\tgoto no_open;\n\t\t\tbreak;\n\t\t\t/* case -EINVAL: */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\terr = nfs_finish_open(ctx, ctx->dentry, file, open_flags, opened);\n\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\tput_nfs_open_context(ctx);\nout:\n\treturn err;\n\nno_open:\n\tres = nfs_lookup(dir, dentry, lookup_flags);\n\terr = PTR_ERR(res);\n\tif (IS_ERR(res))\n\t\tgoto out;\n\n\treturn finish_no_open(file, res);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "res"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_lookup",
          "args": [
            "dir",
            "dentry",
            "lookup_flags"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1355-1427",
          "snippet": "struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct dentry *parent;\n\tstruct inode *inode = NULL;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: lookup(%pd2)\\n\", dentry);\n\tnfs_inc_stats(dir, NFSIOS_VFSLOOKUP);\n\n\tres = ERR_PTR(-ENAMETOOLONG);\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\tgoto out;\n\n\t/*\n\t * If we're doing an exclusive create, optimize away the lookup\n\t * but don't hash the dentry.\n\t */\n\tif (nfs_is_exclusive_create(dir, flags)) {\n\t\td_instantiate(dentry, NULL);\n\t\tres = NULL;\n\t\tgoto out;\n\t}\n\n\tres = ERR_PTR(-ENOMEM);\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(dir), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out;\n\n\tparent = dentry->d_parent;\n\t/* Protect against concurrent sillydeletes */\n\ttrace_nfs_lookup_enter(dir, dentry, flags);\n\tnfs_block_sillyrename(parent);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\tif (error == -ENOENT)\n\t\tgoto no_entry;\n\tif (error < 0) {\n\t\tres = ERR_PTR(error);\n\t\tgoto out_unblock_sillyrename;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr, label);\n\tres = ERR_CAST(inode);\n\tif (IS_ERR(res))\n\t\tgoto out_unblock_sillyrename;\n\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n\nno_entry:\n\tres = d_splice_alias(inode, dentry);\n\tif (res != NULL) {\n\t\tif (IS_ERR(res))\n\t\t\tgoto out_unblock_sillyrename;\n\t\tdentry = res;\n\t}\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\nout_unblock_sillyrename:\n\tnfs_unblock_sillyrename(parent);\n\ttrace_nfs_lookup_exit(dir, dentry, flags, error);\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct dentry *parent;\n\tstruct inode *inode = NULL;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: lookup(%pd2)\\n\", dentry);\n\tnfs_inc_stats(dir, NFSIOS_VFSLOOKUP);\n\n\tres = ERR_PTR(-ENAMETOOLONG);\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\tgoto out;\n\n\t/*\n\t * If we're doing an exclusive create, optimize away the lookup\n\t * but don't hash the dentry.\n\t */\n\tif (nfs_is_exclusive_create(dir, flags)) {\n\t\td_instantiate(dentry, NULL);\n\t\tres = NULL;\n\t\tgoto out;\n\t}\n\n\tres = ERR_PTR(-ENOMEM);\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(dir), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out;\n\n\tparent = dentry->d_parent;\n\t/* Protect against concurrent sillydeletes */\n\ttrace_nfs_lookup_enter(dir, dentry, flags);\n\tnfs_block_sillyrename(parent);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\tif (error == -ENOENT)\n\t\tgoto no_entry;\n\tif (error < 0) {\n\t\tres = ERR_PTR(error);\n\t\tgoto out_unblock_sillyrename;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr, label);\n\tres = ERR_CAST(inode);\n\tif (IS_ERR(res))\n\t\tgoto out_unblock_sillyrename;\n\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n\nno_entry:\n\tres = d_splice_alias(inode, dentry);\n\tif (res != NULL) {\n\t\tif (IS_ERR(res))\n\t\t\tgoto out_unblock_sillyrename;\n\t\tdentry = res;\n\t}\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\nout_unblock_sillyrename:\n\tnfs_unblock_sillyrename(parent);\n\ttrace_nfs_lookup_exit(dir, dentry, flags, error);\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nfs_open_context",
          "args": [
            "ctx"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "833-836",
          "snippet": "void put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_atomic_open_exit",
          "args": [
            "dir",
            "ctx",
            "open_flags",
            "err"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_finish_open",
          "args": [
            "ctx",
            "ctx->dentry",
            "file",
            "open_flags",
            "opened"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1463-1480",
          "snippet": "static int nfs_finish_open(struct nfs_open_context *ctx,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct file *file, unsigned open_flags,\n\t\t\t   int *opened)\n{\n\tint err;\n\n\tif ((open_flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t*opened |= FILE_CREATED;\n\n\terr = finish_open(file, dentry, do_open, opened);\n\tif (err)\n\t\tgoto out;\n\tnfs_file_set_open_context(file, ctx);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic int nfs_finish_open(struct nfs_open_context *ctx,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct file *file, unsigned open_flags,\n\t\t\t   int *opened)\n{\n\tint err;\n\n\tif ((open_flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t*opened |= FILE_CREATED;\n\n\terr = finish_open(file, dentry, do_open, opened);\n\tif (err)\n\t\tgoto out;\n\tnfs_file_set_open_context(file, ctx);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_atomic_open_exit",
          "args": [
            "dir",
            "ctx",
            "open_flags",
            "err"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_unblock_sillyrename",
          "args": [
            "dentry->d_parent"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unblock_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "225-244",
          "snippet": "void nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "ctx",
            "open_flags",
            "&attr",
            "opened"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_block_sillyrename",
          "args": [
            "dentry->d_parent"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_block_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "218-223",
          "snippet": "void nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_atomic_open_enter",
          "args": [
            "dir",
            "ctx",
            "open_flags"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_nfs_open_context",
          "args": [
            "dentry",
            "open_flags"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "create_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1452-1455",
          "snippet": "static struct nfs_open_context *create_nfs_open_context(struct dentry *dentry, int open_flags)\n{\n\treturn alloc_nfs_open_context(dentry, flags_to_mode(open_flags));\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct nfs_open_context *create_nfs_open_context(struct dentry *dentry, int open_flags)\n{\n\treturn alloc_nfs_open_context(dentry, flags_to_mode(open_flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "dir"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_check_flags",
          "args": [
            "open_flags"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/file.c",
          "lines": "52-58",
          "snippet": "int nfs_check_flags(int flags)\n{\n\tif ((flags & (O_APPEND | O_DIRECT)) == (O_APPEND | O_DIRECT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/swap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint nfs_check_flags(int flags)\n{\n\tif ((flags & (O_APPEND | O_DIRECT)) == (O_APPEND | O_DIRECT))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: atomic_open(%s/%lu), %pd\\n\"",
            "dir->i_sb->s_id",
            "dir->i_ino",
            "dentry"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nint nfs_atomic_open(struct inode *dir, struct dentry *dentry,\n\t\t    struct file *file, unsigned open_flags,\n\t\t    umode_t mode, int *opened)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *res;\n\tstruct iattr attr = { .ia_valid = ATTR_OPEN };\n\tstruct inode *inode;\n\tunsigned int lookup_flags = 0;\n\tint err;\n\n\t/* Expect a negative dentry */\n\tBUG_ON(dentry->d_inode);\n\n\tdfprintk(VFS, \"NFS: atomic_open(%s/%lu), %pd\\n\",\n\t\t\tdir->i_sb->s_id, dir->i_ino, dentry);\n\n\terr = nfs_check_flags(open_flags);\n\tif (err)\n\t\treturn err;\n\n\t/* NFS only supports OPEN on regular files */\n\tif ((open_flags & O_DIRECTORY)) {\n\t\tif (!d_unhashed(dentry)) {\n\t\t\t/*\n\t\t\t * Hashed negative dentry with O_DIRECTORY: dentry was\n\t\t\t * revalidated and is fine, no need to perform lookup\n\t\t\t * again\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tlookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY;\n\t\tgoto no_open;\n\t}\n\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\treturn -ENAMETOOLONG;\n\n\tif (open_flags & O_CREAT) {\n\t\tattr.ia_valid |= ATTR_MODE;\n\t\tattr.ia_mode = mode & ~current_umask();\n\t}\n\tif (open_flags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t}\n\n\tctx = create_nfs_open_context(dentry, open_flags);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\ttrace_nfs_atomic_open_enter(dir, ctx, open_flags);\n\tnfs_block_sillyrename(dentry->d_parent);\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr, opened);\n\tnfs_unblock_sillyrename(dentry->d_parent);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\t\tput_nfs_open_context(ctx);\n\t\tswitch (err) {\n\t\tcase -ENOENT:\n\t\t\td_drop(dentry);\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t\tbreak;\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\t\tgoto no_open;\n\t\tcase -ELOOP:\n\t\t\tif (!(open_flags & O_NOFOLLOW))\n\t\t\t\tgoto no_open;\n\t\t\tbreak;\n\t\t\t/* case -EINVAL: */\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\terr = nfs_finish_open(ctx, ctx->dentry, file, open_flags, opened);\n\ttrace_nfs_atomic_open_exit(dir, ctx, open_flags, err);\n\tput_nfs_open_context(ctx);\nout:\n\treturn err;\n\nno_open:\n\tres = nfs_lookup(dir, dentry, lookup_flags);\n\terr = PTR_ERR(res);\n\tif (IS_ERR(res))\n\t\tgoto out;\n\n\treturn finish_no_open(file, res);\n}"
  },
  {
    "function_name": "nfs_finish_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1463-1480",
    "snippet": "static int nfs_finish_open(struct nfs_open_context *ctx,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct file *file, unsigned open_flags,\n\t\t\t   int *opened)\n{\n\tint err;\n\n\tif ((open_flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t*opened |= FILE_CREATED;\n\n\terr = finish_open(file, dentry, do_open, opened);\n\tif (err)\n\t\tgoto out;\n\tnfs_file_set_open_context(file, ctx);\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_file_set_open_context",
          "args": [
            "file",
            "ctx"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_file_set_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "854-859",
          "snippet": "void nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tif (list_empty(&ctx->list))\n\t\tnfs_inode_attach_open_context(ctx);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_file_set_open_context(struct file *filp, struct nfs_open_context *ctx)\n{\n\tfilp->private_data = get_nfs_open_context(ctx);\n\tif (list_empty(&ctx->list))\n\t\tnfs_inode_attach_open_context(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "dentry",
            "do_open",
            "opened"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic int nfs_finish_open(struct nfs_open_context *ctx,\n\t\t\t   struct dentry *dentry,\n\t\t\t   struct file *file, unsigned open_flags,\n\t\t\t   int *opened)\n{\n\tint err;\n\n\tif ((open_flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t*opened |= FILE_CREATED;\n\n\terr = finish_open(file, dentry, do_open, opened);\n\tif (err)\n\t\tgoto out;\n\tnfs_file_set_open_context(file, ctx);\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "do_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1457-1461",
    "snippet": "static int do_open(struct inode *inode, struct file *filp)\n{\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_fscache_open_file",
          "args": [
            "inode",
            "filp"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_open_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "233-252",
          "snippet": "void nfs_fscache_open_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn;\n\n\tif (inode_is_open_for_write(inode)) {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p disabling cache\\n\", nfsi);\n\t\tclear_bit(NFS_INO_FSCACHE, &nfsi->flags);\n\t\tfscache_disable_cookie(cookie, true);\n\t\tfscache_uncache_all_inode_pages(cookie, inode);\n\t} else {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p enabling cache\\n\", nfsi);\n\t\tfscache_enable_cookie(cookie, nfs_fscache_can_enable, inode);\n\t\tif (fscache_cookie_enabled(cookie))\n\t\t\tset_bit(NFS_INO_FSCACHE, &NFS_I(inode)->flags);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid nfs_fscache_open_file(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct fscache_cookie *cookie = nfs_i_fscache(inode);\n\n\tif (!fscache_cookie_valid(cookie))\n\t\treturn;\n\n\tif (inode_is_open_for_write(inode)) {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p disabling cache\\n\", nfsi);\n\t\tclear_bit(NFS_INO_FSCACHE, &nfsi->flags);\n\t\tfscache_disable_cookie(cookie, true);\n\t\tfscache_uncache_all_inode_pages(cookie, inode);\n\t} else {\n\t\tdfprintk(FSCACHE, \"NFS: nfsi 0x%p enabling cache\\n\", nfsi);\n\t\tfscache_enable_cookie(cookie, nfs_fscache_can_enable, inode);\n\t\tif (fscache_cookie_enabled(cookie))\n\t\t\tset_bit(NFS_INO_FSCACHE, &NFS_I(inode)->flags);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic int do_open(struct inode *inode, struct file *filp)\n{\n\tnfs_fscache_open_file(inode, filp);\n\treturn 0;\n}"
  },
  {
    "function_name": "create_nfs_open_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1452-1455",
    "snippet": "static struct nfs_open_context *create_nfs_open_context(struct dentry *dentry, int open_flags)\n{\n\treturn alloc_nfs_open_context(dentry, flags_to_mode(open_flags));\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_nfs_open_context",
          "args": [
            "dentry",
            "flags_to_mode(open_flags)"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "776-800",
          "snippet": "struct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry, fmode_t f_mode)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct rpc_cred *cred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn ERR_CAST(cred);\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tput_rpccred(cred);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnfs_sb_active(dentry->d_sb);\n\tctx->dentry = dget(dentry);\n\tctx->cred = cred;\n\tctx->state = NULL;\n\tctx->mode = f_mode;\n\tctx->flags = 0;\n\tctx->error = 0;\n\tnfs_init_lock_context(&ctx->lock_context);\n\tctx->lock_context.open_context = ctx;\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->mdsthreshold = NULL;\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_open_context *alloc_nfs_open_context(struct dentry *dentry, fmode_t f_mode)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct rpc_cred *cred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn ERR_CAST(cred);\n\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tput_rpccred(cred);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnfs_sb_active(dentry->d_sb);\n\tctx->dentry = dget(dentry);\n\tctx->cred = cred;\n\tctx->state = NULL;\n\tctx->mode = f_mode;\n\tctx->flags = 0;\n\tctx->error = 0;\n\tnfs_init_lock_context(&ctx->lock_context);\n\tctx->lock_context.open_context = ctx;\n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->mdsthreshold = NULL;\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flags_to_mode",
          "args": [
            "open_flags"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "flags_to_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1442-1450",
          "snippet": "static fmode_t flags_to_mode(int flags)\n{\n\tfmode_t res = (__force fmode_t)flags & FMODE_EXEC;\n\tif ((flags & O_ACCMODE) != O_WRONLY)\n\t\tres |= FMODE_READ;\n\tif ((flags & O_ACCMODE) != O_RDONLY)\n\t\tres |= FMODE_WRITE;\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic fmode_t flags_to_mode(int flags)\n{\n\tfmode_t res = (__force fmode_t)flags & FMODE_EXEC;\n\tif ((flags & O_ACCMODE) != O_WRONLY)\n\t\tres |= FMODE_READ;\n\tif ((flags & O_ACCMODE) != O_RDONLY)\n\t\tres |= FMODE_WRITE;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct nfs_open_context *create_nfs_open_context(struct dentry *dentry, int open_flags)\n{\n\treturn alloc_nfs_open_context(dentry, flags_to_mode(open_flags));\n}"
  },
  {
    "function_name": "flags_to_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1442-1450",
    "snippet": "static fmode_t flags_to_mode(int flags)\n{\n\tfmode_t res = (__force fmode_t)flags & FMODE_EXEC;\n\tif ((flags & O_ACCMODE) != O_WRONLY)\n\t\tres |= FMODE_READ;\n\tif ((flags & O_ACCMODE) != O_RDONLY)\n\t\tres |= FMODE_WRITE;\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic fmode_t flags_to_mode(int flags)\n{\n\tfmode_t res = (__force fmode_t)flags & FMODE_EXEC;\n\tif ((flags & O_ACCMODE) != O_WRONLY)\n\t\tres |= FMODE_READ;\n\tif ((flags & O_ACCMODE) != O_RDONLY)\n\t\tres |= FMODE_WRITE;\n\treturn res;\n}"
  },
  {
    "function_name": "nfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1355-1427",
    "snippet": "struct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct dentry *parent;\n\tstruct inode *inode = NULL;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: lookup(%pd2)\\n\", dentry);\n\tnfs_inc_stats(dir, NFSIOS_VFSLOOKUP);\n\n\tres = ERR_PTR(-ENAMETOOLONG);\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\tgoto out;\n\n\t/*\n\t * If we're doing an exclusive create, optimize away the lookup\n\t * but don't hash the dentry.\n\t */\n\tif (nfs_is_exclusive_create(dir, flags)) {\n\t\td_instantiate(dentry, NULL);\n\t\tres = NULL;\n\t\tgoto out;\n\t}\n\n\tres = ERR_PTR(-ENOMEM);\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(dir), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out;\n\n\tparent = dentry->d_parent;\n\t/* Protect against concurrent sillydeletes */\n\ttrace_nfs_lookup_enter(dir, dentry, flags);\n\tnfs_block_sillyrename(parent);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\tif (error == -ENOENT)\n\t\tgoto no_entry;\n\tif (error < 0) {\n\t\tres = ERR_PTR(error);\n\t\tgoto out_unblock_sillyrename;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr, label);\n\tres = ERR_CAST(inode);\n\tif (IS_ERR(res))\n\t\tgoto out_unblock_sillyrename;\n\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n\nno_entry:\n\tres = d_splice_alias(inode, dentry);\n\tif (res != NULL) {\n\t\tif (IS_ERR(res))\n\t\t\tgoto out_unblock_sillyrename;\n\t\tdentry = res;\n\t}\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\nout_unblock_sillyrename:\n\tnfs_unblock_sillyrename(parent);\n\ttrace_nfs_lookup_exit(dir, dentry, flags, error);\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_free_fhandle",
          "args": [
            "fhandle"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "fattr"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_label_free",
          "args": [
            "label"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_label_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "315-315",
          "snippet": "static inline void nfs4_label_free(void *label) {}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs4_label_free(void *label) {}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_lookup_exit",
          "args": [
            "dir",
            "dentry",
            "flags",
            "error"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_unblock_sillyrename",
          "args": [
            "parent"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unblock_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "225-244",
          "snippet": "void nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_advise_use_readdirplus",
          "args": [
            "dir"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_advise_use_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "448-452",
          "snippet": "static\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fhget",
          "args": [
            "dentry->d_sb",
            "fhandle",
            "fattr",
            "label"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fhget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "343-490",
          "snippet": "struct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "&dentry->d_name",
            "fhandle",
            "fattr",
            "label"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_block_sillyrename",
          "args": [
            "parent"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_block_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "218-223",
          "snippet": "void nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_lookup_enter",
          "args": [
            "dir",
            "dentry",
            "flags"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "label"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_label_alloc",
          "args": [
            "NFS_SERVER(dir)",
            "GFP_NOWAIT"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_label_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "306-329",
          "snippet": "struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label = NULL;\n\tint minor_version = server->nfs_client->cl_minorversion;\n\n\tif (minor_version < 2)\n\t\treturn label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn label;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label = NULL;\n\tint minor_version = server->nfs_client->cl_minorversion;\n\n\tif (minor_version < 2)\n\t\treturn label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn label;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "dir"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fattr",
          "args": [],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1312-1320",
          "snippet": "struct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fhandle",
          "args": [],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1323-1331",
          "snippet": "struct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_is_exclusive_create",
          "args": [
            "dir",
            "flags"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_is_exclusive_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1035-1040",
          "snippet": "static int nfs_is_exclusive_create(struct inode *dir, unsigned int flags)\n{\n\tif (NFS_PROTO(dir)->version == 2)\n\t\treturn 0;\n\treturn flags & LOOKUP_EXCL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_is_exclusive_create(struct inode *dir, unsigned int flags)\n{\n\tif (NFS_PROTO(dir)->version == 2)\n\t\treturn 0;\n\treturn flags & LOOKUP_EXCL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "dir"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "dir",
            "NFSIOS_VFSLOOKUP"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: lookup(%pd2)\\n\"",
            "dentry"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct dentry *nfs_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct dentry *parent;\n\tstruct inode *inode = NULL;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tdfprintk(VFS, \"NFS: lookup(%pd2)\\n\", dentry);\n\tnfs_inc_stats(dir, NFSIOS_VFSLOOKUP);\n\n\tres = ERR_PTR(-ENAMETOOLONG);\n\tif (dentry->d_name.len > NFS_SERVER(dir)->namelen)\n\t\tgoto out;\n\n\t/*\n\t * If we're doing an exclusive create, optimize away the lookup\n\t * but don't hash the dentry.\n\t */\n\tif (nfs_is_exclusive_create(dir, flags)) {\n\t\td_instantiate(dentry, NULL);\n\t\tres = NULL;\n\t\tgoto out;\n\t}\n\n\tres = ERR_PTR(-ENOMEM);\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(dir), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out;\n\n\tparent = dentry->d_parent;\n\t/* Protect against concurrent sillydeletes */\n\ttrace_nfs_lookup_enter(dir, dentry, flags);\n\tnfs_block_sillyrename(parent);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\tif (error == -ENOENT)\n\t\tgoto no_entry;\n\tif (error < 0) {\n\t\tres = ERR_PTR(error);\n\t\tgoto out_unblock_sillyrename;\n\t}\n\tinode = nfs_fhget(dentry->d_sb, fhandle, fattr, label);\n\tres = ERR_CAST(inode);\n\tif (IS_ERR(res))\n\t\tgoto out_unblock_sillyrename;\n\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n\nno_entry:\n\tres = d_splice_alias(inode, dentry);\n\tif (res != NULL) {\n\t\tif (IS_ERR(res))\n\t\t\tgoto out_unblock_sillyrename;\n\t\tdentry = res;\n\t}\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\nout_unblock_sillyrename:\n\tnfs_unblock_sillyrename(parent);\n\ttrace_nfs_lookup_exit(dir, dentry, flags, error);\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\treturn res;\n}"
  },
  {
    "function_name": "nfs_d_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1334-1343",
    "snippet": "static void nfs_d_release(struct dentry *dentry)\n{\n\t/* free cached devname value, if it survived that far */\n\tif (unlikely(dentry->d_fsdata)) {\n\t\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\t\tWARN_ON(1);\n\t\telse\n\t\t\tkfree(dentry->d_fsdata);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dentry->d_fsdata"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_fsdata"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_d_release(struct dentry *dentry)\n{\n\t/* free cached devname value, if it survived that far */\n\tif (unlikely(dentry->d_fsdata)) {\n\t\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\t\tWARN_ON(1);\n\t\telse\n\t\t\tkfree(dentry->d_fsdata);\n\t}\n}"
  },
  {
    "function_name": "nfs_dentry_iput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1321-1332",
    "snippet": "static void nfs_dentry_iput(struct dentry *dentry, struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\t/* drop any readdir cache as it could easily be old */\n\t\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_DATA;\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tnfs_complete_unlink(dentry, inode);\n\t\tnfs_drop_nlink(inode);\n\t}\n\tiput(inode);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_drop_nlink",
          "args": [
            "inode"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1307-1315",
          "snippet": "static void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_complete_unlink",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_complete_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "302-317",
          "snippet": "void\nnfs_complete_unlink(struct dentry *dentry, struct inode *inode)\n{\n\tstruct nfs_unlinkdata\t*data = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdata = dentry->d_fsdata;\n\t\tdentry->d_fsdata = NULL;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\tif (data != NULL && (NFS_STALE(inode) || !nfs_call_unlink(dentry, data)))\n\t\tnfs_free_unlinkdata(data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid\nnfs_complete_unlink(struct dentry *dentry, struct inode *inode)\n{\n\tstruct nfs_unlinkdata\t*data = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tdentry->d_flags &= ~DCACHE_NFSFS_RENAMED;\n\t\tdata = dentry->d_fsdata;\n\t\tdentry->d_fsdata = NULL;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\tif (data != NULL && (NFS_STALE(inode) || !nfs_call_unlink(dentry, data)))\n\t\tnfs_free_unlinkdata(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_dentry_iput(struct dentry *dentry, struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\t/* drop any readdir cache as it could easily be old */\n\t\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_DATA;\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\tnfs_complete_unlink(dentry, inode);\n\t\tnfs_drop_nlink(inode);\n\t}\n\tiput(inode);\n}"
  },
  {
    "function_name": "nfs_drop_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1307-1315",
    "snippet": "static void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_drop_nlink(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t/* drop the inode if we're reasonably sure this is the last link */\n\tif (inode->i_nlink == 1)\n\t\tclear_nlink(inode);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "nfs_dentry_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1284-1304",
    "snippet": "static int nfs_dentry_delete(const struct dentry *dentry)\n{\n\tdfprintk(VFS, \"NFS: dentry_delete(%pd2, %x)\\n\",\n\t\tdentry, dentry->d_flags);\n\n\t/* Unhash any dentry with a stale inode */\n\tif (dentry->d_inode != NULL && NFS_STALE(dentry->d_inode))\n\t\treturn 1;\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\t/* Unhash it, so that ->d_iput() would be called */\n\t\treturn 1;\n\t}\n\tif (!(dentry->d_sb->s_flags & MS_ACTIVE)) {\n\t\t/* Unhash it, so that ancestors of killed async unlink\n\t\t * files will be cleaned up during umount */\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_STALE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "VFS",
            "\"NFS: dentry_delete(%pd2, %x)\\n\"",
            "dentry",
            "dentry->d_flags"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_dentry_delete(const struct dentry *dentry)\n{\n\tdfprintk(VFS, \"NFS: dentry_delete(%pd2, %x)\\n\",\n\t\tdentry, dentry->d_flags);\n\n\t/* Unhash any dentry with a stale inode */\n\tif (dentry->d_inode != NULL && NFS_STALE(dentry->d_inode))\n\t\treturn 1;\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED) {\n\t\t/* Unhash it, so that ->d_iput() would be called */\n\t\treturn 1;\n\t}\n\tif (!(dentry->d_sb->s_flags & MS_ACTIVE)) {\n\t\t/* Unhash it, so that ancestors of killed async unlink\n\t\t * files will be cleaned up during umount */\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "function_name": "nfs_weak_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1253-1279",
    "snippet": "static int nfs_weak_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\t/*\n\t * I believe we can only get a negative dentry here in the case of a\n\t * procfs-style symlink. Just assume it's correct for now, but we may\n\t * eventually need to do something more here.\n\t */\n\tif (!inode) {\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has negative inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\treturn 1;\n\t}\n\n\tif (is_bad_inode(inode)) {\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\treturn 0;\n\t}\n\n\terror = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s: inode %lu is %s\\n\",\n\t\t\t__func__, inode->i_ino, error ? \"invalid\" : \"valid\");\n\treturn !error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "LOOKUPCACHE",
            "\"NFS: %s: inode %lu is %s\\n\"",
            "__func__",
            "inode->i_ino",
            "error ? \"invalid\" : \"valid\""
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_inode",
          "args": [
            "NFS_SERVER(inode)",
            "inode"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_inode_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1022-1029",
          "snippet": "int nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "LOOKUPCACHE",
            "\"%s: %pd2 has dud inode\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "LOOKUPCACHE",
            "\"%s: %pd2 has negative inode\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_weak_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\t/*\n\t * I believe we can only get a negative dentry here in the case of a\n\t * procfs-style symlink. Just assume it's correct for now, but we may\n\t * eventually need to do something more here.\n\t */\n\tif (!inode) {\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has negative inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\treturn 1;\n\t}\n\n\tif (is_bad_inode(inode)) {\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\treturn 0;\n\t}\n\n\terror = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s: inode %lu is %s\\n\",\n\t\t\t__func__, inode->i_ino, error ? \"invalid\" : \"valid\");\n\treturn !error;\n}"
  },
  {
    "function_name": "nfs_lookup_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1109-1242",
    "snippet": "static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *dir;\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tif (flags & LOOKUP_RCU) {\n\t\tparent = ACCESS_ONCE(dentry->d_parent);\n\t\tdir = ACCESS_ONCE(parent->d_inode);\n\t\tif (!dir)\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tparent = dget_parent(dentry);\n\t\tdir = parent->d_inode;\n\t}\n\tnfs_inc_stats(dir, NFSIOS_DENTRYREVALIDATE);\n\tinode = dentry->d_inode;\n\n\tif (!inode) {\n\t\tif (nfs_neg_need_reval(dir, dentry, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_bad;\n\t\t}\n\t\tgoto out_valid_noent;\n\t}\n\n\tif (is_bad_inode(inode)) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\treturn -ECHILD;\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\tgoto out_bad;\n\t}\n\n\tif (NFS_PROTO(dir)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_set_verifier;\n\n\t/* Force a full look up iff the parent directory has changed */\n\tif (!nfs_is_exclusive_create(dir, flags) &&\n\t    nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU)) {\n\n\t\tif (nfs_lookup_verify_inode(inode, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_zap_parent;\n\t\t}\n\t\tgoto out_valid;\n\t}\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (NFS_STALE(inode))\n\t\tgoto out_bad;\n\n\terror = -ENOMEM;\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out_error;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out_error;\n\n\ttrace_nfs_lookup_revalidate_enter(dir, dentry, flags);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\ttrace_nfs_lookup_revalidate_exit(dir, dentry, flags, error);\n\tif (error)\n\t\tgoto out_bad;\n\tif (nfs_compare_fh(NFS_FH(inode), fhandle))\n\t\tgoto out_bad;\n\tif ((error = nfs_refresh_inode(inode, fattr)) != 0)\n\t\tgoto out_bad;\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\nout_set_verifier:\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n out_valid:\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n out_valid_noent:\n\tif (flags & LOOKUP_RCU) {\n\t\tif (parent != ACCESS_ONCE(dentry->d_parent))\n\t\t\treturn -ECHILD;\n\t} else\n\t\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is valid\\n\",\n\t\t\t__func__, dentry);\n\treturn 1;\nout_zap_parent:\n\tnfs_zap_caches(dir);\n out_bad:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tnfs_mark_for_revalidate(dir);\n\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t/* Purge readdir caches. */\n\t\tnfs_zap_caches(inode);\n\t\t/*\n\t\t * We can't d_drop the root of a disconnected tree:\n\t\t * its d_hash is on the s_anon list and d_drop() would hide\n\t\t * it from shrink_dcache_for_unmount(), leading to busy\n\t\t * inodes on unmount and further oopses.\n\t\t */\n\t\tif (IS_ROOT(dentry))\n\t\t\tgoto out_valid;\n\t}\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is invalid\\n\",\n\t\t\t__func__, dentry);\n\treturn 0;\nout_error:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) lookup returned error %d\\n\",\n\t\t\t__func__, dentry, error);\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "LOOKUPCACHE",
            "\"NFS: %s(%pd2) lookup returned error %d\\n\"",
            "__func__",
            "dentry",
            "error"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_label_free",
          "args": [
            "label"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_label_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "315-315",
          "snippet": "static inline void nfs4_label_free(void *label) {}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs4_label_free(void *label) {}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_free_fhandle",
          "args": [
            "fhandle"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "fattr"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "flags & LOOKUP_RCU"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "LOOKUPCACHE",
            "\"NFS: %s(%pd2) is invalid\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_zap_caches",
          "args": [
            "inode"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "189-194",
          "snippet": "void nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_mark_for_revalidate",
          "args": [
            "dir"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fhandle",
          "args": [
            "fhandle"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "fattr"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "flags & LOOKUP_RCU"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "LOOKUPCACHE",
            "\"NFS: %s(%pd2) is valid\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "dentry->d_parent"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_advise_use_readdirplus",
          "args": [
            "dir"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_advise_use_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "448-452",
          "snippet": "static\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fhandle",
          "args": [
            "fhandle"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "fattr"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_setsecurity",
          "args": [
            "inode",
            "fattr",
            "label"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_setsecurity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "332-335",
          "snippet": "void nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_refresh_inode",
          "args": [
            "inode",
            "fattr"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1466-1477",
          "snippet": "int nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_compare_fh",
          "args": [
            "NFS_FH(inode)",
            "fhandle"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "inode"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_lookup_revalidate_exit",
          "args": [
            "dir",
            "dentry",
            "flags",
            "error"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir",
            "&dentry->d_name",
            "fhandle",
            "fattr",
            "label"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_lookup_revalidate_enter",
          "args": [
            "dir",
            "dentry",
            "flags"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "label"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_label_alloc",
          "args": [
            "NFS_SERVER(inode)",
            "GFP_NOWAIT"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_label_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "306-329",
          "snippet": "struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label = NULL;\n\tint minor_version = server->nfs_client->cl_minorversion;\n\n\tif (minor_version < 2)\n\t\treturn label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn label;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label = NULL;\n\tint minor_version = server->nfs_client->cl_minorversion;\n\n\tif (minor_version < 2)\n\t\treturn label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn label;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fattr",
          "args": [],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1312-1320",
          "snippet": "struct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fhandle",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1323-1331",
          "snippet": "struct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_STALE",
          "args": [
            "inode"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_lookup_verify_inode",
          "args": [
            "inode",
            "flags"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_lookup_verify_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1050-1074",
          "snippet": "static\nint nfs_lookup_verify_inode(struct inode *inode, unsigned int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (IS_AUTOMOUNT(inode))\n\t\treturn 0;\n\t/* VFS wants an on-the-wire revalidation */\n\tif (flags & LOOKUP_REVAL)\n\t\tgoto out_force;\n\t/* This is an open(2) */\n\tif ((flags & LOOKUP_OPEN) && !(server->flags & NFS_MOUNT_NOCTO) &&\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))\n\t\tgoto out_force;\nout:\n\treturn (inode->i_nlink == 0) ? -ENOENT : 0;\nout_force:\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tret = __nfs_revalidate_inode(server, inode);\n\tif (ret != 0)\n\t\treturn ret;\n\tgoto out;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nint nfs_lookup_verify_inode(struct inode *inode, unsigned int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (IS_AUTOMOUNT(inode))\n\t\treturn 0;\n\t/* VFS wants an on-the-wire revalidation */\n\tif (flags & LOOKUP_REVAL)\n\t\tgoto out_force;\n\t/* This is an open(2) */\n\tif ((flags & LOOKUP_OPEN) && !(server->flags & NFS_MOUNT_NOCTO) &&\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))\n\t\tgoto out_force;\nout:\n\treturn (inode->i_nlink == 0) ? -ENOENT : 0;\nout_force:\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tret = __nfs_revalidate_inode(server, inode);\n\tif (ret != 0)\n\t\treturn ret;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_check_verifier",
          "args": [
            "dir",
            "dentry",
            "flags & LOOKUP_RCU"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_check_verifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1008-1029",
          "snippet": "static int nfs_check_verifier(struct inode *dir, struct dentry *dentry,\n\t\t\t      int rcu_walk)\n{\n\tint ret;\n\n\tif (IS_ROOT(dentry))\n\t\treturn 1;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\t/* Revalidate nfsi->cache_change_attribute before we declare a match */\n\tif (rcu_walk)\n\t\tret = nfs_revalidate_inode_rcu(NFS_SERVER(dir), dir);\n\telse\n\t\tret = nfs_revalidate_inode(NFS_SERVER(dir), dir);\n\tif (ret < 0)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_check_verifier(struct inode *dir, struct dentry *dentry,\n\t\t\t      int rcu_walk)\n{\n\tint ret;\n\n\tif (IS_ROOT(dentry))\n\t\treturn 1;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\t/* Revalidate nfsi->cache_change_attribute before we declare a match */\n\tif (rcu_walk)\n\t\tret = nfs_revalidate_inode_rcu(NFS_SERVER(dir), dir);\n\telse\n\t\tret = nfs_revalidate_inode(NFS_SERVER(dir), dir);\n\tif (ret < 0)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_is_exclusive_create",
          "args": [
            "dir",
            "flags"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_is_exclusive_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1035-1040",
          "snippet": "static int nfs_is_exclusive_create(struct inode *dir, unsigned int flags)\n{\n\tif (NFS_PROTO(dir)->version == 2)\n\t\treturn 0;\n\treturn flags & LOOKUP_EXCL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_is_exclusive_create(struct inode *dir, unsigned int flags)\n{\n\tif (NFS_PROTO(dir)->version == 2)\n\t\treturn 0;\n\treturn flags & LOOKUP_EXCL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "FMODE_READ"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "LOOKUPCACHE",
            "\"%s: %pd2 has dud inode\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_neg_need_reval",
          "args": [
            "dir",
            "dentry",
            "flags"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_neg_need_reval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1086-1096",
          "snippet": "static inline\nint nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,\n\t\t       unsigned int flags)\n{\n\t/* Don't revalidate a negative dentry if we're creating a new file */\n\tif (flags & LOOKUP_CREATE)\n\t\treturn 0;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG)\n\t\treturn 1;\n\treturn !nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic inline\nint nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,\n\t\t       unsigned int flags)\n{\n\t/* Don't revalidate a negative dentry if we're creating a new file */\n\tif (flags & LOOKUP_CREATE)\n\t\treturn 0;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG)\n\t\treturn 1;\n\treturn !nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "dir",
            "NFSIOS_DENTRYREVALIDATE"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "parent->d_inode"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "dentry->d_parent"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *dir;\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\tstruct nfs_fh *fhandle = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint error;\n\n\tif (flags & LOOKUP_RCU) {\n\t\tparent = ACCESS_ONCE(dentry->d_parent);\n\t\tdir = ACCESS_ONCE(parent->d_inode);\n\t\tif (!dir)\n\t\t\treturn -ECHILD;\n\t} else {\n\t\tparent = dget_parent(dentry);\n\t\tdir = parent->d_inode;\n\t}\n\tnfs_inc_stats(dir, NFSIOS_DENTRYREVALIDATE);\n\tinode = dentry->d_inode;\n\n\tif (!inode) {\n\t\tif (nfs_neg_need_reval(dir, dentry, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_bad;\n\t\t}\n\t\tgoto out_valid_noent;\n\t}\n\n\tif (is_bad_inode(inode)) {\n\t\tif (flags & LOOKUP_RCU)\n\t\t\treturn -ECHILD;\n\t\tdfprintk(LOOKUPCACHE, \"%s: %pd2 has dud inode\\n\",\n\t\t\t\t__func__, dentry);\n\t\tgoto out_bad;\n\t}\n\n\tif (NFS_PROTO(dir)->have_delegation(inode, FMODE_READ))\n\t\tgoto out_set_verifier;\n\n\t/* Force a full look up iff the parent directory has changed */\n\tif (!nfs_is_exclusive_create(dir, flags) &&\n\t    nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU)) {\n\n\t\tif (nfs_lookup_verify_inode(inode, flags)) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\treturn -ECHILD;\n\t\t\tgoto out_zap_parent;\n\t\t}\n\t\tgoto out_valid;\n\t}\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (NFS_STALE(inode))\n\t\tgoto out_bad;\n\n\terror = -ENOMEM;\n\tfhandle = nfs_alloc_fhandle();\n\tfattr = nfs_alloc_fattr();\n\tif (fhandle == NULL || fattr == NULL)\n\t\tgoto out_error;\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(label))\n\t\tgoto out_error;\n\n\ttrace_nfs_lookup_revalidate_enter(dir, dentry, flags);\n\terror = NFS_PROTO(dir)->lookup(dir, &dentry->d_name, fhandle, fattr, label);\n\ttrace_nfs_lookup_revalidate_exit(dir, dentry, flags, error);\n\tif (error)\n\t\tgoto out_bad;\n\tif (nfs_compare_fh(NFS_FH(inode), fhandle))\n\t\tgoto out_bad;\n\tif ((error = nfs_refresh_inode(inode, fattr)) != 0)\n\t\tgoto out_bad;\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\nout_set_verifier:\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n out_valid:\n\t/* Success: notify readdir to use READDIRPLUS */\n\tnfs_advise_use_readdirplus(dir);\n out_valid_noent:\n\tif (flags & LOOKUP_RCU) {\n\t\tif (parent != ACCESS_ONCE(dentry->d_parent))\n\t\t\treturn -ECHILD;\n\t} else\n\t\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is valid\\n\",\n\t\t\t__func__, dentry);\n\treturn 1;\nout_zap_parent:\n\tnfs_zap_caches(dir);\n out_bad:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tnfs_mark_for_revalidate(dir);\n\tif (inode && S_ISDIR(inode->i_mode)) {\n\t\t/* Purge readdir caches. */\n\t\tnfs_zap_caches(inode);\n\t\t/*\n\t\t * We can't d_drop the root of a disconnected tree:\n\t\t * its d_hash is on the s_anon list and d_drop() would hide\n\t\t * it from shrink_dcache_for_unmount(), leading to busy\n\t\t * inodes on unmount and further oopses.\n\t\t */\n\t\tif (IS_ROOT(dentry))\n\t\t\tgoto out_valid;\n\t}\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) is invalid\\n\",\n\t\t\t__func__, dentry);\n\treturn 0;\nout_error:\n\tWARN_ON(flags & LOOKUP_RCU);\n\tnfs_free_fattr(fattr);\n\tnfs_free_fhandle(fhandle);\n\tnfs4_label_free(label);\n\tdput(parent);\n\tdfprintk(LOOKUPCACHE, \"NFS: %s(%pd2) lookup returned error %d\\n\",\n\t\t\t__func__, dentry, error);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_neg_need_reval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1086-1096",
    "snippet": "static inline\nint nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,\n\t\t       unsigned int flags)\n{\n\t/* Don't revalidate a negative dentry if we're creating a new file */\n\tif (flags & LOOKUP_CREATE)\n\t\treturn 0;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG)\n\t\treturn 1;\n\treturn !nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_check_verifier",
          "args": [
            "dir",
            "dentry",
            "flags & LOOKUP_RCU"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_check_verifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "1008-1029",
          "snippet": "static int nfs_check_verifier(struct inode *dir, struct dentry *dentry,\n\t\t\t      int rcu_walk)\n{\n\tint ret;\n\n\tif (IS_ROOT(dentry))\n\t\treturn 1;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\t/* Revalidate nfsi->cache_change_attribute before we declare a match */\n\tif (rcu_walk)\n\t\tret = nfs_revalidate_inode_rcu(NFS_SERVER(dir), dir);\n\telse\n\t\tret = nfs_revalidate_inode(NFS_SERVER(dir), dir);\n\tif (ret < 0)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_check_verifier(struct inode *dir, struct dentry *dentry,\n\t\t\t      int rcu_walk)\n{\n\tint ret;\n\n\tif (IS_ROOT(dentry))\n\t\treturn 1;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\t/* Revalidate nfsi->cache_change_attribute before we declare a match */\n\tif (rcu_walk)\n\t\tret = nfs_revalidate_inode_rcu(NFS_SERVER(dir), dir);\n\telse\n\t\tret = nfs_revalidate_inode(NFS_SERVER(dir), dir);\n\tif (ret < 0)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "dir"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic inline\nint nfs_neg_need_reval(struct inode *dir, struct dentry *dentry,\n\t\t       unsigned int flags)\n{\n\t/* Don't revalidate a negative dentry if we're creating a new file */\n\tif (flags & LOOKUP_CREATE)\n\t\treturn 0;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONEG)\n\t\treturn 1;\n\treturn !nfs_check_verifier(dir, dentry, flags & LOOKUP_RCU);\n}"
  },
  {
    "function_name": "nfs_lookup_verify_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1050-1074",
    "snippet": "static\nint nfs_lookup_verify_inode(struct inode *inode, unsigned int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (IS_AUTOMOUNT(inode))\n\t\treturn 0;\n\t/* VFS wants an on-the-wire revalidation */\n\tif (flags & LOOKUP_REVAL)\n\t\tgoto out_force;\n\t/* This is an open(2) */\n\tif ((flags & LOOKUP_OPEN) && !(server->flags & NFS_MOUNT_NOCTO) &&\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))\n\t\tgoto out_force;\nout:\n\treturn (inode->i_nlink == 0) ? -ENOENT : 0;\nout_force:\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tret = __nfs_revalidate_inode(server, inode);\n\tif (ret != 0)\n\t\treturn ret;\n\tgoto out;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs_revalidate_inode",
          "args": [
            "server",
            "inode"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_revalidate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "924-991",
          "snippet": "int\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_AUTOMOUNT",
          "args": [
            "inode"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nint nfs_lookup_verify_inode(struct inode *inode, unsigned int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (IS_AUTOMOUNT(inode))\n\t\treturn 0;\n\t/* VFS wants an on-the-wire revalidation */\n\tif (flags & LOOKUP_REVAL)\n\t\tgoto out_force;\n\t/* This is an open(2) */\n\tif ((flags & LOOKUP_OPEN) && !(server->flags & NFS_MOUNT_NOCTO) &&\n\t    (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))\n\t\tgoto out_force;\nout:\n\treturn (inode->i_nlink == 0) ? -ENOENT : 0;\nout_force:\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tret = __nfs_revalidate_inode(server, inode);\n\tif (ret != 0)\n\t\treturn ret;\n\tgoto out;\n}"
  },
  {
    "function_name": "nfs_is_exclusive_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1035-1040",
    "snippet": "static int nfs_is_exclusive_create(struct inode *dir, unsigned int flags)\n{\n\tif (NFS_PROTO(dir)->version == 2)\n\t\treturn 0;\n\treturn flags & LOOKUP_EXCL;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "dir"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_is_exclusive_create(struct inode *dir, unsigned int flags)\n{\n\tif (NFS_PROTO(dir)->version == 2)\n\t\treturn 0;\n\treturn flags & LOOKUP_EXCL;\n}"
  },
  {
    "function_name": "nfs_check_verifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "1008-1029",
    "snippet": "static int nfs_check_verifier(struct inode *dir, struct dentry *dentry,\n\t\t\t      int rcu_walk)\n{\n\tint ret;\n\n\tif (IS_ROOT(dentry))\n\t\treturn 1;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\t/* Revalidate nfsi->cache_change_attribute before we declare a match */\n\tif (rcu_walk)\n\t\tret = nfs_revalidate_inode_rcu(NFS_SERVER(dir), dir);\n\telse\n\t\tret = nfs_revalidate_inode(NFS_SERVER(dir), dir);\n\tif (ret < 0)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_verify_change_attribute",
          "args": [
            "dir",
            "dentry->d_time"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_inode",
          "args": [
            "NFS_SERVER(dir)",
            "dir"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_inode_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1022-1029",
          "snippet": "int nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_inode_rcu(struct nfs_server *server, struct inode *inode)\n{\n\tif (!(NFS_I(inode)->cache_validity &\n\t\t\t(NFS_INO_INVALID_ATTR|NFS_INO_INVALID_LABEL))\n\t\t\t&& !nfs_attribute_cache_expired(inode))\n\t\treturn NFS_STALE(inode) ? -ESTALE : 0;\n\treturn -ECHILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "dir"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "dir"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_verify_change_attribute",
          "args": [
            "dir",
            "dentry->d_time"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "dir"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_check_verifier(struct inode *dir, struct dentry *dentry,\n\t\t\t      int rcu_walk)\n{\n\tint ret;\n\n\tif (IS_ROOT(dentry))\n\t\treturn 1;\n\tif (NFS_SERVER(dir)->flags & NFS_MOUNT_LOOKUP_CACHE_NONE)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\t/* Revalidate nfsi->cache_change_attribute before we declare a match */\n\tif (rcu_walk)\n\t\tret = nfs_revalidate_inode_rcu(NFS_SERVER(dir), dir);\n\telse\n\t\tret = nfs_revalidate_inode(NFS_SERVER(dir), dir);\n\tif (ret < 0)\n\t\treturn 0;\n\tif (!nfs_verify_change_attribute(dir, dentry->d_time))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs_force_lookup_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "996-999",
    "snippet": "void nfs_force_lookup_revalidate(struct inode *dir)\n{\n\tNFS_I(dir)->cache_change_attribute++;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid nfs_force_lookup_revalidate(struct inode *dir)\n{\n\tNFS_I(dir)->cache_change_attribute++;\n}"
  },
  {
    "function_name": "nfs_fsync_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "973-984",
    "snippet": "static int nfs_fsync_dir(struct file *filp, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tdfprintk(FILE, \"NFS: fsync dir(%pD2) datasync %d\\n\", filp, datasync);\n\n\tmutex_lock(&inode->i_mutex);\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tmutex_unlock(&inode->i_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static int nfs_fsync_dir(struct file *, loff_t, loff_t, int);",
      "static loff_t nfs_llseek_dir(struct file *, loff_t, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSFSYNC"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FILE",
            "\"NFS: fsync dir(%pD2) datasync %d\\n\"",
            "filp",
            "datasync"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic int nfs_fsync_dir(struct file *, loff_t, loff_t, int);\nstatic loff_t nfs_llseek_dir(struct file *, loff_t, int);\n\nstatic int nfs_fsync_dir(struct file *filp, loff_t start, loff_t end,\n\t\t\t int datasync)\n{\n\tstruct inode *inode = file_inode(filp);\n\n\tdfprintk(FILE, \"NFS: fsync dir(%pD2) datasync %d\\n\", filp, datasync);\n\n\tmutex_lock(&inode->i_mutex);\n\tnfs_inc_stats(inode, NFSIOS_VFSFSYNC);\n\tmutex_unlock(&inode->i_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_llseek_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "940-967",
    "snippet": "static loff_t nfs_llseek_dir(struct file *filp, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct nfs_open_dir_context *dir_ctx = filp->private_data;\n\n\tdfprintk(FILE, \"NFS: llseek dir(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += filp->f_pos;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t}\n\tif (offset != filp->f_pos) {\n\t\tfilp->f_pos = offset;\n\t\tdir_ctx->dir_cookie = 0;\n\t\tdir_ctx->duped = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn offset;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static int nfs_fsync_dir(struct file *, loff_t, loff_t, int);",
      "static loff_t nfs_llseek_dir(struct file *, loff_t, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FILE",
            "\"NFS: llseek dir(%pD2, %lld, %d)\\n\"",
            "filp",
            "offset",
            "whence"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic int nfs_fsync_dir(struct file *, loff_t, loff_t, int);\nstatic loff_t nfs_llseek_dir(struct file *, loff_t, int);\n\nstatic loff_t nfs_llseek_dir(struct file *filp, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct nfs_open_dir_context *dir_ctx = filp->private_data;\n\n\tdfprintk(FILE, \"NFS: llseek dir(%pD2, %lld, %d)\\n\",\n\t\t\tfilp, offset, whence);\n\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase 1:\n\t\t\toffset += filp->f_pos;\n\t\tcase 0:\n\t\t\tif (offset >= 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t}\n\tif (offset != filp->f_pos) {\n\t\tfilp->f_pos = offset;\n\t\tdir_ctx->dir_cookie = 0;\n\t\tdir_ctx->duped = 0;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn offset;\n}"
  },
  {
    "function_name": "nfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "870-938",
    "snippet": "static int nfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry\t*dentry = file->f_path.dentry;\n\tstruct inode\t*inode = dentry->d_inode;\n\tnfs_readdir_descriptor_t my_desc,\n\t\t\t*desc = &my_desc;\n\tstruct nfs_open_dir_context *dir_ctx = file->private_data;\n\tint res = 0;\n\n\tdfprintk(FILE, \"NFS: readdir(%pD2) starting at cookie %llu\\n\",\n\t\t\tfile, (long long)ctx->pos);\n\tnfs_inc_stats(inode, NFSIOS_VFSGETDENTS);\n\n\t/*\n\t * ctx->pos points to the dirent entry number.\n\t * *desc->dir_cookie has the cookie for the next entry. We have\n\t * to either find the entry with the appropriate number or\n\t * revalidate the cookie.\n\t */\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->file = file;\n\tdesc->ctx = ctx;\n\tdesc->dir_cookie = &dir_ctx->dir_cookie;\n\tdesc->decode = NFS_PROTO(inode)->decode_dirent;\n\tdesc->plus = nfs_use_readdirplus(inode, ctx) ? 1 : 0;\n\n\tnfs_block_sillyrename(dentry);\n\tif (ctx->pos == 0 || nfs_dir_mapping_need_revalidate(inode))\n\t\tres = nfs_revalidate_mapping(inode, file->f_mapping);\n\tif (res < 0)\n\t\tgoto out;\n\n\tdo {\n\t\tres = readdir_search_pagecache(desc);\n\n\t\tif (res == -EBADCOOKIE) {\n\t\t\tres = 0;\n\t\t\t/* This means either end of directory */\n\t\t\tif (*desc->dir_cookie && desc->eof == 0) {\n\t\t\t\t/* Or that the server has 'lost' a cookie */\n\t\t\t\tres = uncached_readdir(desc);\n\t\t\t\tif (res == 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (res == -ETOOSMALL && desc->plus) {\n\t\t\tclear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\tnfs_zap_caches(inode);\n\t\t\tdesc->page_index = 0;\n\t\t\tdesc->plus = 0;\n\t\t\tdesc->eof = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tres = nfs_do_filldir(desc);\n\t\tif (res < 0)\n\t\t\tbreak;\n\t} while (!desc->eof);\nout:\n\tnfs_unblock_sillyrename(dentry);\n\tif (res > 0)\n\t\tres = 0;\n\tdfprintk(FILE, \"NFS: readdir(%pD2) returns %d\\n\", file, res);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static int nfs_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FILE",
            "\"NFS: readdir(%pD2) returns %d\\n\"",
            "file",
            "res"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_unblock_sillyrename",
          "args": [
            "dentry"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unblock_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "225-244",
          "snippet": "void nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_unblock_sillyrename(struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_unlinkdata *data;\n\n\tatomic_inc(&nfsi->silly_count);\n\tspin_lock(&dir->i_lock);\n\twhile (!hlist_empty(&nfsi->silly_list)) {\n\t\tif (!atomic_inc_not_zero(&nfsi->silly_count))\n\t\t\tbreak;\n\t\tdata = hlist_entry(nfsi->silly_list.first, struct nfs_unlinkdata, list);\n\t\thlist_del(&data->list);\n\t\tspin_unlock(&dir->i_lock);\n\t\tif (nfs_do_call_unlink(dentry, dir, data) == 0)\n\t\t\tnfs_free_unlinkdata(data);\n\t\tspin_lock(&dir->i_lock);\n\t}\n\tspin_unlock(&dir->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_do_filldir",
          "args": [
            "desc"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_filldir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "763-804",
          "snippet": "static \nint nfs_do_filldir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct file\t*file = desc->file;\n\tint i = 0;\n\tint res = 0;\n\tstruct nfs_cache_array *array = NULL;\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tres = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tfor (i = desc->cache_entry_index; i < array->size; i++) {\n\t\tstruct nfs_cache_array_entry *ent;\n\n\t\tent = &array->array[i];\n\t\tif (!dir_emit(desc->ctx, ent->string.name, ent->string.len,\n\t\t    nfs_compat_user_ino64(ent->ino), ent->d_type)) {\n\t\t\tdesc->eof = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdesc->ctx->pos++;\n\t\tif (i < (array->size-1))\n\t\t\t*desc->dir_cookie = array->array[i+1].cookie;\n\t\telse\n\t\t\t*desc->dir_cookie = array->last_cookie;\n\t\tif (ctx->duped != 0)\n\t\t\tctx->duped = 1;\n\t}\n\tif (array->eof_index >= 0)\n\t\tdesc->eof = 1;\n\n\tnfs_readdir_release_array(desc->page);\nout:\n\tcache_page_release(desc);\n\tdfprintk(DIRCACHE, \"NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie, res);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic \nint nfs_do_filldir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct file\t*file = desc->file;\n\tint i = 0;\n\tint res = 0;\n\tstruct nfs_cache_array *array = NULL;\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tres = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tfor (i = desc->cache_entry_index; i < array->size; i++) {\n\t\tstruct nfs_cache_array_entry *ent;\n\n\t\tent = &array->array[i];\n\t\tif (!dir_emit(desc->ctx, ent->string.name, ent->string.len,\n\t\t    nfs_compat_user_ino64(ent->ino), ent->d_type)) {\n\t\t\tdesc->eof = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdesc->ctx->pos++;\n\t\tif (i < (array->size-1))\n\t\t\t*desc->dir_cookie = array->array[i+1].cookie;\n\t\telse\n\t\t\t*desc->dir_cookie = array->last_cookie;\n\t\tif (ctx->duped != 0)\n\t\t\tctx->duped = 1;\n\t}\n\tif (array->eof_index >= 0)\n\t\tdesc->eof = 1;\n\n\tnfs_readdir_release_array(desc->page);\nout:\n\tcache_page_release(desc);\n\tdfprintk(DIRCACHE, \"NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie, res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_zap_caches",
          "args": [
            "inode"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "189-194",
          "snippet": "void nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_caches(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tnfs_zap_caches_locked(inode);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_INO_ADVISE_RDPLUS",
            "&NFS_I(inode)->flags"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uncached_readdir",
          "args": [
            "desc"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "uncached_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "818-853",
          "snippet": "static inline\nint uncached_readdir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct page\t*page = NULL;\n\tint\t\tstatus;\n\tstruct inode *inode = file_inode(desc->file);\n\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\tdfprintk(DIRCACHE, \"NFS: uncached_readdir() searching for cookie %Lu\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie);\n\n\tpage = alloc_page(GFP_HIGHUSER);\n\tif (!page) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdesc->page_index = 0;\n\tdesc->last_cookie = *desc->dir_cookie;\n\tdesc->page = page;\n\tctx->duped = 0;\n\n\tstatus = nfs_readdir_xdr_to_array(desc, page, inode);\n\tif (status < 0)\n\t\tgoto out_release;\n\n\tstatus = nfs_do_filldir(desc);\n\n out:\n\tdfprintk(DIRCACHE, \"NFS: %s: returns %d\\n\",\n\t\t\t__func__, status);\n\treturn status;\n out_release:\n\tcache_page_release(desc);\n\tgoto out;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic inline\nint uncached_readdir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct page\t*page = NULL;\n\tint\t\tstatus;\n\tstruct inode *inode = file_inode(desc->file);\n\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\tdfprintk(DIRCACHE, \"NFS: uncached_readdir() searching for cookie %Lu\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie);\n\n\tpage = alloc_page(GFP_HIGHUSER);\n\tif (!page) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdesc->page_index = 0;\n\tdesc->last_cookie = *desc->dir_cookie;\n\tdesc->page = page;\n\tctx->duped = 0;\n\n\tstatus = nfs_readdir_xdr_to_array(desc, page, inode);\n\tif (status < 0)\n\t\tgoto out_release;\n\n\tstatus = nfs_do_filldir(desc);\n\n out:\n\tdfprintk(DIRCACHE, \"NFS: %s: returns %d\\n\",\n\t\t\t__func__, status);\n\treturn status;\n out_release:\n\tcache_page_release(desc);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdir_search_pagecache",
          "args": [
            "desc"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "readdir_search_pagecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "745-758",
          "snippet": "static inline\nint readdir_search_pagecache(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tif (desc->page_index == 0) {\n\t\tdesc->current_index = 0;\n\t\tdesc->last_cookie = 0;\n\t}\n\tdo {\n\t\tres = find_cache_page(desc);\n\t} while (res == -EAGAIN);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic inline\nint readdir_search_pagecache(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tif (desc->page_index == 0) {\n\t\tdesc->current_index = 0;\n\t\tdesc->last_cookie = 0;\n\t}\n\tdo {\n\t\tres = find_cache_page(desc);\n\t} while (res == -EAGAIN);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_revalidate_mapping",
          "args": [
            "inode",
            "file->f_mapping"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_revalidate_mapping_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1160-1163",
          "snippet": "int nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_revalidate_mapping_protected(struct inode *inode, struct address_space *mapping)\n{\n\treturn __nfs_revalidate_mapping(inode, mapping, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_dir_mapping_need_revalidate",
          "args": [
            "inode"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dir_mapping_need_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "855-864",
          "snippet": "static bool nfs_dir_mapping_need_revalidate(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tif (nfs_attribute_cache_expired(dir))\n\t\treturn true;\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic bool nfs_dir_mapping_need_revalidate(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tif (nfs_attribute_cache_expired(dir))\n\t\treturn true;\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_block_sillyrename",
          "args": [
            "dentry"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_block_sillyrename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/unlink.c",
          "lines": "218-223",
          "snippet": "void nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"delegation.h\"",
            "#include \"iostat.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/namei.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"delegation.h\"\n#include \"iostat.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nvoid nfs_block_sillyrename(struct dentry *dentry)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dentry->d_inode);\n\n\twait_event(nfsi->waitqueue, atomic_cmpxchg(&nfsi->silly_count, 1, 0) == 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_use_readdirplus",
          "args": [
            "inode",
            "ctx"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_use_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "431-441",
          "snippet": "static\nbool nfs_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tif (!nfs_server_capable(dir, NFS_CAP_READDIRPLUS))\n\t\treturn false;\n\tif (test_and_clear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_readdir(struct file *, struct dir_context *);\n\nstatic\nbool nfs_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tif (!nfs_server_capable(dir, NFS_CAP_READDIRPLUS))\n\t\treturn false;\n\tif (test_and_clear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "desc",
            "0",
            "sizeof(*desc)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSGETDENTS"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FILE",
            "\"NFS: readdir(%pD2) starting at cookie %llu\\n\"",
            "file",
            "(long long)ctx->pos"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic int nfs_readdir(struct file *, struct dir_context *);\n\nstatic int nfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry\t*dentry = file->f_path.dentry;\n\tstruct inode\t*inode = dentry->d_inode;\n\tnfs_readdir_descriptor_t my_desc,\n\t\t\t*desc = &my_desc;\n\tstruct nfs_open_dir_context *dir_ctx = file->private_data;\n\tint res = 0;\n\n\tdfprintk(FILE, \"NFS: readdir(%pD2) starting at cookie %llu\\n\",\n\t\t\tfile, (long long)ctx->pos);\n\tnfs_inc_stats(inode, NFSIOS_VFSGETDENTS);\n\n\t/*\n\t * ctx->pos points to the dirent entry number.\n\t * *desc->dir_cookie has the cookie for the next entry. We have\n\t * to either find the entry with the appropriate number or\n\t * revalidate the cookie.\n\t */\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->file = file;\n\tdesc->ctx = ctx;\n\tdesc->dir_cookie = &dir_ctx->dir_cookie;\n\tdesc->decode = NFS_PROTO(inode)->decode_dirent;\n\tdesc->plus = nfs_use_readdirplus(inode, ctx) ? 1 : 0;\n\n\tnfs_block_sillyrename(dentry);\n\tif (ctx->pos == 0 || nfs_dir_mapping_need_revalidate(inode))\n\t\tres = nfs_revalidate_mapping(inode, file->f_mapping);\n\tif (res < 0)\n\t\tgoto out;\n\n\tdo {\n\t\tres = readdir_search_pagecache(desc);\n\n\t\tif (res == -EBADCOOKIE) {\n\t\t\tres = 0;\n\t\t\t/* This means either end of directory */\n\t\t\tif (*desc->dir_cookie && desc->eof == 0) {\n\t\t\t\t/* Or that the server has 'lost' a cookie */\n\t\t\t\tres = uncached_readdir(desc);\n\t\t\t\tif (res == 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (res == -ETOOSMALL && desc->plus) {\n\t\t\tclear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\tnfs_zap_caches(inode);\n\t\t\tdesc->page_index = 0;\n\t\t\tdesc->plus = 0;\n\t\t\tdesc->eof = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tres = nfs_do_filldir(desc);\n\t\tif (res < 0)\n\t\t\tbreak;\n\t} while (!desc->eof);\nout:\n\tnfs_unblock_sillyrename(dentry);\n\tif (res > 0)\n\t\tres = 0;\n\tdfprintk(FILE, \"NFS: readdir(%pD2) returns %d\\n\", file, res);\n\treturn res;\n}"
  },
  {
    "function_name": "nfs_dir_mapping_need_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "855-864",
    "snippet": "static bool nfs_dir_mapping_need_revalidate(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tif (nfs_attribute_cache_expired(dir))\n\t\treturn true;\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_attribute_cache_expired",
          "args": [
            "dir"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_attribute_cache_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1000-1005",
          "snippet": "int nfs_attribute_cache_expired(struct inode *inode)\n{\n\tif (nfs_have_delegated_attributes(inode))\n\t\treturn 0;\n\treturn nfs_attribute_timeout(inode);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nint nfs_attribute_cache_expired(struct inode *inode)\n{\n\tif (nfs_have_delegated_attributes(inode))\n\t\treturn 0;\n\treturn nfs_attribute_timeout(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic bool nfs_dir_mapping_need_revalidate(struct inode *dir)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tif (nfs_attribute_cache_expired(dir))\n\t\treturn true;\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "uncached_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "818-853",
    "snippet": "static inline\nint uncached_readdir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct page\t*page = NULL;\n\tint\t\tstatus;\n\tstruct inode *inode = file_inode(desc->file);\n\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\tdfprintk(DIRCACHE, \"NFS: uncached_readdir() searching for cookie %Lu\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie);\n\n\tpage = alloc_page(GFP_HIGHUSER);\n\tif (!page) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdesc->page_index = 0;\n\tdesc->last_cookie = *desc->dir_cookie;\n\tdesc->page = page;\n\tctx->duped = 0;\n\n\tstatus = nfs_readdir_xdr_to_array(desc, page, inode);\n\tif (status < 0)\n\t\tgoto out_release;\n\n\tstatus = nfs_do_filldir(desc);\n\n out:\n\tdfprintk(DIRCACHE, \"NFS: %s: returns %d\\n\",\n\t\t\t__func__, status);\n\treturn status;\n out_release:\n\tcache_page_release(desc);\n\tgoto out;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_page_release",
          "args": [
            "desc"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "cache_page_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "710-717",
          "snippet": "static\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "DIRCACHE",
            "\"NFS: %s: returns %d\\n\"",
            "__func__",
            "status"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_do_filldir",
          "args": [
            "desc"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_filldir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "763-804",
          "snippet": "static \nint nfs_do_filldir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct file\t*file = desc->file;\n\tint i = 0;\n\tint res = 0;\n\tstruct nfs_cache_array *array = NULL;\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tres = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tfor (i = desc->cache_entry_index; i < array->size; i++) {\n\t\tstruct nfs_cache_array_entry *ent;\n\n\t\tent = &array->array[i];\n\t\tif (!dir_emit(desc->ctx, ent->string.name, ent->string.len,\n\t\t    nfs_compat_user_ino64(ent->ino), ent->d_type)) {\n\t\t\tdesc->eof = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdesc->ctx->pos++;\n\t\tif (i < (array->size-1))\n\t\t\t*desc->dir_cookie = array->array[i+1].cookie;\n\t\telse\n\t\t\t*desc->dir_cookie = array->last_cookie;\n\t\tif (ctx->duped != 0)\n\t\t\tctx->duped = 1;\n\t}\n\tif (array->eof_index >= 0)\n\t\tdesc->eof = 1;\n\n\tnfs_readdir_release_array(desc->page);\nout:\n\tcache_page_release(desc);\n\tdfprintk(DIRCACHE, \"NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie, res);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic \nint nfs_do_filldir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct file\t*file = desc->file;\n\tint i = 0;\n\tint res = 0;\n\tstruct nfs_cache_array *array = NULL;\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tres = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tfor (i = desc->cache_entry_index; i < array->size; i++) {\n\t\tstruct nfs_cache_array_entry *ent;\n\n\t\tent = &array->array[i];\n\t\tif (!dir_emit(desc->ctx, ent->string.name, ent->string.len,\n\t\t    nfs_compat_user_ino64(ent->ino), ent->d_type)) {\n\t\t\tdesc->eof = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdesc->ctx->pos++;\n\t\tif (i < (array->size-1))\n\t\t\t*desc->dir_cookie = array->array[i+1].cookie;\n\t\telse\n\t\t\t*desc->dir_cookie = array->last_cookie;\n\t\tif (ctx->duped != 0)\n\t\t\tctx->duped = 1;\n\t}\n\tif (array->eof_index >= 0)\n\t\tdesc->eof = 1;\n\n\tnfs_readdir_release_array(desc->page);\nout:\n\tcache_page_release(desc);\n\tdfprintk(DIRCACHE, \"NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie, res);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_xdr_to_array",
          "args": [
            "desc",
            "page",
            "inode"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_xdr_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "619-680",
          "snippet": "static\nint nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page, struct inode *inode)\n{\n\tstruct page *pages[NFS_MAX_READDIR_PAGES];\n\tvoid *pages_ptr = NULL;\n\tstruct nfs_entry entry;\n\tstruct file\t*file = desc->file;\n\tstruct nfs_cache_array *array;\n\tint status = -ENOMEM;\n\tunsigned int array_size = ARRAY_SIZE(pages);\n\n\tentry.prev_cookie = 0;\n\tentry.cookie = desc->last_cookie;\n\tentry.eof = 0;\n\tentry.fh = nfs_alloc_fhandle();\n\tentry.fattr = nfs_alloc_fattr();\n\tentry.server = NFS_SERVER(inode);\n\tif (entry.fh == NULL || entry.fattr == NULL)\n\t\tgoto out;\n\n\tentry.label = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(entry.label)) {\n\t\tstatus = PTR_ERR(entry.label);\n\t\tgoto out;\n\t}\n\n\tarray = nfs_readdir_get_array(page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out_label_free;\n\t}\n\tmemset(array, 0, sizeof(struct nfs_cache_array));\n\tarray->eof_index = -1;\n\n\tstatus = nfs_readdir_large_page(pages, array_size);\n\tif (status < 0)\n\t\tgoto out_release_array;\n\tdo {\n\t\tunsigned int pglen;\n\t\tstatus = nfs_readdir_xdr_filler(pages, desc, &entry, file, inode);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tpglen = status;\n\t\tstatus = nfs_readdir_page_filler(desc, &entry, pages, page, pglen);\n\t\tif (status < 0) {\n\t\t\tif (status == -ENOSPC)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (array->eof_index < 0);\n\n\tnfs_readdir_free_large_page(pages_ptr, pages, array_size);\nout_release_array:\n\tnfs_readdir_release_array(page);\nout_label_free:\n\tnfs4_label_free(entry.label);\nout:\n\tnfs_free_fattr(entry.fattr);\n\tnfs_free_fhandle(entry.fh);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page, struct inode *inode)\n{\n\tstruct page *pages[NFS_MAX_READDIR_PAGES];\n\tvoid *pages_ptr = NULL;\n\tstruct nfs_entry entry;\n\tstruct file\t*file = desc->file;\n\tstruct nfs_cache_array *array;\n\tint status = -ENOMEM;\n\tunsigned int array_size = ARRAY_SIZE(pages);\n\n\tentry.prev_cookie = 0;\n\tentry.cookie = desc->last_cookie;\n\tentry.eof = 0;\n\tentry.fh = nfs_alloc_fhandle();\n\tentry.fattr = nfs_alloc_fattr();\n\tentry.server = NFS_SERVER(inode);\n\tif (entry.fh == NULL || entry.fattr == NULL)\n\t\tgoto out;\n\n\tentry.label = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(entry.label)) {\n\t\tstatus = PTR_ERR(entry.label);\n\t\tgoto out;\n\t}\n\n\tarray = nfs_readdir_get_array(page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out_label_free;\n\t}\n\tmemset(array, 0, sizeof(struct nfs_cache_array));\n\tarray->eof_index = -1;\n\n\tstatus = nfs_readdir_large_page(pages, array_size);\n\tif (status < 0)\n\t\tgoto out_release_array;\n\tdo {\n\t\tunsigned int pglen;\n\t\tstatus = nfs_readdir_xdr_filler(pages, desc, &entry, file, inode);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tpglen = status;\n\t\tstatus = nfs_readdir_page_filler(desc, &entry, pages, page, pglen);\n\t\tif (status < 0) {\n\t\t\tif (status == -ENOSPC)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (array->eof_index < 0);\n\n\tnfs_readdir_free_large_page(pages_ptr, pages, array_size);\nout_release_array:\n\tnfs_readdir_release_array(page);\nout_label_free:\n\tnfs4_label_free(entry.label);\nout:\n\tnfs_free_fattr(entry.fattr);\n\tnfs_free_fhandle(entry.fh);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "DIRCACHE",
            "\"NFS: uncached_readdir() searching for cookie %Lu\\n\"",
            "(unsigned long long)*desc->dir_cookie"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "desc->file"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic inline\nint uncached_readdir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct page\t*page = NULL;\n\tint\t\tstatus;\n\tstruct inode *inode = file_inode(desc->file);\n\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\tdfprintk(DIRCACHE, \"NFS: uncached_readdir() searching for cookie %Lu\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie);\n\n\tpage = alloc_page(GFP_HIGHUSER);\n\tif (!page) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdesc->page_index = 0;\n\tdesc->last_cookie = *desc->dir_cookie;\n\tdesc->page = page;\n\tctx->duped = 0;\n\n\tstatus = nfs_readdir_xdr_to_array(desc, page, inode);\n\tif (status < 0)\n\t\tgoto out_release;\n\n\tstatus = nfs_do_filldir(desc);\n\n out:\n\tdfprintk(DIRCACHE, \"NFS: %s: returns %d\\n\",\n\t\t\t__func__, status);\n\treturn status;\n out_release:\n\tcache_page_release(desc);\n\tgoto out;\n}"
  },
  {
    "function_name": "nfs_do_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "763-804",
    "snippet": "static \nint nfs_do_filldir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct file\t*file = desc->file;\n\tint i = 0;\n\tint res = 0;\n\tstruct nfs_cache_array *array = NULL;\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tres = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tfor (i = desc->cache_entry_index; i < array->size; i++) {\n\t\tstruct nfs_cache_array_entry *ent;\n\n\t\tent = &array->array[i];\n\t\tif (!dir_emit(desc->ctx, ent->string.name, ent->string.len,\n\t\t    nfs_compat_user_ino64(ent->ino), ent->d_type)) {\n\t\t\tdesc->eof = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdesc->ctx->pos++;\n\t\tif (i < (array->size-1))\n\t\t\t*desc->dir_cookie = array->array[i+1].cookie;\n\t\telse\n\t\t\t*desc->dir_cookie = array->last_cookie;\n\t\tif (ctx->duped != 0)\n\t\t\tctx->duped = 1;\n\t}\n\tif (array->eof_index >= 0)\n\t\tdesc->eof = 1;\n\n\tnfs_readdir_release_array(desc->page);\nout:\n\tcache_page_release(desc);\n\tdfprintk(DIRCACHE, \"NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie, res);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "DIRCACHE",
            "\"NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\\n\"",
            "(unsigned long long)*desc->dir_cookie",
            "res"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_page_release",
          "args": [
            "desc"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "cache_page_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "710-717",
          "snippet": "static\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_release_array",
          "args": [
            "desc->page"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_release_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "187-191",
          "snippet": "static\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "desc->ctx",
            "ent->string.name",
            "ent->string.len",
            "nfs_compat_user_ino64(ent->ino)",
            "ent->d_type"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_compat_user_ino64",
          "args": [
            "ent->ino"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_compat_user_ino64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "94-108",
          "snippet": "u64 nfs_compat_user_ino64(u64 fileid)\n{\n#ifdef CONFIG_COMPAT\n\tcompat_ulong_t ino;\n#else\t\n\tunsigned long ino;\n#endif\n\n\tif (enable_ino64)\n\t\treturn fileid;\n\tino = fileid;\n\tif (sizeof(ino) < sizeof(fileid))\n\t\tino ^= fileid >> (sizeof(fileid)-sizeof(ino)) * 8;\n\treturn ino;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool enable_ino64 = NFS_64_BIT_INODE_NUMBERS_ENABLED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool enable_ino64 = NFS_64_BIT_INODE_NUMBERS_ENABLED;\n\nu64 nfs_compat_user_ino64(u64 fileid)\n{\n#ifdef CONFIG_COMPAT\n\tcompat_ulong_t ino;\n#else\t\n\tunsigned long ino;\n#endif\n\n\tif (enable_ino64)\n\t\treturn fileid;\n\tino = fileid;\n\tif (sizeof(ino) < sizeof(fileid))\n\t\tino ^= fileid >> (sizeof(fileid)-sizeof(ino)) * 8;\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "array"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "array"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_get_array",
          "args": [
            "desc->page"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_get_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "175-185",
          "snippet": "static\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic \nint nfs_do_filldir(nfs_readdir_descriptor_t *desc)\n{\n\tstruct file\t*file = desc->file;\n\tint i = 0;\n\tint res = 0;\n\tstruct nfs_cache_array *array = NULL;\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tres = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tfor (i = desc->cache_entry_index; i < array->size; i++) {\n\t\tstruct nfs_cache_array_entry *ent;\n\n\t\tent = &array->array[i];\n\t\tif (!dir_emit(desc->ctx, ent->string.name, ent->string.len,\n\t\t    nfs_compat_user_ino64(ent->ino), ent->d_type)) {\n\t\t\tdesc->eof = 1;\n\t\t\tbreak;\n\t\t}\n\t\tdesc->ctx->pos++;\n\t\tif (i < (array->size-1))\n\t\t\t*desc->dir_cookie = array->array[i+1].cookie;\n\t\telse\n\t\t\t*desc->dir_cookie = array->last_cookie;\n\t\tif (ctx->duped != 0)\n\t\t\tctx->duped = 1;\n\t}\n\tif (array->eof_index >= 0)\n\t\tdesc->eof = 1;\n\n\tnfs_readdir_release_array(desc->page);\nout:\n\tcache_page_release(desc);\n\tdfprintk(DIRCACHE, \"NFS: nfs_do_filldir() filling ended @ cookie %Lu; returning = %d\\n\",\n\t\t\t(unsigned long long)*desc->dir_cookie, res);\n\treturn res;\n}"
  },
  {
    "function_name": "readdir_search_pagecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "745-758",
    "snippet": "static inline\nint readdir_search_pagecache(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tif (desc->page_index == 0) {\n\t\tdesc->current_index = 0;\n\t\tdesc->last_cookie = 0;\n\t}\n\tdo {\n\t\tres = find_cache_page(desc);\n\t} while (res == -EAGAIN);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_cache_page",
          "args": [
            "desc"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "find_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "729-742",
          "snippet": "static\nint find_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tdesc->page = get_cache_page(desc);\n\tif (IS_ERR(desc->page))\n\t\treturn PTR_ERR(desc->page);\n\n\tres = nfs_readdir_search_array(desc);\n\tif (res != 0)\n\t\tcache_page_release(desc);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint find_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tdesc->page = get_cache_page(desc);\n\tif (IS_ERR(desc->page))\n\t\treturn PTR_ERR(desc->page);\n\n\tres = nfs_readdir_search_array(desc);\n\tif (res != 0)\n\t\tcache_page_release(desc);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic inline\nint readdir_search_pagecache(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tif (desc->page_index == 0) {\n\t\tdesc->current_index = 0;\n\t\tdesc->last_cookie = 0;\n\t}\n\tdo {\n\t\tres = find_cache_page(desc);\n\t} while (res == -EAGAIN);\n\treturn res;\n}"
  },
  {
    "function_name": "find_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "729-742",
    "snippet": "static\nint find_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tdesc->page = get_cache_page(desc);\n\tif (IS_ERR(desc->page))\n\t\treturn PTR_ERR(desc->page);\n\n\tres = nfs_readdir_search_array(desc);\n\tif (res != 0)\n\t\tcache_page_release(desc);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_page_release",
          "args": [
            "desc"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "cache_page_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "710-717",
          "snippet": "static\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_search_array",
          "args": [
            "desc"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_search_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "340-365",
          "snippet": "static\nint nfs_readdir_search_array(nfs_readdir_descriptor_t *desc)\n{\n\tstruct nfs_cache_array *array;\n\tint status;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tif (*desc->dir_cookie == 0)\n\t\tstatus = nfs_readdir_search_for_pos(array, desc);\n\telse\n\t\tstatus = nfs_readdir_search_for_cookie(array, desc);\n\n\tif (status == -EAGAIN) {\n\t\tdesc->last_cookie = array->last_cookie;\n\t\tdesc->current_index += array->size;\n\t\tdesc->page_index++;\n\t}\n\tnfs_readdir_release_array(desc->page);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_search_array(nfs_readdir_descriptor_t *desc)\n{\n\tstruct nfs_cache_array *array;\n\tint status;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tif (*desc->dir_cookie == 0)\n\t\tstatus = nfs_readdir_search_for_pos(array, desc);\n\telse\n\t\tstatus = nfs_readdir_search_for_cookie(array, desc);\n\n\tif (status == -EAGAIN) {\n\t\tdesc->last_cookie = array->last_cookie;\n\t\tdesc->current_index += array->size;\n\t\tdesc->page_index++;\n\t}\n\tnfs_readdir_release_array(desc->page);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "desc->page"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "desc->page"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cache_page",
          "args": [
            "desc"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "get_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "719-724",
          "snippet": "static\nstruct page *get_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\treturn read_cache_page(file_inode(desc->file)->i_mapping,\n\t\t\tdesc->page_index, (filler_t *)nfs_readdir_filler, desc);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct page *get_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\treturn read_cache_page(file_inode(desc->file)->i_mapping,\n\t\t\tdesc->page_index, (filler_t *)nfs_readdir_filler, desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint find_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\tint res;\n\n\tdesc->page = get_cache_page(desc);\n\tif (IS_ERR(desc->page))\n\t\treturn PTR_ERR(desc->page);\n\n\tres = nfs_readdir_search_array(desc);\n\tif (res != 0)\n\t\tcache_page_release(desc);\n\treturn res;\n}"
  },
  {
    "function_name": "get_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "719-724",
    "snippet": "static\nstruct page *get_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\treturn read_cache_page(file_inode(desc->file)->i_mapping,\n\t\t\tdesc->page_index, (filler_t *)nfs_readdir_filler, desc);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "file_inode(desc->file)->i_mapping",
            "desc->page_index",
            "(filler_t *)nfs_readdir_filler",
            "desc"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "desc->file"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct page *get_cache_page(nfs_readdir_descriptor_t *desc)\n{\n\treturn read_cache_page(file_inode(desc->file)->i_mapping,\n\t\t\tdesc->page_index, (filler_t *)nfs_readdir_filler, desc);\n}"
  },
  {
    "function_name": "cache_page_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "710-717",
    "snippet": "static\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "desc->page"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_clear_array",
          "args": [
            "desc->page"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_clear_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "196-206",
          "snippet": "static\nvoid nfs_readdir_clear_array(struct page *page)\n{\n\tstruct nfs_cache_array *array;\n\tint i;\n\n\tarray = kmap_atomic(page);\n\tfor (i = 0; i < array->size; i++)\n\t\tkfree(array->array[i].string.name);\n\tkunmap_atomic(array);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_clear_array(struct page *page)\n{\n\tstruct nfs_cache_array *array;\n\tint i;\n\n\tarray = kmap_atomic(page);\n\tfor (i = 0; i < array->size; i++)\n\t\tkfree(array->array[i].string.name);\n\tkunmap_atomic(array);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid cache_page_release(nfs_readdir_descriptor_t *desc)\n{\n\tif (!desc->page->mapping)\n\t\tnfs_readdir_clear_array(desc->page);\n\tpage_cache_release(desc->page);\n\tdesc->page = NULL;\n}"
  },
  {
    "function_name": "nfs_readdir_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "688-708",
    "snippet": "static\nint nfs_readdir_filler(nfs_readdir_descriptor_t *desc, struct page* page)\n{\n\tstruct inode\t*inode = file_inode(desc->file);\n\tint ret;\n\n\tret = nfs_readdir_xdr_to_array(desc, page, inode);\n\tif (ret < 0)\n\t\tgoto error;\n\tSetPageUptodate(page);\n\n\tif (invalidate_inode_pages2_range(inode->i_mapping, page->index + 1, -1) < 0) {\n\t\t/* Should never happen */\n\t\tnfs_zap_mapping(inode, inode->i_mapping);\n\t}\n\tunlock_page(page);\n\treturn 0;\n error:\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_zap_mapping",
          "args": [
            "inode",
            "inode->i_mapping"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "197-204",
          "snippet": "void nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "inode->i_mapping",
            "page->index + 1",
            "-1"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_xdr_to_array",
          "args": [
            "desc",
            "page",
            "inode"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_xdr_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "619-680",
          "snippet": "static\nint nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page, struct inode *inode)\n{\n\tstruct page *pages[NFS_MAX_READDIR_PAGES];\n\tvoid *pages_ptr = NULL;\n\tstruct nfs_entry entry;\n\tstruct file\t*file = desc->file;\n\tstruct nfs_cache_array *array;\n\tint status = -ENOMEM;\n\tunsigned int array_size = ARRAY_SIZE(pages);\n\n\tentry.prev_cookie = 0;\n\tentry.cookie = desc->last_cookie;\n\tentry.eof = 0;\n\tentry.fh = nfs_alloc_fhandle();\n\tentry.fattr = nfs_alloc_fattr();\n\tentry.server = NFS_SERVER(inode);\n\tif (entry.fh == NULL || entry.fattr == NULL)\n\t\tgoto out;\n\n\tentry.label = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(entry.label)) {\n\t\tstatus = PTR_ERR(entry.label);\n\t\tgoto out;\n\t}\n\n\tarray = nfs_readdir_get_array(page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out_label_free;\n\t}\n\tmemset(array, 0, sizeof(struct nfs_cache_array));\n\tarray->eof_index = -1;\n\n\tstatus = nfs_readdir_large_page(pages, array_size);\n\tif (status < 0)\n\t\tgoto out_release_array;\n\tdo {\n\t\tunsigned int pglen;\n\t\tstatus = nfs_readdir_xdr_filler(pages, desc, &entry, file, inode);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tpglen = status;\n\t\tstatus = nfs_readdir_page_filler(desc, &entry, pages, page, pglen);\n\t\tif (status < 0) {\n\t\t\tif (status == -ENOSPC)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (array->eof_index < 0);\n\n\tnfs_readdir_free_large_page(pages_ptr, pages, array_size);\nout_release_array:\n\tnfs_readdir_release_array(page);\nout_label_free:\n\tnfs4_label_free(entry.label);\nout:\n\tnfs_free_fattr(entry.fattr);\n\tnfs_free_fhandle(entry.fh);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page, struct inode *inode)\n{\n\tstruct page *pages[NFS_MAX_READDIR_PAGES];\n\tvoid *pages_ptr = NULL;\n\tstruct nfs_entry entry;\n\tstruct file\t*file = desc->file;\n\tstruct nfs_cache_array *array;\n\tint status = -ENOMEM;\n\tunsigned int array_size = ARRAY_SIZE(pages);\n\n\tentry.prev_cookie = 0;\n\tentry.cookie = desc->last_cookie;\n\tentry.eof = 0;\n\tentry.fh = nfs_alloc_fhandle();\n\tentry.fattr = nfs_alloc_fattr();\n\tentry.server = NFS_SERVER(inode);\n\tif (entry.fh == NULL || entry.fattr == NULL)\n\t\tgoto out;\n\n\tentry.label = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(entry.label)) {\n\t\tstatus = PTR_ERR(entry.label);\n\t\tgoto out;\n\t}\n\n\tarray = nfs_readdir_get_array(page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out_label_free;\n\t}\n\tmemset(array, 0, sizeof(struct nfs_cache_array));\n\tarray->eof_index = -1;\n\n\tstatus = nfs_readdir_large_page(pages, array_size);\n\tif (status < 0)\n\t\tgoto out_release_array;\n\tdo {\n\t\tunsigned int pglen;\n\t\tstatus = nfs_readdir_xdr_filler(pages, desc, &entry, file, inode);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tpglen = status;\n\t\tstatus = nfs_readdir_page_filler(desc, &entry, pages, page, pglen);\n\t\tif (status < 0) {\n\t\t\tif (status == -ENOSPC)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (array->eof_index < 0);\n\n\tnfs_readdir_free_large_page(pages_ptr, pages, array_size);\nout_release_array:\n\tnfs_readdir_release_array(page);\nout_label_free:\n\tnfs4_label_free(entry.label);\nout:\n\tnfs_free_fattr(entry.fattr);\n\tnfs_free_fhandle(entry.fh);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "desc->file"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_filler(nfs_readdir_descriptor_t *desc, struct page* page)\n{\n\tstruct inode\t*inode = file_inode(desc->file);\n\tint ret;\n\n\tret = nfs_readdir_xdr_to_array(desc, page, inode);\n\tif (ret < 0)\n\t\tgoto error;\n\tSetPageUptodate(page);\n\n\tif (invalidate_inode_pages2_range(inode->i_mapping, page->index + 1, -1) < 0) {\n\t\t/* Should never happen */\n\t\tnfs_zap_mapping(inode, inode->i_mapping);\n\t}\n\tunlock_page(page);\n\treturn 0;\n error:\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_readdir_xdr_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "619-680",
    "snippet": "static\nint nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page, struct inode *inode)\n{\n\tstruct page *pages[NFS_MAX_READDIR_PAGES];\n\tvoid *pages_ptr = NULL;\n\tstruct nfs_entry entry;\n\tstruct file\t*file = desc->file;\n\tstruct nfs_cache_array *array;\n\tint status = -ENOMEM;\n\tunsigned int array_size = ARRAY_SIZE(pages);\n\n\tentry.prev_cookie = 0;\n\tentry.cookie = desc->last_cookie;\n\tentry.eof = 0;\n\tentry.fh = nfs_alloc_fhandle();\n\tentry.fattr = nfs_alloc_fattr();\n\tentry.server = NFS_SERVER(inode);\n\tif (entry.fh == NULL || entry.fattr == NULL)\n\t\tgoto out;\n\n\tentry.label = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(entry.label)) {\n\t\tstatus = PTR_ERR(entry.label);\n\t\tgoto out;\n\t}\n\n\tarray = nfs_readdir_get_array(page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out_label_free;\n\t}\n\tmemset(array, 0, sizeof(struct nfs_cache_array));\n\tarray->eof_index = -1;\n\n\tstatus = nfs_readdir_large_page(pages, array_size);\n\tif (status < 0)\n\t\tgoto out_release_array;\n\tdo {\n\t\tunsigned int pglen;\n\t\tstatus = nfs_readdir_xdr_filler(pages, desc, &entry, file, inode);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tpglen = status;\n\t\tstatus = nfs_readdir_page_filler(desc, &entry, pages, page, pglen);\n\t\tif (status < 0) {\n\t\t\tif (status == -ENOSPC)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (array->eof_index < 0);\n\n\tnfs_readdir_free_large_page(pages_ptr, pages, array_size);\nout_release_array:\n\tnfs_readdir_release_array(page);\nout_label_free:\n\tnfs4_label_free(entry.label);\nout:\n\tnfs_free_fattr(entry.fattr);\n\tnfs_free_fhandle(entry.fh);\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_free_fhandle",
          "args": [
            "entry.fh"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_free_fattr",
          "args": [
            "entry.fattr"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_label_free",
          "args": [
            "entry.label"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_label_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "315-315",
          "snippet": "static inline void nfs4_label_free(void *label) {}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs4_label_free(void *label) {}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_release_array",
          "args": [
            "page"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_release_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "187-191",
          "snippet": "static\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_free_large_page",
          "args": [
            "pages_ptr",
            "pages",
            "array_size"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_free_large_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "590-595",
          "snippet": "static\nvoid nfs_readdir_free_large_page(void *ptr, struct page **pages,\n\t\tunsigned int npages)\n{\n\tnfs_readdir_free_pagearray(pages, npages);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_free_large_page(void *ptr, struct page **pages,\n\t\tunsigned int npages)\n{\n\tnfs_readdir_free_pagearray(pages, npages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_page_filler",
          "args": [
            "desc",
            "&entry",
            "pages",
            "page",
            "pglen"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_page_filler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "532-580",
          "snippet": "static\nint nfs_readdir_page_filler(nfs_readdir_descriptor_t *desc, struct nfs_entry *entry,\n\t\t\t\tstruct page **xdr_pages, struct page *page, unsigned int buflen)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct nfs_cache_array *array;\n\tunsigned int count = 0;\n\tint status;\n\n\tscratch = alloc_page(GFP_KERNEL);\n\tif (scratch == NULL)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, xdr_pages, buflen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\tdo {\n\t\tstatus = xdr_decode(desc, entry, &stream);\n\t\tif (status != 0) {\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\tif (desc->plus != 0)\n\t\t\tnfs_prime_dcache(desc->file->f_path.dentry, entry);\n\n\t\tstatus = nfs_readdir_add_to_array(entry, page);\n\t\tif (status != 0)\n\t\t\tbreak;\n\t} while (!entry->eof);\n\n\tif (count == 0 || (status == -EBADCOOKIE && entry->eof != 0)) {\n\t\tarray = nfs_readdir_get_array(page);\n\t\tif (!IS_ERR(array)) {\n\t\t\tarray->eof_index = array->size;\n\t\t\tstatus = 0;\n\t\t\tnfs_readdir_release_array(page);\n\t\t} else\n\t\t\tstatus = PTR_ERR(array);\n\t}\n\n\tput_page(scratch);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_page_filler(nfs_readdir_descriptor_t *desc, struct nfs_entry *entry,\n\t\t\t\tstruct page **xdr_pages, struct page *page, unsigned int buflen)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct nfs_cache_array *array;\n\tunsigned int count = 0;\n\tint status;\n\n\tscratch = alloc_page(GFP_KERNEL);\n\tif (scratch == NULL)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, xdr_pages, buflen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\tdo {\n\t\tstatus = xdr_decode(desc, entry, &stream);\n\t\tif (status != 0) {\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\tif (desc->plus != 0)\n\t\t\tnfs_prime_dcache(desc->file->f_path.dentry, entry);\n\n\t\tstatus = nfs_readdir_add_to_array(entry, page);\n\t\tif (status != 0)\n\t\t\tbreak;\n\t} while (!entry->eof);\n\n\tif (count == 0 || (status == -EBADCOOKIE && entry->eof != 0)) {\n\t\tarray = nfs_readdir_get_array(page);\n\t\tif (!IS_ERR(array)) {\n\t\t\tarray->eof_index = array->size;\n\t\t\tstatus = 0;\n\t\t\tnfs_readdir_release_array(page);\n\t\t} else\n\t\t\tstatus = PTR_ERR(array);\n\t}\n\n\tput_page(scratch);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_xdr_filler",
          "args": [
            "pages",
            "desc",
            "&entry",
            "file",
            "inode"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_xdr_filler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "368-396",
          "snippet": "static\nint nfs_readdir_xdr_filler(struct page **pages, nfs_readdir_descriptor_t *desc,\n\t\t\tstruct nfs_entry *entry, struct file *file, struct inode *inode)\n{\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\tstruct rpc_cred\t*cred = ctx->cred;\n\tunsigned long\ttimestamp, gencount;\n\tint\t\terror;\n\n again:\n\ttimestamp = jiffies;\n\tgencount = nfs_inc_attr_generation_counter();\n\terror = NFS_PROTO(inode)->readdir(file->f_path.dentry, cred, entry->cookie, pages,\n\t\t\t\t\t  NFS_SERVER(inode)->dtsize, desc->plus);\n\tif (error < 0) {\n\t\t/* We requested READDIRPLUS, but the server doesn't grok it */\n\t\tif (error == -ENOTSUPP && desc->plus) {\n\t\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_READDIRPLUS;\n\t\t\tclear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\tdesc->plus = 0;\n\t\t\tgoto again;\n\t\t}\n\t\tgoto error;\n\t}\n\tdesc->timestamp = timestamp;\n\tdesc->gencount = gencount;\nerror:\n\treturn error;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_xdr_filler(struct page **pages, nfs_readdir_descriptor_t *desc,\n\t\t\tstruct nfs_entry *entry, struct file *file, struct inode *inode)\n{\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\tstruct rpc_cred\t*cred = ctx->cred;\n\tunsigned long\ttimestamp, gencount;\n\tint\t\terror;\n\n again:\n\ttimestamp = jiffies;\n\tgencount = nfs_inc_attr_generation_counter();\n\terror = NFS_PROTO(inode)->readdir(file->f_path.dentry, cred, entry->cookie, pages,\n\t\t\t\t\t  NFS_SERVER(inode)->dtsize, desc->plus);\n\tif (error < 0) {\n\t\t/* We requested READDIRPLUS, but the server doesn't grok it */\n\t\tif (error == -ENOTSUPP && desc->plus) {\n\t\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_READDIRPLUS;\n\t\t\tclear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\tdesc->plus = 0;\n\t\t\tgoto again;\n\t\t}\n\t\tgoto error;\n\t}\n\tdesc->timestamp = timestamp;\n\tdesc->gencount = gencount;\nerror:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_large_page",
          "args": [
            "pages",
            "array_size"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_large_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "601-617",
          "snippet": "static\nint nfs_readdir_large_page(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = alloc_page(GFP_KERNEL);\n\t\tif (page == NULL)\n\t\t\tgoto out_freepages;\n\t\tpages[i] = page;\n\t}\n\treturn 0;\n\nout_freepages:\n\tnfs_readdir_free_pagearray(pages, i);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_large_page(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = alloc_page(GFP_KERNEL);\n\t\tif (page == NULL)\n\t\t\tgoto out_freepages;\n\t\tpages[i] = page;\n\t}\n\treturn 0;\n\nout_freepages:\n\tnfs_readdir_free_pagearray(pages, i);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "array",
            "0",
            "sizeof(struct nfs_cache_array)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "array"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "array"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_get_array",
          "args": [
            "page"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_get_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "175-185",
          "snippet": "static\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "entry.label"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "entry.label"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_label_alloc",
          "args": [
            "NFS_SERVER(inode)",
            "GFP_NOWAIT"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_label_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "306-329",
          "snippet": "struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label = NULL;\n\tint minor_version = server->nfs_client->cl_minorversion;\n\n\tif (minor_version < 2)\n\t\treturn label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn label;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags)\n{\n\tstruct nfs4_label *label = NULL;\n\tint minor_version = server->nfs_client->cl_minorversion;\n\n\tif (minor_version < 2)\n\t\treturn label;\n\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\treturn label;\n\n\tlabel = kzalloc(sizeof(struct nfs4_label), flags);\n\tif (label == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlabel->label = kzalloc(NFS4_MAXLABELLEN, flags);\n\tif (label->label == NULL) {\n\t\tkfree(label);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlabel->len = NFS4_MAXLABELLEN;\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fattr",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1312-1320",
          "snippet": "struct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct nfs_fattr *nfs_alloc_fattr(void)\n{\n\tstruct nfs_fattr *fattr;\n\n\tfattr = kmalloc(sizeof(*fattr), GFP_NOFS);\n\tif (fattr != NULL)\n\t\tnfs_fattr_init(fattr);\n\treturn fattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_alloc_fhandle",
          "args": [],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_alloc_fhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1323-1331",
          "snippet": "struct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_fh *nfs_alloc_fhandle(void)\n{\n\tstruct nfs_fh *fh;\n\n\tfh = kmalloc(sizeof(struct nfs_fh), GFP_NOFS);\n\tif (fh != NULL)\n\t\tfh->size = 0;\n\treturn fh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_xdr_to_array(nfs_readdir_descriptor_t *desc, struct page *page, struct inode *inode)\n{\n\tstruct page *pages[NFS_MAX_READDIR_PAGES];\n\tvoid *pages_ptr = NULL;\n\tstruct nfs_entry entry;\n\tstruct file\t*file = desc->file;\n\tstruct nfs_cache_array *array;\n\tint status = -ENOMEM;\n\tunsigned int array_size = ARRAY_SIZE(pages);\n\n\tentry.prev_cookie = 0;\n\tentry.cookie = desc->last_cookie;\n\tentry.eof = 0;\n\tentry.fh = nfs_alloc_fhandle();\n\tentry.fattr = nfs_alloc_fattr();\n\tentry.server = NFS_SERVER(inode);\n\tif (entry.fh == NULL || entry.fattr == NULL)\n\t\tgoto out;\n\n\tentry.label = nfs4_label_alloc(NFS_SERVER(inode), GFP_NOWAIT);\n\tif (IS_ERR(entry.label)) {\n\t\tstatus = PTR_ERR(entry.label);\n\t\tgoto out;\n\t}\n\n\tarray = nfs_readdir_get_array(page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out_label_free;\n\t}\n\tmemset(array, 0, sizeof(struct nfs_cache_array));\n\tarray->eof_index = -1;\n\n\tstatus = nfs_readdir_large_page(pages, array_size);\n\tif (status < 0)\n\t\tgoto out_release_array;\n\tdo {\n\t\tunsigned int pglen;\n\t\tstatus = nfs_readdir_xdr_filler(pages, desc, &entry, file, inode);\n\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tpglen = status;\n\t\tstatus = nfs_readdir_page_filler(desc, &entry, pages, page, pglen);\n\t\tif (status < 0) {\n\t\t\tif (status == -ENOSPC)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (array->eof_index < 0);\n\n\tnfs_readdir_free_large_page(pages_ptr, pages, array_size);\nout_release_array:\n\tnfs_readdir_release_array(page);\nout_label_free:\n\tnfs4_label_free(entry.label);\nout:\n\tnfs_free_fattr(entry.fattr);\n\tnfs_free_fhandle(entry.fh);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_readdir_large_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "601-617",
    "snippet": "static\nint nfs_readdir_large_page(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = alloc_page(GFP_KERNEL);\n\t\tif (page == NULL)\n\t\t\tgoto out_freepages;\n\t\tpages[i] = page;\n\t}\n\treturn 0;\n\nout_freepages:\n\tnfs_readdir_free_pagearray(pages, i);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_readdir_free_pagearray",
          "args": [
            "pages",
            "i"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_free_pagearray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "582-588",
          "snippet": "static\nvoid nfs_readdir_free_pagearray(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\tfor (i = 0; i < npages; i++)\n\t\tput_page(pages[i]);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_free_pagearray(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\tfor (i = 0; i < npages; i++)\n\t\tput_page(pages[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_large_page(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *page = alloc_page(GFP_KERNEL);\n\t\tif (page == NULL)\n\t\t\tgoto out_freepages;\n\t\tpages[i] = page;\n\t}\n\treturn 0;\n\nout_freepages:\n\tnfs_readdir_free_pagearray(pages, i);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nfs_readdir_free_large_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "590-595",
    "snippet": "static\nvoid nfs_readdir_free_large_page(void *ptr, struct page **pages,\n\t\tunsigned int npages)\n{\n\tnfs_readdir_free_pagearray(pages, npages);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_readdir_free_pagearray",
          "args": [
            "pages",
            "npages"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_free_pagearray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "582-588",
          "snippet": "static\nvoid nfs_readdir_free_pagearray(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\tfor (i = 0; i < npages; i++)\n\t\tput_page(pages[i]);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_free_pagearray(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\tfor (i = 0; i < npages; i++)\n\t\tput_page(pages[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_free_large_page(void *ptr, struct page **pages,\n\t\tunsigned int npages)\n{\n\tnfs_readdir_free_pagearray(pages, npages);\n}"
  },
  {
    "function_name": "nfs_readdir_free_pagearray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "582-588",
    "snippet": "static\nvoid nfs_readdir_free_pagearray(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\tfor (i = 0; i < npages; i++)\n\t\tput_page(pages[i]);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_free_pagearray(struct page **pages, unsigned int npages)\n{\n\tunsigned int i;\n\tfor (i = 0; i < npages; i++)\n\t\tput_page(pages[i]);\n}"
  },
  {
    "function_name": "nfs_readdir_page_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "532-580",
    "snippet": "static\nint nfs_readdir_page_filler(nfs_readdir_descriptor_t *desc, struct nfs_entry *entry,\n\t\t\t\tstruct page **xdr_pages, struct page *page, unsigned int buflen)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct nfs_cache_array *array;\n\tunsigned int count = 0;\n\tint status;\n\n\tscratch = alloc_page(GFP_KERNEL);\n\tif (scratch == NULL)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, xdr_pages, buflen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\tdo {\n\t\tstatus = xdr_decode(desc, entry, &stream);\n\t\tif (status != 0) {\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\tif (desc->plus != 0)\n\t\t\tnfs_prime_dcache(desc->file->f_path.dentry, entry);\n\n\t\tstatus = nfs_readdir_add_to_array(entry, page);\n\t\tif (status != 0)\n\t\t\tbreak;\n\t} while (!entry->eof);\n\n\tif (count == 0 || (status == -EBADCOOKIE && entry->eof != 0)) {\n\t\tarray = nfs_readdir_get_array(page);\n\t\tif (!IS_ERR(array)) {\n\t\t\tarray->eof_index = array->size;\n\t\t\tstatus = 0;\n\t\t\tnfs_readdir_release_array(page);\n\t\t} else\n\t\t\tstatus = PTR_ERR(array);\n\t}\n\n\tput_page(scratch);\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "scratch"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "array"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_release_array",
          "args": [
            "page"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_release_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "187-191",
          "snippet": "static\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "array"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_get_array",
          "args": [
            "page"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_get_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "175-185",
          "snippet": "static\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_add_to_array",
          "args": [
            "entry",
            "page"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_add_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "229-259",
          "snippet": "static\nint nfs_readdir_add_to_array(struct nfs_entry *entry, struct page *page)\n{\n\tstruct nfs_cache_array *array = nfs_readdir_get_array(page);\n\tstruct nfs_cache_array_entry *cache_entry;\n\tint ret;\n\n\tif (IS_ERR(array))\n\t\treturn PTR_ERR(array);\n\n\tcache_entry = &array->array[array->size];\n\n\t/* Check that this entry lies within the page bounds */\n\tret = -ENOSPC;\n\tif ((char *)&cache_entry[1] - (char *)page_address(page) > PAGE_SIZE)\n\t\tgoto out;\n\n\tcache_entry->cookie = entry->prev_cookie;\n\tcache_entry->ino = entry->ino;\n\tcache_entry->d_type = entry->d_type;\n\tret = nfs_readdir_make_qstr(&cache_entry->string, entry->name, entry->len);\n\tif (ret)\n\t\tgoto out;\n\tarray->last_cookie = entry->cookie;\n\tarray->size++;\n\tif (entry->eof != 0)\n\t\tarray->eof_index = array->size;\nout:\n\tnfs_readdir_release_array(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_add_to_array(struct nfs_entry *entry, struct page *page)\n{\n\tstruct nfs_cache_array *array = nfs_readdir_get_array(page);\n\tstruct nfs_cache_array_entry *cache_entry;\n\tint ret;\n\n\tif (IS_ERR(array))\n\t\treturn PTR_ERR(array);\n\n\tcache_entry = &array->array[array->size];\n\n\t/* Check that this entry lies within the page bounds */\n\tret = -ENOSPC;\n\tif ((char *)&cache_entry[1] - (char *)page_address(page) > PAGE_SIZE)\n\t\tgoto out;\n\n\tcache_entry->cookie = entry->prev_cookie;\n\tcache_entry->ino = entry->ino;\n\tcache_entry->d_type = entry->d_type;\n\tret = nfs_readdir_make_qstr(&cache_entry->string, entry->name, entry->len);\n\tif (ret)\n\t\tgoto out;\n\tarray->last_cookie = entry->cookie;\n\tarray->size++;\n\tif (entry->eof != 0)\n\t\tarray->eof_index = array->size;\nout:\n\tnfs_readdir_release_array(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_prime_dcache",
          "args": [
            "desc->file->f_path.dentry",
            "entry"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_prime_dcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "470-529",
          "snippet": "static\nvoid nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry)\n{\n\tstruct qstr filename = QSTR_INIT(entry->name, entry->len);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tint status;\n\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FILEID))\n\t\treturn;\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FSID))\n\t\treturn;\n\tif (filename.name[0] == '.') {\n\t\tif (filename.len == 1)\n\t\t\treturn;\n\t\tif (filename.len == 2 && filename.name[1] == '.')\n\t\t\treturn;\n\t}\n\tfilename.hash = full_name_hash(filename.name, filename.len);\n\n\tdentry = d_lookup(parent, &filename);\n\tif (dentry != NULL) {\n\t\t/* Is there a mountpoint here? If so, just exit */\n\t\tif (!nfs_fsid_equal(&NFS_SB(dentry->d_sb)->fsid,\n\t\t\t\t\t&entry->fattr->fsid))\n\t\t\tgoto out;\n\t\tif (nfs_same_file(dentry, entry)) {\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t\tstatus = nfs_refresh_inode(dentry->d_inode, entry->fattr);\n\t\t\tif (!status)\n\t\t\t\tnfs_setsecurity(dentry->d_inode, entry->fattr, entry->label);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n\n\tdentry = d_alloc(parent, &filename);\n\tif (dentry == NULL)\n\t\treturn;\n\n\tinode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr, entry->label);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\telse if (alias) {\n\t\tnfs_set_verifier(alias, nfs_save_change_attribute(dir));\n\t\tdput(alias);\n\t} else\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\nout:\n\tdput(dentry);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nvoid nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry)\n{\n\tstruct qstr filename = QSTR_INIT(entry->name, entry->len);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tint status;\n\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FILEID))\n\t\treturn;\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FSID))\n\t\treturn;\n\tif (filename.name[0] == '.') {\n\t\tif (filename.len == 1)\n\t\t\treturn;\n\t\tif (filename.len == 2 && filename.name[1] == '.')\n\t\t\treturn;\n\t}\n\tfilename.hash = full_name_hash(filename.name, filename.len);\n\n\tdentry = d_lookup(parent, &filename);\n\tif (dentry != NULL) {\n\t\t/* Is there a mountpoint here? If so, just exit */\n\t\tif (!nfs_fsid_equal(&NFS_SB(dentry->d_sb)->fsid,\n\t\t\t\t\t&entry->fattr->fsid))\n\t\t\tgoto out;\n\t\tif (nfs_same_file(dentry, entry)) {\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t\tstatus = nfs_refresh_inode(dentry->d_inode, entry->fattr);\n\t\t\tif (!status)\n\t\t\t\tnfs_setsecurity(dentry->d_inode, entry->fattr, entry->label);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n\n\tdentry = d_alloc(parent, &filename);\n\tif (dentry == NULL)\n\t\treturn;\n\n\tinode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr, entry->label);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\telse if (alias) {\n\t\tnfs_set_verifier(alias, nfs_save_change_attribute(dir));\n\t\tdput(alias);\n\t} else\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\nout:\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode",
          "args": [
            "desc",
            "entry",
            "&stream"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "398-409",
          "snippet": "static int xdr_decode(nfs_readdir_descriptor_t *desc,\n\t\t      struct nfs_entry *entry, struct xdr_stream *xdr)\n{\n\tint error;\n\n\terror = desc->decode(xdr, entry, desc->plus);\n\tif (error)\n\t\treturn error;\n\tentry->fattr->time_start = desc->timestamp;\n\tentry->fattr->gencount = desc->gencount;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int xdr_decode(nfs_readdir_descriptor_t *desc,\n\t\t      struct nfs_entry *entry, struct xdr_stream *xdr)\n{\n\tint error;\n\n\terror = desc->decode(xdr, entry, desc->plus);\n\tif (error)\n\t\treturn error;\n\tentry->fattr->time_start = desc->timestamp;\n\tentry->fattr->gencount = desc->gencount;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&stream",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode_pages",
          "args": [
            "&stream",
            "&buf",
            "xdr_pages",
            "buflen"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_page_filler(nfs_readdir_descriptor_t *desc, struct nfs_entry *entry,\n\t\t\t\tstruct page **xdr_pages, struct page *page, unsigned int buflen)\n{\n\tstruct xdr_stream stream;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tstruct nfs_cache_array *array;\n\tunsigned int count = 0;\n\tint status;\n\n\tscratch = alloc_page(GFP_KERNEL);\n\tif (scratch == NULL)\n\t\treturn -ENOMEM;\n\n\txdr_init_decode_pages(&stream, &buf, xdr_pages, buflen);\n\txdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\n\n\tdo {\n\t\tstatus = xdr_decode(desc, entry, &stream);\n\t\tif (status != 0) {\n\t\t\tif (status == -EAGAIN)\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\tif (desc->plus != 0)\n\t\t\tnfs_prime_dcache(desc->file->f_path.dentry, entry);\n\n\t\tstatus = nfs_readdir_add_to_array(entry, page);\n\t\tif (status != 0)\n\t\t\tbreak;\n\t} while (!entry->eof);\n\n\tif (count == 0 || (status == -EBADCOOKIE && entry->eof != 0)) {\n\t\tarray = nfs_readdir_get_array(page);\n\t\tif (!IS_ERR(array)) {\n\t\t\tarray->eof_index = array->size;\n\t\t\tstatus = 0;\n\t\t\tnfs_readdir_release_array(page);\n\t\t} else\n\t\t\tstatus = PTR_ERR(array);\n\t}\n\n\tput_page(scratch);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_prime_dcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "470-529",
    "snippet": "static\nvoid nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry)\n{\n\tstruct qstr filename = QSTR_INIT(entry->name, entry->len);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tint status;\n\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FILEID))\n\t\treturn;\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FSID))\n\t\treturn;\n\tif (filename.name[0] == '.') {\n\t\tif (filename.len == 1)\n\t\t\treturn;\n\t\tif (filename.len == 2 && filename.name[1] == '.')\n\t\t\treturn;\n\t}\n\tfilename.hash = full_name_hash(filename.name, filename.len);\n\n\tdentry = d_lookup(parent, &filename);\n\tif (dentry != NULL) {\n\t\t/* Is there a mountpoint here? If so, just exit */\n\t\tif (!nfs_fsid_equal(&NFS_SB(dentry->d_sb)->fsid,\n\t\t\t\t\t&entry->fattr->fsid))\n\t\t\tgoto out;\n\t\tif (nfs_same_file(dentry, entry)) {\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t\tstatus = nfs_refresh_inode(dentry->d_inode, entry->fattr);\n\t\t\tif (!status)\n\t\t\t\tnfs_setsecurity(dentry->d_inode, entry->fattr, entry->label);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n\n\tdentry = d_alloc(parent, &filename);\n\tif (dentry == NULL)\n\t\treturn;\n\n\tinode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr, entry->label);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\telse if (alias) {\n\t\tnfs_set_verifier(alias, nfs_save_change_attribute(dir));\n\t\tdput(alias);\n\t} else\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\nout:\n\tdput(dentry);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "alias",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "alias"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_fhget",
          "args": [
            "dentry->d_sb",
            "entry->fh",
            "entry->fattr",
            "entry->label"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fhget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "343-490",
          "snippet": "struct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nstruct inode *\nnfs_fhget(struct super_block *sb, struct nfs_fh *fh, struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_find_desc desc = {\n\t\t.fh\t= fh,\n\t\t.fattr\t= fattr\n\t};\n\tstruct inode *inode = ERR_PTR(-ENOENT);\n\tunsigned long hash;\n\n\tnfs_attr_check_mountpoint(sb, fattr);\n\n\tif (nfs_attr_use_mounted_on_fileid(fattr))\n\t\tfattr->fileid = fattr->mounted_on_fileid;\n\telse if ((fattr->valid & NFS_ATTR_FATTR_FILEID) == 0)\n\t\tgoto out_no_inode;\n\tif ((fattr->valid & NFS_ATTR_FATTR_TYPE) == 0)\n\t\tgoto out_no_inode;\n\n\thash = nfs_fattr_to_ino_t(fattr);\n\n\tinode = iget5_locked(sb, hash, nfs_find_actor, nfs_init_locked, &desc);\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out_no_inode;\n\t}\n\n\tif (inode->i_state & I_NEW) {\n\t\tstruct nfs_inode *nfsi = NFS_I(inode);\n\t\tunsigned long now = jiffies;\n\n\t\t/* We set i_ino for the few things that still rely on it,\n\t\t * such as stat(2) */\n\t\tinode->i_ino = hash;\n\n\t\t/* We can't support update_atime(), since the server will reset it */\n\t\tinode->i_flags |= S_NOATIME|S_NOCMTIME;\n\t\tinode->i_mode = fattr->mode;\n\t\tif ((fattr->valid & NFS_ATTR_FATTR_MODE) == 0\n\t\t\t\t&& nfs_server_capable(inode, NFS_CAP_MODE))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\t/* Why so? Because we want revalidate for devices/FIFOs, and\n\t\t * that's precisely what we have in nfs_file_inode_operations.\n\t\t */\n\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->file_inode_ops;\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_fop = NFS_SB(sb)->nfs_client->rpc_ops->file_ops;\n\t\t\tinode->i_data.a_ops = &nfs_file_aops;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = NFS_SB(sb)->nfs_client->rpc_ops->dir_inode_ops;\n\t\t\tinode->i_fop = &nfs_dir_operations;\n\t\t\tinode->i_data.a_ops = &nfs_dir_aops;\n\t\t\t/* Deal with crossing mountpoints */\n\t\t\tif (fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT ||\n\t\t\t\t\tfattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\t\t\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL)\n\t\t\t\t\tinode->i_op = &nfs_referral_inode_operations;\n\t\t\t\telse\n\t\t\t\t\tinode->i_op = &nfs_mountpoint_inode_operations;\n\t\t\t\tinode->i_fop = NULL;\n\t\t\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\t\t}\n\t\t} else if (S_ISLNK(inode->i_mode))\n\t\t\tinode->i_op = &nfs_symlink_inode_operations;\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode, fattr->rdev);\n\n\t\tmemset(&inode->i_atime, 0, sizeof(inode->i_atime));\n\t\tmemset(&inode->i_mtime, 0, sizeof(inode->i_mtime));\n\t\tmemset(&inode->i_ctime, 0, sizeof(inode->i_ctime));\n\t\tinode->i_version = 0;\n\t\tinode->i_size = 0;\n\t\tclear_nlink(inode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, -2);\n\t\tinode->i_gid = make_kgid(&init_user_ns, -2);\n\t\tinode->i_blocks = 0;\n\t\tmemset(nfsi->cookieverf, 0, sizeof(nfsi->cookieverf));\n\t\tnfsi->write_io = 0;\n\t\tnfsi->read_io = 0;\n\n\t\tnfsi->read_cache_jiffies = fattr->time_start;\n\t\tnfsi->attr_gencount = fattr->gencount;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_ATIME)\n\t\t\tinode->i_atime = fattr->atime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_ATIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_MTIME)\n\t\t\tinode->i_mtime = fattr->mtime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_MTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CTIME)\n\t\t\tinode->i_ctime = fattr->ctime;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CTIME))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_CHANGE)\n\t\t\tinode->i_version = fattr->change_attr;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_CHANGE_ATTR))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SIZE)\n\t\t\tinode->i_size = nfs_size_to_loff_t(fattr->size);\n\t\telse\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR\n\t\t\t\t| NFS_INO_REVAL_PAGECACHE);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_NLINK)\n\t\t\tset_nlink(inode, fattr->nlink);\n\t\telse if (nfs_server_capable(inode, NFS_CAP_NLINK))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_OWNER)\n\t\t\tinode->i_uid = fattr->uid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_GROUP)\n\t\t\tinode->i_gid = fattr->gid;\n\t\telse if (nfs_server_capable(inode, NFS_CAP_OWNER_GROUP))\n\t\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_ATTR);\n\t\tif (fattr->valid & NFS_ATTR_FATTR_BLOCKS_USED)\n\t\t\tinode->i_blocks = fattr->du.nfs2.blocks;\n\t\tif (fattr->valid & NFS_ATTR_FATTR_SPACE_USED) {\n\t\t\t/*\n\t\t\t * report the blocks in 512byte units\n\t\t\t */\n\t\t\tinode->i_blocks = nfs_calc_block_size(fattr->du.nfs3.used);\n\t\t}\n\n\t\tnfs_setsecurity(inode, fattr, label);\n\n\t\tnfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n\t\tnfsi->attrtimeo_timestamp = now;\n\t\tnfsi->access_cache = RB_ROOT;\n\n\t\tnfs_fscache_init_inode(inode);\n\n\t\tunlock_new_inode(inode);\n\t} else\n\t\tnfs_refresh_inode(inode, fattr);\n\tdprintk(\"NFS: nfs_fhget(%s/%Lu fh_crc=0x%08x ct=%d)\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode),\n\t\tnfs_display_fhandle_hash(fh),\n\t\tatomic_read(&inode->i_count));\n\nout:\n\treturn inode;\n\nout_no_inode:\n\tdprintk(\"nfs_fhget: iget failed with error %ld\\n\", PTR_ERR(inode));\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "&filename"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "dentry"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_setsecurity",
          "args": [
            "dentry->d_inode",
            "entry->fattr",
            "entry->label"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_setsecurity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "332-335",
          "snippet": "void nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nvoid nfs_setsecurity(struct inode *inode, struct nfs_fattr *fattr,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_refresh_inode",
          "args": [
            "dentry->d_inode",
            "entry->fattr"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_refresh_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1466-1477",
          "snippet": "int nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint nfs_refresh_inode(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0)\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tstatus = nfs_refresh_inode_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_verifier",
          "args": [
            "dentry",
            "nfs_save_change_attribute(dir)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_save_change_attribute",
          "args": [
            "dir"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_same_file",
          "args": [
            "dentry",
            "entry"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_same_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "414-429",
          "snippet": "static\nint nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)\n{\n\tstruct nfs_inode *nfsi;\n\n\tif (dentry->d_inode == NULL)\n\t\tgoto different;\n\n\tnfsi = NFS_I(dentry->d_inode);\n\tif (entry->fattr->fileid == nfsi->fileid)\n\t\treturn 1;\n\tif (nfs_compare_fh(entry->fh, &nfsi->fh) == 0)\n\t\treturn 1;\ndifferent:\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nint nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)\n{\n\tstruct nfs_inode *nfsi;\n\n\tif (dentry->d_inode == NULL)\n\t\tgoto different;\n\n\tnfsi = NFS_I(dentry->d_inode);\n\tif (entry->fattr->fileid == nfsi->fileid)\n\t\treturn 1;\n\tif (nfs_compare_fh(entry->fh, &nfsi->fh) == 0)\n\t\treturn 1;\ndifferent:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_fsid_equal",
          "args": [
            "&NFS_SB(dentry->d_sb)->fsid",
            "&entry->fattr->fsid"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&filename"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "filename.name",
            "filename.len"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "entry->name",
            "entry->len"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nvoid nfs_prime_dcache(struct dentry *parent, struct nfs_entry *entry)\n{\n\tstruct qstr filename = QSTR_INIT(entry->name, entry->len);\n\tstruct dentry *dentry;\n\tstruct dentry *alias;\n\tstruct inode *dir = parent->d_inode;\n\tstruct inode *inode;\n\tint status;\n\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FILEID))\n\t\treturn;\n\tif (!(entry->fattr->valid & NFS_ATTR_FATTR_FSID))\n\t\treturn;\n\tif (filename.name[0] == '.') {\n\t\tif (filename.len == 1)\n\t\t\treturn;\n\t\tif (filename.len == 2 && filename.name[1] == '.')\n\t\t\treturn;\n\t}\n\tfilename.hash = full_name_hash(filename.name, filename.len);\n\n\tdentry = d_lookup(parent, &filename);\n\tif (dentry != NULL) {\n\t\t/* Is there a mountpoint here? If so, just exit */\n\t\tif (!nfs_fsid_equal(&NFS_SB(dentry->d_sb)->fsid,\n\t\t\t\t\t&entry->fattr->fsid))\n\t\t\tgoto out;\n\t\tif (nfs_same_file(dentry, entry)) {\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t\tstatus = nfs_refresh_inode(dentry->d_inode, entry->fattr);\n\t\t\tif (!status)\n\t\t\t\tnfs_setsecurity(dentry->d_inode, entry->fattr, entry->label);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\td_invalidate(dentry);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n\n\tdentry = d_alloc(parent, &filename);\n\tif (dentry == NULL)\n\t\treturn;\n\n\tinode = nfs_fhget(dentry->d_sb, entry->fh, entry->fattr, entry->label);\n\tif (IS_ERR(inode))\n\t\tgoto out;\n\n\talias = d_splice_alias(inode, dentry);\n\tif (IS_ERR(alias))\n\t\tgoto out;\n\telse if (alias) {\n\t\tnfs_set_verifier(alias, nfs_save_change_attribute(dir));\n\t\tdput(alias);\n\t} else\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\nout:\n\tdput(dentry);\n}"
  },
  {
    "function_name": "nfs_force_use_readdirplus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "462-468",
    "snippet": "void nfs_force_use_readdirplus(struct inode *dir)\n{\n\tif (!list_empty(&NFS_I(dir)->open_files)) {\n\t\tnfs_advise_use_readdirplus(dir);\n\t\tnfs_zap_mapping(dir, dir->i_mapping);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_zap_mapping",
          "args": [
            "dir",
            "dir->i_mapping"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "197-204",
          "snippet": "void nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_advise_use_readdirplus",
          "args": [
            "dir"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_advise_use_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "448-452",
          "snippet": "static\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&NFS_I(dir)->open_files"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid nfs_force_use_readdirplus(struct inode *dir)\n{\n\tif (!list_empty(&NFS_I(dir)->open_files)) {\n\t\tnfs_advise_use_readdirplus(dir);\n\t\tnfs_zap_mapping(dir, dir->i_mapping);\n\t}\n}"
  },
  {
    "function_name": "nfs_advise_use_readdirplus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "448-452",
    "snippet": "static\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_INO_ADVISE_RDPLUS",
            "&NFS_I(dir)->flags"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nvoid nfs_advise_use_readdirplus(struct inode *dir)\n{\n\tset_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags);\n}"
  },
  {
    "function_name": "nfs_use_readdirplus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "431-441",
    "snippet": "static\nbool nfs_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tif (!nfs_server_capable(dir, NFS_CAP_READDIRPLUS))\n\t\treturn false;\n\tif (test_and_clear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "NFS_INO_ADVISE_RDPLUS",
            "&NFS_I(dir)->flags"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "dir",
            "NFS_CAP_READDIRPLUS"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_readdir(struct file *, struct dir_context *);\n\nstatic\nbool nfs_use_readdirplus(struct inode *dir, struct dir_context *ctx)\n{\n\tif (!nfs_server_capable(dir, NFS_CAP_READDIRPLUS))\n\t\treturn false;\n\tif (test_and_clear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(dir)->flags))\n\t\treturn true;\n\tif (ctx->pos == 0)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "nfs_same_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "414-429",
    "snippet": "static\nint nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)\n{\n\tstruct nfs_inode *nfsi;\n\n\tif (dentry->d_inode == NULL)\n\t\tgoto different;\n\n\tnfsi = NFS_I(dentry->d_inode);\n\tif (entry->fattr->fileid == nfsi->fileid)\n\t\treturn 1;\n\tif (nfs_compare_fh(entry->fh, &nfsi->fh) == 0)\n\t\treturn 1;\ndifferent:\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_compare_fh",
          "args": [
            "entry->fh",
            "&nfsi->fh"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic\nint nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)\n{\n\tstruct nfs_inode *nfsi;\n\n\tif (dentry->d_inode == NULL)\n\t\tgoto different;\n\n\tnfsi = NFS_I(dentry->d_inode);\n\tif (entry->fattr->fileid == nfsi->fileid)\n\t\treturn 1;\n\tif (nfs_compare_fh(entry->fh, &nfsi->fh) == 0)\n\t\treturn 1;\ndifferent:\n\treturn 0;\n}"
  },
  {
    "function_name": "xdr_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "398-409",
    "snippet": "static int xdr_decode(nfs_readdir_descriptor_t *desc,\n\t\t      struct nfs_entry *entry, struct xdr_stream *xdr)\n{\n\tint error;\n\n\terror = desc->decode(xdr, entry, desc->plus);\n\tif (error)\n\t\treturn error;\n\tentry->fattr->time_start = desc->timestamp;\n\tentry->fattr->gencount = desc->gencount;\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "desc->decode",
          "args": [
            "xdr",
            "entry",
            "desc->plus"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int xdr_decode(nfs_readdir_descriptor_t *desc,\n\t\t      struct nfs_entry *entry, struct xdr_stream *xdr)\n{\n\tint error;\n\n\terror = desc->decode(xdr, entry, desc->plus);\n\tif (error)\n\t\treturn error;\n\tentry->fattr->time_start = desc->timestamp;\n\tentry->fattr->gencount = desc->gencount;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_readdir_xdr_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "368-396",
    "snippet": "static\nint nfs_readdir_xdr_filler(struct page **pages, nfs_readdir_descriptor_t *desc,\n\t\t\tstruct nfs_entry *entry, struct file *file, struct inode *inode)\n{\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\tstruct rpc_cred\t*cred = ctx->cred;\n\tunsigned long\ttimestamp, gencount;\n\tint\t\terror;\n\n again:\n\ttimestamp = jiffies;\n\tgencount = nfs_inc_attr_generation_counter();\n\terror = NFS_PROTO(inode)->readdir(file->f_path.dentry, cred, entry->cookie, pages,\n\t\t\t\t\t  NFS_SERVER(inode)->dtsize, desc->plus);\n\tif (error < 0) {\n\t\t/* We requested READDIRPLUS, but the server doesn't grok it */\n\t\tif (error == -ENOTSUPP && desc->plus) {\n\t\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_READDIRPLUS;\n\t\t\tclear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\tdesc->plus = 0;\n\t\t\tgoto again;\n\t\t}\n\t\tgoto error;\n\t}\n\tdesc->timestamp = timestamp;\n\tdesc->gencount = gencount;\nerror:\n\treturn error;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_INO_ADVISE_RDPLUS",
            "&NFS_I(inode)->flags"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "file->f_path.dentry",
            "cred",
            "entry->cookie",
            "pages",
            "NFS_SERVER(inode)->dtsize",
            "desc->plus"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_attr_generation_counter",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_attr_generation_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1280-1283",
          "snippet": "unsigned long nfs_inc_attr_generation_counter(void)\n{\n\treturn atomic_long_inc_return(&nfs_attr_generation_counter);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_long_t nfs_attr_generation_counter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic atomic_long_t nfs_attr_generation_counter;\n\nunsigned long nfs_inc_attr_generation_counter(void)\n{\n\treturn atomic_long_inc_return(&nfs_attr_generation_counter);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_xdr_filler(struct page **pages, nfs_readdir_descriptor_t *desc,\n\t\t\tstruct nfs_entry *entry, struct file *file, struct inode *inode)\n{\n\tstruct nfs_open_dir_context *ctx = file->private_data;\n\tstruct rpc_cred\t*cred = ctx->cred;\n\tunsigned long\ttimestamp, gencount;\n\tint\t\terror;\n\n again:\n\ttimestamp = jiffies;\n\tgencount = nfs_inc_attr_generation_counter();\n\terror = NFS_PROTO(inode)->readdir(file->f_path.dentry, cred, entry->cookie, pages,\n\t\t\t\t\t  NFS_SERVER(inode)->dtsize, desc->plus);\n\tif (error < 0) {\n\t\t/* We requested READDIRPLUS, but the server doesn't grok it */\n\t\tif (error == -ENOTSUPP && desc->plus) {\n\t\t\tNFS_SERVER(inode)->caps &= ~NFS_CAP_READDIRPLUS;\n\t\t\tclear_bit(NFS_INO_ADVISE_RDPLUS, &NFS_I(inode)->flags);\n\t\t\tdesc->plus = 0;\n\t\t\tgoto again;\n\t\t}\n\t\tgoto error;\n\t}\n\tdesc->timestamp = timestamp;\n\tdesc->gencount = gencount;\nerror:\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_readdir_search_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "340-365",
    "snippet": "static\nint nfs_readdir_search_array(nfs_readdir_descriptor_t *desc)\n{\n\tstruct nfs_cache_array *array;\n\tint status;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tif (*desc->dir_cookie == 0)\n\t\tstatus = nfs_readdir_search_for_pos(array, desc);\n\telse\n\t\tstatus = nfs_readdir_search_for_cookie(array, desc);\n\n\tif (status == -EAGAIN) {\n\t\tdesc->last_cookie = array->last_cookie;\n\t\tdesc->current_index += array->size;\n\t\tdesc->page_index++;\n\t}\n\tnfs_readdir_release_array(desc->page);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_readdir_release_array",
          "args": [
            "desc->page"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_release_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "187-191",
          "snippet": "static\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_search_for_cookie",
          "args": [
            "array",
            "desc"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_search_for_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "293-338",
          "snippet": "static\nint nfs_readdir_search_for_cookie(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tint i;\n\tloff_t new_pos;\n\tint status = -EAGAIN;\n\n\tfor (i = 0; i < array->size; i++) {\n\t\tif (array->array[i].cookie == *desc->dir_cookie) {\n\t\t\tstruct nfs_inode *nfsi = NFS_I(file_inode(desc->file));\n\t\t\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\t\t\tnew_pos = desc->current_index + i;\n\t\t\tif (ctx->attr_gencount != nfsi->attr_gencount ||\n\t\t\t    !nfs_readdir_inode_mapping_valid(nfsi)) {\n\t\t\t\tctx->duped = 0;\n\t\t\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\t\t} else if (new_pos < desc->ctx->pos) {\n\t\t\t\tif (ctx->duped > 0\n\t\t\t\t    && ctx->dup_cookie == *desc->dir_cookie) {\n\t\t\t\t\tif (printk_ratelimit()) {\n\t\t\t\t\t\tpr_notice(\"NFS: directory %pD2 contains a readdir loop.\"\n\t\t\t\t\t\t\t\t\"Please contact your server vendor.  \"\n\t\t\t\t\t\t\t\t\"The file: %.*s has duplicate cookie %llu\\n\",\n\t\t\t\t\t\t\t\tdesc->file, array->array[i].string.len,\n\t\t\t\t\t\t\t\tarray->array[i].string.name, *desc->dir_cookie);\n\t\t\t\t\t}\n\t\t\t\t\tstatus = -ELOOP;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tctx->dup_cookie = *desc->dir_cookie;\n\t\t\t\tctx->duped = -1;\n\t\t\t}\n\t\t\tdesc->ctx->pos = new_pos;\n\t\t\tdesc->cache_entry_index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (array->eof_index >= 0) {\n\t\tstatus = -EBADCOOKIE;\n\t\tif (*desc->dir_cookie == array->last_cookie)\n\t\t\tdesc->eof = 1;\n\t}\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_opendir(struct inode *, struct file *);",
            "static int nfs_closedir(struct inode *, struct file *);",
            "static int nfs_fsync_dir(struct file *, loff_t, loff_t, int);",
            "static loff_t nfs_llseek_dir(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic int nfs_fsync_dir(struct file *, loff_t, loff_t, int);\nstatic loff_t nfs_llseek_dir(struct file *, loff_t, int);\n\nstatic\nint nfs_readdir_search_for_cookie(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tint i;\n\tloff_t new_pos;\n\tint status = -EAGAIN;\n\n\tfor (i = 0; i < array->size; i++) {\n\t\tif (array->array[i].cookie == *desc->dir_cookie) {\n\t\t\tstruct nfs_inode *nfsi = NFS_I(file_inode(desc->file));\n\t\t\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\t\t\tnew_pos = desc->current_index + i;\n\t\t\tif (ctx->attr_gencount != nfsi->attr_gencount ||\n\t\t\t    !nfs_readdir_inode_mapping_valid(nfsi)) {\n\t\t\t\tctx->duped = 0;\n\t\t\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\t\t} else if (new_pos < desc->ctx->pos) {\n\t\t\t\tif (ctx->duped > 0\n\t\t\t\t    && ctx->dup_cookie == *desc->dir_cookie) {\n\t\t\t\t\tif (printk_ratelimit()) {\n\t\t\t\t\t\tpr_notice(\"NFS: directory %pD2 contains a readdir loop.\"\n\t\t\t\t\t\t\t\t\"Please contact your server vendor.  \"\n\t\t\t\t\t\t\t\t\"The file: %.*s has duplicate cookie %llu\\n\",\n\t\t\t\t\t\t\t\tdesc->file, array->array[i].string.len,\n\t\t\t\t\t\t\t\tarray->array[i].string.name, *desc->dir_cookie);\n\t\t\t\t\t}\n\t\t\t\t\tstatus = -ELOOP;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tctx->dup_cookie = *desc->dir_cookie;\n\t\t\t\tctx->duped = -1;\n\t\t\t}\n\t\t\tdesc->ctx->pos = new_pos;\n\t\t\tdesc->cache_entry_index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (array->eof_index >= 0) {\n\t\tstatus = -EBADCOOKIE;\n\t\tif (*desc->dir_cookie == array->last_cookie)\n\t\t\tdesc->eof = 1;\n\t}\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_search_for_pos",
          "args": [
            "array",
            "desc"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_search_for_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "261-282",
          "snippet": "static\nint nfs_readdir_search_for_pos(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tloff_t diff = desc->ctx->pos - desc->current_index;\n\tunsigned int index;\n\n\tif (diff < 0)\n\t\tgoto out_eof;\n\tif (diff >= array->size) {\n\t\tif (array->eof_index >= 0)\n\t\t\tgoto out_eof;\n\t\treturn -EAGAIN;\n\t}\n\n\tindex = (unsigned int)diff;\n\t*desc->dir_cookie = array->array[index].cookie;\n\tdesc->cache_entry_index = index;\n\treturn 0;\nout_eof:\n\tdesc->eof = 1;\n\treturn -EBADCOOKIE;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_fsync_dir(struct file *, loff_t, loff_t, int);",
            "static loff_t nfs_llseek_dir(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_fsync_dir(struct file *, loff_t, loff_t, int);\nstatic loff_t nfs_llseek_dir(struct file *, loff_t, int);\n\nstatic\nint nfs_readdir_search_for_pos(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tloff_t diff = desc->ctx->pos - desc->current_index;\n\tunsigned int index;\n\n\tif (diff < 0)\n\t\tgoto out_eof;\n\tif (diff >= array->size) {\n\t\tif (array->eof_index >= 0)\n\t\t\tgoto out_eof;\n\t\treturn -EAGAIN;\n\t}\n\n\tindex = (unsigned int)diff;\n\t*desc->dir_cookie = array->array[index].cookie;\n\tdesc->cache_entry_index = index;\n\treturn 0;\nout_eof:\n\tdesc->eof = 1;\n\treturn -EBADCOOKIE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "array"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "array"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_get_array",
          "args": [
            "desc->page"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_get_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "175-185",
          "snippet": "static\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_search_array(nfs_readdir_descriptor_t *desc)\n{\n\tstruct nfs_cache_array *array;\n\tint status;\n\n\tarray = nfs_readdir_get_array(desc->page);\n\tif (IS_ERR(array)) {\n\t\tstatus = PTR_ERR(array);\n\t\tgoto out;\n\t}\n\n\tif (*desc->dir_cookie == 0)\n\t\tstatus = nfs_readdir_search_for_pos(array, desc);\n\telse\n\t\tstatus = nfs_readdir_search_for_cookie(array, desc);\n\n\tif (status == -EAGAIN) {\n\t\tdesc->last_cookie = array->last_cookie;\n\t\tdesc->current_index += array->size;\n\t\tdesc->page_index++;\n\t}\n\tnfs_readdir_release_array(desc->page);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_readdir_search_for_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "293-338",
    "snippet": "static\nint nfs_readdir_search_for_cookie(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tint i;\n\tloff_t new_pos;\n\tint status = -EAGAIN;\n\n\tfor (i = 0; i < array->size; i++) {\n\t\tif (array->array[i].cookie == *desc->dir_cookie) {\n\t\t\tstruct nfs_inode *nfsi = NFS_I(file_inode(desc->file));\n\t\t\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\t\t\tnew_pos = desc->current_index + i;\n\t\t\tif (ctx->attr_gencount != nfsi->attr_gencount ||\n\t\t\t    !nfs_readdir_inode_mapping_valid(nfsi)) {\n\t\t\t\tctx->duped = 0;\n\t\t\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\t\t} else if (new_pos < desc->ctx->pos) {\n\t\t\t\tif (ctx->duped > 0\n\t\t\t\t    && ctx->dup_cookie == *desc->dir_cookie) {\n\t\t\t\t\tif (printk_ratelimit()) {\n\t\t\t\t\t\tpr_notice(\"NFS: directory %pD2 contains a readdir loop.\"\n\t\t\t\t\t\t\t\t\"Please contact your server vendor.  \"\n\t\t\t\t\t\t\t\t\"The file: %.*s has duplicate cookie %llu\\n\",\n\t\t\t\t\t\t\t\tdesc->file, array->array[i].string.len,\n\t\t\t\t\t\t\t\tarray->array[i].string.name, *desc->dir_cookie);\n\t\t\t\t\t}\n\t\t\t\t\tstatus = -ELOOP;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tctx->dup_cookie = *desc->dir_cookie;\n\t\t\t\tctx->duped = -1;\n\t\t\t}\n\t\t\tdesc->ctx->pos = new_pos;\n\t\t\tdesc->cache_entry_index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (array->eof_index >= 0) {\n\t\tstatus = -EBADCOOKIE;\n\t\tif (*desc->dir_cookie == array->last_cookie)\n\t\t\tdesc->eof = 1;\n\t}\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);",
      "static int nfs_fsync_dir(struct file *, loff_t, loff_t, int);",
      "static loff_t nfs_llseek_dir(struct file *, loff_t, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"NFS: directory %pD2 contains a readdir loop.\"\n\t\t\t\t\t\t\t\t\"Please contact your server vendor.  \"\n\t\t\t\t\t\t\t\t\"The file: %.*s has duplicate cookie %llu\\n\"",
            "desc->file",
            "array->array[i].string.len",
            "array->array[i].string.name",
            "*desc->dir_cookie"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_inode_mapping_valid",
          "args": [
            "nfsi"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_inode_mapping_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "284-291",
          "snippet": "static bool\nnfs_readdir_inode_mapping_valid(struct nfs_inode *nfsi)\n{\n\tif (nfsi->cache_validity & (NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA))\n\t\treturn false;\n\tsmp_rmb();\n\treturn !test_bit(NFS_INO_INVALIDATING, &nfsi->flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic bool\nnfs_readdir_inode_mapping_valid(struct nfs_inode *nfsi)\n{\n\tif (nfsi->cache_validity & (NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA))\n\t\treturn false;\n\tsmp_rmb();\n\treturn !test_bit(NFS_INO_INVALIDATING, &nfsi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "file_inode(desc->file)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "desc->file"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\nstatic int nfs_fsync_dir(struct file *, loff_t, loff_t, int);\nstatic loff_t nfs_llseek_dir(struct file *, loff_t, int);\n\nstatic\nint nfs_readdir_search_for_cookie(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tint i;\n\tloff_t new_pos;\n\tint status = -EAGAIN;\n\n\tfor (i = 0; i < array->size; i++) {\n\t\tif (array->array[i].cookie == *desc->dir_cookie) {\n\t\t\tstruct nfs_inode *nfsi = NFS_I(file_inode(desc->file));\n\t\t\tstruct nfs_open_dir_context *ctx = desc->file->private_data;\n\n\t\t\tnew_pos = desc->current_index + i;\n\t\t\tif (ctx->attr_gencount != nfsi->attr_gencount ||\n\t\t\t    !nfs_readdir_inode_mapping_valid(nfsi)) {\n\t\t\t\tctx->duped = 0;\n\t\t\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\t\t} else if (new_pos < desc->ctx->pos) {\n\t\t\t\tif (ctx->duped > 0\n\t\t\t\t    && ctx->dup_cookie == *desc->dir_cookie) {\n\t\t\t\t\tif (printk_ratelimit()) {\n\t\t\t\t\t\tpr_notice(\"NFS: directory %pD2 contains a readdir loop.\"\n\t\t\t\t\t\t\t\t\"Please contact your server vendor.  \"\n\t\t\t\t\t\t\t\t\"The file: %.*s has duplicate cookie %llu\\n\",\n\t\t\t\t\t\t\t\tdesc->file, array->array[i].string.len,\n\t\t\t\t\t\t\t\tarray->array[i].string.name, *desc->dir_cookie);\n\t\t\t\t\t}\n\t\t\t\t\tstatus = -ELOOP;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tctx->dup_cookie = *desc->dir_cookie;\n\t\t\t\tctx->duped = -1;\n\t\t\t}\n\t\t\tdesc->ctx->pos = new_pos;\n\t\t\tdesc->cache_entry_index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (array->eof_index >= 0) {\n\t\tstatus = -EBADCOOKIE;\n\t\tif (*desc->dir_cookie == array->last_cookie)\n\t\t\tdesc->eof = 1;\n\t}\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_readdir_inode_mapping_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "284-291",
    "snippet": "static bool\nnfs_readdir_inode_mapping_valid(struct nfs_inode *nfsi)\n{\n\tif (nfsi->cache_validity & (NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA))\n\t\treturn false;\n\tsmp_rmb();\n\treturn !test_bit(NFS_INO_INVALIDATING, &nfsi->flags);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_INO_INVALIDATING",
            "&nfsi->flags"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic bool\nnfs_readdir_inode_mapping_valid(struct nfs_inode *nfsi)\n{\n\tif (nfsi->cache_validity & (NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA))\n\t\treturn false;\n\tsmp_rmb();\n\treturn !test_bit(NFS_INO_INVALIDATING, &nfsi->flags);\n}"
  },
  {
    "function_name": "nfs_readdir_search_for_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "261-282",
    "snippet": "static\nint nfs_readdir_search_for_pos(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tloff_t diff = desc->ctx->pos - desc->current_index;\n\tunsigned int index;\n\n\tif (diff < 0)\n\t\tgoto out_eof;\n\tif (diff >= array->size) {\n\t\tif (array->eof_index >= 0)\n\t\t\tgoto out_eof;\n\t\treturn -EAGAIN;\n\t}\n\n\tindex = (unsigned int)diff;\n\t*desc->dir_cookie = array->array[index].cookie;\n\tdesc->cache_entry_index = index;\n\treturn 0;\nout_eof:\n\tdesc->eof = 1;\n\treturn -EBADCOOKIE;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_fsync_dir(struct file *, loff_t, loff_t, int);",
      "static loff_t nfs_llseek_dir(struct file *, loff_t, int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_fsync_dir(struct file *, loff_t, loff_t, int);\nstatic loff_t nfs_llseek_dir(struct file *, loff_t, int);\n\nstatic\nint nfs_readdir_search_for_pos(struct nfs_cache_array *array, nfs_readdir_descriptor_t *desc)\n{\n\tloff_t diff = desc->ctx->pos - desc->current_index;\n\tunsigned int index;\n\n\tif (diff < 0)\n\t\tgoto out_eof;\n\tif (diff >= array->size) {\n\t\tif (array->eof_index >= 0)\n\t\t\tgoto out_eof;\n\t\treturn -EAGAIN;\n\t}\n\n\tindex = (unsigned int)diff;\n\t*desc->dir_cookie = array->array[index].cookie;\n\tdesc->cache_entry_index = index;\n\treturn 0;\nout_eof:\n\tdesc->eof = 1;\n\treturn -EBADCOOKIE;\n}"
  },
  {
    "function_name": "nfs_readdir_add_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "229-259",
    "snippet": "static\nint nfs_readdir_add_to_array(struct nfs_entry *entry, struct page *page)\n{\n\tstruct nfs_cache_array *array = nfs_readdir_get_array(page);\n\tstruct nfs_cache_array_entry *cache_entry;\n\tint ret;\n\n\tif (IS_ERR(array))\n\t\treturn PTR_ERR(array);\n\n\tcache_entry = &array->array[array->size];\n\n\t/* Check that this entry lies within the page bounds */\n\tret = -ENOSPC;\n\tif ((char *)&cache_entry[1] - (char *)page_address(page) > PAGE_SIZE)\n\t\tgoto out;\n\n\tcache_entry->cookie = entry->prev_cookie;\n\tcache_entry->ino = entry->ino;\n\tcache_entry->d_type = entry->d_type;\n\tret = nfs_readdir_make_qstr(&cache_entry->string, entry->name, entry->len);\n\tif (ret)\n\t\tgoto out;\n\tarray->last_cookie = entry->cookie;\n\tarray->size++;\n\tif (entry->eof != 0)\n\t\tarray->eof_index = array->size;\nout:\n\tnfs_readdir_release_array(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_readdir_release_array",
          "args": [
            "page"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_release_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "187-191",
          "snippet": "static\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readdir_make_qstr",
          "args": [
            "&cache_entry->string",
            "entry->name",
            "entry->len"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_make_qstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "213-227",
          "snippet": "static\nint nfs_readdir_make_qstr(struct qstr *string, const char *name, unsigned int len)\n{\n\tstring->len = len;\n\tstring->name = kmemdup(name, len, GFP_KERNEL);\n\tif (string->name == NULL)\n\t\treturn -ENOMEM;\n\t/*\n\t * Avoid a kmemleak false positive. The pointer to the name is stored\n\t * in a page cache page which kmemleak does not scan.\n\t */\n\tkmemleak_not_leak(string->name);\n\tstring->hash = full_name_hash(name, len);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_make_qstr(struct qstr *string, const char *name, unsigned int len)\n{\n\tstring->len = len;\n\tstring->name = kmemdup(name, len, GFP_KERNEL);\n\tif (string->name == NULL)\n\t\treturn -ENOMEM;\n\t/*\n\t * Avoid a kmemleak false positive. The pointer to the name is stored\n\t * in a page cache page which kmemleak does not scan.\n\t */\n\tkmemleak_not_leak(string->name);\n\tstring->hash = full_name_hash(name, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "array"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "array"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readdir_get_array",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readdir_get_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "175-185",
          "snippet": "static\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_readdir_clear_array(struct page*);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_add_to_array(struct nfs_entry *entry, struct page *page)\n{\n\tstruct nfs_cache_array *array = nfs_readdir_get_array(page);\n\tstruct nfs_cache_array_entry *cache_entry;\n\tint ret;\n\n\tif (IS_ERR(array))\n\t\treturn PTR_ERR(array);\n\n\tcache_entry = &array->array[array->size];\n\n\t/* Check that this entry lies within the page bounds */\n\tret = -ENOSPC;\n\tif ((char *)&cache_entry[1] - (char *)page_address(page) > PAGE_SIZE)\n\t\tgoto out;\n\n\tcache_entry->cookie = entry->prev_cookie;\n\tcache_entry->ino = entry->ino;\n\tcache_entry->d_type = entry->d_type;\n\tret = nfs_readdir_make_qstr(&cache_entry->string, entry->name, entry->len);\n\tif (ret)\n\t\tgoto out;\n\tarray->last_cookie = entry->cookie;\n\tarray->size++;\n\tif (entry->eof != 0)\n\t\tarray->eof_index = array->size;\nout:\n\tnfs_readdir_release_array(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_readdir_make_qstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "213-227",
    "snippet": "static\nint nfs_readdir_make_qstr(struct qstr *string, const char *name, unsigned int len)\n{\n\tstring->len = len;\n\tstring->name = kmemdup(name, len, GFP_KERNEL);\n\tif (string->name == NULL)\n\t\treturn -ENOMEM;\n\t/*\n\t * Avoid a kmemleak false positive. The pointer to the name is stored\n\t * in a page cache page which kmemleak does not scan.\n\t */\n\tkmemleak_not_leak(string->name);\n\tstring->hash = full_name_hash(name, len);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "name",
            "len"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemleak_not_leak",
          "args": [
            "string->name"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "name",
            "len",
            "GFP_KERNEL"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nint nfs_readdir_make_qstr(struct qstr *string, const char *name, unsigned int len)\n{\n\tstring->len = len;\n\tstring->name = kmemdup(name, len, GFP_KERNEL);\n\tif (string->name == NULL)\n\t\treturn -ENOMEM;\n\t/*\n\t * Avoid a kmemleak false positive. The pointer to the name is stored\n\t * in a page cache page which kmemleak does not scan.\n\t */\n\tkmemleak_not_leak(string->name);\n\tstring->hash = full_name_hash(name, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_readdir_clear_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "196-206",
    "snippet": "static\nvoid nfs_readdir_clear_array(struct page *page)\n{\n\tstruct nfs_cache_array *array;\n\tint i;\n\n\tarray = kmap_atomic(page);\n\tfor (i = 0; i < array->size; i++)\n\t\tkfree(array->array[i].string.name);\n\tkunmap_atomic(array);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "array"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array->array[i].string.name"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_clear_array(struct page *page)\n{\n\tstruct nfs_cache_array *array;\n\tint i;\n\n\tarray = kmap_atomic(page);\n\tfor (i = 0; i < array->size; i++)\n\t\tkfree(array->array[i].string.name);\n\tkunmap_atomic(array);\n}"
  },
  {
    "function_name": "nfs_readdir_release_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "187-191",
    "snippet": "static\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nvoid nfs_readdir_release_array(struct page *page)\n{\n\tkunmap(page);\n}"
  },
  {
    "function_name": "nfs_readdir_get_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "175-185",
    "snippet": "static\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_readdir_clear_array(struct page*);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void nfs_readdir_clear_array(struct page*);\n\nstatic\nstruct nfs_cache_array *nfs_readdir_get_array(struct page *page)\n{\n\tvoid *ptr;\n\tif (page == NULL)\n\t\treturn ERR_PTR(-EIO);\n\tptr = kmap(page);\n\tif (ptr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn ptr;\n}"
  },
  {
    "function_name": "nfs_closedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "133-138",
    "snippet": "static int\nnfs_closedir(struct inode *inode, struct file *filp)\n{\n\tput_nfs_open_dir_context(file_inode(filp), filp->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs_open_dir_context",
          "args": [
            "file_inode(filp)",
            "filp->private_data"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs_open_dir_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "89-96",
          "snippet": "static void put_nfs_open_dir_context(struct inode *dir, struct nfs_open_dir_context *ctx)\n{\n\tspin_lock(&dir->i_lock);\n\tlist_del(&ctx->list);\n\tspin_unlock(&dir->i_lock);\n\tput_rpccred(ctx->cred);\n\tkfree(ctx);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void put_nfs_open_dir_context(struct inode *dir, struct nfs_open_dir_context *ctx)\n{\n\tspin_lock(&dir->i_lock);\n\tlist_del(&ctx->list);\n\tspin_unlock(&dir->i_lock);\n\tput_rpccred(ctx->cred);\n\tkfree(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic int\nnfs_closedir(struct inode *inode, struct file *filp)\n{\n\tput_nfs_open_dir_context(file_inode(filp), filp->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_opendir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "101-131",
    "snippet": "static int\nnfs_opendir(struct inode *inode, struct file *filp)\n{\n\tint res = 0;\n\tstruct nfs_open_dir_context *ctx;\n\tstruct rpc_cred *cred;\n\n\tdfprintk(FILE, \"NFS: open dir(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSOPEN);\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tctx = alloc_nfs_open_dir_context(inode, cred);\n\tif (IS_ERR(ctx)) {\n\t\tres = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tfilp->private_data = ctx;\n\tif (filp->f_path.dentry == filp->f_path.mnt->mnt_root) {\n\t\t/* This is a mountpoint, so d_revalidate will never\n\t\t * have been called, so we need to refresh the\n\t\t * inode (for close-open consistency) ourselves.\n\t\t */\n\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t}\nout:\n\tput_rpccred(cred);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nfs_opendir(struct inode *, struct file *);",
      "static int nfs_closedir(struct inode *, struct file *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfs_revalidate_inode",
          "args": [
            "NFS_SERVER(inode)",
            "inode"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_revalidate_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "924-991",
          "snippet": "int\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint\n__nfs_revalidate_inode(struct nfs_server *server, struct inode *inode)\n{\n\tint\t\t status = -ESTALE;\n\tstruct nfs4_label *label = NULL;\n\tstruct nfs_fattr *fattr = NULL;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tdfprintk(PAGECACHE, \"NFS: revalidating (%s/%Lu)\\n\",\n\t\tinode->i_sb->s_id, (unsigned long long)NFS_FILEID(inode));\n\n\ttrace_nfs_revalidate_inode_enter(inode);\n\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\tgoto out;\n\n\tnfs_inc_stats(inode, NFSIOS_INODEREVALIDATE);\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label)) {\n\t\tstatus = PTR_ERR(label);\n\t\tgoto out;\n\t}\n\n\tstatus = NFS_PROTO(inode)->getattr(server, NFS_FH(inode), fattr, label);\n\tif (status != 0) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) getattr failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tif (status == -ESTALE) {\n\t\t\tnfs_zap_caches(inode);\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\t}\n\t\tgoto err_out;\n\t}\n\n\tstatus = nfs_refresh_inode(inode, fattr);\n\tif (status) {\n\t\tdfprintk(PAGECACHE, \"nfs_revalidate_inode: (%s/%Lu) refresh failed, error=%d\\n\",\n\t\t\t inode->i_sb->s_id,\n\t\t\t (unsigned long long)NFS_FILEID(inode), status);\n\t\tgoto err_out;\n\t}\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\n\tnfs_setsecurity(inode, fattr, label);\n\n\tdfprintk(PAGECACHE, \"NFS: (%s/%Lu) revalidation complete\\n\",\n\t\tinode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(inode));\n\nerr_out:\n\tnfs4_label_free(label);\nout:\n\tnfs_free_fattr(fattr);\n\ttrace_nfs_revalidate_inode_exit(inode, status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ctx"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nfs_open_dir_context",
          "args": [
            "inode",
            "cred"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nfs_open_dir_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
          "lines": "70-87",
          "snippet": "static struct nfs_open_dir_context *alloc_nfs_open_dir_context(struct inode *dir, struct rpc_cred *cred)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_open_dir_context *ctx;\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx != NULL) {\n\t\tctx->duped = 0;\n\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\tctx->dir_cookie = 0;\n\t\tctx->dup_cookie = 0;\n\t\tctx->cred = get_rpccred(cred);\n\t\tspin_lock(&dir->i_lock);\n\t\tlist_add(&ctx->list, &nfsi->open_files);\n\t\tspin_unlock(&dir->i_lock);\n\t\treturn ctx;\n\t}\n\treturn  ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/sched.h>",
            "#include <linux/swap.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct nfs_open_dir_context *alloc_nfs_open_dir_context(struct inode *dir, struct rpc_cred *cred)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_open_dir_context *ctx;\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx != NULL) {\n\t\tctx->duped = 0;\n\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\tctx->dir_cookie = 0;\n\t\tctx->dup_cookie = 0;\n\t\tctx->cred = get_rpccred(cred);\n\t\tspin_lock(&dir->i_lock);\n\t\tlist_add(&ctx->list, &nfsi->open_files);\n\t\tspin_unlock(&dir->i_lock);\n\t\treturn ctx;\n\t}\n\treturn  ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cred"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cred"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_lookup_cred",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSOPEN"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfprintk",
          "args": [
            "FILE",
            "\"NFS: open dir(%pD2)\\n\"",
            "filp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int nfs_opendir(struct inode *, struct file *);\nstatic int nfs_closedir(struct inode *, struct file *);\n\nstatic int\nnfs_opendir(struct inode *inode, struct file *filp)\n{\n\tint res = 0;\n\tstruct nfs_open_dir_context *ctx;\n\tstruct rpc_cred *cred;\n\n\tdfprintk(FILE, \"NFS: open dir(%pD2)\\n\", filp);\n\n\tnfs_inc_stats(inode, NFSIOS_VFSOPEN);\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tctx = alloc_nfs_open_dir_context(inode, cred);\n\tif (IS_ERR(ctx)) {\n\t\tres = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\tfilp->private_data = ctx;\n\tif (filp->f_path.dentry == filp->f_path.mnt->mnt_root) {\n\t\t/* This is a mountpoint, so d_revalidate will never\n\t\t * have been called, so we need to refresh the\n\t\t * inode (for close-open consistency) ourselves.\n\t\t */\n\t\t__nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\t}\nout:\n\tput_rpccred(cred);\n\treturn res;\n}"
  },
  {
    "function_name": "put_nfs_open_dir_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "89-96",
    "snippet": "static void put_nfs_open_dir_context(struct inode *dir, struct nfs_open_dir_context *ctx)\n{\n\tspin_lock(&dir->i_lock);\n\tlist_del(&ctx->list);\n\tspin_unlock(&dir->i_lock);\n\tput_rpccred(ctx->cred);\n\tkfree(ctx);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "ctx->cred"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ctx->list"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void put_nfs_open_dir_context(struct inode *dir, struct nfs_open_dir_context *ctx)\n{\n\tspin_lock(&dir->i_lock);\n\tlist_del(&ctx->list);\n\tspin_unlock(&dir->i_lock);\n\tput_rpccred(ctx->cred);\n\tkfree(ctx);\n}"
  },
  {
    "function_name": "alloc_nfs_open_dir_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dir.c",
    "lines": "70-87",
    "snippet": "static struct nfs_open_dir_context *alloc_nfs_open_dir_context(struct inode *dir, struct rpc_cred *cred)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_open_dir_context *ctx;\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx != NULL) {\n\t\tctx->duped = 0;\n\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\tctx->dir_cookie = 0;\n\t\tctx->dup_cookie = 0;\n\t\tctx->cred = get_rpccred(cred);\n\t\tspin_lock(&dir->i_lock);\n\t\tlist_add(&ctx->list, &nfsi->open_files);\n\t\tspin_unlock(&dir->i_lock);\n\t\treturn ctx;\n\t}\n\treturn  ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"fscache.h\"",
      "#include \"internal.h\"",
      "#include \"iostat.h\"",
      "#include \"delegation.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/kmemleak.h>",
      "#include <linux/sched.h>",
      "#include <linux/swap.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ctx->list",
            "&nfsi->open_files"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dir->i_lock"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "cred"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ctx)",
            "GFP_KERNEL"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "dir"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include <linux/xattr.h>\n#include <linux/kmemleak.h>\n#include <linux/sched.h>\n#include <linux/swap.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct nfs_open_dir_context *alloc_nfs_open_dir_context(struct inode *dir, struct rpc_cred *cred)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\tstruct nfs_open_dir_context *ctx;\n\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx != NULL) {\n\t\tctx->duped = 0;\n\t\tctx->attr_gencount = nfsi->attr_gencount;\n\t\tctx->dir_cookie = 0;\n\t\tctx->dup_cookie = 0;\n\t\tctx->cred = get_rpccred(cred);\n\t\tspin_lock(&dir->i_lock);\n\t\tlist_add(&ctx->list, &nfsi->open_files);\n\t\tspin_unlock(&dir->i_lock);\n\t\treturn ctx;\n\t}\n\treturn  ERR_PTR(-ENOMEM);\n}"
  }
]