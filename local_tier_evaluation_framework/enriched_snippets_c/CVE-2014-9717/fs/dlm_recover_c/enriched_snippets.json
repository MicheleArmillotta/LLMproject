[
  {
    "function_name": "dlm_clear_toss",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "933-954",
    "snippet": "void dlm_clear_toss(struct dlm_ls *ls)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].toss); n; n = next) {\n\t\t\tnext = rb_next(n);\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(r);\n\t\t\tcount++;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_clear_toss %u done\", count);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_clear_toss %u done\"",
            "count"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[i].lock"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_rsb",
          "args": [
            "r"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "68-73",
          "snippet": "void dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *rsb_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nstatic struct kmem_cache *rsb_cache;\n\nvoid dlm_free_rsb(struct dlm_rsb *r)\n{\n\tif (r->res_lvbptr)\n\t\tdlm_free_lvb(r->res_lvbptr);\n\tkmem_cache_free(rsb_cache, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&ls->ls_rsbtbl[i].toss"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->ls_rsbtbl[i].toss"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[i].lock"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_clear_toss(struct dlm_ls *ls)\n{\n\tstruct rb_node *n, *next;\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\tint i;\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].toss); n; n = next) {\n\t\t\tnext = rb_next(n);\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\trb_erase(n, &ls->ls_rsbtbl[i].toss);\n\t\t\tdlm_free_rsb(r);\n\t\t\tcount++;\n\t\t}\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_clear_toss %u done\", count);\n}"
  },
  {
    "function_name": "dlm_release_root_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "921-931",
    "snippet": "void dlm_release_root_list(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *safe;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry_safe(r, safe, &ls->ls_root_list, res_root_list) {\n\t\tlist_del_init(&r->res_root_list);\n\t\tdlm_put_rsb(r);\n\t}\n\tup_write(&ls->ls_root_sem);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_rsb",
          "args": [
            "r"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&r->res_root_list"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "safe",
            "&ls->ls_root_list",
            "res_root_list"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_release_root_list(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *safe;\n\n\tdown_write(&ls->ls_root_sem);\n\tlist_for_each_entry_safe(r, safe, &ls->ls_root_list, res_root_list) {\n\t\tlist_del_init(&r->res_root_list);\n\t\tdlm_put_rsb(r);\n\t}\n\tup_write(&ls->ls_root_sem);\n}"
  },
  {
    "function_name": "dlm_create_root_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "891-919",
    "snippet": "int dlm_create_root_list(struct dlm_ls *ls)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i, error = 0;\n\n\tdown_write(&ls->ls_root_sem);\n\tif (!list_empty(&ls->ls_root_list)) {\n\t\tlog_error(ls, \"root list not empty\");\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tlist_add(&r->res_root_list, &ls->ls_root_list);\n\t\t\tdlm_hold_rsb(r);\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&ls->ls_rsbtbl[i].toss))\n\t\t\tlog_error(ls, \"dlm_create_root_list toss not empty\");\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n out:\n\tup_write(&ls->ls_root_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rsbtbl[i].lock"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_create_root_list toss not empty\""
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&ls->ls_rsbtbl[i].toss"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_hold_rsb",
          "args": [
            "r"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "341-344",
          "snippet": "void dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&r->res_root_list",
            "&ls->ls_root_list"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structdlm_rsb",
            "res_hashnode"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ls->ls_rsbtbl[i].keep"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rsbtbl[i].lock"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"root list not empty\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_root_list"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_create_root_list(struct dlm_ls *ls)\n{\n\tstruct rb_node *n;\n\tstruct dlm_rsb *r;\n\tint i, error = 0;\n\n\tdown_write(&ls->ls_root_sem);\n\tif (!list_empty(&ls->ls_root_list)) {\n\t\tlog_error(ls, \"root list not empty\");\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ls->ls_rsbtbl_size; i++) {\n\t\tspin_lock(&ls->ls_rsbtbl[i].lock);\n\t\tfor (n = rb_first(&ls->ls_rsbtbl[i].keep); n; n = rb_next(n)) {\n\t\t\tr = rb_entry(n, struct dlm_rsb, res_hashnode);\n\t\t\tlist_add(&r->res_root_list, &ls->ls_root_list);\n\t\t\tdlm_hold_rsb(r);\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&ls->ls_rsbtbl[i].toss))\n\t\t\tlog_error(ls, \"dlm_create_root_list toss not empty\");\n\t\tspin_unlock(&ls->ls_rsbtbl[i].lock);\n\t}\n out:\n\tup_write(&ls->ls_root_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_recover_rsbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "856-887",
    "snippet": "void dlm_recover_rsbs(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tif (rsb_flag(r, RSB_RECOVER_CONVERT))\n\t\t\t\trecover_conversion(r);\n\n\t\t\t/* recover lvb before granting locks so the updated\n\t\t\t   lvb/VALNOTVALID is presented in the completion */\n\t\t\trecover_lvb(r);\n\n\t\t\tif (rsb_flag(r, RSB_NEW_MASTER2))\n\t\t\t\trecover_grant(r);\n\t\t\tcount++;\n\t\t} else {\n\t\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t\t}\n\t\trsb_clear_flag(r, RSB_RECOVER_CONVERT);\n\t\trsb_clear_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\trsb_clear_flag(r, RSB_NEW_MASTER2);\n\t\tunlock_rsb(r);\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_recover_rsbs %d done\", count);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_rsbs %d done\"",
            "count"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER2"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_grant",
          "args": [
            "r"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "recover_grant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "850-854",
          "snippet": "static void recover_grant(struct dlm_rsb *r)\n{\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_grant(struct dlm_rsb *r)\n{\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER2"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_lvb",
          "args": [
            "r"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "recover_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "731-812",
          "snippet": "static void recover_lvb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *high_lkb = NULL;\n\tuint32_t high_seq = 0;\n\tint lock_lvb_exists = 0;\n\tint big_lock_exists = 0;\n\tint lvblen = r->res_ls->ls_lvblen;\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2) &&\n\t    rsb_flag(r, RSB_RECOVER_LVB_INVAL)) {\n\t\t/* case 1 above */\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2))\n\t\treturn;\n\n\t/* we are the new master, so figure out if VALNOTVALID should\n\t   be set, and set the rsb lvb from the best lkb available. */\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n setflag:\n\tif (!lock_lvb_exists)\n\t\tgoto out;\n\n\t/* lvb is invalidated if only NL/CR locks remain */\n\tif (!big_lock_exists)\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\n\tif (!r->res_lvbptr) {\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\t\tif (!r->res_lvbptr)\n\t\t\tgoto out;\n\t}\n\n\tif (big_lock_exists) {\n\t\tr->res_lvbseq = lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, lvblen);\n\t} else if (high_lkb) {\n\t\tr->res_lvbseq = high_lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, high_lkb->lkb_lvbptr, lvblen);\n\t} else {\n\t\tr->res_lvbseq = 0;\n\t\tmemset(r->res_lvbptr, 0, lvblen);\n\t}\n out:\n\treturn;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_lvb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *high_lkb = NULL;\n\tuint32_t high_seq = 0;\n\tint lock_lvb_exists = 0;\n\tint big_lock_exists = 0;\n\tint lvblen = r->res_ls->ls_lvblen;\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2) &&\n\t    rsb_flag(r, RSB_RECOVER_LVB_INVAL)) {\n\t\t/* case 1 above */\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2))\n\t\treturn;\n\n\t/* we are the new master, so figure out if VALNOTVALID should\n\t   be set, and set the rsb lvb from the best lkb available. */\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n setflag:\n\tif (!lock_lvb_exists)\n\t\tgoto out;\n\n\t/* lvb is invalidated if only NL/CR locks remain */\n\tif (!big_lock_exists)\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\n\tif (!r->res_lvbptr) {\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\t\tif (!r->res_lvbptr)\n\t\t\tgoto out;\n\t}\n\n\tif (big_lock_exists) {\n\t\tr->res_lvbseq = lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, lvblen);\n\t} else if (high_lkb) {\n\t\tr->res_lvbseq = high_lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, high_lkb->lkb_lvbptr, lvblen);\n\t} else {\n\t\tr->res_lvbseq = 0;\n\t\tmemset(r->res_lvbptr, 0, lvblen);\n\t}\n out:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_conversion",
          "args": [
            "r"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "recover_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "817-844",
          "snippet": "static void recover_conversion(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_lkb *lkb;\n\tint grmode = -1;\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode == DLM_LOCK_PR ||\n\t\t    lkb->lkb_grmode == DLM_LOCK_CW) {\n\t\t\tgrmode = lkb->lkb_grmode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode != DLM_LOCK_IV)\n\t\t\tcontinue;\n\t\tif (grmode == -1) {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr to rq %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_rqmode);\n\t\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\t} else {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr %d\",\n\t\t\t\t  lkb->lkb_id, grmode);\n\t\t\tlkb->lkb_grmode = grmode;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_conversion(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_lkb *lkb;\n\tint grmode = -1;\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode == DLM_LOCK_PR ||\n\t\t    lkb->lkb_grmode == DLM_LOCK_CW) {\n\t\t\tgrmode = lkb->lkb_grmode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode != DLM_LOCK_IV)\n\t\t\tcontinue;\n\t\tif (grmode == -1) {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr to rq %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_rqmode);\n\t\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\t} else {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr %d\",\n\t\t\t\t  lkb->lkb_id, grmode);\n\t\t\tlkb->lkb_grmode = grmode;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master",
          "args": [
            "r"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&ls->ls_root_list",
            "res_root_list"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recover_rsbs(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tlock_rsb(r);\n\t\tif (is_master(r)) {\n\t\t\tif (rsb_flag(r, RSB_RECOVER_CONVERT))\n\t\t\t\trecover_conversion(r);\n\n\t\t\t/* recover lvb before granting locks so the updated\n\t\t\t   lvb/VALNOTVALID is presented in the completion */\n\t\t\trecover_lvb(r);\n\n\t\t\tif (rsb_flag(r, RSB_NEW_MASTER2))\n\t\t\t\trecover_grant(r);\n\t\t\tcount++;\n\t\t} else {\n\t\t\trsb_clear_flag(r, RSB_VALNOTVALID);\n\t\t}\n\t\trsb_clear_flag(r, RSB_RECOVER_CONVERT);\n\t\trsb_clear_flag(r, RSB_RECOVER_LVB_INVAL);\n\t\trsb_clear_flag(r, RSB_NEW_MASTER2);\n\t\tunlock_rsb(r);\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tif (count)\n\t\tlog_rinfo(ls, \"dlm_recover_rsbs %d done\", count);\n}"
  },
  {
    "function_name": "recover_grant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "850-854",
    "snippet": "static void recover_grant(struct dlm_rsb *r)\n{\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_RECOVER_GRANT"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_convertqueue"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_grant(struct dlm_rsb *r)\n{\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n}"
  },
  {
    "function_name": "recover_conversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "817-844",
    "snippet": "static void recover_conversion(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_lkb *lkb;\n\tint grmode = -1;\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode == DLM_LOCK_PR ||\n\t\t    lkb->lkb_grmode == DLM_LOCK_CW) {\n\t\t\tgrmode = lkb->lkb_grmode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode != DLM_LOCK_IV)\n\t\t\tcontinue;\n\t\tif (grmode == -1) {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr to rq %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_rqmode);\n\t\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\t} else {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr %d\",\n\t\t\t\t  lkb->lkb_id, grmode);\n\t\t\tlkb->lkb_grmode = grmode;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"recover_conversion %x set gr %d\"",
            "lkb->lkb_id",
            "grmode"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"recover_conversion %x set gr to rq %d\"",
            "lkb->lkb_id",
            "lkb->lkb_rqmode"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_grantqueue",
            "lkb_statequeue"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_conversion(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_lkb *lkb;\n\tint grmode = -1;\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode == DLM_LOCK_PR ||\n\t\t    lkb->lkb_grmode == DLM_LOCK_CW) {\n\t\t\tgrmode = lkb->lkb_grmode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (lkb->lkb_grmode != DLM_LOCK_IV)\n\t\t\tcontinue;\n\t\tif (grmode == -1) {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr to rq %d\",\n\t\t\t\t  lkb->lkb_id, lkb->lkb_rqmode);\n\t\t\tlkb->lkb_grmode = lkb->lkb_rqmode;\n\t\t} else {\n\t\t\tlog_debug(ls, \"recover_conversion %x set gr %d\",\n\t\t\t\t  lkb->lkb_id, grmode);\n\t\t\tlkb->lkb_grmode = grmode;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "recover_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "731-812",
    "snippet": "static void recover_lvb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *high_lkb = NULL;\n\tuint32_t high_seq = 0;\n\tint lock_lvb_exists = 0;\n\tint big_lock_exists = 0;\n\tint lvblen = r->res_ls->ls_lvblen;\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2) &&\n\t    rsb_flag(r, RSB_RECOVER_LVB_INVAL)) {\n\t\t/* case 1 above */\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2))\n\t\treturn;\n\n\t/* we are the new master, so figure out if VALNOTVALID should\n\t   be set, and set the rsb lvb from the best lkb available. */\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n setflag:\n\tif (!lock_lvb_exists)\n\t\tgoto out;\n\n\t/* lvb is invalidated if only NL/CR locks remain */\n\tif (!big_lock_exists)\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\n\tif (!r->res_lvbptr) {\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\t\tif (!r->res_lvbptr)\n\t\t\tgoto out;\n\t}\n\n\tif (big_lock_exists) {\n\t\tr->res_lvbseq = lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, lvblen);\n\t} else if (high_lkb) {\n\t\tr->res_lvbseq = high_lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, high_lkb->lkb_lvbptr, lvblen);\n\t} else {\n\t\tr->res_lvbseq = 0;\n\t\tmemset(r->res_lvbptr, 0, lvblen);\n\t}\n out:\n\treturn;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "r->res_lvbptr",
            "0",
            "lvblen"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r->res_lvbptr",
            "high_lkb->lkb_lvbptr",
            "lvblen"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "r->res_lvbptr",
            "lkb->lkb_lvbptr",
            "lvblen"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_allocate_lvb",
          "args": [
            "r->res_ls"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_allocate_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/memory.c",
          "lines": "47-53",
          "snippet": "char *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}",
          "includes": [
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n#include \"config.h\"\n#include \"dlm_internal.h\"\n\nchar *dlm_allocate_lvb(struct dlm_ls *ls)\n{\n\tchar *p;\n\n\tp = kzalloc(ls->ls_lvblen, GFP_NOFS);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_VALNOTVALID"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_convertqueue",
            "lkb_statequeue"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "&r->res_grantqueue",
            "lkb_statequeue"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER2"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_lvb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb, *high_lkb = NULL;\n\tuint32_t high_seq = 0;\n\tint lock_lvb_exists = 0;\n\tint big_lock_exists = 0;\n\tint lvblen = r->res_ls->ls_lvblen;\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2) &&\n\t    rsb_flag(r, RSB_RECOVER_LVB_INVAL)) {\n\t\t/* case 1 above */\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\t\treturn;\n\t}\n\n\tif (!rsb_flag(r, RSB_NEW_MASTER2))\n\t\treturn;\n\n\t/* we are the new master, so figure out if VALNOTVALID should\n\t   be set, and set the rsb lvb from the best lkb available. */\n\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_exflags & DLM_LKF_VALBLK))\n\t\t\tcontinue;\n\n\t\tlock_lvb_exists = 1;\n\n\t\tif (lkb->lkb_grmode > DLM_LOCK_CR) {\n\t\t\tbig_lock_exists = 1;\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tif (((int)lkb->lkb_lvbseq - (int)high_seq) >= 0) {\n\t\t\thigh_lkb = lkb;\n\t\t\thigh_seq = lkb->lkb_lvbseq;\n\t\t}\n\t}\n\n setflag:\n\tif (!lock_lvb_exists)\n\t\tgoto out;\n\n\t/* lvb is invalidated if only NL/CR locks remain */\n\tif (!big_lock_exists)\n\t\trsb_set_flag(r, RSB_VALNOTVALID);\n\n\tif (!r->res_lvbptr) {\n\t\tr->res_lvbptr = dlm_allocate_lvb(r->res_ls);\n\t\tif (!r->res_lvbptr)\n\t\t\tgoto out;\n\t}\n\n\tif (big_lock_exists) {\n\t\tr->res_lvbseq = lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, lkb->lkb_lvbptr, lvblen);\n\t} else if (high_lkb) {\n\t\tr->res_lvbseq = high_lkb->lkb_lvbseq;\n\t\tmemcpy(r->res_lvbptr, high_lkb->lkb_lvbptr, lvblen);\n\t} else {\n\t\tr->res_lvbseq = 0;\n\t\tmemset(r->res_lvbptr, 0, lvblen);\n\t}\n out:\n\treturn;\n}"
  },
  {
    "function_name": "dlm_recovered_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "697-709",
    "snippet": "void dlm_recovered_lock(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(rsb_flag(r, RSB_NEW_MASTER), dlm_dump_rsb(r););\n\n\tr->res_recover_locks_count--;\n\tif (!r->res_recover_locks_count) {\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\trecover_list_del(r);\n\t}\n\n\tif (recover_list_empty(r->res_ls))\n\t\twake_up(&r->res_ls->ls_wait_general);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&r->res_ls->ls_wait_general"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_list_empty",
          "args": [
            "r->res_ls"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_list_del",
          "args": [
            "r"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "261-271",
          "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "rsb_flag(r, RSB_NEW_MASTER)",
            "dlm_dump_rsb(r);"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_recovered_lock(struct dlm_rsb *r)\n{\n\tDLM_ASSERT(rsb_flag(r, RSB_NEW_MASTER), dlm_dump_rsb(r););\n\n\tr->res_recover_locks_count--;\n\tif (!r->res_recover_locks_count) {\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\trecover_list_del(r);\n\t}\n\n\tif (recover_list_empty(r->res_ls))\n\t\twake_up(&r->res_ls->ls_wait_general);\n}"
  },
  {
    "function_name": "dlm_recover_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "657-695",
    "snippet": "int dlm_recover_locks(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint error, count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rsb_flag(r, RSB_NEW_MASTER))\n\t\t\tcontinue;\n\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = recover_locks(r);\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcount += r->res_recover_locks_count;\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_locks %d out\", count);\n\n\terror = dlm_wait_function(ls, &recover_list_empty);\n out:\n\tif (error)\n\t\trecover_list_clear(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recover_list_clear",
          "args": [
            "ls"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "273-291",
          "snippet": "static void recover_list_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *s;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_for_each_entry_safe(r, s, &ls->ls_recover_list, res_recover_list) {\n\t\tlist_del_init(&r->res_recover_list);\n\t\tr->res_recover_locks_count = 0;\n\t\tdlm_put_rsb(r);\n\t\tls->ls_recover_list_count--;\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *s;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_for_each_entry_safe(r, s, &ls->ls_recover_list, res_recover_list) {\n\t\tlist_del_init(&r->res_recover_list);\n\t\tr->res_recover_locks_count = 0;\n\t\tdlm_put_rsb(r);\n\t\tls->ls_recover_list_count--;\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_function",
          "args": [
            "ls",
            "&recover_list_empty"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "44-62",
          "snippet": "int dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_locks %d out\"",
            "count"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recover_locks",
          "args": [
            "r"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "657-695",
          "snippet": "int dlm_recover_locks(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint error, count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rsb_flag(r, RSB_NEW_MASTER))\n\t\t\tcontinue;\n\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = recover_locks(r);\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcount += r->res_recover_locks_count;\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_locks %d out\", count);\n\n\terror = dlm_wait_function(ls, &recover_list_empty);\n out:\n\tif (error)\n\t\trecover_list_clear(ls);\n\treturn error;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master",
          "args": [
            "r"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&ls->ls_root_list",
            "res_root_list"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_locks(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint error, count = 0;\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (is_master(r)) {\n\t\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rsb_flag(r, RSB_NEW_MASTER))\n\t\t\tcontinue;\n\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = recover_locks(r);\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcount += r->res_recover_locks_count;\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_locks %d out\", count);\n\n\terror = dlm_wait_function(ls, &recover_list_empty);\n out:\n\tif (error)\n\t\trecover_list_clear(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "recover_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "630-655",
    "snippet": "static int recover_locks(struct dlm_rsb *r)\n{\n\tint error = 0;\n\n\tlock_rsb(r);\n\n\tDLM_ASSERT(!r->res_recover_locks_count, dlm_dump_rsb(r););\n\n\terror = recover_locks_queue(r, &r->res_grantqueue);\n\tif (error)\n\t\tgoto out;\n\terror = recover_locks_queue(r, &r->res_convertqueue);\n\tif (error)\n\t\tgoto out;\n\terror = recover_locks_queue(r, &r->res_waitqueue);\n\tif (error)\n\t\tgoto out;\n\n\tif (r->res_recover_locks_count)\n\t\trecover_list_add(r);\n\telse\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n out:\n\tunlock_rsb(r);\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_clear_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_clear_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "353-356",
          "snippet": "static inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_clear_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__clear_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_list_add",
          "args": [
            "r"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "248-259",
          "snippet": "static void recover_list_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tif (list_empty(&r->res_recover_list)) {\n\t\tlist_add_tail(&r->res_recover_list, &ls->ls_recover_list);\n\t\tls->ls_recover_list_count++;\n\t\tdlm_hold_rsb(r);\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tif (list_empty(&r->res_recover_list)) {\n\t\tlist_add_tail(&r->res_recover_list, &ls->ls_recover_list);\n\t\tls->ls_recover_list_count++;\n\t\tdlm_hold_rsb(r);\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_locks_queue",
          "args": [
            "r",
            "&r->res_waitqueue"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "recover_locks_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "615-628",
          "snippet": "static int recover_locks_queue(struct dlm_rsb *r, struct list_head *head)\n{\n\tstruct dlm_lkb *lkb;\n\tint error = 0;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t   \terror = dlm_send_rcom_lock(r, lkb);\n\t\tif (error)\n\t\t\tbreak;\n\t\tr->res_recover_locks_count++;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_locks_queue(struct dlm_rsb *r, struct list_head *head)\n{\n\tstruct dlm_lkb *lkb;\n\tint error = 0;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t   \terror = dlm_send_rcom_lock(r, lkb);\n\t\tif (error)\n\t\t\tbreak;\n\t\tr->res_recover_locks_count++;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "!r->res_recover_locks_count",
            "dlm_dump_rsb(r);"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb",
          "args": [
            "r"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "181-201",
          "snippet": "void dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_dump_rsb(struct dlm_rsb *r)\n{\n\tstruct dlm_lkb *lkb;\n\n\tdlm_print_rsb(r);\n\n\tprintk(KERN_ERR \"rsb: root_list empty %d recover_list empty %d\\n\",\n\t       list_empty(&r->res_root_list), list_empty(&r->res_recover_list));\n\tprintk(KERN_ERR \"rsb lookup list\\n\");\n\tlist_for_each_entry(lkb, &r->res_lookup, lkb_rsb_lookup)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb grant queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_grantqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb convert queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_convertqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n\tprintk(KERN_ERR \"rsb wait queue:\\n\");\n\tlist_for_each_entry(lkb, &r->res_waitqueue, lkb_statequeue)\n\t\tdlm_print_lkb(lkb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_locks(struct dlm_rsb *r)\n{\n\tint error = 0;\n\n\tlock_rsb(r);\n\n\tDLM_ASSERT(!r->res_recover_locks_count, dlm_dump_rsb(r););\n\n\terror = recover_locks_queue(r, &r->res_grantqueue);\n\tif (error)\n\t\tgoto out;\n\terror = recover_locks_queue(r, &r->res_convertqueue);\n\tif (error)\n\t\tgoto out;\n\terror = recover_locks_queue(r, &r->res_waitqueue);\n\tif (error)\n\t\tgoto out;\n\n\tif (r->res_recover_locks_count)\n\t\trecover_list_add(r);\n\telse\n\t\trsb_clear_flag(r, RSB_NEW_MASTER);\n out:\n\tunlock_rsb(r);\n\treturn error;\n}"
  },
  {
    "function_name": "recover_locks_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "615-628",
    "snippet": "static int recover_locks_queue(struct dlm_rsb *r, struct list_head *head)\n{\n\tstruct dlm_lkb *lkb;\n\tint error = 0;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t   \terror = dlm_send_rcom_lock(r, lkb);\n\t\tif (error)\n\t\t\tbreak;\n\t\tr->res_recover_locks_count++;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_send_rcom_lock",
          "args": [
            "r",
            "lkb"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_rcom_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "417-439",
          "snippet": "int dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_lock *rl;\n\tint error, len = sizeof(struct rcom_lock);\n\n\tif (lkb->lkb_lvbptr)\n\t\tlen += ls->ls_lvblen;\n\n\terror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\trl = (struct rcom_lock *) rc->rc_buf;\n\tpack_rcom_lock(r, lkb, rl);\n\trc->rc_id = (unsigned long) r;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_lock *rl;\n\tint error, len = sizeof(struct rcom_lock);\n\n\tif (lkb->lkb_lvbptr)\n\t\tlen += ls->ls_lvblen;\n\n\terror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\trl = (struct rcom_lock *) rc->rc_buf;\n\tpack_rcom_lock(r, lkb, rl);\n\trc->rc_id = (unsigned long) r;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "head",
            "lkb_statequeue"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_locks_queue(struct dlm_rsb *r, struct list_head *head)\n{\n\tstruct dlm_lkb *lkb;\n\tint error = 0;\n\n\tlist_for_each_entry(lkb, head, lkb_statequeue) {\n\t   \terror = dlm_send_rcom_lock(r, lkb);\n\t\tif (error)\n\t\t\tbreak;\n\t\tr->res_recover_locks_count++;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_recover_master_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "564-594",
    "snippet": "int dlm_recover_master_reply(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_rsb *r;\n\tint ret_nodeid, new_master;\n\n\tr = recover_idr_find(ls, rc->rc_id);\n\tif (!r) {\n\t\tlog_error(ls, \"dlm_recover_master_reply no id %llx\",\n\t\t\t  (unsigned long long)rc->rc_id);\n\t\tgoto out;\n\t}\n\n\tret_nodeid = rc->rc_result;\n\n\tif (ret_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\telse\n\t\tnew_master = ret_nodeid;\n\n\tlock_rsb(r);\n\tr->res_master_nodeid = ret_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\tunlock_rsb(r);\n\trecover_idr_del(r);\n\n\tif (recover_idr_empty(ls))\n\t\twake_up(&ls->ls_wait_general);\n out:\n\treturn 0;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&ls->ls_wait_general"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_idr_empty",
          "args": [
            "ls"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "293-303",
          "snippet": "static int recover_idr_empty(struct dlm_ls *ls)\n{\n\tint empty = 1;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (ls->ls_recover_list_count)\n\t\tempty = 0;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_idr_empty(struct dlm_ls *ls)\n{\n\tint empty = 1;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (ls->ls_recover_list_count)\n\t\tempty = 0;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_idr_del",
          "args": [
            "r"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "330-341",
          "snippet": "static void recover_idr_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tidr_remove(&ls->ls_recover_idr, r->res_id);\n\tr->res_id = 0;\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\tdlm_put_rsb(r);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_idr_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tidr_remove(&ls->ls_recover_idr, r->res_id);\n\tr->res_id = 0;\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\tdlm_put_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_master",
          "args": [
            "r"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "425-430",
          "snippet": "static void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"dlm_recover_master_reply no id %llx\"",
            "(unsigned long long)rc->rc_id"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recover_idr_find",
          "args": [
            "ls",
            "rc->rc_id"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "343-351",
          "snippet": "static struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_master_reply(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_rsb *r;\n\tint ret_nodeid, new_master;\n\n\tr = recover_idr_find(ls, rc->rc_id);\n\tif (!r) {\n\t\tlog_error(ls, \"dlm_recover_master_reply no id %llx\",\n\t\t\t  (unsigned long long)rc->rc_id);\n\t\tgoto out;\n\t}\n\n\tret_nodeid = rc->rc_result;\n\n\tif (ret_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\telse\n\t\tnew_master = ret_nodeid;\n\n\tlock_rsb(r);\n\tr->res_master_nodeid = ret_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\tunlock_rsb(r);\n\trecover_idr_del(r);\n\n\tif (recover_idr_empty(ls))\n\t\twake_up(&ls->ls_wait_general);\n out:\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_recover_masters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "521-562",
    "snippet": "int dlm_recover_masters(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int total = 0;\n\tunsigned int count = 0;\n\tint nodir = dlm_no_directory(ls);\n\tint error;\n\n\tlog_rinfo(ls, \"dlm_recover_masters\");\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_rsb(r);\n\t\tif (nodir)\n\t\t\terror = recover_master_static(r, &count);\n\t\telse\n\t\t\terror = recover_master(r, &count);\n\t\tunlock_rsb(r);\n\t\tcond_resched();\n\t\ttotal++;\n\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_masters %u of %u\", count, total);\n\n\terror = dlm_wait_function(ls, &recover_idr_empty);\n out:\n\tif (error)\n\t\trecover_idr_clear(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recover_idr_clear",
          "args": [
            "ls"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "353-375",
          "snippet": "static void recover_idr_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint id;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\n\tidr_for_each_entry(&ls->ls_recover_idr, r, id) {\n\t\tidr_remove(&ls->ls_recover_idr, id);\n\t\tr->res_id = 0;\n\t\tr->res_recover_locks_count = 0;\n\t\tls->ls_recover_list_count--;\n\n\t\tdlm_put_rsb(r);\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_idr_lock);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_idr_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint id;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\n\tidr_for_each_entry(&ls->ls_recover_idr, r, id) {\n\t\tidr_remove(&ls->ls_recover_idr, id);\n\t\tr->res_id = 0;\n\t\tr->res_recover_locks_count = 0;\n\t\tls->ls_recover_list_count--;\n\n\t\tdlm_put_rsb(r);\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_function",
          "args": [
            "ls",
            "&recover_idr_empty"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "44-62",
          "snippet": "int dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_masters %u of %u\"",
            "count",
            "total"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_rsb",
          "args": [
            "r"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.h",
          "lines": "74-77",
          "snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void unlock_rsb(struct dlm_rsb *r)\n{\n\tmutex_unlock(&r->res_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_master",
          "args": [
            "r",
            "&count"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_master_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "564-594",
          "snippet": "int dlm_recover_master_reply(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_rsb *r;\n\tint ret_nodeid, new_master;\n\n\tr = recover_idr_find(ls, rc->rc_id);\n\tif (!r) {\n\t\tlog_error(ls, \"dlm_recover_master_reply no id %llx\",\n\t\t\t  (unsigned long long)rc->rc_id);\n\t\tgoto out;\n\t}\n\n\tret_nodeid = rc->rc_result;\n\n\tif (ret_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\telse\n\t\tnew_master = ret_nodeid;\n\n\tlock_rsb(r);\n\tr->res_master_nodeid = ret_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\tunlock_rsb(r);\n\trecover_idr_del(r);\n\n\tif (recover_idr_empty(ls))\n\t\twake_up(&ls->ls_wait_general);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_master_reply(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_rsb *r;\n\tint ret_nodeid, new_master;\n\n\tr = recover_idr_find(ls, rc->rc_id);\n\tif (!r) {\n\t\tlog_error(ls, \"dlm_recover_master_reply no id %llx\",\n\t\t\t  (unsigned long long)rc->rc_id);\n\t\tgoto out;\n\t}\n\n\tret_nodeid = rc->rc_result;\n\n\tif (ret_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\telse\n\t\tnew_master = ret_nodeid;\n\n\tlock_rsb(r);\n\tr->res_master_nodeid = ret_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\tunlock_rsb(r);\n\trecover_idr_del(r);\n\n\tif (recover_idr_empty(ls))\n\t\twake_up(&ls->ls_wait_general);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_master_static",
          "args": [
            "r",
            "&count"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "recover_master_static",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "495-509",
          "snippet": "static int recover_master_static(struct dlm_rsb *r, unsigned int *count)\n{\n\tint dir_nodeid = dlm_dir_nodeid(r);\n\tint new_master = dir_nodeid;\n\n\tif (dir_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\n\tdlm_purge_mstcpy_locks(r);\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\t(*count)++;\n\treturn 0;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_master_static(struct dlm_rsb *r, unsigned int *count)\n{\n\tint dir_nodeid = dlm_dir_nodeid(r);\n\tint new_master = dir_nodeid;\n\n\tif (dir_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\n\tdlm_purge_mstcpy_locks(r);\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\t(*count)++;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "r",
            "&ls->ls_root_list",
            "res_root_list"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ls->ls_root_sem"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_rinfo",
          "args": [
            "ls",
            "\"dlm_recover_masters\""
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_no_directory",
          "args": [
            "ls"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_no_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "705-708",
          "snippet": "static inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_NODIR\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_NODIR\t\t10\n\nstatic inline int dlm_no_directory(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_NODIR, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_masters(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tunsigned int total = 0;\n\tunsigned int count = 0;\n\tint nodir = dlm_no_directory(ls);\n\tint error;\n\n\tlog_rinfo(ls, \"dlm_recover_masters\");\n\n\tdown_read(&ls->ls_root_sem);\n\tlist_for_each_entry(r, &ls->ls_root_list, res_root_list) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_rsb(r);\n\t\tif (nodir)\n\t\t\terror = recover_master_static(r, &count);\n\t\telse\n\t\t\terror = recover_master(r, &count);\n\t\tunlock_rsb(r);\n\t\tcond_resched();\n\t\ttotal++;\n\n\t\tif (error) {\n\t\t\tup_read(&ls->ls_root_sem);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tup_read(&ls->ls_root_sem);\n\n\tlog_rinfo(ls, \"dlm_recover_masters %u of %u\", count, total);\n\n\terror = dlm_wait_function(ls, &recover_idr_empty);\n out:\n\tif (error)\n\t\trecover_idr_clear(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "recover_master_static",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "495-509",
    "snippet": "static int recover_master_static(struct dlm_rsb *r, unsigned int *count)\n{\n\tint dir_nodeid = dlm_dir_nodeid(r);\n\tint new_master = dir_nodeid;\n\n\tif (dir_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\n\tdlm_purge_mstcpy_locks(r);\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\t(*count)++;\n\treturn 0;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_new_master",
          "args": [
            "r"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "425-430",
          "snippet": "static void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_purge_mstcpy_locks",
          "args": [
            "r"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_purge_mstcpy_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5384-5391",
          "snippet": "void dlm_purge_mstcpy_locks(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tpurge_mstcpy_list(ls, r, &r->res_grantqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_convertqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_waitqueue);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_purge_mstcpy_locks(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tpurge_mstcpy_list(ls, r, &r->res_grantqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_convertqueue);\n\tpurge_mstcpy_list(ls, r, &r->res_waitqueue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_master_static(struct dlm_rsb *r, unsigned int *count)\n{\n\tint dir_nodeid = dlm_dir_nodeid(r);\n\tint new_master = dir_nodeid;\n\n\tif (dir_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\n\tdlm_purge_mstcpy_locks(r);\n\tr->res_master_nodeid = dir_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\t(*count)++;\n\treturn 0;\n}"
  },
  {
    "function_name": "recover_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "442-478",
    "snippet": "static int recover_master(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint our_nodeid, dir_nodeid;\n\tint is_removed = 0;\n\tint error;\n\n\tif (is_master(r))\n\t\treturn 0;\n\n\tis_removed = dlm_is_removed(ls, r->res_nodeid);\n\n\tif (!is_removed && !rsb_flag(r, RSB_NEW_MASTER))\n\t\treturn 0;\n\n\tour_nodeid = dlm_our_nodeid();\n\tdir_nodeid = dlm_dir_nodeid(r);\n\n\tif (dir_nodeid == our_nodeid) {\n\t\tif (is_removed) {\n\t\t\tr->res_master_nodeid = our_nodeid;\n\t\t\tr->res_nodeid = 0;\n\t\t}\n\n\t\t/* set master of lkbs to ourself when is_removed, or to\n\t\t   another new master which we set along with NEW_MASTER\n\t\t   in dlm_master_lookup */\n\t\tset_new_master(r);\n\t\terror = 0;\n\t} else {\n\t\trecover_idr_add(r);\n\t\terror = dlm_send_rcom_lookup(r, dir_nodeid);\n\t}\n\n\t(*count)++;\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_send_rcom_lookup",
          "args": [
            "r",
            "dir_nodeid"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_rcom_lookup_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "335-352",
          "snippet": "int dlm_send_rcom_lookup_dump(struct dlm_rsb *r, int to_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, to_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = 0xFFFFFFFF;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_rcom_lookup_dump(struct dlm_rsb *r, int to_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, to_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = 0xFFFFFFFF;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recover_idr_add",
          "args": [
            "r"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "305-328",
          "snippet": "static int recover_idr_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint rv;\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (r->res_id) {\n\t\trv = -1;\n\t\tgoto out_unlock;\n\t}\n\trv = idr_alloc(&ls->ls_recover_idr, r, 1, 0, GFP_NOWAIT);\n\tif (rv < 0)\n\t\tgoto out_unlock;\n\n\tr->res_id = rv;\n\tls->ls_recover_list_count++;\n\tdlm_hold_rsb(r);\n\trv = 0;\nout_unlock:\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\tidr_preload_end();\n\treturn rv;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_idr_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint rv;\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (r->res_id) {\n\t\trv = -1;\n\t\tgoto out_unlock;\n\t}\n\trv = idr_alloc(&ls->ls_recover_idr, r, 1, 0, GFP_NOWAIT);\n\tif (rv < 0)\n\t\tgoto out_unlock;\n\n\tr->res_id = rv;\n\tls->ls_recover_list_count++;\n\tdlm_hold_rsb(r);\n\trv = 0;\nout_unlock:\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\tidr_preload_end();\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_new_master",
          "args": [
            "r"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "set_new_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "425-430",
          "snippet": "static void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dir_nodeid",
          "args": [
            "r"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dir_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "47-50",
          "snippet": "int dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_dir_nodeid(struct dlm_rsb *r)\n{\n\treturn r->res_dir_nodeid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsb_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "358-361",
          "snippet": "static inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline int rsb_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\treturn test_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_removed",
          "args": [
            "ls",
            "r->res_nodeid"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_removed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "358-363",
          "snippet": "int dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\n{\n\tif (find_memb(&ls->ls_nodes_gone, nodeid))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_master",
          "args": [
            "r"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "is_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "256-259",
          "snippet": "static inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nstatic inline int is_master_copy(struct dlm_lkb *lkb)\n{\n\treturn (lkb->lkb_flags & DLM_IFL_MSTCPY) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_master(struct dlm_rsb *r, unsigned int *count)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint our_nodeid, dir_nodeid;\n\tint is_removed = 0;\n\tint error;\n\n\tif (is_master(r))\n\t\treturn 0;\n\n\tis_removed = dlm_is_removed(ls, r->res_nodeid);\n\n\tif (!is_removed && !rsb_flag(r, RSB_NEW_MASTER))\n\t\treturn 0;\n\n\tour_nodeid = dlm_our_nodeid();\n\tdir_nodeid = dlm_dir_nodeid(r);\n\n\tif (dir_nodeid == our_nodeid) {\n\t\tif (is_removed) {\n\t\t\tr->res_master_nodeid = our_nodeid;\n\t\t\tr->res_nodeid = 0;\n\t\t}\n\n\t\t/* set master of lkbs to ourself when is_removed, or to\n\t\t   another new master which we set along with NEW_MASTER\n\t\t   in dlm_master_lookup */\n\t\tset_new_master(r);\n\t\terror = 0;\n\t} else {\n\t\trecover_idr_add(r);\n\t\terror = dlm_send_rcom_lookup(r, dir_nodeid);\n\t}\n\n\t(*count)++;\n\treturn error;\n}"
  },
  {
    "function_name": "set_new_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "425-430",
    "snippet": "static void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsb_set_flag",
          "args": [
            "r",
            "RSB_NEW_MASTER2"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "rsb_set_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "348-351",
          "snippet": "static inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline void rsb_set_flag(struct dlm_rsb *r, enum rsb_flags flag)\n{\n\t__set_bit(flag, &r->res_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_master_lkbs",
          "args": [
            "r"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "set_master_lkbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "411-416",
          "snippet": "static void set_master_lkbs(struct dlm_rsb *r)\n{\n\tset_lock_master(&r->res_grantqueue, r->res_nodeid);\n\tset_lock_master(&r->res_convertqueue, r->res_nodeid);\n\tset_lock_master(&r->res_waitqueue, r->res_nodeid);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_master_lkbs(struct dlm_rsb *r)\n{\n\tset_lock_master(&r->res_grantqueue, r->res_nodeid);\n\tset_lock_master(&r->res_convertqueue, r->res_nodeid);\n\tset_lock_master(&r->res_waitqueue, r->res_nodeid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_new_master(struct dlm_rsb *r)\n{\n\tset_master_lkbs(r);\n\trsb_set_flag(r, RSB_NEW_MASTER);\n\trsb_set_flag(r, RSB_NEW_MASTER2);\n}"
  },
  {
    "function_name": "set_master_lkbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "411-416",
    "snippet": "static void set_master_lkbs(struct dlm_rsb *r)\n{\n\tset_lock_master(&r->res_grantqueue, r->res_nodeid);\n\tset_lock_master(&r->res_convertqueue, r->res_nodeid);\n\tset_lock_master(&r->res_waitqueue, r->res_nodeid);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_lock_master",
          "args": [
            "&r->res_waitqueue",
            "r->res_nodeid"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "set_lock_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "399-409",
          "snippet": "static void set_lock_master(struct list_head *queue, int nodeid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, queue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_flags & DLM_IFL_MSTCPY)) {\n\t\t\tlkb->lkb_nodeid = nodeid;\n\t\t\tlkb->lkb_remid = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_lock_master(struct list_head *queue, int nodeid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, queue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_flags & DLM_IFL_MSTCPY)) {\n\t\t\tlkb->lkb_nodeid = nodeid;\n\t\t\tlkb->lkb_remid = 0;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_master_lkbs(struct dlm_rsb *r)\n{\n\tset_lock_master(&r->res_grantqueue, r->res_nodeid);\n\tset_lock_master(&r->res_convertqueue, r->res_nodeid);\n\tset_lock_master(&r->res_waitqueue, r->res_nodeid);\n}"
  },
  {
    "function_name": "set_lock_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "399-409",
    "snippet": "static void set_lock_master(struct list_head *queue, int nodeid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, queue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_flags & DLM_IFL_MSTCPY)) {\n\t\t\tlkb->lkb_nodeid = nodeid;\n\t\t\tlkb->lkb_remid = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lkb",
            "queue",
            "lkb_statequeue"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_lock_master(struct list_head *queue, int nodeid)\n{\n\tstruct dlm_lkb *lkb;\n\n\tlist_for_each_entry(lkb, queue, lkb_statequeue) {\n\t\tif (!(lkb->lkb_flags & DLM_IFL_MSTCPY)) {\n\t\t\tlkb->lkb_nodeid = nodeid;\n\t\t\tlkb->lkb_remid = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "recover_idr_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "353-375",
    "snippet": "static void recover_idr_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint id;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\n\tidr_for_each_entry(&ls->ls_recover_idr, r, id) {\n\t\tidr_remove(&ls->ls_recover_idr, id);\n\t\tr->res_id = 0;\n\t\tr->res_recover_locks_count = 0;\n\t\tls->ls_recover_list_count--;\n\n\t\tdlm_put_rsb(r);\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_idr_lock);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"warning: recover_list_count %d\"",
            "ls->ls_recover_list_count"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_rsb",
          "args": [
            "r"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&ls->ls_recover_idr",
            "id"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_for_each_entry",
          "args": [
            "&ls->ls_recover_idr",
            "r",
            "id"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_idr_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r;\n\tint id;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\n\tidr_for_each_entry(&ls->ls_recover_idr, r, id) {\n\t\tidr_remove(&ls->ls_recover_idr, id);\n\t\tr->res_id = 0;\n\t\tr->res_recover_locks_count = 0;\n\t\tls->ls_recover_list_count--;\n\n\t\tdlm_put_rsb(r);\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_idr_lock);\n}"
  },
  {
    "function_name": "recover_idr_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "343-351",
    "snippet": "static struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&ls->ls_recover_idr",
            "(int)id"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "recover_idr_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "343-351",
          "snippet": "static struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct dlm_rsb *recover_idr_find(struct dlm_ls *ls, uint64_t id)\n{\n\tstruct dlm_rsb *r;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tr = idr_find(&ls->ls_recover_idr, (int)id);\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\treturn r;\n}"
  },
  {
    "function_name": "recover_idr_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "330-341",
    "snippet": "static void recover_idr_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tidr_remove(&ls->ls_recover_idr, r->res_id);\n\tr->res_id = 0;\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\tdlm_put_rsb(r);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_rsb",
          "args": [
            "r"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&ls->ls_recover_idr",
            "r->res_id"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_idr_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tidr_remove(&ls->ls_recover_idr, r->res_id);\n\tr->res_id = 0;\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\tdlm_put_rsb(r);\n}"
  },
  {
    "function_name": "recover_idr_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "305-328",
    "snippet": "static int recover_idr_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint rv;\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (r->res_id) {\n\t\trv = -1;\n\t\tgoto out_unlock;\n\t}\n\trv = idr_alloc(&ls->ls_recover_idr, r, 1, 0, GFP_NOWAIT);\n\tif (rv < 0)\n\t\tgoto out_unlock;\n\n\tr->res_id = rv;\n\tls->ls_recover_list_count++;\n\tdlm_hold_rsb(r);\n\trv = 0;\nout_unlock:\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\tidr_preload_end();\n\treturn rv;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hold_rsb",
          "args": [
            "r"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "341-344",
          "snippet": "void dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&ls->ls_recover_idr",
            "r",
            "1",
            "0",
            "GFP_NOWAIT"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_NOFS"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_idr_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tint rv;\n\n\tidr_preload(GFP_NOFS);\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (r->res_id) {\n\t\trv = -1;\n\t\tgoto out_unlock;\n\t}\n\trv = idr_alloc(&ls->ls_recover_idr, r, 1, 0, GFP_NOWAIT);\n\tif (rv < 0)\n\t\tgoto out_unlock;\n\n\tr->res_id = rv;\n\tls->ls_recover_list_count++;\n\tdlm_hold_rsb(r);\n\trv = 0;\nout_unlock:\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\tidr_preload_end();\n\treturn rv;\n}"
  },
  {
    "function_name": "recover_idr_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "293-303",
    "snippet": "static int recover_idr_empty(struct dlm_ls *ls)\n{\n\tint empty = 1;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (ls->ls_recover_list_count)\n\t\tempty = 0;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\treturn empty;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_idr_lock"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_idr_empty(struct dlm_ls *ls)\n{\n\tint empty = 1;\n\n\tspin_lock(&ls->ls_recover_idr_lock);\n\tif (ls->ls_recover_list_count)\n\t\tempty = 0;\n\tspin_unlock(&ls->ls_recover_idr_lock);\n\n\treturn empty;\n}"
  },
  {
    "function_name": "recover_list_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "273-291",
    "snippet": "static void recover_list_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *s;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_for_each_entry_safe(r, s, &ls->ls_recover_list, res_recover_list) {\n\t\tlist_del_init(&r->res_recover_list);\n\t\tr->res_recover_locks_count = 0;\n\t\tdlm_put_rsb(r);\n\t\tls->ls_recover_list_count--;\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"warning: recover_list_count %d\"",
            "ls->ls_recover_list_count"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_rsb",
          "args": [
            "r"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&r->res_recover_list"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "r",
            "s",
            "&ls->ls_recover_list",
            "res_recover_list"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_clear(struct dlm_ls *ls)\n{\n\tstruct dlm_rsb *r, *s;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_for_each_entry_safe(r, s, &ls->ls_recover_list, res_recover_list) {\n\t\tlist_del_init(&r->res_recover_list);\n\t\tr->res_recover_locks_count = 0;\n\t\tdlm_put_rsb(r);\n\t\tls->ls_recover_list_count--;\n\t}\n\n\tif (ls->ls_recover_list_count != 0) {\n\t\tlog_error(ls, \"warning: recover_list_count %d\",\n\t\t\t  ls->ls_recover_list_count);\n\t\tls->ls_recover_list_count = 0;\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}"
  },
  {
    "function_name": "recover_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "261-271",
    "snippet": "static void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_rsb",
          "args": [
            "r"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "359-362",
          "snippet": "void dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_put_rsb(struct dlm_rsb *r)\n{\n\tput_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&r->res_recover_list"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_del(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tlist_del_init(&r->res_recover_list);\n\tls->ls_recover_list_count--;\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\tdlm_put_rsb(r);\n}"
  },
  {
    "function_name": "recover_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "248-259",
    "snippet": "static void recover_list_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tif (list_empty(&r->res_recover_list)) {\n\t\tlist_add_tail(&r->res_recover_list, &ls->ls_recover_list);\n\t\tls->ls_recover_list_count++;\n\t\tdlm_hold_rsb(r);\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hold_rsb",
          "args": [
            "r"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hold_rsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "341-344",
          "snippet": "void dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_hold_rsb(struct dlm_rsb *r)\n{\n\thold_rsb(r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&r->res_recover_list",
            "&ls->ls_recover_list"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&r->res_recover_list"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void recover_list_add(struct dlm_rsb *r)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tif (list_empty(&r->res_recover_list)) {\n\t\tlist_add_tail(&r->res_recover_list, &ls->ls_recover_list);\n\t\tls->ls_recover_list_count++;\n\t\tdlm_hold_rsb(r);\n\t}\n\tspin_unlock(&ls->ls_recover_list_lock);\n}"
  },
  {
    "function_name": "recover_list_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "237-246",
    "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_recover_list"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_list_lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
  },
  {
    "function_name": "dlm_recover_done_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "220-223",
    "snippet": "int dlm_recover_done_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DONE);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_status",
          "args": [
            "ls",
            "DLM_RS_DONE"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "wait_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "152-165",
          "snippet": "static int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_done_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DONE);\n}"
  },
  {
    "function_name": "dlm_recover_locks_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "215-218",
    "snippet": "int dlm_recover_locks_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_LOCKS);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_status",
          "args": [
            "ls",
            "DLM_RS_LOCKS"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "wait_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "152-165",
          "snippet": "static int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_locks_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_LOCKS);\n}"
  },
  {
    "function_name": "dlm_recover_directory_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "210-213",
    "snippet": "int dlm_recover_directory_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DIR);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_status",
          "args": [
            "ls",
            "DLM_RS_DIR"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "wait_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "152-165",
          "snippet": "static int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_directory_wait(struct dlm_ls *ls)\n{\n\treturn wait_status(ls, DLM_RS_DIR);\n}"
  },
  {
    "function_name": "dlm_recover_members_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "167-208",
    "snippet": "int dlm_recover_members_wait(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint num_slots, slots_size;\n\tint error, rv;\n\tuint32_t gen;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tmemb->slot = -1;\n\t\tmemb->generation = 0;\n\t}\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, DLM_RS_NODES, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/* slots array is sparse, slots_size may be > num_slots */\n\n\t\trv = dlm_slots_assign(ls, &num_slots, &slots_size, &slots, &gen);\n\t\tif (!rv) {\n\t\t\tspin_lock(&ls->ls_recover_lock);\n\t\t\t_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t\tls->ls_num_slots = num_slots;\n\t\t\tls->ls_slots_size = slots_size;\n\t\t\tls->ls_slots = slots;\n\t\t\tls->ls_generation = gen;\n\t\t\tspin_unlock(&ls->ls_recover_lock);\n\t\t} else {\n\t\t\tdlm_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t}\n\t} else {\n\t\terror = wait_status_low(ls, DLM_RS_NODES_ALL, DLM_RSF_NEED_SLOTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tdlm_slots_copy_in(ls);\n\t}\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_slots_copy_in",
          "args": [
            "ls"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_slots_copy_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "98-160",
          "snippet": "int dlm_slots_copy_in(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\tstruct rcom_slot *ro0, *ro;\n\tint our_nodeid = dlm_our_nodeid();\n\tint i, num_slots;\n\tuint32_t gen;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn -1;\n\n\tgen = le32_to_cpu(rf->rf_generation);\n\tif (gen <= ls->ls_generation) {\n\t\tlog_error(ls, \"dlm_slots_copy_in gen %u old %u\",\n\t\t\t  gen, ls->ls_generation);\n\t}\n\tls->ls_generation = gen;\n\n\tnum_slots = le16_to_cpu(rf->rf_num_slots);\n\tif (!num_slots)\n\t\treturn -1;\n\n\tro0 = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\tro->ro_nodeid = le32_to_cpu(ro->ro_nodeid);\n\t\tro->ro_slot = le16_to_cpu(ro->ro_slot);\n\t}\n\n\tlog_slots(ls, gen, num_slots, ro0, NULL, 0);\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\t\tif (ro->ro_nodeid != memb->nodeid)\n\t\t\t\tcontinue;\n\t\t\tmemb->slot = ro->ro_slot;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tif (ls->ls_slot && ls->ls_slot != memb->slot) {\n\t\t\t\tlog_error(ls, \"dlm_slots_copy_in our slot \"\n\t\t\t\t\t  \"changed %d %d\", ls->ls_slot,\n\t\t\t\t\t  memb->slot);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!ls->ls_slot)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"dlm_slots_copy_in nodeid %d no slot\",\n\t\t\t\t   memb->nodeid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_copy_in(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\tstruct rcom_slot *ro0, *ro;\n\tint our_nodeid = dlm_our_nodeid();\n\tint i, num_slots;\n\tuint32_t gen;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn -1;\n\n\tgen = le32_to_cpu(rf->rf_generation);\n\tif (gen <= ls->ls_generation) {\n\t\tlog_error(ls, \"dlm_slots_copy_in gen %u old %u\",\n\t\t\t  gen, ls->ls_generation);\n\t}\n\tls->ls_generation = gen;\n\n\tnum_slots = le16_to_cpu(rf->rf_num_slots);\n\tif (!num_slots)\n\t\treturn -1;\n\n\tro0 = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\tro->ro_nodeid = le32_to_cpu(ro->ro_nodeid);\n\t\tro->ro_slot = le16_to_cpu(ro->ro_slot);\n\t}\n\n\tlog_slots(ls, gen, num_slots, ro0, NULL, 0);\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\n\t\t\tif (ro->ro_nodeid != memb->nodeid)\n\t\t\t\tcontinue;\n\t\t\tmemb->slot = ro->ro_slot;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tif (ls->ls_slot && ls->ls_slot != memb->slot) {\n\t\t\t\tlog_error(ls, \"dlm_slots_copy_in our slot \"\n\t\t\t\t\t  \"changed %d %d\", ls->ls_slot,\n\t\t\t\t\t  memb->slot);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (!ls->ls_slot)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"dlm_slots_copy_in nodeid %d no slot\",\n\t\t\t\t   memb->nodeid);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_status_low",
          "args": [
            "ls",
            "DLM_RS_NODES_ALL",
            "DLM_RSF_NEED_SLOTS"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "wait_status_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "126-150",
          "snippet": "static int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\n\n\tfor (;;) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = dlm_rcom_status(ls, nodeid, status_flags);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (rc->rc_result & wait_status)\n\t\t\tbreak;\n\t\tif (delay < 1000)\n\t\t\tdelay += 20;\n\t\tmsleep(delay);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\n\n\tfor (;;) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = dlm_rcom_status(ls, nodeid, status_flags);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (rc->rc_result & wait_status)\n\t\t\tbreak;\n\t\tif (delay < 1000)\n\t\t\tdelay += 20;\n\t\tmsleep(delay);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_recover_status",
          "args": [
            "ls",
            "DLM_RS_NODES_ALL"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "86-91",
          "snippet": "void dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_slots_assign",
          "args": [
            "ls",
            "&num_slots",
            "&slots_size",
            "&slots",
            "&gen"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_slots_assign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "166-291",
          "snippet": "int dlm_slots_assign(struct dlm_ls *ls, int *num_slots, int *slots_size,\n\t\t     struct dlm_slot **slots_out, uint32_t *gen_out)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *array;\n\tint our_nodeid = dlm_our_nodeid();\n\tint array_size, max_slots, i;\n\tint need = 0;\n\tint max = 0;\n\tint num = 0;\n\tuint32_t gen = 0;\n\n\t/* our own memb struct will have slot -1 gen 0 */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tmemb->slot = ls->ls_slot;\n\t\t\tmemb->generation = ls->ls_generation;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->generation > gen)\n\t\t\tgen = memb->generation;\n\n\t\t/* node doesn't support slots */\n\n\t\tif (memb->slot == -1)\n\t\t\treturn -1;\n\n\t\t/* node needs a slot assigned */\n\n\t\tif (!memb->slot)\n\t\t\tneed++;\n\n\t\t/* node has a slot assigned */\n\n\t\tnum++;\n\n\t\tif (!max || max < memb->slot)\n\t\t\tmax = memb->slot;\n\n\t\t/* sanity check, once slot is assigned it shouldn't change */\n\n\t\tif (memb->slot_prev && memb->slot && memb->slot_prev != memb->slot) {\n\t\t\tlog_error(ls, \"nodeid %d slot changed %d %d\",\n\t\t\t\t  memb->nodeid, memb->slot_prev, memb->slot);\n\t\t\treturn -1;\n\t\t}\n\t\tmemb->slot_prev = memb->slot;\n\t}\n\n\tarray_size = max + need;\n\n\tarray = kzalloc(array_size * sizeof(struct dlm_slot), GFP_NOFS);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tnum = 0;\n\n\t/* fill in slots (offsets) that are used */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!memb->slot)\n\t\t\tcontinue;\n\n\t\tif (memb->slot > array_size) {\n\t\t\tlog_error(ls, \"invalid slot number %d\", memb->slot);\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray[memb->slot - 1].nodeid = memb->nodeid;\n\t\tarray[memb->slot - 1].slot = memb->slot;\n\t\tnum++;\n\t}\n\n\t/* assign new slots from unused offsets */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->slot)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tmemb->slot = i + 1;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tarray[i].nodeid = memb->nodeid;\n\t\t\tarray[i].slot = memb->slot;\n\t\t\tnum++;\n\n\t\t\tif (!ls->ls_slot && memb->nodeid == our_nodeid)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"no free slot found\");\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgen++;\n\n\tlog_slots(ls, gen, num, NULL, array, array_size);\n\n\tmax_slots = (dlm_config.ci_buffer_size - sizeof(struct dlm_rcom) -\n\t\t     sizeof(struct rcom_config)) / sizeof(struct rcom_slot);\n\n\tif (num > max_slots) {\n\t\tlog_error(ls, \"num_slots %d exceeds max_slots %d\",\n\t\t\t  num, max_slots);\n\t\tkfree(array);\n\t\treturn -1;\n\t}\n\n\t*gen_out = gen;\n\t*slots_out = array;\n\t*slots_size = array_size;\n\t*num_slots = num;\n\treturn 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_assign(struct dlm_ls *ls, int *num_slots, int *slots_size,\n\t\t     struct dlm_slot **slots_out, uint32_t *gen_out)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *array;\n\tint our_nodeid = dlm_our_nodeid();\n\tint array_size, max_slots, i;\n\tint need = 0;\n\tint max = 0;\n\tint num = 0;\n\tuint32_t gen = 0;\n\n\t/* our own memb struct will have slot -1 gen 0 */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->nodeid == our_nodeid) {\n\t\t\tmemb->slot = ls->ls_slot;\n\t\t\tmemb->generation = ls->ls_generation;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->generation > gen)\n\t\t\tgen = memb->generation;\n\n\t\t/* node doesn't support slots */\n\n\t\tif (memb->slot == -1)\n\t\t\treturn -1;\n\n\t\t/* node needs a slot assigned */\n\n\t\tif (!memb->slot)\n\t\t\tneed++;\n\n\t\t/* node has a slot assigned */\n\n\t\tnum++;\n\n\t\tif (!max || max < memb->slot)\n\t\t\tmax = memb->slot;\n\n\t\t/* sanity check, once slot is assigned it shouldn't change */\n\n\t\tif (memb->slot_prev && memb->slot && memb->slot_prev != memb->slot) {\n\t\t\tlog_error(ls, \"nodeid %d slot changed %d %d\",\n\t\t\t\t  memb->nodeid, memb->slot_prev, memb->slot);\n\t\t\treturn -1;\n\t\t}\n\t\tmemb->slot_prev = memb->slot;\n\t}\n\n\tarray_size = max + need;\n\n\tarray = kzalloc(array_size * sizeof(struct dlm_slot), GFP_NOFS);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tnum = 0;\n\n\t/* fill in slots (offsets) that are used */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (!memb->slot)\n\t\t\tcontinue;\n\n\t\tif (memb->slot > array_size) {\n\t\t\tlog_error(ls, \"invalid slot number %d\", memb->slot);\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\n\t\tarray[memb->slot - 1].nodeid = memb->nodeid;\n\t\tarray[memb->slot - 1].slot = memb->slot;\n\t\tnum++;\n\t}\n\n\t/* assign new slots from unused offsets */\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tif (memb->slot)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < array_size; i++) {\n\t\t\tif (array[i].nodeid)\n\t\t\t\tcontinue;\n\n\t\t\tmemb->slot = i + 1;\n\t\t\tmemb->slot_prev = memb->slot;\n\t\t\tarray[i].nodeid = memb->nodeid;\n\t\t\tarray[i].slot = memb->slot;\n\t\t\tnum++;\n\n\t\t\tif (!ls->ls_slot && memb->nodeid == our_nodeid)\n\t\t\t\tls->ls_slot = memb->slot;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!memb->slot) {\n\t\t\tlog_error(ls, \"no free slot found\");\n\t\t\tkfree(array);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgen++;\n\n\tlog_slots(ls, gen, num, NULL, array, array_size);\n\n\tmax_slots = (dlm_config.ci_buffer_size - sizeof(struct dlm_rcom) -\n\t\t     sizeof(struct rcom_config)) / sizeof(struct rcom_slot);\n\n\tif (num > max_slots) {\n\t\tlog_error(ls, \"num_slots %d exceeds max_slots %d\",\n\t\t\t  num, max_slots);\n\t\tkfree(array);\n\t\treturn -1;\n\t}\n\n\t*gen_out = gen;\n\t*slots_out = array;\n\t*slots_size = array_size;\n\t*num_slots = num;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_status_all",
          "args": [
            "ls",
            "DLM_RS_NODES",
            "1"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "wait_status_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "93-124",
          "snippet": "static int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   int save_slots)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct dlm_member *memb;\n\tint error = 0, delay;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tdelay = 0;\n\t\tfor (;;) {\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tif (save_slots)\n\t\t\t\tdlm_slot_save(ls, rc, memb);\n\n\t\t\tif (rc->rc_result & wait_status)\n\t\t\t\tbreak;\n\t\t\tif (delay < 1000)\n\t\t\t\tdelay += 20;\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   int save_slots)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct dlm_member *memb;\n\tint error = 0, delay;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tdelay = 0;\n\t\tfor (;;) {\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tif (save_slots)\n\t\t\t\tdlm_slot_save(ls, rc, memb);\n\n\t\t\tif (rc->rc_result & wait_status)\n\t\t\t\tbreak;\n\t\t\tif (delay < 1000)\n\t\t\t\tdelay += 20;\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_members_wait(struct dlm_ls *ls)\n{\n\tstruct dlm_member *memb;\n\tstruct dlm_slot *slots;\n\tint num_slots, slots_size;\n\tint error, rv;\n\tuint32_t gen;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tmemb->slot = -1;\n\t\tmemb->generation = 0;\n\t}\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, DLM_RS_NODES, 1);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/* slots array is sparse, slots_size may be > num_slots */\n\n\t\trv = dlm_slots_assign(ls, &num_slots, &slots_size, &slots, &gen);\n\t\tif (!rv) {\n\t\t\tspin_lock(&ls->ls_recover_lock);\n\t\t\t_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t\tls->ls_num_slots = num_slots;\n\t\t\tls->ls_slots_size = slots_size;\n\t\t\tls->ls_slots = slots;\n\t\t\tls->ls_generation = gen;\n\t\t\tspin_unlock(&ls->ls_recover_lock);\n\t\t} else {\n\t\t\tdlm_set_recover_status(ls, DLM_RS_NODES_ALL);\n\t\t}\n\t} else {\n\t\terror = wait_status_low(ls, DLM_RS_NODES_ALL, DLM_RSF_NEED_SLOTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tdlm_slots_copy_in(ls);\n\t}\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "wait_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "152-165",
    "snippet": "static int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_status_low",
          "args": [
            "ls",
            "status_all",
            "0"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "wait_status_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "126-150",
          "snippet": "static int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\n\n\tfor (;;) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = dlm_rcom_status(ls, nodeid, status_flags);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (rc->rc_result & wait_status)\n\t\t\tbreak;\n\t\tif (delay < 1000)\n\t\t\tdelay += 20;\n\t\tmsleep(delay);\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\n\n\tfor (;;) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = dlm_rcom_status(ls, nodeid, status_flags);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (rc->rc_result & wait_status)\n\t\t\tbreak;\n\t\tif (delay < 1000)\n\t\t\tdelay += 20;\n\t\tmsleep(delay);\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_recover_status",
          "args": [
            "ls",
            "status_all"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "86-91",
          "snippet": "void dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_status_all",
          "args": [
            "ls",
            "status",
            "0"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "wait_status_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "93-124",
          "snippet": "static int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   int save_slots)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct dlm_member *memb;\n\tint error = 0, delay;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tdelay = 0;\n\t\tfor (;;) {\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tif (save_slots)\n\t\t\t\tdlm_slot_save(ls, rc, memb);\n\n\t\t\tif (rc->rc_result & wait_status)\n\t\t\t\tbreak;\n\t\t\tif (delay < 1000)\n\t\t\t\tdelay += 20;\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   int save_slots)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct dlm_member *memb;\n\tint error = 0, delay;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tdelay = 0;\n\t\tfor (;;) {\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tif (save_slots)\n\t\t\t\tdlm_slot_save(ls, rc, memb);\n\n\t\t\tif (rc->rc_result & wait_status)\n\t\t\t\tbreak;\n\t\t\tif (delay < 1000)\n\t\t\t\tdelay += 20;\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status(struct dlm_ls *ls, uint32_t status)\n{\n\tuint32_t status_all = status << 1;\n\tint error;\n\n\tif (ls->ls_low_nodeid == dlm_our_nodeid()) {\n\t\terror = wait_status_all(ls, status, 0);\n\t\tif (!error)\n\t\t\tdlm_set_recover_status(ls, status_all);\n\t} else\n\t\terror = wait_status_low(ls, status_all, 0);\n\n\treturn error;\n}"
  },
  {
    "function_name": "wait_status_low",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "126-150",
    "snippet": "static int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\n\n\tfor (;;) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = dlm_rcom_status(ls, nodeid, status_flags);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (rc->rc_result & wait_status)\n\t\t\tbreak;\n\t\tif (delay < 1000)\n\t\t\tdelay += 20;\n\t\tmsleep(delay);\n\t}\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "delay"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_rcom_status",
          "args": [
            "ls",
            "nodeid",
            "status_flags"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rcom_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "144-189",
          "snippet": "int dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status_low(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tint error = 0, delay = 0, nodeid = ls->ls_low_nodeid;\n\n\tfor (;;) {\n\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\terror = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = dlm_rcom_status(ls, nodeid, status_flags);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tif (rc->rc_result & wait_status)\n\t\t\tbreak;\n\t\tif (delay < 1000)\n\t\t\tdelay += 20;\n\t\tmsleep(delay);\n\t}\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "wait_status_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "93-124",
    "snippet": "static int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   int save_slots)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct dlm_member *memb;\n\tint error = 0, delay;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tdelay = 0;\n\t\tfor (;;) {\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tif (save_slots)\n\t\t\t\tdlm_slot_save(ls, rc, memb);\n\n\t\t\tif (rc->rc_result & wait_status)\n\t\t\t\tbreak;\n\t\t\tif (delay < 1000)\n\t\t\t\tdelay += 20;\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "delay"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_slot_save",
          "args": [
            "ls",
            "rc",
            "memb"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_slot_save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "29-39",
          "snippet": "void dlm_slot_save(struct dlm_ls *ls, struct dlm_rcom *rc,\n\t\t   struct dlm_member *memb)\n{\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn;\n\n\tmemb->slot = le16_to_cpu(rf->rf_our_slot);\n\tmemb->generation = le32_to_cpu(rf->rf_generation);\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_slot_save(struct dlm_ls *ls, struct dlm_rcom *rc,\n\t\t   struct dlm_member *memb)\n{\n\tstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\n\n\tif (!dlm_slots_version(&rc->rc_header))\n\t\treturn;\n\n\tmemb->slot = le16_to_cpu(rf->rf_our_slot);\n\tmemb->generation = le32_to_cpu(rf->rf_generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_rcom_status",
          "args": [
            "ls",
            "memb->nodeid",
            "0"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rcom_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "144-189",
          "snippet": "int dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "memb",
            "&ls->ls_nodes",
            "list"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int wait_status_all(struct dlm_ls *ls, uint32_t wait_status,\n\t\t\t   int save_slots)\n{\n\tstruct dlm_rcom *rc = ls->ls_recover_buf;\n\tstruct dlm_member *memb;\n\tint error = 0, delay;\n\n\tlist_for_each_entry(memb, &ls->ls_nodes, list) {\n\t\tdelay = 0;\n\t\tfor (;;) {\n\t\t\tif (dlm_recovery_stopped(ls)) {\n\t\t\t\terror = -EINTR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terror = dlm_rcom_status(ls, memb->nodeid, 0);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tif (save_slots)\n\t\t\t\tdlm_slot_save(ls, rc, memb);\n\n\t\t\tif (rc->rc_result & wait_status)\n\t\t\t\tbreak;\n\t\t\tif (delay < 1000)\n\t\t\t\tdelay += 20;\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_set_recover_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "86-91",
    "snippet": "void dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_set_recover_status",
          "args": [
            "ls",
            "status"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "86-91",
          "snippet": "void dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tspin_lock(&ls->ls_recover_lock);\n\t_set_recover_status(ls, status);\n\tspin_unlock(&ls->ls_recover_lock);\n}"
  },
  {
    "function_name": "_set_recover_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "81-84",
    "snippet": "static void _set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tls->ls_recover_status |= status;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void _set_recover_status(struct dlm_ls *ls, uint32_t status)\n{\n\tls->ls_recover_status |= status;\n}"
  },
  {
    "function_name": "dlm_recover_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "72-79",
    "snippet": "uint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nuint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_wait_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
    "lines": "44-62",
    "snippet": "int dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"recover.h\"",
      "#include \"member.h\"",
      "#include \"lowcomms.h\"",
      "#include \"lock.h\"",
      "#include \"rcom.h\"",
      "#include \"memory.h\"",
      "#include \"ast.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"dlm_wait_function aborted\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recovery_stopped",
          "args": [
            "ls"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recovery_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dlm_internal.h",
          "lines": "700-703",
          "snippet": "static inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/idr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/jhash.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kref.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kthread.h>",
            "#include <linux/socket.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/errno.h>",
            "#include <linux/list.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LSFL_RECOVER_STOP\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/ratelimit.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/kobject.h>\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define LSFL_RECOVER_STOP\t0\n\nstatic inline int dlm_recovery_stopped(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "ls->ls_wait_general",
            "testfn(ls) || dlm_recovery_stopped(ls)",
            "dlm_config.ci_recover_timer * HZ"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "testfn",
          "args": [
            "ls"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}"
  }
]