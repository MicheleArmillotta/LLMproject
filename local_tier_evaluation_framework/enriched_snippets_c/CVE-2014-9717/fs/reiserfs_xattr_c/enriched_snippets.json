[
  {
    "function_name": "reiserfs_xattr_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "1020-1064",
    "snippet": "int reiserfs_xattr_init(struct super_block *s, int mount_flags)\n{\n\tint err = 0;\n\tstruct dentry *privroot = REISERFS_SB(s)->priv_root;\n\n\terr = xattr_mount_check(s);\n\tif (err)\n\t\tgoto error;\n\n\tif (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {\n\t\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\t\terr = create_privroot(REISERFS_SB(s)->priv_root);\n\t\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\t}\n\n\tif (privroot->d_inode) {\n\t\ts->s_xattr = reiserfs_xattr_handlers;\n\t\tmutex_lock(&privroot->d_inode->i_mutex);\n\t\tif (!REISERFS_SB(s)->xattr_root) {\n\t\t\tstruct dentry *dentry;\n\n\t\t\tdentry = lookup_one_len(XAROOT_NAME, privroot,\n\t\t\t\t\t\tstrlen(XAROOT_NAME));\n\t\t\tif (!IS_ERR(dentry))\n\t\t\t\tREISERFS_SB(s)->xattr_root = dentry;\n\t\t\telse\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t}\n\t\tmutex_unlock(&privroot->d_inode->i_mutex);\n\t}\n\nerror:\n\tif (err) {\n\t\tclear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);\n\t\tclear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);\n\t}\n\n\t/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */\n\tif (reiserfs_posixacl(s))\n\t\ts->s_flags |= MS_POSIXACL;\n\telse\n\t\ts->s_flags &= ~MS_POSIXACL;\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [
      "#define XAROOT_NAME   \"xattrs\""
    ],
    "globals_used": [
      "static const struct xattr_handler *reiserfs_xattr_handlers[] = {\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t&reiserfs_xattr_user_handler,\n\t&reiserfs_xattr_trusted_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_SECURITY\n\t&reiserfs_xattr_security_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_posixacl",
          "args": [
            "s"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "REISERFS_POSIXACL",
            "&REISERFS_SB(s)->s_mount_opt"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&privroot->d_inode->i_mutex"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "XAROOT_NAME",
            "privroot",
            "strlen(XAROOT_NAME)"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "XAROOT_NAME"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&privroot->d_inode->i_mutex"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&s->s_root->d_inode->i_mutex"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_privroot",
          "args": [
            "REISERFS_SB(s)->priv_root"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "create_privroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "931-931",
          "snippet": "static int create_privroot(struct dentry *dentry) { return 0; }",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int create_privroot(struct dentry *dentry) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&s->s_root->d_inode->i_mutex"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_mount_check",
          "args": [
            "s"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_mount_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "950-971",
          "snippet": "static int xattr_mount_check(struct super_block *s)\n{\n\t/*\n\t * We need generation numbers to ensure that the oid mapping is correct\n\t * v3.5 filesystems don't have them.\n\t */\n\tif (old_format_only(s)) {\n\t\tif (reiserfs_xattrs_optional(s)) {\n\t\t\t/*\n\t\t\t * Old format filesystem, but optional xattrs have\n\t\t\t * been enabled. Error out.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"jdm-2005\",\n\t\t\t\t\t \"xattrs/ACLs not supported \"\n\t\t\t\t\t \"on pre-v3.6 format filesystems. \"\n\t\t\t\t\t \"Failing mount.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_mount_check(struct super_block *s)\n{\n\t/*\n\t * We need generation numbers to ensure that the oid mapping is correct\n\t * v3.5 filesystems don't have them.\n\t */\n\tif (old_format_only(s)) {\n\t\tif (reiserfs_xattrs_optional(s)) {\n\t\t\t/*\n\t\t\t * Old format filesystem, but optional xattrs have\n\t\t\t * been enabled. Error out.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"jdm-2005\",\n\t\t\t\t\t \"xattrs/ACLs not supported \"\n\t\t\t\t\t \"on pre-v3.6 format filesystems. \"\n\t\t\t\t\t \"Failing mount.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\n#define XAROOT_NAME   \"xattrs\"\n\nstatic const struct xattr_handler *reiserfs_xattr_handlers[] = {\n#ifdef CONFIG_REISERFS_FS_XATTR\n\t&reiserfs_xattr_user_handler,\n\t&reiserfs_xattr_trusted_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_SECURITY\n\t&reiserfs_xattr_security_handler,\n#endif\n#ifdef CONFIG_REISERFS_FS_POSIX_ACL\n\t&posix_acl_access_xattr_handler,\n\t&posix_acl_default_xattr_handler,\n#endif\n\tNULL\n};\n\nint reiserfs_xattr_init(struct super_block *s, int mount_flags)\n{\n\tint err = 0;\n\tstruct dentry *privroot = REISERFS_SB(s)->priv_root;\n\n\terr = xattr_mount_check(s);\n\tif (err)\n\t\tgoto error;\n\n\tif (!privroot->d_inode && !(mount_flags & MS_RDONLY)) {\n\t\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\t\terr = create_privroot(REISERFS_SB(s)->priv_root);\n\t\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\t}\n\n\tif (privroot->d_inode) {\n\t\ts->s_xattr = reiserfs_xattr_handlers;\n\t\tmutex_lock(&privroot->d_inode->i_mutex);\n\t\tif (!REISERFS_SB(s)->xattr_root) {\n\t\t\tstruct dentry *dentry;\n\n\t\t\tdentry = lookup_one_len(XAROOT_NAME, privroot,\n\t\t\t\t\t\tstrlen(XAROOT_NAME));\n\t\t\tif (!IS_ERR(dentry))\n\t\t\t\tREISERFS_SB(s)->xattr_root = dentry;\n\t\t\telse\n\t\t\t\terr = PTR_ERR(dentry);\n\t\t}\n\t\tmutex_unlock(&privroot->d_inode->i_mutex);\n\t}\n\nerror:\n\tif (err) {\n\t\tclear_bit(REISERFS_XATTRS_USER, &REISERFS_SB(s)->s_mount_opt);\n\t\tclear_bit(REISERFS_POSIXACL, &REISERFS_SB(s)->s_mount_opt);\n\t}\n\n\t/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */\n\tif (reiserfs_posixacl(s))\n\t\ts->s_flags |= MS_POSIXACL;\n\telse\n\t\ts->s_flags &= ~MS_POSIXACL;\n\n\treturn err;\n}"
  },
  {
    "function_name": "reiserfs_lookup_privroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "994-1013",
    "snippet": "int reiserfs_lookup_privroot(struct super_block *s)\n{\n\tstruct dentry *dentry;\n\tint err = 0;\n\n\t/* If we don't have the privroot located yet - go find it */\n\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(PRIVROOT_NAME, s->s_root,\n\t\t\t\tstrlen(PRIVROOT_NAME));\n\tif (!IS_ERR(dentry)) {\n\t\tREISERFS_SB(s)->priv_root = dentry;\n\t\td_set_d_op(dentry, &xattr_lookup_poison_ops);\n\t\tif (dentry->d_inode)\n\t\t\tdentry->d_inode->i_flags |= S_PRIVATE;\n\t} else\n\t\terr = PTR_ERR(dentry);\n\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [
      "#define PRIVROOT_NAME \".reiserfs_priv\""
    ],
    "globals_used": [
      "static const struct dentry_operations xattr_lookup_poison_ops = {\n\t.d_revalidate = xattr_hide_revalidate,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&s->s_root->d_inode->i_mutex"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&xattr_lookup_poison_ops"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "s"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "PRIVROOT_NAME",
            "s->s_root",
            "strlen(PRIVROOT_NAME)"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "PRIVROOT_NAME"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&s->s_root->d_inode->i_mutex"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\n#define PRIVROOT_NAME \".reiserfs_priv\"\n\nstatic const struct dentry_operations xattr_lookup_poison_ops = {\n\t.d_revalidate = xattr_hide_revalidate,\n};\n\nint reiserfs_lookup_privroot(struct super_block *s)\n{\n\tstruct dentry *dentry;\n\tint err = 0;\n\n\t/* If we don't have the privroot located yet - go find it */\n\tmutex_lock(&s->s_root->d_inode->i_mutex);\n\tdentry = lookup_one_len(PRIVROOT_NAME, s->s_root,\n\t\t\t\tstrlen(PRIVROOT_NAME));\n\tif (!IS_ERR(dentry)) {\n\t\tREISERFS_SB(s)->priv_root = dentry;\n\t\td_set_d_op(dentry, &xattr_lookup_poison_ops);\n\t\tif (dentry->d_inode)\n\t\t\tdentry->d_inode->i_flags |= S_PRIVATE;\n\t} else\n\t\terr = PTR_ERR(dentry);\n\tmutex_unlock(&s->s_root->d_inode->i_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "xattr_hide_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "985-988",
    "snippet": "static int xattr_hide_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn -EPERM;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_hide_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\treturn -EPERM;\n}"
  },
  {
    "function_name": "reiserfs_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "973-983",
    "snippet": "int reiserfs_permission(struct inode *inode, int mask)\n{\n\t/*\n\t * We don't do permission checks on the internal objects.\n\t * Permissions are determined by the \"owning\" object.\n\t */\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\treturn generic_permission(inode, mask);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_permission(struct inode *inode, int mask)\n{\n\t/*\n\t * We don't do permission checks on the internal objects.\n\t * Permissions are determined by the \"owning\" object.\n\t */\n\tif (IS_PRIVATE(inode))\n\t\treturn 0;\n\n\treturn generic_permission(inode, mask);\n}"
  },
  {
    "function_name": "xattr_mount_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "950-971",
    "snippet": "static int xattr_mount_check(struct super_block *s)\n{\n\t/*\n\t * We need generation numbers to ensure that the oid mapping is correct\n\t * v3.5 filesystems don't have them.\n\t */\n\tif (old_format_only(s)) {\n\t\tif (reiserfs_xattrs_optional(s)) {\n\t\t\t/*\n\t\t\t * Old format filesystem, but optional xattrs have\n\t\t\t * been enabled. Error out.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"jdm-2005\",\n\t\t\t\t\t \"xattrs/ACLs not supported \"\n\t\t\t\t\t \"on pre-v3.6 format filesystems. \"\n\t\t\t\t\t \"Failing mount.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"jdm-2005\"",
            "\"xattrs/ACLs not supported \"\n\t\t\t\t\t \"on pre-v3.6 format filesystems. \"\n\t\t\t\t\t \"Failing mount.\""
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_xattrs_optional",
          "args": [
            "s"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_format_only",
          "args": [
            "s"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_mount_check(struct super_block *s)\n{\n\t/*\n\t * We need generation numbers to ensure that the oid mapping is correct\n\t * v3.5 filesystems don't have them.\n\t */\n\tif (old_format_only(s)) {\n\t\tif (reiserfs_xattrs_optional(s)) {\n\t\t\t/*\n\t\t\t * Old format filesystem, but optional xattrs have\n\t\t\t * been enabled. Error out.\n\t\t\t */\n\t\t\treiserfs_warning(s, \"jdm-2005\",\n\t\t\t\t\t \"xattrs/ACLs not supported \"\n\t\t\t\t\t \"on pre-v3.6 format filesystems. \"\n\t\t\t\t\t \"Failing mount.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "create_privroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "931-931",
    "snippet": "static int create_privroot(struct dentry *dentry) { return 0; }",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int create_privroot(struct dentry *dentry) { return 0; }"
  },
  {
    "function_name": "reiserfs_xattr_unregister_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "930-930",
    "snippet": "void reiserfs_xattr_unregister_handlers(void) {}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_xattr_unregister_handlers(void) {}"
  },
  {
    "function_name": "reiserfs_xattr_register_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "929-929",
    "snippet": "int __init reiserfs_xattr_register_handlers(void) { return 0; }",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint __init reiserfs_xattr_register_handlers(void) { return 0; }"
  },
  {
    "function_name": "create_privroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "905-926",
    "snippet": "static int create_privroot(struct dentry *dentry)\n{\n\tint err;\n\tstruct inode *inode = dentry->d_parent->d_inode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\terr = xattr_mkdir(inode, dentry, 0700);\n\tif (err || !dentry->d_inode) {\n\t\treiserfs_warning(dentry->d_sb, \"jdm-20006\",\n\t\t\t\t \"xattrs/ACLs enabled and couldn't \"\n\t\t\t\t \"find/create .reiserfs_priv. \"\n\t\t\t\t \"Failing mount.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdentry->d_inode->i_flags |= S_PRIVATE;\n\treiserfs_info(dentry->d_sb, \"Created %s - reserved for xattr \"\n\t\t      \"storage.\\n\", PRIVROOT_NAME);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [
      "#define PRIVROOT_NAME \".reiserfs_priv\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "dentry->d_sb",
            "\"Created %s - reserved for xattr \"\n\t\t      \"storage.\\n\"",
            "PRIVROOT_NAME"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "dentry->d_sb",
            "\"jdm-20006\"",
            "\"xattrs/ACLs enabled and couldn't \"\n\t\t\t\t \"find/create .reiserfs_priv. \"\n\t\t\t\t \"Failing mount.\""
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_mkdir",
          "args": [
            "inode",
            "dentry",
            "0700"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "72-76",
          "snippet": "static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\n#define PRIVROOT_NAME \".reiserfs_priv\"\n\nstatic int create_privroot(struct dentry *dentry)\n{\n\tint err;\n\tstruct inode *inode = dentry->d_parent->d_inode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\terr = xattr_mkdir(inode, dentry, 0700);\n\tif (err || !dentry->d_inode) {\n\t\treiserfs_warning(dentry->d_sb, \"jdm-20006\",\n\t\t\t\t \"xattrs/ACLs enabled and couldn't \"\n\t\t\t\t \"find/create .reiserfs_priv. \"\n\t\t\t\t \"Failing mount.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdentry->d_inode->i_flags |= S_PRIVATE;\n\treiserfs_info(dentry->d_sb, \"Created %s - reserved for xattr \"\n\t\t      \"storage.\\n\", PRIVROOT_NAME);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "867-903",
    "snippet": "ssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)\n{\n\tstruct dentry *dir;\n\tint err = 0;\n\tstruct listxattr_buf buf = {\n\t\t.ctx.actor = listxattr_filler,\n\t\t.dentry = dentry,\n\t\t.buf = buffer,\n\t\t.size = buffer ? size : 0,\n\t};\n\n\tif (!dentry->d_inode)\n\t\treturn -EINVAL;\n\n\tif (!dentry->d_sb->s_xattr ||\n\t    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tif (err == -ENODATA)\n\t\t\terr = 0;  /* Not an error if there aren't any xattrs */\n\t\tgoto out;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (!err)\n\t\terr = buf.pos;\n\n\tdput(dir);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_readdir_inode",
          "args": [
            "dir->d_inode",
            "&buf.ctx"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_readdir_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
          "lines": "60-270",
          "snippet": "int reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const struct reiserfs_key MIN_KEY;",
            "static int reiserfs_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nextern const struct reiserfs_key MIN_KEY;\nstatic int reiserfs_readdir(struct file *, struct dir_context *);\n\nint reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_xa_dir",
          "args": [
            "dentry->d_inode",
            "XATTR_REPLACE"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "open_xa_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "146-176",
          "snippet": "static struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "dentry->d_inode"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nssize_t reiserfs_listxattr(struct dentry * dentry, char *buffer, size_t size)\n{\n\tstruct dentry *dir;\n\tint err = 0;\n\tstruct listxattr_buf buf = {\n\t\t.ctx.actor = listxattr_filler,\n\t\t.dentry = dentry,\n\t\t.buf = buffer,\n\t\t.size = buffer ? size : 0,\n\t};\n\n\tif (!dentry->d_inode)\n\t\treturn -EINVAL;\n\n\tif (!dentry->d_sb->s_xattr ||\n\t    get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdir = open_xa_dir(dentry->d_inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tif (err == -ENODATA)\n\t\t\terr = 0;  /* Not an error if there aren't any xattrs */\n\t\tgoto out;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (!err)\n\t\terr = buf.pos;\n\n\tdput(dir);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "listxattr_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "828-858",
    "snippet": "static int listxattr_filler(struct dir_context *ctx, const char *name,\n\t\t\t    int namelen, loff_t offset, u64 ino,\n\t\t\t    unsigned int d_type)\n{\n\tstruct listxattr_buf *b =\n\t\tcontainer_of(ctx, struct listxattr_buf, ctx);\n\tsize_t size;\n\n\tif (name[0] != '.' ||\n\t    (namelen != 1 && (name[1] != '.' || namelen != 2))) {\n\t\tconst struct xattr_handler *handler;\n\n\t\thandler = find_xattr_handler_prefix(b->dentry->d_sb->s_xattr,\n\t\t\t\t\t\t    name);\n\t\tif (!handler)\t/* Unsupported xattr name */\n\t\t\treturn 0;\n\t\tif (b->buf) {\n\t\t\tsize = handler->list(b->dentry, b->buf + b->pos,\n\t\t\t\t\t b->size, name, namelen,\n\t\t\t\t\t handler->flags);\n\t\t\tif (size > b->size)\n\t\t\t\treturn -ERANGE;\n\t\t} else {\n\t\t\tsize = handler->list(b->dentry, NULL, 0, name,\n\t\t\t\t\t     namelen, handler->flags);\n\t\t}\n\n\t\tb->pos += size;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "b->dentry",
            "NULL",
            "0",
            "name",
            "namelen",
            "handler->flags"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "b->dentry",
            "b->buf + b->pos",
            "b->size",
            "name",
            "namelen",
            "handler->flags"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_xattr_handler_prefix",
          "args": [
            "b->dentry->d_sb->s_xattr",
            "name"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "find_xattr_handler_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "749-764",
          "snippet": "static inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structlistxattr_buf",
            "ctx"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int listxattr_filler(struct dir_context *ctx, const char *name,\n\t\t\t    int namelen, loff_t offset, u64 ino,\n\t\t\t    unsigned int d_type)\n{\n\tstruct listxattr_buf *b =\n\t\tcontainer_of(ctx, struct listxattr_buf, ctx);\n\tsize_t size;\n\n\tif (name[0] != '.' ||\n\t    (namelen != 1 && (name[1] != '.' || namelen != 2))) {\n\t\tconst struct xattr_handler *handler;\n\n\t\thandler = find_xattr_handler_prefix(b->dentry->d_sb->s_xattr,\n\t\t\t\t\t\t    name);\n\t\tif (!handler)\t/* Unsupported xattr name */\n\t\t\treturn 0;\n\t\tif (b->buf) {\n\t\t\tsize = handler->list(b->dentry, b->buf + b->pos,\n\t\t\t\t\t b->size, name, namelen,\n\t\t\t\t\t handler->flags);\n\t\t\tif (size > b->size)\n\t\t\t\treturn -ERANGE;\n\t\t} else {\n\t\t\tsize = handler->list(b->dentry, NULL, 0, name,\n\t\t\t\t\t     namelen, handler->flags);\n\t\t}\n\n\t\tb->pos += size;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "808-818",
    "snippet": "int reiserfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);\n\n\tif (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handler->set(dentry, name, NULL, 0, XATTR_REPLACE, handler->flags);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->set",
          "args": [
            "dentry",
            "name",
            "NULL",
            "0",
            "XATTR_REPLACE",
            "handler->flags"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "dentry->d_inode"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_xattr_handler_prefix",
          "args": [
            "dentry->d_sb->s_xattr",
            "name"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "find_xattr_handler_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "749-764",
          "snippet": "static inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);\n\n\tif (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handler->set(dentry, name, NULL, 0, XATTR_REPLACE, handler->flags);\n}"
  },
  {
    "function_name": "reiserfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "789-801",
    "snippet": "int\nreiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t  size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);\n\n\tif (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->set",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags",
            "handler->flags"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "dentry->d_inode"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_xattr_handler_prefix",
          "args": [
            "dentry->d_sb->s_xattr",
            "name"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "find_xattr_handler_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "749-764",
          "snippet": "static inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\t  size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);\n\n\tif (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handler->set(dentry, name, value, size, flags, handler->flags);\n}"
  },
  {
    "function_name": "reiserfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "770-782",
    "snippet": "ssize_t\nreiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,\n\t\t  size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);\n\n\tif (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->get",
          "args": [
            "dentry",
            "name",
            "buffer",
            "size",
            "handler->flags"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "dentry->d_inode"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_xattr_handler_prefix",
          "args": [
            "dentry->d_sb->s_xattr",
            "name"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "find_xattr_handler_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "749-764",
          "snippet": "static inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nssize_t\nreiserfs_getxattr(struct dentry * dentry, const char *name, void *buffer,\n\t\t  size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = find_xattr_handler_prefix(dentry->d_sb->s_xattr, name);\n\n\tif (!handler || get_inode_sd_version(dentry->d_inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handler->get(dentry, name, buffer, size, handler->flags);\n}"
  },
  {
    "function_name": "find_xattr_handler_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "749-764",
    "snippet": "static inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "xah->prefix",
            "name",
            "strlen(xah->prefix)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xah->prefix"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_xattr_handler",
          "args": [
            "handlers",
            "xah"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline const struct xattr_handler *\nfind_xattr_handler_prefix(const struct xattr_handler **handlers,\n\t\t\t   const char *name)\n{\n\tconst struct xattr_handler *xah;\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\tfor_each_xattr_handler(handlers, xah) {\n\t\tif (strncmp(xah->prefix, name, strlen(xah->prefix)) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn xah;\n}"
  },
  {
    "function_name": "reiserfs_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "630-732",
    "snippet": "int\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&REISERFS_I(inode)->i_xattr_sem"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"jdm-20002\"",
            "\"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\"",
            "name",
            "INODE_PKEY(inode)"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_hash",
          "args": [
            "buffer",
            "isize - sizeof(struct reiserfs_xattr_header)"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "443-446",
          "snippet": "static inline __u32 xattr_hash(const char *msg, int len)\n{\n\treturn csum_partial(msg, len, 0);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline __u32 xattr_hash(const char *msg, int len)\n{\n\treturn csum_partial(msg, len, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_put_page",
          "args": [
            "page"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "415-419",
          "snippet": "static inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer + buffer_pos",
            "data + skip",
            "chunk"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rxh->h_hash"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "REISERFS_XATTR_MAGIC"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_get_page",
          "args": [
            "dentry->d_inode",
            "file_pos"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "421-441",
          "snippet": "static struct page *reiserfs_get_page(struct inode *dir, size_t n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page;\n\t/*\n\t * We can deadlock if we try to free dentries,\n\t * and an unlink/rmdir has just occurred - GFP_NOFS avoids this\n\t */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tpage = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\treiserfs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct page *reiserfs_get_page(struct inode *dir, size_t n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page;\n\t/*\n\t * We can deadlock if we try to free dentries,\n\t * and an unlink/rmdir has just occurred - GFP_NOFS avoids this\n\t */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tpage = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\treiserfs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dentry->d_inode"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&REISERFS_I(inode)->i_xattr_sem"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_lookup",
          "args": [
            "inode",
            "name",
            "XATTR_REPLACE"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "377-412",
          "snippet": "static struct dentry *xattr_lookup(struct inode *inode, const char *name,\n\t\t\t\t    int flags)\n{\n\tstruct dentry *xadir, *xafile;\n\tint err = 0;\n\n\txadir = open_xa_dir(inode, flags);\n\tif (IS_ERR(xadir))\n\t\treturn ERR_CAST(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\txafile = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(xafile)) {\n\t\terr = PTR_ERR(xafile);\n\t\tgoto out;\n\t}\n\n\tif (xafile->d_inode && (flags & XATTR_CREATE))\n\t\terr = -EEXIST;\n\n\tif (!xafile->d_inode) {\n\t\terr = -ENODATA;\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_create(xadir->d_inode, xafile,\n\t\t\t\t\t      0700|S_IFREG);\n\t}\n\n\tif (err)\n\t\tdput(xafile);\nout:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn xafile;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *xattr_lookup(struct inode *inode, const char *name,\n\t\t\t\t    int flags)\n{\n\tstruct dentry *xadir, *xafile;\n\tint err = 0;\n\n\txadir = open_xa_dir(inode, flags);\n\tif (IS_ERR(xadir))\n\t\treturn ERR_CAST(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\txafile = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(xafile)) {\n\t\terr = PTR_ERR(xafile);\n\t\tgoto out;\n\t}\n\n\tif (xafile->d_inode && (flags & XATTR_CREATE))\n\t\terr = -EEXIST;\n\n\tif (!xafile->d_inode) {\n\t\terr = -ENODATA;\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_create(xadir->d_inode, xafile,\n\t\t\t\t\t      0700|S_IFREG);\n\t}\n\n\tif (err)\n\t\tdput(xafile);\nout:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn xafile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "inode"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "reiserfs_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "597-625",
    "snippet": "int reiserfs_xattr_set(struct inode *inode, const char *name,\n\t\t       const void *buffer, size_t buffer_size, int flags)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint error, error2;\n\tsize_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);\n\n\tif (!(flags & XATTR_REPLACE))\n\t\tjbegin_count += reiserfs_xattr_jcreate_nblocks(inode);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = reiserfs_xattr_set_handle(&th, inode, name,\n\t\t\t\t\t  buffer, buffer_size, flags);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror2 = journal_end(&th);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0)\n\t\terror = error2;\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_set_handle",
          "args": [
            "&th",
            "inode",
            "name",
            "buffer",
            "buffer_size",
            "flags"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "497-594",
          "snippet": "int\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "jbegin_count"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_jcreate_nblocks",
          "args": [
            "inode"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_jcreate_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "75-86",
          "snippet": "static inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline size_t reiserfs_xattr_jcreate_nblocks(struct inode *inode)\n{\n\tsize_t nblocks = JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\n\tif ((REISERFS_I(inode)->i_flags & i_has_xattr_dir) == 0) {\n\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t\tif (!REISERFS_SB(inode->i_sb)->xattr_root->d_inode)\n\t\t\tnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\n\t}\n\n\treturn nblocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattr_nblocks",
          "args": [
            "inode",
            "buffer_size"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_nblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.h",
          "lines": "53-61",
          "snippet": "static inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/reiserfs_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_delete_xattrs(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/reiserfs_xattr.h>\n\nint reiserfs_delete_xattrs(struct inode *inode);\n\nstatic inline loff_t reiserfs_xattr_nblocks(struct inode *inode, loff_t size)\n{\n\tloff_t ret = 0;\n\tif (reiserfs_file_data_log(inode)) {\n\t\tret = _ROUND_UP(xattr_size(size), inode->i_sb->s_blocksize);\n\t\tret >>= inode->i_sb->s_blocksize_bits;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_xattr_set(struct inode *inode, const char *name,\n\t\t       const void *buffer, size_t buffer_size, int flags)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint error, error2;\n\tsize_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);\n\n\tif (!(flags & XATTR_REPLACE))\n\t\tjbegin_count += reiserfs_xattr_jcreate_nblocks(inode);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = reiserfs_xattr_set_handle(&th, inode, name,\n\t\t\t\t\t  buffer, buffer_size, flags);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror2 = journal_end(&th);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0)\n\t\terror = error2;\n\n\treturn error;\n}"
  },
  {
    "function_name": "reiserfs_xattr_set_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "497-594",
    "snippet": "int\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&REISERFS_I(inode)->i_xattr_sem"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_ctime",
          "args": [
            "inode"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "update_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "451-461",
          "snippet": "static void update_ctime(struct inode *inode)\n{\n\tstruct timespec now = current_fs_time(inode->i_sb);\n\n\tif (inode_unhashed(inode) || !inode->i_nlink ||\n\t    timespec_equal(&inode->i_ctime, &now))\n\t\treturn;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic void update_ctime(struct inode *inode)\n{\n\tstruct timespec now = current_fs_time(inode->i_sb);\n\n\tif (inode_unhashed(inode) || !inode->i_nlink ||\n\t    timespec_equal(&inode->i_ctime, &now))\n\t\treturn;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_setattr",
          "args": [
            "dentry",
            "&newattrs"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3309-3448",
          "snippet": "int reiserfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\t/* must be turned off for recursive notify_change calls */\n\tia_valid = attr->ia_valid &= ~(ATTR_KILL_SUID|ATTR_KILL_SGID);\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\treiserfs_write_lock(inode->i_sb);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/*\n\t\t * version 2 items will be caught by the s_maxbytes check\n\t\t * done for us in vmtruncate\n\t\t */\n\t\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&\n\t\t    attr->ia_size > MAX_NON_LFS) {\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\terror = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_dio_wait(inode);\n\n\t\t/* fill in hole pointers in the expanding truncate case. */\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = generic_cont_expand_simple(inode, attr->ia_size);\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\t\t\tint err;\n\t\t\t\tstruct reiserfs_transaction_handle th;\n\t\t\t\t/* we're changing at most 2 bitmaps, inode + super */\n\t\t\t\terr = journal_begin(&th, inode->i_sb, 4);\n\t\t\t\tif (!err) {\n\t\t\t\t\treiserfs_discard_prealloc(&th, inode);\n\t\t\t\t\terr = journal_end(&th);\n\t\t\t\t}\n\t\t\t\tif (err)\n\t\t\t\t\terror = err;\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * file size is changed, ctime and mtime are\n\t\t\t * to be updated\n\t\t\t */\n\t\t\tattr->ia_valid |= (ATTR_MTIME | ATTR_CTIME);\n\t\t}\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\tif ((((attr->ia_valid & ATTR_UID) && (from_kuid(&init_user_ns, attr->ia_uid) & ~0xffff)) ||\n\t     ((attr->ia_valid & ATTR_GID) && (from_kgid(&init_user_ns, attr->ia_gid) & ~0xffff))) &&\n\t    (get_inode_sd_version(inode) == STAT_DATA_V1)) {\n\t\t/* stat data of format v3.5 has 16 bit uid and gid */\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\tstruct reiserfs_transaction_handle th;\n\t\tint jbegin_count =\n\t\t    2 *\n\t\t    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +\n\t\t     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +\n\t\t    2;\n\n\t\terror = reiserfs_chown_xattrs(inode, attr);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * (user+group)*(old+new) structure - we count quota\n\t\t * info and , inode write (sb, inode)\n\t\t */\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = dquot_transfer(inode, attr);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (error) {\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Update corresponding info in inode so that everything\n\t\t * is in one transaction\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tmark_inode_dirty(inode);\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Could race against reiserfs_file_release\n\t\t\t * if called from NFS, so take tailpack mutex.\n\t\t\t */\n\t\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\treiserfs_truncate_file(inode, 1);\n\t\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\t}\n\t}\n\n\tif (!error) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (!error && reiserfs_posixacl(inode->i_sb)) {\n\t\tif (attr->ia_valid & ATTR_MODE)\n\t\t\terror = reiserfs_acl_chmod(inode);\n\t}\n\nout:\n\treturn error;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\t/* must be turned off for recursive notify_change calls */\n\tia_valid = attr->ia_valid &= ~(ATTR_KILL_SUID|ATTR_KILL_SGID);\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\treiserfs_write_lock(inode->i_sb);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/*\n\t\t * version 2 items will be caught by the s_maxbytes check\n\t\t * done for us in vmtruncate\n\t\t */\n\t\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&\n\t\t    attr->ia_size > MAX_NON_LFS) {\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\terror = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_dio_wait(inode);\n\n\t\t/* fill in hole pointers in the expanding truncate case. */\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = generic_cont_expand_simple(inode, attr->ia_size);\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\t\t\tint err;\n\t\t\t\tstruct reiserfs_transaction_handle th;\n\t\t\t\t/* we're changing at most 2 bitmaps, inode + super */\n\t\t\t\terr = journal_begin(&th, inode->i_sb, 4);\n\t\t\t\tif (!err) {\n\t\t\t\t\treiserfs_discard_prealloc(&th, inode);\n\t\t\t\t\terr = journal_end(&th);\n\t\t\t\t}\n\t\t\t\tif (err)\n\t\t\t\t\terror = err;\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * file size is changed, ctime and mtime are\n\t\t\t * to be updated\n\t\t\t */\n\t\t\tattr->ia_valid |= (ATTR_MTIME | ATTR_CTIME);\n\t\t}\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\tif ((((attr->ia_valid & ATTR_UID) && (from_kuid(&init_user_ns, attr->ia_uid) & ~0xffff)) ||\n\t     ((attr->ia_valid & ATTR_GID) && (from_kgid(&init_user_ns, attr->ia_gid) & ~0xffff))) &&\n\t    (get_inode_sd_version(inode) == STAT_DATA_V1)) {\n\t\t/* stat data of format v3.5 has 16 bit uid and gid */\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\tstruct reiserfs_transaction_handle th;\n\t\tint jbegin_count =\n\t\t    2 *\n\t\t    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +\n\t\t     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +\n\t\t    2;\n\n\t\terror = reiserfs_chown_xattrs(inode, attr);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * (user+group)*(old+new) structure - we count quota\n\t\t * info and , inode write (sb, inode)\n\t\t */\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = dquot_transfer(inode, attr);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (error) {\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Update corresponding info in inode so that everything\n\t\t * is in one transaction\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tmark_inode_dirty(inode);\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Could race against reiserfs_file_release\n\t\t\t * if called from NFS, so take tailpack mutex.\n\t\t\t */\n\t\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\treiserfs_truncate_file(inode, 1);\n\t\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\t}\n\t}\n\n\tif (!error) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (!error && reiserfs_posixacl(inode->i_sb)) {\n\t\tif (attr->ia_valid & ATTR_MODE)\n\t\t\terror = reiserfs_acl_chmod(inode);\n\t}\n\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "dentry->d_inode"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dentry->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dentry->d_inode"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_put_page",
          "args": [
            "page"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "415-419",
          "snippet": "static inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_commit_write",
          "args": [
            "NULL",
            "page",
            "page_offset",
            "page_offset + chunk +\n\t\t\t\t\t\t    skip"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2994-3068",
          "snippet": "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\tloff_t pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;\n\tint ret = 0;\n\tint update_sd = 0;\n\tstruct reiserfs_transaction_handle *th = NULL;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tth = current->journal_info;\n\t}\n\treiserfs_commit_page(inode, page, from, to);\n\n\t/*\n\t * generic_commit_write does this for us, but does not update the\n\t * transaction tracking stuff when the size changes.  So, we have\n\t * to do the i_size updates here.\n\t */\n\tif (pos > inode->i_size) {\n\t\tstruct reiserfs_transaction_handle myth;\n\t\t/*\n\t\t * If the file have grown beyond the border where it\n\t\t * can have a tail, unmark it as needing a tail\n\t\t * packing\n\t\t */\n\t\tif ((have_large_tails(inode->i_sb)\n\t\t     && inode->i_size > i_block_size(inode) * 4)\n\t\t    || (have_small_tails(inode->i_sb)\n\t\t\t&& inode->i_size > i_block_size(inode)))\n\t\t\tREISERFS_I(inode)->i_flags &= ~i_pack_on_close_mask;\n\n\t\tret = journal_begin(&myth, inode->i_sb, 1);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\n\t\treiserfs_update_inode_transaction(inode);\n\t\tinode->i_size = pos;\n\t\t/*\n\t\t * this will just nest into our transaction.  It's important\n\t\t * to use mark_inode_dirty so the inode gets pushed around\n\t\t * on the dirty lists, and so that O_SYNC works as expected\n\t\t */\n\t\tmark_inode_dirty(inode);\n\t\treiserfs_update_sd(&myth, inode);\n\t\tupdate_sd = 1;\n\t\tret = journal_end(&myth);\n\t\tif (ret)\n\t\t\tgoto journal_error;\n\t}\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\tmark_inode_dirty(inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n\njournal_error:\n\tif (th) {\n\t\tif (!update_sd)\n\t\t\treiserfs_update_sd(th, inode);\n\t\tret = reiserfs_end_persistent_transaction(th);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + skip",
            "buffer + buffer_pos",
            "chunk"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reiserfs_write_begin",
          "args": [
            "page",
            "page_offset",
            "chunk + skip"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "2831-2884",
          "snippet": "int __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint __reiserfs_write_begin(struct page *page, unsigned from, unsigned len)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret;\n\tint old_ref = 0;\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\treiserfs_wait_on_write_block(inode->i_sb);\n\treiserfs_write_lock_nested(inode->i_sb, depth);\n\n\tfix_tail_page_for_writing(page);\n\tif (reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th;\n\t\tth = (struct reiserfs_transaction_handle *)current->\n\t\t    journal_info;\n\t\tBUG_ON(!th->t_refcount);\n\t\tBUG_ON(!th->t_trans_id);\n\t\told_ref = th->t_refcount;\n\t\tth->t_refcount++;\n\t}\n\n\tret = __block_write_begin(page, from, len, reiserfs_get_block);\n\tif (ret && reiserfs_transaction_running(inode->i_sb)) {\n\t\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\t\t/*\n\t\t * this gets a little ugly.  If reiserfs_get_block returned an\n\t\t * error and left a transacstion running, we've got to close\n\t\t * it, and we've got to free handle if it was a persistent\n\t\t * transaction.\n\t\t *\n\t\t * But, if we had nested into an existing transaction, we need\n\t\t * to just drop the ref count on the handle.\n\t\t *\n\t\t * If old_ref == 0, the transaction is from reiserfs_get_block,\n\t\t * and it was a persistent trans.  Otherwise, it was nested\n\t\t * above.\n\t\t */\n\t\tif (th->t_refcount > old_ref) {\n\t\t\tif (old_ref)\n\t\t\t\tth->t_refcount--;\n\t\t\telse {\n\t\t\t\tint err;\n\t\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\t\terr = reiserfs_end_persistent_transaction(th);\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tif (err)\n\t\t\t\t\tret = err;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "xahash"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "REISERFS_XATTR_MAGIC"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_get_page",
          "args": [
            "dentry->d_inode",
            "file_pos"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "421-441",
          "snippet": "static struct page *reiserfs_get_page(struct inode *dir, size_t n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page;\n\t/*\n\t * We can deadlock if we try to free dentries,\n\t * and an unlink/rmdir has just occurred - GFP_NOFS avoids this\n\t */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tpage = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\treiserfs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct page *reiserfs_get_page(struct inode *dir, size_t n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page;\n\t/*\n\t * We can deadlock if we try to free dentries,\n\t * and an unlink/rmdir has just occurred - GFP_NOFS avoids this\n\t */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tpage = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\treiserfs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_hash",
          "args": [
            "buffer",
            "buffer_size"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "443-446",
          "snippet": "static inline __u32 xattr_hash(const char *msg, int len)\n{\n\treturn csum_partial(msg, len, 0);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline __u32 xattr_hash(const char *msg, int len)\n{\n\treturn csum_partial(msg, len, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&REISERFS_I(inode)->i_xattr_sem"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_lookup",
          "args": [
            "inode",
            "name",
            "flags"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "377-412",
          "snippet": "static struct dentry *xattr_lookup(struct inode *inode, const char *name,\n\t\t\t\t    int flags)\n{\n\tstruct dentry *xadir, *xafile;\n\tint err = 0;\n\n\txadir = open_xa_dir(inode, flags);\n\tif (IS_ERR(xadir))\n\t\treturn ERR_CAST(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\txafile = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(xafile)) {\n\t\terr = PTR_ERR(xafile);\n\t\tgoto out;\n\t}\n\n\tif (xafile->d_inode && (flags & XATTR_CREATE))\n\t\terr = -EEXIST;\n\n\tif (!xafile->d_inode) {\n\t\terr = -ENODATA;\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_create(xadir->d_inode, xafile,\n\t\t\t\t\t      0700|S_IFREG);\n\t}\n\n\tif (err)\n\t\tdput(xafile);\nout:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn xafile;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *xattr_lookup(struct inode *inode, const char *name,\n\t\t\t\t    int flags)\n{\n\tstruct dentry *xadir, *xafile;\n\tint err = 0;\n\n\txadir = open_xa_dir(inode, flags);\n\tif (IS_ERR(xadir))\n\t\treturn ERR_CAST(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\txafile = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(xafile)) {\n\t\terr = PTR_ERR(xafile);\n\t\tgoto out;\n\t}\n\n\tif (xafile->d_inode && (flags & XATTR_CREATE))\n\t\terr = -EEXIST;\n\n\tif (!xafile->d_inode) {\n\t\terr = -ENODATA;\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_create(xadir->d_inode, xafile,\n\t\t\t\t\t      0700|S_IFREG);\n\t}\n\n\tif (err)\n\t\tdput(xafile);\nout:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn xafile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_and_delete_xattr",
          "args": [
            "inode",
            "name"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_and_delete_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "463-489",
          "snippet": "static int lookup_and_delete_xattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct dentry *dentry, *xadir;\n\n\txadir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(xadir))\n\t\treturn PTR_ERR(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\tdentry = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (dentry->d_inode) {\n\t\terr = xattr_unlink(xadir->d_inode, dentry);\n\t\tupdate_ctime(inode);\n\t}\n\n\tdput(dentry);\nout_dput:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int lookup_and_delete_xattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct dentry *dentry, *xadir;\n\n\txadir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(xadir))\n\t\treturn PTR_ERR(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\tdentry = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (dentry->d_inode) {\n\t\terr = xattr_unlink(xadir->d_inode, dentry);\n\t\tupdate_ctime(inode);\n\t}\n\n\tdput(dentry);\nout_dput:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "inode"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_set_handle(struct reiserfs_transaction_handle *th,\n\t\t\t  struct inode *inode, const char *name,\n\t\t\t  const void *buffer, size_t buffer_size, int flags)\n{\n\tint err = 0;\n\tstruct dentry *dentry;\n\tstruct page *page;\n\tchar *data;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tsize_t new_size;\n\t__u32 xahash = 0;\n\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!buffer) {\n\t\terr = lookup_and_delete_xattr(inode, name);\n\t\treturn err;\n\t}\n\n\tdentry = xattr_lookup(inode, name, flags);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdown_write(&REISERFS_I(inode)->i_xattr_sem);\n\n\txahash = xattr_hash(buffer, buffer_size);\n\twhile (buffer_pos < buffer_size || buffer_pos == 0) {\n\t\tsize_t chunk;\n\t\tsize_t skip = 0;\n\t\tsize_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));\n\n\t\tif (buffer_size - buffer_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = buffer_size - buffer_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh;\n\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tif (chunk + skip > PAGE_CACHE_SIZE)\n\t\t\t\tchunk = PAGE_CACHE_SIZE - skip;\n\t\t\trxh = (struct reiserfs_xattr_header *)data;\n\t\t\trxh->h_magic = cpu_to_le32(REISERFS_XATTR_MAGIC);\n\t\t\trxh->h_hash = cpu_to_le32(xahash);\n\t\t}\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = __reiserfs_write_begin(page, page_offset, chunk + skip);\n\t\tif (!err) {\n\t\t\tif (buffer)\n\t\t\t\tmemcpy(data + skip, buffer + buffer_pos, chunk);\n\t\t\terr = reiserfs_commit_write(NULL, page, page_offset,\n\t\t\t\t\t\t    page_offset + chunk +\n\t\t\t\t\t\t    skip);\n\t\t}\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tbuffer_pos += chunk;\n\t\tfile_pos += chunk;\n\t\tskip = 0;\n\t\tif (err || buffer_size == 0 || !buffer)\n\t\t\tbreak;\n\t}\n\n\tnew_size = buffer_size + sizeof(struct reiserfs_xattr_header);\n\tif (!err && new_size < i_size_read(dentry->d_inode)) {\n\t\tstruct iattr newattrs = {\n\t\t\t.ia_ctime = current_fs_time(inode->i_sb),\n\t\t\t.ia_size = new_size,\n\t\t\t.ia_valid = ATTR_SIZE | ATTR_CTIME,\n\t\t};\n\n\t\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_XATTR);\n\t\tinode_dio_wait(dentry->d_inode);\n\n\t\terr = reiserfs_setattr(dentry, &newattrs);\n\t\tmutex_unlock(&dentry->d_inode->i_mutex);\n\t} else\n\t\tupdate_ctime(inode);\nout_unlock:\n\tup_write(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\treturn err;\n}"
  },
  {
    "function_name": "lookup_and_delete_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "463-489",
    "snippet": "static int lookup_and_delete_xattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct dentry *dentry, *xadir;\n\n\txadir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(xadir))\n\t\treturn PTR_ERR(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\tdentry = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (dentry->d_inode) {\n\t\terr = xattr_unlink(xadir->d_inode, dentry);\n\t\tupdate_ctime(inode);\n\t}\n\n\tdput(dentry);\nout_dput:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "xadir"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&xadir->d_inode->i_mutex"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ctime",
          "args": [
            "inode"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "update_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "451-461",
          "snippet": "static void update_ctime(struct inode *inode)\n{\n\tstruct timespec now = current_fs_time(inode->i_sb);\n\n\tif (inode_unhashed(inode) || !inode->i_nlink ||\n\t    timespec_equal(&inode->i_ctime, &now))\n\t\treturn;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic void update_ctime(struct inode *inode)\n{\n\tstruct timespec now = current_fs_time(inode->i_sb);\n\n\tif (inode_unhashed(inode) || !inode->i_nlink ||\n\t    timespec_equal(&inode->i_ctime, &now))\n\t\treturn;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_unlink",
          "args": [
            "xadir->d_inode",
            "dentry"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "84-97",
          "snippet": "static int xattr_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->unlink(dir, dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->unlink(dir, dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "xadir",
            "strlen(name)"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&xadir->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "xadir"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xadir"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_xa_dir",
          "args": [
            "inode",
            "XATTR_REPLACE"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "open_xa_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "146-176",
          "snippet": "static struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int lookup_and_delete_xattr(struct inode *inode, const char *name)\n{\n\tint err = 0;\n\tstruct dentry *dentry, *xadir;\n\n\txadir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(xadir))\n\t\treturn PTR_ERR(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\tdentry = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_dput;\n\t}\n\n\tif (dentry->d_inode) {\n\t\terr = xattr_unlink(xadir->d_inode, dentry);\n\t\tupdate_ctime(inode);\n\t}\n\n\tdput(dentry);\nout_dput:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\treturn err;\n}"
  },
  {
    "function_name": "update_ctime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "451-461",
    "snippet": "static void update_ctime(struct inode *inode)\n{\n\tstruct timespec now = current_fs_time(inode->i_sb);\n\n\tif (inode_unhashed(inode) || !inode->i_nlink ||\n\t    timespec_equal(&inode->i_ctime, &now))\n\t\treturn;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_ctime",
            "&now"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic void update_ctime(struct inode *inode)\n{\n\tstruct timespec now = current_fs_time(inode->i_sb);\n\n\tif (inode_unhashed(inode) || !inode->i_nlink ||\n\t    timespec_equal(&inode->i_ctime, &now))\n\t\treturn;\n\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n}"
  },
  {
    "function_name": "xattr_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "443-446",
    "snippet": "static inline __u32 xattr_hash(const char *msg, int len)\n{\n\treturn csum_partial(msg, len, 0);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "csum_partial",
          "args": [
            "msg",
            "len",
            "0"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline __u32 xattr_hash(const char *msg, int len)\n{\n\treturn csum_partial(msg, len, 0);\n}"
  },
  {
    "function_name": "reiserfs_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "421-441",
    "snippet": "static struct page *reiserfs_get_page(struct inode *dir, size_t n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page;\n\t/*\n\t * We can deadlock if we try to free dentries,\n\t * and an unlink/rmdir has just occurred - GFP_NOFS avoids this\n\t */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tpage = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\treiserfs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_put_page",
          "args": [
            "page"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "415-419",
          "snippet": "static inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "n >> PAGE_CACHE_SHIFT",
            "NULL"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "mapping",
            "GFP_NOFS"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct page *reiserfs_get_page(struct inode *dir, size_t n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page;\n\t/*\n\t * We can deadlock if we try to free dentries,\n\t * and an unlink/rmdir has just occurred - GFP_NOFS avoids this\n\t */\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tpage = read_mapping_page(mapping, n >> PAGE_CACHE_SHIFT, NULL);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\treiserfs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "reiserfs_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "415-419",
    "snippet": "static inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic inline void reiserfs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "xattr_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "377-412",
    "snippet": "static struct dentry *xattr_lookup(struct inode *inode, const char *name,\n\t\t\t\t    int flags)\n{\n\tstruct dentry *xadir, *xafile;\n\tint err = 0;\n\n\txadir = open_xa_dir(inode, flags);\n\tif (IS_ERR(xadir))\n\t\treturn ERR_CAST(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\txafile = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(xafile)) {\n\t\terr = PTR_ERR(xafile);\n\t\tgoto out;\n\t}\n\n\tif (xafile->d_inode && (flags & XATTR_CREATE))\n\t\terr = -EEXIST;\n\n\tif (!xafile->d_inode) {\n\t\terr = -ENODATA;\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_create(xadir->d_inode, xafile,\n\t\t\t\t\t      0700|S_IFREG);\n\t}\n\n\tif (err)\n\t\tdput(xafile);\nout:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn xafile;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "xadir"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&xadir->d_inode->i_mutex"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_create",
          "args": [
            "xadir->d_inode",
            "xafile",
            "0700|S_IFREG"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "65-69",
          "snippet": "static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->create(dir, dentry, mode, true);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_create(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->create(dir, dentry, mode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_may_create",
          "args": [
            "flags"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "xafile"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xafile"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "xadir",
            "strlen(name)"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&xadir->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "xadir"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xadir"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_xa_dir",
          "args": [
            "inode",
            "flags"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "open_xa_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "146-176",
          "snippet": "static struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *xattr_lookup(struct inode *inode, const char *name,\n\t\t\t\t    int flags)\n{\n\tstruct dentry *xadir, *xafile;\n\tint err = 0;\n\n\txadir = open_xa_dir(inode, flags);\n\tif (IS_ERR(xadir))\n\t\treturn ERR_CAST(xadir);\n\n\tmutex_lock_nested(&xadir->d_inode->i_mutex, I_MUTEX_XATTR);\n\txafile = lookup_one_len(name, xadir, strlen(name));\n\tif (IS_ERR(xafile)) {\n\t\terr = PTR_ERR(xafile);\n\t\tgoto out;\n\t}\n\n\tif (xafile->d_inode && (flags & XATTR_CREATE))\n\t\terr = -EEXIST;\n\n\tif (!xafile->d_inode) {\n\t\terr = -ENODATA;\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_create(xadir->d_inode, xafile,\n\t\t\t\t\t      0700|S_IFREG);\n\t}\n\n\tif (err)\n\t\tdput(xafile);\nout:\n\tmutex_unlock(&xadir->d_inode->i_mutex);\n\tdput(xadir);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn xafile;\n}"
  },
  {
    "function_name": "reiserfs_chown_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "361-369",
    "snippet": "int reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)\n{\n\tint err = reiserfs_for_each_xattr(inode, chown_one_xattr, attrs);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20007\",\n\t\t\t\t \"Couldn't chown all xattrs (%d)\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"jdm-20007\"",
            "\"Couldn't chown all xattrs (%d)\\n\"",
            "err"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_for_each_xattr",
          "args": [
            "inode",
            "chown_one_xattr",
            "attrs"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_for_each_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "234-318",
          "snippet": "static int reiserfs_for_each_xattr(struct inode *inode,\n\t\t\t\t   int (*action)(struct dentry *, void *),\n\t\t\t\t   void *data)\n{\n\tstruct dentry *dir;\n\tint i, err = 0;\n\tstruct reiserfs_dentry_buf buf = {\n\t\t.ctx.actor = fill_with_dentries,\n\t};\n\n\t/* Skip out, an xattr has no xattrs associated with it */\n\tif (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn 0;\n\n\tdir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t} else if (!dir->d_inode) {\n\t\terr = 0;\n\t\tgoto out_dir;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\tbuf.xadir = dir;\n\twhile (1) {\n\t\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!buf.count)\n\t\t\tbreak;\n\t\tfor (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {\n\t\t\tstruct dentry *dentry = buf.dentries[i];\n\n\t\t\tif (!d_is_dir(dentry))\n\t\t\t\terr = action(dentry, data);\n\n\t\t\tdput(dentry);\n\t\t\tbuf.dentries[i] = NULL;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t\tbuf.count = 0;\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tcleanup_dentry_buf(&buf);\n\n\tif (!err) {\n\t\t/*\n\t\t * We start a transaction here to avoid a ABBA situation\n\t\t * between the xattr root's i_mutex and the journal lock.\n\t\t * This doesn't incur much additional overhead since the\n\t\t * new transaction will just nest inside the\n\t\t * outer transaction.\n\t\t */\n\t\tint blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t\t\t     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\t\tstruct reiserfs_transaction_handle th;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = journal_begin(&th, inode->i_sb, blocks);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (!err) {\n\t\t\tint jerror;\n\n\t\t\tmutex_lock_nested(&dir->d_parent->d_inode->i_mutex,\n\t\t\t\t\t  I_MUTEX_XATTR);\n\t\t\terr = action(dir, data);\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tjerror = journal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tmutex_unlock(&dir->d_parent->d_inode->i_mutex);\n\t\t\terr = jerror ?: err;\n\t\t}\n\t}\nout_dir:\n\tdput(dir);\nout:\n\t/* -ENODATA isn't an error */\n\tif (err == -ENODATA)\n\t\terr = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int reiserfs_for_each_xattr(struct inode *inode,\n\t\t\t\t   int (*action)(struct dentry *, void *),\n\t\t\t\t   void *data)\n{\n\tstruct dentry *dir;\n\tint i, err = 0;\n\tstruct reiserfs_dentry_buf buf = {\n\t\t.ctx.actor = fill_with_dentries,\n\t};\n\n\t/* Skip out, an xattr has no xattrs associated with it */\n\tif (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn 0;\n\n\tdir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t} else if (!dir->d_inode) {\n\t\terr = 0;\n\t\tgoto out_dir;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\tbuf.xadir = dir;\n\twhile (1) {\n\t\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!buf.count)\n\t\t\tbreak;\n\t\tfor (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {\n\t\t\tstruct dentry *dentry = buf.dentries[i];\n\n\t\t\tif (!d_is_dir(dentry))\n\t\t\t\terr = action(dentry, data);\n\n\t\t\tdput(dentry);\n\t\t\tbuf.dentries[i] = NULL;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t\tbuf.count = 0;\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tcleanup_dentry_buf(&buf);\n\n\tif (!err) {\n\t\t/*\n\t\t * We start a transaction here to avoid a ABBA situation\n\t\t * between the xattr root's i_mutex and the journal lock.\n\t\t * This doesn't incur much additional overhead since the\n\t\t * new transaction will just nest inside the\n\t\t * outer transaction.\n\t\t */\n\t\tint blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t\t\t     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\t\tstruct reiserfs_transaction_handle th;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = journal_begin(&th, inode->i_sb, blocks);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (!err) {\n\t\t\tint jerror;\n\n\t\t\tmutex_lock_nested(&dir->d_parent->d_inode->i_mutex,\n\t\t\t\t\t  I_MUTEX_XATTR);\n\t\t\terr = action(dir, data);\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tjerror = journal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tmutex_unlock(&dir->d_parent->d_inode->i_mutex);\n\t\t\terr = jerror ?: err;\n\t\t}\n\t}\nout_dir:\n\tdput(dir);\nout:\n\t/* -ENODATA isn't an error */\n\tif (err == -ENODATA)\n\t\terr = 0;\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_chown_xattrs(struct inode *inode, struct iattr *attrs)\n{\n\tint err = reiserfs_for_each_xattr(inode, chown_one_xattr, attrs);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20007\",\n\t\t\t\t \"Couldn't chown all xattrs (%d)\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "reiserfs_delete_xattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "350-358",
    "snippet": "int reiserfs_delete_xattrs(struct inode *inode)\n{\n\tint err = reiserfs_for_each_xattr(inode, delete_one_xattr, NULL);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20004\",\n\t\t\t\t \"Couldn't delete all xattrs (%d)\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "inode->i_sb",
            "\"jdm-20004\"",
            "\"Couldn't delete all xattrs (%d)\\n\"",
            "err"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_for_each_xattr",
          "args": [
            "inode",
            "delete_one_xattr",
            "NULL"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_for_each_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "234-318",
          "snippet": "static int reiserfs_for_each_xattr(struct inode *inode,\n\t\t\t\t   int (*action)(struct dentry *, void *),\n\t\t\t\t   void *data)\n{\n\tstruct dentry *dir;\n\tint i, err = 0;\n\tstruct reiserfs_dentry_buf buf = {\n\t\t.ctx.actor = fill_with_dentries,\n\t};\n\n\t/* Skip out, an xattr has no xattrs associated with it */\n\tif (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn 0;\n\n\tdir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t} else if (!dir->d_inode) {\n\t\terr = 0;\n\t\tgoto out_dir;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\tbuf.xadir = dir;\n\twhile (1) {\n\t\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!buf.count)\n\t\t\tbreak;\n\t\tfor (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {\n\t\t\tstruct dentry *dentry = buf.dentries[i];\n\n\t\t\tif (!d_is_dir(dentry))\n\t\t\t\terr = action(dentry, data);\n\n\t\t\tdput(dentry);\n\t\t\tbuf.dentries[i] = NULL;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t\tbuf.count = 0;\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tcleanup_dentry_buf(&buf);\n\n\tif (!err) {\n\t\t/*\n\t\t * We start a transaction here to avoid a ABBA situation\n\t\t * between the xattr root's i_mutex and the journal lock.\n\t\t * This doesn't incur much additional overhead since the\n\t\t * new transaction will just nest inside the\n\t\t * outer transaction.\n\t\t */\n\t\tint blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t\t\t     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\t\tstruct reiserfs_transaction_handle th;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = journal_begin(&th, inode->i_sb, blocks);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (!err) {\n\t\t\tint jerror;\n\n\t\t\tmutex_lock_nested(&dir->d_parent->d_inode->i_mutex,\n\t\t\t\t\t  I_MUTEX_XATTR);\n\t\t\terr = action(dir, data);\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tjerror = journal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tmutex_unlock(&dir->d_parent->d_inode->i_mutex);\n\t\t\terr = jerror ?: err;\n\t\t}\n\t}\nout_dir:\n\tdput(dir);\nout:\n\t/* -ENODATA isn't an error */\n\tif (err == -ENODATA)\n\t\terr = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int reiserfs_for_each_xattr(struct inode *inode,\n\t\t\t\t   int (*action)(struct dentry *, void *),\n\t\t\t\t   void *data)\n{\n\tstruct dentry *dir;\n\tint i, err = 0;\n\tstruct reiserfs_dentry_buf buf = {\n\t\t.ctx.actor = fill_with_dentries,\n\t};\n\n\t/* Skip out, an xattr has no xattrs associated with it */\n\tif (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn 0;\n\n\tdir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t} else if (!dir->d_inode) {\n\t\terr = 0;\n\t\tgoto out_dir;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\tbuf.xadir = dir;\n\twhile (1) {\n\t\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!buf.count)\n\t\t\tbreak;\n\t\tfor (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {\n\t\t\tstruct dentry *dentry = buf.dentries[i];\n\n\t\t\tif (!d_is_dir(dentry))\n\t\t\t\terr = action(dentry, data);\n\n\t\t\tdput(dentry);\n\t\t\tbuf.dentries[i] = NULL;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t\tbuf.count = 0;\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tcleanup_dentry_buf(&buf);\n\n\tif (!err) {\n\t\t/*\n\t\t * We start a transaction here to avoid a ABBA situation\n\t\t * between the xattr root's i_mutex and the journal lock.\n\t\t * This doesn't incur much additional overhead since the\n\t\t * new transaction will just nest inside the\n\t\t * outer transaction.\n\t\t */\n\t\tint blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t\t\t     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\t\tstruct reiserfs_transaction_handle th;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = journal_begin(&th, inode->i_sb, blocks);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (!err) {\n\t\t\tint jerror;\n\n\t\t\tmutex_lock_nested(&dir->d_parent->d_inode->i_mutex,\n\t\t\t\t\t  I_MUTEX_XATTR);\n\t\t\terr = action(dir, data);\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tjerror = journal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tmutex_unlock(&dir->d_parent->d_inode->i_mutex);\n\t\t\terr = jerror ?: err;\n\t\t}\n\t}\nout_dir:\n\tdput(dir);\nout:\n\t/* -ENODATA isn't an error */\n\tif (err == -ENODATA)\n\t\terr = 0;\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_delete_xattrs(struct inode *inode)\n{\n\tint err = reiserfs_for_each_xattr(inode, delete_one_xattr, NULL);\n\n\tif (err)\n\t\treiserfs_warning(inode->i_sb, \"jdm-20004\",\n\t\t\t\t \"Couldn't delete all xattrs (%d)\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "chown_one_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "331-347",
    "snippet": "static int chown_one_xattr(struct dentry *dentry, void *data)\n{\n\tstruct iattr *attrs = data;\n\tint ia_valid = attrs->ia_valid;\n\tint err;\n\n\t/*\n\t * We only want the ownership bits. Otherwise, we'll do\n\t * things like change a directory to a regular file if\n\t * ATTR_MODE is set.\n\t */\n\tattrs->ia_valid &= (ATTR_UID|ATTR_GID);\n\terr = reiserfs_setattr(dentry, attrs);\n\tattrs->ia_valid = ia_valid;\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_setattr",
          "args": [
            "dentry",
            "attrs"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "3309-3448",
          "snippet": "int reiserfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\t/* must be turned off for recursive notify_change calls */\n\tia_valid = attr->ia_valid &= ~(ATTR_KILL_SUID|ATTR_KILL_SGID);\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\treiserfs_write_lock(inode->i_sb);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/*\n\t\t * version 2 items will be caught by the s_maxbytes check\n\t\t * done for us in vmtruncate\n\t\t */\n\t\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&\n\t\t    attr->ia_size > MAX_NON_LFS) {\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\terror = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_dio_wait(inode);\n\n\t\t/* fill in hole pointers in the expanding truncate case. */\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = generic_cont_expand_simple(inode, attr->ia_size);\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\t\t\tint err;\n\t\t\t\tstruct reiserfs_transaction_handle th;\n\t\t\t\t/* we're changing at most 2 bitmaps, inode + super */\n\t\t\t\terr = journal_begin(&th, inode->i_sb, 4);\n\t\t\t\tif (!err) {\n\t\t\t\t\treiserfs_discard_prealloc(&th, inode);\n\t\t\t\t\terr = journal_end(&th);\n\t\t\t\t}\n\t\t\t\tif (err)\n\t\t\t\t\terror = err;\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * file size is changed, ctime and mtime are\n\t\t\t * to be updated\n\t\t\t */\n\t\t\tattr->ia_valid |= (ATTR_MTIME | ATTR_CTIME);\n\t\t}\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\tif ((((attr->ia_valid & ATTR_UID) && (from_kuid(&init_user_ns, attr->ia_uid) & ~0xffff)) ||\n\t     ((attr->ia_valid & ATTR_GID) && (from_kgid(&init_user_ns, attr->ia_gid) & ~0xffff))) &&\n\t    (get_inode_sd_version(inode) == STAT_DATA_V1)) {\n\t\t/* stat data of format v3.5 has 16 bit uid and gid */\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\tstruct reiserfs_transaction_handle th;\n\t\tint jbegin_count =\n\t\t    2 *\n\t\t    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +\n\t\t     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +\n\t\t    2;\n\n\t\terror = reiserfs_chown_xattrs(inode, attr);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * (user+group)*(old+new) structure - we count quota\n\t\t * info and , inode write (sb, inode)\n\t\t */\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = dquot_transfer(inode, attr);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (error) {\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Update corresponding info in inode so that everything\n\t\t * is in one transaction\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tmark_inode_dirty(inode);\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Could race against reiserfs_file_release\n\t\t\t * if called from NFS, so take tailpack mutex.\n\t\t\t */\n\t\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\treiserfs_truncate_file(inode, 1);\n\t\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\t}\n\t}\n\n\tif (!error) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (!error && reiserfs_posixacl(inode->i_sb)) {\n\t\tif (attr->ia_valid & ATTR_MODE)\n\t\t\terror = reiserfs_acl_chmod(inode);\n\t}\n\nout:\n\treturn error;\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint reiserfs_commit_write(struct file *f, struct page *page,\n\t\t\t  unsigned from, unsigned to);\n\nint reiserfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\t/* must be turned off for recursive notify_change calls */\n\tia_valid = attr->ia_valid &= ~(ATTR_KILL_SUID|ATTR_KILL_SGID);\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\treiserfs_write_lock(inode->i_sb);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/*\n\t\t * version 2 items will be caught by the s_maxbytes check\n\t\t * done for us in vmtruncate\n\t\t */\n\t\tif (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&\n\t\t    attr->ia_size > MAX_NON_LFS) {\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\terror = -EFBIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinode_dio_wait(inode);\n\n\t\t/* fill in hole pointers in the expanding truncate case. */\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = generic_cont_expand_simple(inode, attr->ia_size);\n\t\t\tif (REISERFS_I(inode)->i_prealloc_count > 0) {\n\t\t\t\tint err;\n\t\t\t\tstruct reiserfs_transaction_handle th;\n\t\t\t\t/* we're changing at most 2 bitmaps, inode + super */\n\t\t\t\terr = journal_begin(&th, inode->i_sb, 4);\n\t\t\t\tif (!err) {\n\t\t\t\t\treiserfs_discard_prealloc(&th, inode);\n\t\t\t\t\terr = journal_end(&th);\n\t\t\t\t}\n\t\t\t\tif (err)\n\t\t\t\t\terror = err;\n\t\t\t}\n\t\t\tif (error) {\n\t\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * file size is changed, ctime and mtime are\n\t\t\t * to be updated\n\t\t\t */\n\t\t\tattr->ia_valid |= (ATTR_MTIME | ATTR_CTIME);\n\t\t}\n\t}\n\treiserfs_write_unlock(inode->i_sb);\n\n\tif ((((attr->ia_valid & ATTR_UID) && (from_kuid(&init_user_ns, attr->ia_uid) & ~0xffff)) ||\n\t     ((attr->ia_valid & ATTR_GID) && (from_kgid(&init_user_ns, attr->ia_gid) & ~0xffff))) &&\n\t    (get_inode_sd_version(inode) == STAT_DATA_V1)) {\n\t\t/* stat data of format v3.5 has 16 bit uid and gid */\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\tstruct reiserfs_transaction_handle th;\n\t\tint jbegin_count =\n\t\t    2 *\n\t\t    (REISERFS_QUOTA_INIT_BLOCKS(inode->i_sb) +\n\t\t     REISERFS_QUOTA_DEL_BLOCKS(inode->i_sb)) +\n\t\t    2;\n\n\t\terror = reiserfs_chown_xattrs(inode, attr);\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * (user+group)*(old+new) structure - we count quota\n\t\t * info and , inode write (sb, inode)\n\t\t */\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = dquot_transfer(inode, attr);\n\t\treiserfs_write_lock(inode->i_sb);\n\t\tif (error) {\n\t\t\tjournal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Update corresponding info in inode so that everything\n\t\t * is in one transaction\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\tmark_inode_dirty(inode);\n\t\terror = journal_end(&th);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (!error) {\n\t\t\t/*\n\t\t\t * Could race against reiserfs_file_release\n\t\t\t * if called from NFS, so take tailpack mutex.\n\t\t\t */\n\t\t\tmutex_lock(&REISERFS_I(inode)->tailpack);\n\t\t\ttruncate_setsize(inode, attr->ia_size);\n\t\t\treiserfs_truncate_file(inode, 1);\n\t\t\tmutex_unlock(&REISERFS_I(inode)->tailpack);\n\t\t}\n\t}\n\n\tif (!error) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\tif (!error && reiserfs_posixacl(inode->i_sb)) {\n\t\tif (attr->ia_valid & ATTR_MODE)\n\t\t\terror = reiserfs_acl_chmod(inode);\n\t}\n\nout:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int chown_one_xattr(struct dentry *dentry, void *data)\n{\n\tstruct iattr *attrs = data;\n\tint ia_valid = attrs->ia_valid;\n\tint err;\n\n\t/*\n\t * We only want the ownership bits. Otherwise, we'll do\n\t * things like change a directory to a regular file if\n\t * ATTR_MODE is set.\n\t */\n\tattrs->ia_valid &= (ATTR_UID|ATTR_GID);\n\terr = reiserfs_setattr(dentry, attrs);\n\tattrs->ia_valid = ia_valid;\n\n\treturn err;\n}"
  },
  {
    "function_name": "delete_one_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "320-329",
    "snippet": "static int delete_one_xattr(struct dentry *dentry, void *data)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\n\t/* This is the xattr dir, handle specially. */\n\tif (d_is_dir(dentry))\n\t\treturn xattr_rmdir(dir, dentry);\n\n\treturn xattr_unlink(dir, dentry);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xattr_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "84-97",
          "snippet": "static int xattr_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->unlink(dir, dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->unlink(dir, dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_rmdir",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "99-114",
          "snippet": "static int xattr_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (!error)\n\t\tdentry->d_inode->i_flags |= S_DEAD;\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error)\n\t\td_delete(dentry);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (!error)\n\t\tdentry->d_inode->i_flags |= S_DEAD;\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error)\n\t\td_delete(dentry);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int delete_one_xattr(struct dentry *dentry, void *data)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\n\t/* This is the xattr dir, handle specially. */\n\tif (d_is_dir(dentry))\n\t\treturn xattr_rmdir(dir, dentry);\n\n\treturn xattr_unlink(dir, dentry);\n}"
  },
  {
    "function_name": "reiserfs_for_each_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "234-318",
    "snippet": "static int reiserfs_for_each_xattr(struct inode *inode,\n\t\t\t\t   int (*action)(struct dentry *, void *),\n\t\t\t\t   void *data)\n{\n\tstruct dentry *dir;\n\tint i, err = 0;\n\tstruct reiserfs_dentry_buf buf = {\n\t\t.ctx.actor = fill_with_dentries,\n\t};\n\n\t/* Skip out, an xattr has no xattrs associated with it */\n\tif (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn 0;\n\n\tdir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t} else if (!dir->d_inode) {\n\t\terr = 0;\n\t\tgoto out_dir;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\tbuf.xadir = dir;\n\twhile (1) {\n\t\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!buf.count)\n\t\t\tbreak;\n\t\tfor (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {\n\t\t\tstruct dentry *dentry = buf.dentries[i];\n\n\t\t\tif (!d_is_dir(dentry))\n\t\t\t\terr = action(dentry, data);\n\n\t\t\tdput(dentry);\n\t\t\tbuf.dentries[i] = NULL;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t\tbuf.count = 0;\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tcleanup_dentry_buf(&buf);\n\n\tif (!err) {\n\t\t/*\n\t\t * We start a transaction here to avoid a ABBA situation\n\t\t * between the xattr root's i_mutex and the journal lock.\n\t\t * This doesn't incur much additional overhead since the\n\t\t * new transaction will just nest inside the\n\t\t * outer transaction.\n\t\t */\n\t\tint blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t\t\t     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\t\tstruct reiserfs_transaction_handle th;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = journal_begin(&th, inode->i_sb, blocks);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (!err) {\n\t\t\tint jerror;\n\n\t\t\tmutex_lock_nested(&dir->d_parent->d_inode->i_mutex,\n\t\t\t\t\t  I_MUTEX_XATTR);\n\t\t\terr = action(dir, data);\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tjerror = journal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tmutex_unlock(&dir->d_parent->d_inode->i_mutex);\n\t\t\terr = jerror ?: err;\n\t\t}\n\t}\nout_dir:\n\tdput(dir);\nout:\n\t/* -ENODATA isn't an error */\n\tif (err == -ENODATA)\n\t\terr = 0;\n\treturn err;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_parent->d_inode->i_mutex"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "&th"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "action",
          "args": [
            "dir",
            "data"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_persistent_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3142-3172",
          "snippet": "struct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *s,\n\t\t\t\t\t\t\t\t    int nblocks)\n{\n\tint ret;\n\tstruct reiserfs_transaction_handle *th;\n\n\t/*\n\t * if we're nesting into an existing transaction.  It will be\n\t * persistent on its own\n\t */\n\tif (reiserfs_transaction_running(s)) {\n\t\tth = current->journal_info;\n\t\tth->t_refcount++;\n\t\tBUG_ON(th->t_refcount < 2);\n\n\t\treturn th;\n\t}\n\tth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\n\tif (!th)\n\t\treturn NULL;\n\tret = journal_begin(th, s, nblocks);\n\tif (ret) {\n\t\tkfree(th);\n\t\treturn NULL;\n\t}\n\n\tSB_JOURNAL(s)->j_persistent_trans++;\n\treturn th;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nstruct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *s,\n\t\t\t\t\t\t\t\t    int nblocks)\n{\n\tint ret;\n\tstruct reiserfs_transaction_handle *th;\n\n\t/*\n\t * if we're nesting into an existing transaction.  It will be\n\t * persistent on its own\n\t */\n\tif (reiserfs_transaction_running(s)) {\n\t\tth = current->journal_info;\n\t\tth->t_refcount++;\n\t\tBUG_ON(th->t_refcount < 2);\n\n\t\treturn th;\n\t}\n\tth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\n\tif (!th)\n\t\treturn NULL;\n\tret = journal_begin(th, s, nblocks);\n\tif (ret) {\n\t\tkfree(th);\n\t\treturn NULL;\n\t}\n\n\tSB_JOURNAL(s)->j_persistent_trans++;\n\treturn th;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_parent->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "inode->i_sb",
            "blocks"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_QUOTA_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_dentry_buf",
          "args": [
            "&buf"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_dentry_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "224-232",
          "snippet": "static void\ncleanup_dentry_buf(struct reiserfs_dentry_buf *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < buf->count; i++)\n\t\tif (buf->dentries[i])\n\t\t\tdput(buf->dentries[i]);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic void\ncleanup_dentry_buf(struct reiserfs_dentry_buf *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < buf->count; i++)\n\t\tif (buf->dentries[i])\n\t\t\tdput(buf->dentries[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_readdir_inode",
          "args": [
            "dir->d_inode",
            "&buf.ctx"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_readdir_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/dir.c",
          "lines": "60-270",
          "snippet": "int reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern const struct reiserfs_key MIN_KEY;",
            "static int reiserfs_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n\nextern const struct reiserfs_key MIN_KEY;\nstatic int reiserfs_readdir(struct file *, struct dir_context *);\n\nint reiserfs_readdir_inode(struct inode *inode, struct dir_context *ctx)\n{\n\n\t/* key of current position in the directory (key of directory entry) */\n\tstruct cpu_key pos_key;\n\n\tINITIALIZE_PATH(path_to_entry);\n\tstruct buffer_head *bh;\n\tint item_num, entry_num;\n\tconst struct reiserfs_key *rkey;\n\tstruct item_head *ih, tmp_ih;\n\tint search_res;\n\tchar *local_buf;\n\tloff_t next_pos;\n\tchar small_buf[32];\t/* avoid kmalloc if we can */\n\tstruct reiserfs_dir_entry de;\n\tint ret = 0;\n\tint depth;\n\n\treiserfs_write_lock(inode->i_sb);\n\n\treiserfs_check_lock_depth(inode->i_sb, \"readdir\");\n\n\t/*\n\t * form key for search the next directory entry using\n\t * f_pos field of file structure\n\t */\n\tmake_cpu_key(&pos_key, inode, ctx->pos ?: DOT_OFFSET, TYPE_DIRENTRY, 3);\n\tnext_pos = cpu_key_k_offset(&pos_key);\n\n\tpath_to_entry.reada = PATH_READA;\n\twhile (1) {\nresearch:\n\t\t/*\n\t\t * search the directory item, containing entry with\n\t\t * specified key\n\t\t */\n\t\tsearch_res =\n\t\t    search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry,\n\t\t\t\t\t&de);\n\t\tif (search_res == IO_ERROR) {\n\t\t\t/*\n\t\t\t * FIXME: we could just skip part of directory\n\t\t\t * which could not be read\n\t\t\t */\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tentry_num = de.de_entry_num;\n\t\tbh = de.de_bh;\n\t\titem_num = de.de_item_num;\n\t\tih = de.de_ih;\n\t\tstore_ih(&tmp_ih, ih);\n\n\t\t/* we must have found item, that is item of this directory, */\n\t\tRFALSE(COMP_SHORT_KEYS(&ih->ih_key, &pos_key),\n\t\t       \"vs-9000: found item %h does not match to dir we readdir %K\",\n\t\t       ih, &pos_key);\n\t\tRFALSE(item_num > B_NR_ITEMS(bh) - 1,\n\t\t       \"vs-9005 item_num == %d, item amount == %d\",\n\t\t       item_num, B_NR_ITEMS(bh));\n\n\t\t/*\n\t\t * and entry must be not more than number of entries\n\t\t * in the item\n\t\t */\n\t\tRFALSE(ih_entry_count(ih) < entry_num,\n\t\t       \"vs-9010: entry number is too big %d (%d)\",\n\t\t       entry_num, ih_entry_count(ih));\n\n\t\t/*\n\t\t * go through all entries in the directory item beginning\n\t\t * from the entry, that has been found\n\t\t */\n\t\tif (search_res == POSITION_FOUND\n\t\t    || entry_num < ih_entry_count(ih)) {\n\t\t\tstruct reiserfs_de_head *deh =\n\t\t\t    B_I_DEH(bh, ih) + entry_num;\n\n\t\t\tfor (; entry_num < ih_entry_count(ih);\n\t\t\t     entry_num++, deh++) {\n\t\t\t\tint d_reclen;\n\t\t\t\tchar *d_name;\n\t\t\t\tino_t d_ino;\n\t\t\t\tloff_t cur_pos = deh_offset(deh);\n\n\t\t\t\t/* it is hidden entry */\n\t\t\t\tif (!de_visible(deh))\n\t\t\t\t\tcontinue;\n\t\t\t\td_reclen = entry_length(bh, ih, entry_num);\n\t\t\t\td_name = B_I_DEH_ENTRY_FILE_NAME(bh, ih, deh);\n\n\t\t\t\tif (d_reclen <= 0 ||\n\t\t\t\t    d_name + d_reclen > bh->b_data + bh->b_size) {\n\t\t\t\t\t/*\n\t\t\t\t\t * There is corrupted data in entry,\n\t\t\t\t\t * We'd better stop here\n\t\t\t\t\t */\n\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (!d_name[d_reclen - 1])\n\t\t\t\t\td_reclen = strlen(d_name);\n\n\t\t\t\t/* too big to send back to VFS */\n\t\t\t\tif (d_reclen >\n\t\t\t\t    REISERFS_MAX_NAME(inode->i_sb->\n\t\t\t\t\t\t      s_blocksize)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Ignore the .reiserfs_priv entry */\n\t\t\t\tif (is_privroot_deh(inode, deh))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tctx->pos = deh_offset(deh);\n\t\t\t\td_ino = deh_objectid(deh);\n\t\t\t\tif (d_reclen <= 32) {\n\t\t\t\t\tlocal_buf = small_buf;\n\t\t\t\t} else {\n\t\t\t\t\tlocal_buf = kmalloc(d_reclen,\n\t\t\t\t\t\t\t    GFP_NOFS);\n\t\t\t\t\tif (!local_buf) {\n\t\t\t\t\t\tpathrelse(&path_to_entry);\n\t\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t\tgoto research;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Note, that we copy name to user space via\n\t\t\t\t * temporary buffer (local_buf) because\n\t\t\t\t * filldir will block if user space buffer is\n\t\t\t\t * swapped out. At that time entry can move to\n\t\t\t\t * somewhere else\n\t\t\t\t */\n\t\t\t\tmemcpy(local_buf, d_name, d_reclen);\n\n\t\t\t\t/*\n\t\t\t\t * Since filldir might sleep, we can release\n\t\t\t\t * the write lock here for other waiters\n\t\t\t\t */\n\t\t\t\tdepth = reiserfs_write_unlock_nested(inode->i_sb);\n\t\t\t\tif (!dir_emit\n\t\t\t\t    (ctx, local_buf, d_reclen, d_ino,\n\t\t\t\t     DT_UNKNOWN)) {\n\t\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\t\tkfree(local_buf);\n\t\t\t\t\t}\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\treiserfs_write_lock_nested(inode->i_sb, depth);\n\t\t\t\tif (local_buf != small_buf) {\n\t\t\t\t\tkfree(local_buf);\n\t\t\t\t}\n\n\t\t\t\t/* deh_offset(deh) may be invalid now. */\n\t\t\t\tnext_pos = cur_pos + 1;\n\n\t\t\t\tif (item_moved(&tmp_ih, &path_to_entry)) {\n\t\t\t\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t\t\t\t     next_pos);\n\t\t\t\t\tgoto research;\n\t\t\t\t}\n\t\t\t}\t/* for */\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (item_num != B_NR_ITEMS(bh) - 1)\n\t\t\tgoto end;\n\n\t\t/*\n\t\t * item we went through is last item of node. Using right\n\t\t * delimiting key check is it directory end\n\t\t */\n\t\trkey = get_rkey(&path_to_entry, inode->i_sb);\n\t\tif (!comp_le_keys(rkey, &MIN_KEY)) {\n\t\t\t/*\n\t\t\t * set pos_key to key, that is the smallest and greater\n\t\t\t * that key of the last entry in the item\n\t\t\t */\n\t\t\tset_cpu_key_k_offset(&pos_key, next_pos);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* end of directory has been reached */\n\t\tif (COMP_SHORT_KEYS(rkey, &pos_key)) {\n\t\t\tgoto end;\n\t\t}\n\n\t\t/* directory continues in the right neighboring block */\n\t\tset_cpu_key_k_offset(&pos_key,\n\t\t\t\t     le_key_k_offset(KEY_FORMAT_3_5, rkey));\n\n\t}\t\t\t/* while */\n\nend:\n\tctx->pos = next_pos;\n\tpathrelse(&path_to_entry);\n\treiserfs_check_path(&path_to_entry);\nout:\n\treiserfs_write_unlock(inode->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_xa_dir",
          "args": [
            "inode",
            "XATTR_REPLACE"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "open_xa_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "146-176",
          "snippet": "static struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_inode_sd_version",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_PRIVATE",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int reiserfs_for_each_xattr(struct inode *inode,\n\t\t\t\t   int (*action)(struct dentry *, void *),\n\t\t\t\t   void *data)\n{\n\tstruct dentry *dir;\n\tint i, err = 0;\n\tstruct reiserfs_dentry_buf buf = {\n\t\t.ctx.actor = fill_with_dentries,\n\t};\n\n\t/* Skip out, an xattr has no xattrs associated with it */\n\tif (IS_PRIVATE(inode) || get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn 0;\n\n\tdir = open_xa_dir(inode, XATTR_REPLACE);\n\tif (IS_ERR(dir)) {\n\t\terr = PTR_ERR(dir);\n\t\tgoto out;\n\t} else if (!dir->d_inode) {\n\t\terr = 0;\n\t\tgoto out_dir;\n\t}\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\tbuf.xadir = dir;\n\twhile (1) {\n\t\terr = reiserfs_readdir_inode(dir->d_inode, &buf.ctx);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (!buf.count)\n\t\t\tbreak;\n\t\tfor (i = 0; !err && i < buf.count && buf.dentries[i]; i++) {\n\t\t\tstruct dentry *dentry = buf.dentries[i];\n\n\t\t\tif (!d_is_dir(dentry))\n\t\t\t\terr = action(dentry, data);\n\n\t\t\tdput(dentry);\n\t\t\tbuf.dentries[i] = NULL;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t\tbuf.count = 0;\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tcleanup_dentry_buf(&buf);\n\n\tif (!err) {\n\t\t/*\n\t\t * We start a transaction here to avoid a ABBA situation\n\t\t * between the xattr root's i_mutex and the journal lock.\n\t\t * This doesn't incur much additional overhead since the\n\t\t * new transaction will just nest inside the\n\t\t * outer transaction.\n\t\t */\n\t\tint blocks = JOURNAL_PER_BALANCE_CNT * 2 + 2 +\n\t\t\t     4 * REISERFS_QUOTA_TRANS_BLOCKS(inode->i_sb);\n\t\tstruct reiserfs_transaction_handle th;\n\n\t\treiserfs_write_lock(inode->i_sb);\n\t\terr = journal_begin(&th, inode->i_sb, blocks);\n\t\treiserfs_write_unlock(inode->i_sb);\n\t\tif (!err) {\n\t\t\tint jerror;\n\n\t\t\tmutex_lock_nested(&dir->d_parent->d_inode->i_mutex,\n\t\t\t\t\t  I_MUTEX_XATTR);\n\t\t\terr = action(dir, data);\n\t\t\treiserfs_write_lock(inode->i_sb);\n\t\t\tjerror = journal_end(&th);\n\t\t\treiserfs_write_unlock(inode->i_sb);\n\t\t\tmutex_unlock(&dir->d_parent->d_inode->i_mutex);\n\t\t\terr = jerror ?: err;\n\t\t}\n\t}\nout_dir:\n\tdput(dir);\nout:\n\t/* -ENODATA isn't an error */\n\tif (err == -ENODATA)\n\t\terr = 0;\n\treturn err;\n}"
  },
  {
    "function_name": "cleanup_dentry_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "224-232",
    "snippet": "static void\ncleanup_dentry_buf(struct reiserfs_dentry_buf *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < buf->count; i++)\n\t\tif (buf->dentries[i])\n\t\t\tdput(buf->dentries[i]);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "buf->dentries[i]"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic void\ncleanup_dentry_buf(struct reiserfs_dentry_buf *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < buf->count; i++)\n\t\tif (buf->dentries[i])\n\t\t\tdput(buf->dentries[i]);\n}"
  },
  {
    "function_name": "fill_with_dentries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "190-222",
    "snippet": "static int\nfill_with_dentries(struct dir_context *ctx, const char *name, int namelen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct reiserfs_dentry_buf *dbuf =\n\t\tcontainer_of(ctx, struct reiserfs_dentry_buf, ctx);\n\tstruct dentry *dentry;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));\n\n\tif (dbuf->count == ARRAY_SIZE(dbuf->dentries))\n\t\treturn -ENOSPC;\n\n\tif (name[0] == '.' && (namelen < 2 ||\n\t\t\t       (namelen == 2 && name[1] == '.')))\n\t\treturn 0;\n\n\tdentry = lookup_one_len(name, dbuf->xadir, namelen);\n\tif (IS_ERR(dentry)) {\n\t\treturn PTR_ERR(dentry);\n\t} else if (!dentry->d_inode) {\n\t\t/* A directory entry exists, but no file? */\n\t\treiserfs_error(dentry->d_sb, \"xattr-20003\",\n\t\t\t       \"Corrupted directory: xattr %pd listed but \"\n\t\t\t       \"not found for file %pd.\\n\",\n\t\t\t       dentry, dbuf->xadir);\n\t\tdput(dentry);\n\t\treturn -EIO;\n\t}\n\n\tdbuf->dentries[dbuf->count++] = dentry;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "dentry->d_sb",
            "\"xattr-20003\"",
            "\"Corrupted directory: xattr %pd listed but \"\n\t\t\t       \"not found for file %pd.\\n\"",
            "dentry",
            "dbuf->xadir"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "dbuf->xadir",
            "namelen"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "dbuf->dentries"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dbuf->xadir->d_inode->i_mutex"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structreiserfs_dentry_buf",
            "ctx"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int\nfill_with_dentries(struct dir_context *ctx, const char *name, int namelen,\n\t\t   loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct reiserfs_dentry_buf *dbuf =\n\t\tcontainer_of(ctx, struct reiserfs_dentry_buf, ctx);\n\tstruct dentry *dentry;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&dbuf->xadir->d_inode->i_mutex));\n\n\tif (dbuf->count == ARRAY_SIZE(dbuf->dentries))\n\t\treturn -ENOSPC;\n\n\tif (name[0] == '.' && (namelen < 2 ||\n\t\t\t       (namelen == 2 && name[1] == '.')))\n\t\treturn 0;\n\n\tdentry = lookup_one_len(name, dbuf->xadir, namelen);\n\tif (IS_ERR(dentry)) {\n\t\treturn PTR_ERR(dentry);\n\t} else if (!dentry->d_inode) {\n\t\t/* A directory entry exists, but no file? */\n\t\treiserfs_error(dentry->d_sb, \"xattr-20003\",\n\t\t\t       \"Corrupted directory: xattr %pd listed but \"\n\t\t\t       \"not found for file %pd.\\n\",\n\t\t\t       dentry, dbuf->xadir);\n\t\tdput(dentry);\n\t\treturn -EIO;\n\t}\n\n\tdbuf->dentries[dbuf->count++] = dentry;\n\treturn 0;\n}"
  },
  {
    "function_name": "open_xa_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "146-176",
    "snippet": "static struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "xaroot"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&xaroot->d_inode->i_mutex"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_mkdir",
          "args": [
            "xaroot->d_inode",
            "xadir",
            "0700"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "72-76",
          "snippet": "static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_may_create",
          "args": [
            "flags"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xadir"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "namebuf",
            "xaroot",
            "strlen(namebuf)"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "namebuf"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&xaroot->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "namebuf",
            "sizeof(namebuf)",
            "\"%X.%X\"",
            "le32_to_cpu(INODE_PKEY(inode)->k_objectid)",
            "inode->i_generation"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "INODE_PKEY(inode)->k_objectid"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_PKEY",
          "args": [
            "inode"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "xaroot"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_xa_root",
          "args": [
            "inode->i_sb",
            "flags"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "open_xa_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "118-144",
          "snippet": "static struct dentry *open_xa_root(struct super_block *sb, int flags)\n{\n\tstruct dentry *privroot = REISERFS_SB(sb)->priv_root;\n\tstruct dentry *xaroot;\n\n\tif (!privroot->d_inode)\n\t\treturn ERR_PTR(-ENODATA);\n\n\tmutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txaroot = dget(REISERFS_SB(sb)->xattr_root);\n\tif (!xaroot)\n\t\txaroot = ERR_PTR(-ENODATA);\n\telse if (!xaroot->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(privroot->d_inode, xaroot, 0700);\n\t\tif (err) {\n\t\t\tdput(xaroot);\n\t\t\txaroot = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&privroot->d_inode->i_mutex);\n\treturn xaroot;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *open_xa_root(struct super_block *sb, int flags)\n{\n\tstruct dentry *privroot = REISERFS_SB(sb)->priv_root;\n\tstruct dentry *xaroot;\n\n\tif (!privroot->d_inode)\n\t\treturn ERR_PTR(-ENODATA);\n\n\tmutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txaroot = dget(REISERFS_SB(sb)->xattr_root);\n\tif (!xaroot)\n\t\txaroot = ERR_PTR(-ENODATA);\n\telse if (!xaroot->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(privroot->d_inode, xaroot, 0700);\n\t\tif (err) {\n\t\t\tdput(xaroot);\n\t\t\txaroot = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&privroot->d_inode->i_mutex);\n\treturn xaroot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *open_xa_dir(const struct inode *inode, int flags)\n{\n\tstruct dentry *xaroot, *xadir;\n\tchar namebuf[17];\n\n\txaroot = open_xa_root(inode->i_sb, flags);\n\tif (IS_ERR(xaroot))\n\t\treturn xaroot;\n\n\tsnprintf(namebuf, sizeof(namebuf), \"%X.%X\",\n\t\t le32_to_cpu(INODE_PKEY(inode)->k_objectid),\n\t\t inode->i_generation);\n\n\tmutex_lock_nested(&xaroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txadir = lookup_one_len(namebuf, xaroot, strlen(namebuf));\n\tif (!IS_ERR(xadir) && !xadir->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(xaroot->d_inode, xadir, 0700);\n\t\tif (err) {\n\t\t\tdput(xadir);\n\t\t\txadir = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&xaroot->d_inode->i_mutex);\n\tdput(xaroot);\n\treturn xadir;\n}"
  },
  {
    "function_name": "open_xa_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "118-144",
    "snippet": "static struct dentry *open_xa_root(struct super_block *sb, int flags)\n{\n\tstruct dentry *privroot = REISERFS_SB(sb)->priv_root;\n\tstruct dentry *xaroot;\n\n\tif (!privroot->d_inode)\n\t\treturn ERR_PTR(-ENODATA);\n\n\tmutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txaroot = dget(REISERFS_SB(sb)->xattr_root);\n\tif (!xaroot)\n\t\txaroot = ERR_PTR(-ENODATA);\n\telse if (!xaroot->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(privroot->d_inode, xaroot, 0700);\n\t\tif (err) {\n\t\t\tdput(xaroot);\n\t\t\txaroot = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&privroot->d_inode->i_mutex);\n\treturn xaroot;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&privroot->d_inode->i_mutex"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "xaroot"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_mkdir",
          "args": [
            "privroot->d_inode",
            "xaroot",
            "0700"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "72-76",
          "snippet": "static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_may_create",
          "args": [
            "flags"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODATA"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "REISERFS_SB(sb)->xattr_root"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&privroot->d_inode->i_mutex",
            "I_MUTEX_XATTR"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODATA"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic struct dentry *open_xa_root(struct super_block *sb, int flags)\n{\n\tstruct dentry *privroot = REISERFS_SB(sb)->priv_root;\n\tstruct dentry *xaroot;\n\n\tif (!privroot->d_inode)\n\t\treturn ERR_PTR(-ENODATA);\n\n\tmutex_lock_nested(&privroot->d_inode->i_mutex, I_MUTEX_XATTR);\n\n\txaroot = dget(REISERFS_SB(sb)->xattr_root);\n\tif (!xaroot)\n\t\txaroot = ERR_PTR(-ENODATA);\n\telse if (!xaroot->d_inode) {\n\t\tint err = -ENODATA;\n\n\t\tif (xattr_may_create(flags))\n\t\t\terr = xattr_mkdir(privroot->d_inode, xaroot, 0700);\n\t\tif (err) {\n\t\t\tdput(xaroot);\n\t\t\txaroot = ERR_PTR(err);\n\t\t}\n\t}\n\n\tmutex_unlock(&privroot->d_inode->i_mutex);\n\treturn xaroot;\n}"
  },
  {
    "function_name": "xattr_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "99-114",
    "snippet": "static int xattr_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (!error)\n\t\tdentry->d_inode->i_flags |= S_DEAD;\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error)\n\t\td_delete(dentry);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2350-2379",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir->i_op->rmdir",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dentry->d_inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&dir->i_mutex)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (!error)\n\t\tdentry->d_inode->i_flags |= S_DEAD;\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error)\n\t\td_delete(dentry);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xattr_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "84-97",
    "snippet": "static int xattr_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->unlink(dir, dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dentry"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2350-2379",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir->i_op->unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dentry->d_inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&dir->i_mutex)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error;\n\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\terror = dir->i_op->unlink(dir, dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "xattr_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "72-76",
    "snippet": "static int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir->i_op->mkdir",
          "args": [
            "dir",
            "dentry",
            "mode"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&dir->i_mutex)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->mkdir(dir, dentry, mode);\n}"
  },
  {
    "function_name": "xattr_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
    "lines": "65-69",
    "snippet": "static int xattr_create(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->create(dir, dentry, mode, true);\n}",
    "includes": [
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/security.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/stat.h>",
      "#include <net/checksum.h>",
      "#include <linux/uaccess.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/errno.h>",
      "#include <linux/namei.h>",
      "#include <linux/dcache.h>",
      "#include <linux/capability.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir->i_op->create",
          "args": [
            "dir",
            "dentry",
            "mode",
            "true"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&dir->i_mutex)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nstatic int xattr_create(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tBUG_ON(!mutex_is_locked(&dir->i_mutex));\n\treturn dir->i_op->create(dir, dentry, mode, true);\n}"
  }
]