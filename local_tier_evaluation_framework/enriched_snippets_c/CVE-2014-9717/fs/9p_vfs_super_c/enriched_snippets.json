[
  {
    "function_name": "v9fs_write_inode_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "319-340",
    "snippet": "static int v9fs_write_inode_dotl(struct inode *inode,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tint ret;\n\tstruct v9fs_inode *v9inode;\n\t/*\n\t * send an fsync request to server irrespective of\n\t * wbc->sync_mode.\n\t */\n\tv9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_VFS, \"%s: inode %p, writeback_fid %p\\n\",\n\t\t __func__, inode, v9inode->writeback_fid);\n\tif (!v9inode->writeback_fid)\n\t\treturn 0;\n\n\tret = p9_client_fsync(v9inode->writeback_fid, 0);\n\tif (ret < 0) {\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "I_DIRTY_DATASYNC"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_fsync",
          "args": [
            "v9inode->writeback_fid",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"%s: inode %p, writeback_fid %p\\n\"",
            "__func__",
            "inode",
            "v9inode->writeback_fid"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int v9fs_write_inode_dotl(struct inode *inode,\n\t\t\t\t struct writeback_control *wbc)\n{\n\tint ret;\n\tstruct v9fs_inode *v9inode;\n\t/*\n\t * send an fsync request to server irrespective of\n\t * wbc->sync_mode.\n\t */\n\tv9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_VFS, \"%s: inode %p, writeback_fid %p\\n\",\n\t\t __func__, inode, v9inode->writeback_fid);\n\tif (!v9inode->writeback_fid)\n\t\treturn 0;\n\n\tret = p9_client_fsync(v9inode->writeback_fid, 0);\n\tif (ret < 0) {\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "295-317",
    "snippet": "static int v9fs_write_inode(struct inode *inode,\n\t\t\t    struct writeback_control *wbc)\n{\n\tint ret;\n\tstruct p9_wstat wstat;\n\tstruct v9fs_inode *v9inode;\n\t/*\n\t * send an fsync request to server irrespective of\n\t * wbc->sync_mode.\n\t */\n\tp9_debug(P9_DEBUG_VFS, \"%s: inode %p\\n\", __func__, inode);\n\tv9inode = V9FS_I(inode);\n\tif (!v9inode->writeback_fid)\n\t\treturn 0;\n\tv9fs_blank_wstat(&wstat);\n\n\tret = p9_client_wstat(v9inode->writeback_fid, &wstat);\n\tif (ret < 0) {\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "I_DIRTY_DATASYNC"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_wstat",
          "args": [
            "v9inode->writeback_fid",
            "&wstat"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_blank_wstat",
          "args": [
            "&wstat"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_blank_wstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "212-232",
          "snippet": "void\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_blank_wstat(struct p9_wstat *wstat)\n{\n\twstat->type = ~0;\n\twstat->dev = ~0;\n\twstat->qid.type = ~0;\n\twstat->qid.version = ~0;\n\t*((long long *)&wstat->qid.path) = ~0;\n\twstat->mode = ~0;\n\twstat->atime = ~0;\n\twstat->mtime = ~0;\n\twstat->length = ~0;\n\twstat->name = NULL;\n\twstat->uid = NULL;\n\twstat->gid = NULL;\n\twstat->muid = NULL;\n\twstat->n_uid = INVALID_UID;\n\twstat->n_gid = INVALID_GID;\n\twstat->n_muid = INVALID_UID;\n\twstat->extension = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"%s: inode %p\\n\"",
            "__func__",
            "inode"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int v9fs_write_inode(struct inode *inode,\n\t\t\t    struct writeback_control *wbc)\n{\n\tint ret;\n\tstruct p9_wstat wstat;\n\tstruct v9fs_inode *v9inode;\n\t/*\n\t * send an fsync request to server irrespective of\n\t * wbc->sync_mode.\n\t */\n\tp9_debug(P9_DEBUG_VFS, \"%s: inode %p\\n\", __func__, inode);\n\tv9inode = V9FS_I(inode);\n\tif (!v9inode->writeback_fid)\n\t\treturn 0;\n\tv9fs_blank_wstat(&wstat);\n\n\tret = p9_client_wstat(v9inode->writeback_fid, &wstat);\n\tif (ret < 0) {\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "281-293",
    "snippet": "static int v9fs_drop_inode(struct inode *inode)\n{\n\tstruct v9fs_session_info *v9ses;\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\treturn generic_drop_inode(inode);\n\t/*\n\t * in case of non cached mode always drop the\n\t * the inode because we want the inode attribute\n\t * to always match that on the server.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "inode"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int v9fs_drop_inode(struct inode *inode)\n{\n\tstruct v9fs_session_info *v9ses;\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\treturn generic_drop_inode(inode);\n\t/*\n\t * in case of non cached mode always drop the\n\t * the inode because we want the inode attribute\n\t * to always match that on the server.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "v9fs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "245-279",
    "snippet": "static int v9fs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_rstatfs rs;\n\tint res;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid)) {\n\t\tres = PTR_ERR(fid);\n\t\tgoto done;\n\t}\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tres = p9_client_statfs(fid, &rs);\n\t\tif (res == 0) {\n\t\t\tbuf->f_type = rs.type;\n\t\t\tbuf->f_bsize = rs.bsize;\n\t\t\tbuf->f_blocks = rs.blocks;\n\t\t\tbuf->f_bfree = rs.bfree;\n\t\t\tbuf->f_bavail = rs.bavail;\n\t\t\tbuf->f_files = rs.files;\n\t\t\tbuf->f_ffree = rs.ffree;\n\t\t\tbuf->f_fsid.val[0] = rs.fsid & 0xFFFFFFFFUL;\n\t\t\tbuf->f_fsid.val[1] = (rs.fsid >> 32) & 0xFFFFFFFFUL;\n\t\t\tbuf->f_namelen = rs.namelen;\n\t\t}\n\t\tif (res != -ENOSYS)\n\t\t\tgoto done;\n\t}\n\tres = simple_statfs(dentry, buf);\ndone:\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_statfs",
          "args": [
            "dentry",
            "buf"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "simple_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "38-44",
          "snippet": "int simple_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = PAGE_CACHE_SIZE;\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tbuf->f_type = dentry->d_sb->s_magic;\n\tbuf->f_bsize = PAGE_CACHE_SIZE;\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_statfs",
          "args": [
            "fid",
            "&rs"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int v9fs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_rstatfs rs;\n\tint res;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid)) {\n\t\tres = PTR_ERR(fid);\n\t\tgoto done;\n\t}\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tres = p9_client_statfs(fid, &rs);\n\t\tif (res == 0) {\n\t\t\tbuf->f_type = rs.type;\n\t\t\tbuf->f_bsize = rs.bsize;\n\t\t\tbuf->f_blocks = rs.blocks;\n\t\t\tbuf->f_bfree = rs.bfree;\n\t\t\tbuf->f_bavail = rs.bavail;\n\t\t\tbuf->f_files = rs.files;\n\t\t\tbuf->f_ffree = rs.ffree;\n\t\t\tbuf->f_fsid.val[0] = rs.fsid & 0xFFFFFFFFUL;\n\t\t\tbuf->f_fsid.val[1] = (rs.fsid >> 32) & 0xFFFFFFFFUL;\n\t\t\tbuf->f_namelen = rs.namelen;\n\t\t}\n\t\tif (res != -ENOSYS)\n\t\t\tgoto done;\n\t}\n\tres = simple_statfs(dentry, buf);\ndone:\n\treturn res;\n}"
  },
  {
    "function_name": "v9fs_umount_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "236-243",
    "snippet": "static void\nv9fs_umount_begin(struct super_block *sb)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = sb->s_fs_info;\n\tv9fs_session_begin_cancel(v9ses);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_session_begin_cancel",
          "args": [
            "v9ses"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_session_begin_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "479-483",
          "snippet": "void v9fs_session_begin_cancel(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_ERROR, \"begin cancel session %p\\n\", v9ses);\n\tp9_client_begin_disconnect(v9ses->clnt);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_session_begin_cancel(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_ERROR, \"begin cancel session %p\\n\", v9ses);\n\tp9_client_begin_disconnect(v9ses->clnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void\nv9fs_umount_begin(struct super_block *sb)\n{\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = sb->s_fs_info;\n\tv9fs_session_begin_cancel(v9ses);\n}"
  },
  {
    "function_name": "v9fs_kill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "221-234",
    "snippet": "static void v9fs_kill_super(struct super_block *s)\n{\n\tstruct v9fs_session_info *v9ses = s->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \" %p\\n\", s);\n\n\tkill_anon_super(s);\n\n\tv9fs_session_cancel(v9ses);\n\tv9fs_session_close(v9ses);\n\tkfree(v9ses);\n\ts->s_fs_info = NULL;\n\tp9_debug(P9_DEBUG_VFS, \"exiting kill_super\\n\");\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"exiting kill_super\\n\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_session_close",
          "args": [
            "v9ses"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "437-458",
          "snippet": "void v9fs_session_close(struct v9fs_session_info *v9ses)\n{\n\tif (v9ses->clnt) {\n\t\tp9_client_destroy(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->fscache) {\n\t\tv9fs_cache_session_put_cookie(v9ses);\n\t\tkfree(v9ses->cachetag);\n\t}\n#endif\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\n\tbdi_destroy(&v9ses->bdi);\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_del(&v9ses->slist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(v9fs_sessionlist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(v9fs_sessionlist_lock);\n\nvoid v9fs_session_close(struct v9fs_session_info *v9ses)\n{\n\tif (v9ses->clnt) {\n\t\tp9_client_destroy(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->fscache) {\n\t\tv9fs_cache_session_put_cookie(v9ses);\n\t\tkfree(v9ses->cachetag);\n\t}\n#endif\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\n\tbdi_destroy(&v9ses->bdi);\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_del(&v9ses->slist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_session_cancel",
          "args": [
            "v9ses"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_session_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "467-470",
          "snippet": "void v9fs_session_cancel(struct v9fs_session_info *v9ses) {\n\tp9_debug(P9_DEBUG_ERROR, \"cancel session %p\\n\", v9ses);\n\tp9_client_disconnect(v9ses->clnt);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_session_cancel(struct v9fs_session_info *v9ses) {\n\tp9_debug(P9_DEBUG_ERROR, \"cancel session %p\\n\", v9ses);\n\tp9_client_disconnect(v9ses->clnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "s"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" %p\\n\"",
            "s"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void v9fs_kill_super(struct super_block *s)\n{\n\tstruct v9fs_session_info *v9ses = s->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \" %p\\n\", s);\n\n\tkill_anon_super(s);\n\n\tv9fs_session_cancel(v9ses);\n\tv9fs_session_close(v9ses);\n\tkfree(v9ses);\n\ts->s_fs_info = NULL;\n\tp9_debug(P9_DEBUG_VFS, \"exiting kill_super\\n\");\n}"
  },
  {
    "function_name": "v9fs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "113-213",
    "snippet": "static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct dentry *root = NULL;\n\tstruct v9fs_session_info *v9ses = NULL;\n\tumode_t mode = S_IRWXUGO | S_ISVTX;\n\tstruct p9_fid *fid;\n\tint retval = 0;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tv9ses = kzalloc(sizeof(struct v9fs_session_info), GFP_KERNEL);\n\tif (!v9ses)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfid = v9fs_session_init(v9ses, dev_name, data);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\t/*\n\t\t * we need to call session_close to tear down some\n\t\t * of the data structure setup by session_init\n\t\t */\n\t\tgoto close_session;\n\t}\n\n\tsb = sget(fs_type, NULL, v9fs_set_super, flags, v9ses);\n\tif (IS_ERR(sb)) {\n\t\tretval = PTR_ERR(sb);\n\t\tgoto clunk_fid;\n\t}\n\tv9fs_fill_super(sb, v9ses, flags, data);\n\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tsb->s_d_op = &v9fs_cached_dentry_operations;\n\telse\n\t\tsb->s_d_op = &v9fs_dentry_operations;\n\n\tinode = v9fs_get_inode(sb, S_IFDIR | mode, 0);\n\tif (IS_ERR(inode)) {\n\t\tretval = PTR_ERR(inode);\n\t\tgoto release_sb;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tretval = -ENOMEM;\n\t\tgoto release_sb;\n\t}\n\tsb->s_root = root;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tstruct p9_stat_dotl *st = NULL;\n\t\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\t\troot->d_inode->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode_dotl(st, root->d_inode);\n\t\tkfree(st);\n\t} else {\n\t\tstruct p9_wstat *st = NULL;\n\t\tst = p9_client_stat(fid);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\n\t\troot->d_inode->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode(st, root->d_inode, sb);\n\n\t\tp9stat_free(st);\n\t\tkfree(st);\n\t}\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto release_sb;\n\tv9fs_fid_add(root, fid);\n\n\tp9_debug(P9_DEBUG_VFS, \" simple set mount, return 0\\n\");\n\treturn dget(sb->s_root);\n\nclunk_fid:\n\tp9_client_clunk(fid);\nclose_session:\n\tv9fs_session_close(v9ses);\n\tkfree(v9ses);\n\treturn ERR_PTR(retval);\n\nrelease_sb:\n\t/*\n\t * we will do the session_close and root dentry release\n\t * in the below call. But we need to clunk fid, because we haven't\n\t * attached the fid to dentry so it won't get clunked\n\t * automatically.\n\t */\n\tp9_client_clunk(fid);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(retval);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_session_close",
          "args": [
            "v9ses"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "437-458",
          "snippet": "void v9fs_session_close(struct v9fs_session_info *v9ses)\n{\n\tif (v9ses->clnt) {\n\t\tp9_client_destroy(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->fscache) {\n\t\tv9fs_cache_session_put_cookie(v9ses);\n\t\tkfree(v9ses->cachetag);\n\t}\n#endif\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\n\tbdi_destroy(&v9ses->bdi);\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_del(&v9ses->slist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(v9fs_sessionlist_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(v9fs_sessionlist_lock);\n\nvoid v9fs_session_close(struct v9fs_session_info *v9ses)\n{\n\tif (v9ses->clnt) {\n\t\tp9_client_destroy(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->fscache) {\n\t\tv9fs_cache_session_put_cookie(v9ses);\n\t\tkfree(v9ses->cachetag);\n\t}\n#endif\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\n\tbdi_destroy(&v9ses->bdi);\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_del(&v9ses->slist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" simple set mount, return 0\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "root",
            "fid"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_get_acl",
          "args": [
            "inode",
            "fid"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "56-86",
          "snippet": "int v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9stat_free",
          "args": [
            "st"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode",
          "args": [
            "st",
            "root->d_inode",
            "sb"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1156-1204",
          "snippet": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_qid2ino",
          "args": [
            "&st->qid"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_qid2ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1213-1224",
          "snippet": "ino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "st"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_stat",
          "args": [
            "fid"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode_dotl",
          "args": [
            "st",
            "root->d_inode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "613-676",
          "snippet": "void\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "st"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_getattr_dotl",
          "args": [
            "fid",
            "P9_STATS_BASIC"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_inode",
          "args": [
            "sb",
            "S_IFDIR | mode",
            "0"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "370-390",
          "snippet": "struct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fill_super",
          "args": [
            "sb",
            "v9ses",
            "flags",
            "data"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
          "lines": "75-102",
          "snippet": "static void\nv9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,\n\t\tint flags, void *data)\n{\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize_bits = fls(v9ses->maxdata - 1);\n\tsb->s_blocksize = 1 << sb->s_blocksize_bits;\n\tsb->s_magic = V9FS_MAGIC;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tsb->s_op = &v9fs_super_ops_dotl;\n\t\tsb->s_xattr = v9fs_xattr_handlers;\n\t} else\n\t\tsb->s_op = &v9fs_super_ops;\n\tsb->s_bdi = &v9ses->bdi;\n\tif (v9ses->cache)\n\t\tsb->s_bdi->ra_pages = (VM_MAX_READAHEAD * 1024)/PAGE_CACHE_SIZE;\n\n\tsb->s_flags |= MS_ACTIVE | MS_DIRSYNC | MS_NOATIME;\n\tif (!v9ses->cache)\n\t\tsb->s_flags |= MS_SYNCHRONOUS;\n\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\tif ((v9ses->flags & V9FS_ACL_MASK) == V9FS_POSIX_ACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n#endif\n\n\tsave_mount_options(sb, data);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations v9fs_super_ops, v9fs_super_ops_dotl;",
            "static const struct super_operations v9fs_super_ops = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = simple_statfs,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode,\n};",
            "static const struct super_operations v9fs_super_ops_dotl = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = v9fs_statfs,\n\t.drop_inode = v9fs_drop_inode,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode_dotl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic const struct super_operations v9fs_super_ops, v9fs_super_ops_dotl;\nstatic const struct super_operations v9fs_super_ops = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = simple_statfs,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode,\n};\nstatic const struct super_operations v9fs_super_ops_dotl = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = v9fs_statfs,\n\t.drop_inode = v9fs_drop_inode,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode_dotl,\n};\n\nstatic void\nv9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,\n\t\tint flags, void *data)\n{\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize_bits = fls(v9ses->maxdata - 1);\n\tsb->s_blocksize = 1 << sb->s_blocksize_bits;\n\tsb->s_magic = V9FS_MAGIC;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tsb->s_op = &v9fs_super_ops_dotl;\n\t\tsb->s_xattr = v9fs_xattr_handlers;\n\t} else\n\t\tsb->s_op = &v9fs_super_ops;\n\tsb->s_bdi = &v9ses->bdi;\n\tif (v9ses->cache)\n\t\tsb->s_bdi->ra_pages = (VM_MAX_READAHEAD * 1024)/PAGE_CACHE_SIZE;\n\n\tsb->s_flags |= MS_ACTIVE | MS_DIRSYNC | MS_NOATIME;\n\tif (!v9ses->cache)\n\t\tsb->s_flags |= MS_SYNCHRONOUS;\n\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\tif ((v9ses->flags & V9FS_ACL_MASK) == V9FS_POSIX_ACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n#endif\n\n\tsave_mount_options(sb, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sb"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "NULL",
            "v9fs_set_super",
            "flags",
            "v9ses"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_session_init",
          "args": [
            "v9ses",
            "dev_name",
            "data"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_session_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "320-429",
          "snippet": "struct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,\n\t\t  const char *dev_name, char *data)\n{\n\tint retval = -EINVAL;\n\tstruct p9_fid *fid;\n\tint rc;\n\n\tv9ses->uname = kstrdup(V9FS_DEFUSER, GFP_KERNEL);\n\tif (!v9ses->uname)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tv9ses->aname = kstrdup(V9FS_DEFANAME, GFP_KERNEL);\n\tif (!v9ses->aname) {\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinit_rwsem(&v9ses->rename_sem);\n\n\trc = bdi_setup_and_register(&v9ses->bdi, \"9p\");\n\tif (rc) {\n\t\tkfree(v9ses->aname);\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_add(&v9ses->slist, &v9fs_sessionlist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n\n\tv9ses->uid = INVALID_UID;\n\tv9ses->dfltuid = V9FS_DEFUID;\n\tv9ses->dfltgid = V9FS_DEFGID;\n\n\tv9ses->clnt = p9_client_create(dev_name, data);\n\tif (IS_ERR(v9ses->clnt)) {\n\t\tretval = PTR_ERR(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"problem initializing 9p client\\n\");\n\t\tgoto error;\n\t}\n\n\tv9ses->flags = V9FS_ACCESS_USER;\n\n\tif (p9_is_proto_dotl(v9ses->clnt)) {\n\t\tv9ses->flags = V9FS_ACCESS_CLIENT;\n\t\tv9ses->flags |= V9FS_PROTO_2000L;\n\t} else if (p9_is_proto_dotu(v9ses->clnt)) {\n\t\tv9ses->flags |= V9FS_PROTO_2000U;\n\t}\n\n\trc = v9fs_parse_options(v9ses, data);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto error;\n\t}\n\n\tv9ses->maxdata = v9ses->clnt->msize - P9_IOHDRSZ;\n\n\tif (!v9fs_proto_dotl(v9ses) &&\n\t    ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACCESS_CLIENT only for dotl.\n\t\t * Fall back to ACCESS_USER\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t}\n\t/*FIXME !! */\n\t/* for legacy mode, fall back to V9FS_ACCESS_ANY */\n\tif (!(v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses)) &&\n\t\t((v9ses->flags&V9FS_ACCESS_MASK) == V9FS_ACCESS_USER)) {\n\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\tv9ses->uid = INVALID_UID;\n\t}\n\tif (!v9fs_proto_dotl(v9ses) ||\n\t\t!((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACL checks on clinet only if the protocol is\n\t\t * 9P2000.L and access is V9FS_ACCESS_CLIENT.\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACL_MASK;\n\t}\n\n\tfid = p9_client_attach(v9ses->clnt, NULL, v9ses->uname, INVALID_UID,\n\t\t\t\t\t\t\tv9ses->aname);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\tfid = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"cannot attach\\n\");\n\t\tgoto error;\n\t}\n\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_SINGLE)\n\t\tfid->uid = v9ses->uid;\n\telse\n\t\tfid->uid = INVALID_UID;\n\n#ifdef CONFIG_9P_FSCACHE\n\t/* register the session for caching */\n\tv9fs_cache_session_get_cookie(v9ses);\n#endif\n\n\treturn fid;\n\nerror:\n\tbdi_destroy(&v9ses->bdi);\n\treturn ERR_PTR(retval);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(v9fs_sessionlist_lock);",
            "static LIST_HEAD(v9fs_sessionlist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(v9fs_sessionlist_lock);\nstatic LIST_HEAD(v9fs_sessionlist);\n\nstruct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,\n\t\t  const char *dev_name, char *data)\n{\n\tint retval = -EINVAL;\n\tstruct p9_fid *fid;\n\tint rc;\n\n\tv9ses->uname = kstrdup(V9FS_DEFUSER, GFP_KERNEL);\n\tif (!v9ses->uname)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tv9ses->aname = kstrdup(V9FS_DEFANAME, GFP_KERNEL);\n\tif (!v9ses->aname) {\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinit_rwsem(&v9ses->rename_sem);\n\n\trc = bdi_setup_and_register(&v9ses->bdi, \"9p\");\n\tif (rc) {\n\t\tkfree(v9ses->aname);\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_add(&v9ses->slist, &v9fs_sessionlist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n\n\tv9ses->uid = INVALID_UID;\n\tv9ses->dfltuid = V9FS_DEFUID;\n\tv9ses->dfltgid = V9FS_DEFGID;\n\n\tv9ses->clnt = p9_client_create(dev_name, data);\n\tif (IS_ERR(v9ses->clnt)) {\n\t\tretval = PTR_ERR(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"problem initializing 9p client\\n\");\n\t\tgoto error;\n\t}\n\n\tv9ses->flags = V9FS_ACCESS_USER;\n\n\tif (p9_is_proto_dotl(v9ses->clnt)) {\n\t\tv9ses->flags = V9FS_ACCESS_CLIENT;\n\t\tv9ses->flags |= V9FS_PROTO_2000L;\n\t} else if (p9_is_proto_dotu(v9ses->clnt)) {\n\t\tv9ses->flags |= V9FS_PROTO_2000U;\n\t}\n\n\trc = v9fs_parse_options(v9ses, data);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto error;\n\t}\n\n\tv9ses->maxdata = v9ses->clnt->msize - P9_IOHDRSZ;\n\n\tif (!v9fs_proto_dotl(v9ses) &&\n\t    ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACCESS_CLIENT only for dotl.\n\t\t * Fall back to ACCESS_USER\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t}\n\t/*FIXME !! */\n\t/* for legacy mode, fall back to V9FS_ACCESS_ANY */\n\tif (!(v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses)) &&\n\t\t((v9ses->flags&V9FS_ACCESS_MASK) == V9FS_ACCESS_USER)) {\n\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\tv9ses->uid = INVALID_UID;\n\t}\n\tif (!v9fs_proto_dotl(v9ses) ||\n\t\t!((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACL checks on clinet only if the protocol is\n\t\t * 9P2000.L and access is V9FS_ACCESS_CLIENT.\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACL_MASK;\n\t}\n\n\tfid = p9_client_attach(v9ses->clnt, NULL, v9ses->uname, INVALID_UID,\n\t\t\t\t\t\t\tv9ses->aname);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\tfid = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"cannot attach\\n\");\n\t\tgoto error;\n\t}\n\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_SINGLE)\n\t\tfid->uid = v9ses->uid;\n\telse\n\t\tfid->uid = INVALID_UID;\n\n#ifdef CONFIG_9P_FSCACHE\n\t/* register the session for caching */\n\tv9fs_cache_session_get_cookie(v9ses);\n#endif\n\n\treturn fid;\n\nerror:\n\tbdi_destroy(&v9ses->bdi);\n\treturn ERR_PTR(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct v9fs_session_info)",
            "GFP_KERNEL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct dentry *root = NULL;\n\tstruct v9fs_session_info *v9ses = NULL;\n\tumode_t mode = S_IRWXUGO | S_ISVTX;\n\tstruct p9_fid *fid;\n\tint retval = 0;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tv9ses = kzalloc(sizeof(struct v9fs_session_info), GFP_KERNEL);\n\tif (!v9ses)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfid = v9fs_session_init(v9ses, dev_name, data);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\t/*\n\t\t * we need to call session_close to tear down some\n\t\t * of the data structure setup by session_init\n\t\t */\n\t\tgoto close_session;\n\t}\n\n\tsb = sget(fs_type, NULL, v9fs_set_super, flags, v9ses);\n\tif (IS_ERR(sb)) {\n\t\tretval = PTR_ERR(sb);\n\t\tgoto clunk_fid;\n\t}\n\tv9fs_fill_super(sb, v9ses, flags, data);\n\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tsb->s_d_op = &v9fs_cached_dentry_operations;\n\telse\n\t\tsb->s_d_op = &v9fs_dentry_operations;\n\n\tinode = v9fs_get_inode(sb, S_IFDIR | mode, 0);\n\tif (IS_ERR(inode)) {\n\t\tretval = PTR_ERR(inode);\n\t\tgoto release_sb;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tretval = -ENOMEM;\n\t\tgoto release_sb;\n\t}\n\tsb->s_root = root;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tstruct p9_stat_dotl *st = NULL;\n\t\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\t\troot->d_inode->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode_dotl(st, root->d_inode);\n\t\tkfree(st);\n\t} else {\n\t\tstruct p9_wstat *st = NULL;\n\t\tst = p9_client_stat(fid);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\n\t\troot->d_inode->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode(st, root->d_inode, sb);\n\n\t\tp9stat_free(st);\n\t\tkfree(st);\n\t}\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto release_sb;\n\tv9fs_fid_add(root, fid);\n\n\tp9_debug(P9_DEBUG_VFS, \" simple set mount, return 0\\n\");\n\treturn dget(sb->s_root);\n\nclunk_fid:\n\tp9_client_clunk(fid);\nclose_session:\n\tv9fs_session_close(v9ses);\n\tkfree(v9ses);\n\treturn ERR_PTR(retval);\n\nrelease_sb:\n\t/*\n\t * we will do the session_close and root dentry release\n\t * in the below call. But we need to clunk fid, because we haven't\n\t * attached the fid to dentry so it won't get clunked\n\t * automatically.\n\t */\n\tp9_client_clunk(fid);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(retval);\n}"
  },
  {
    "function_name": "v9fs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "75-102",
    "snippet": "static void\nv9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,\n\t\tint flags, void *data)\n{\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize_bits = fls(v9ses->maxdata - 1);\n\tsb->s_blocksize = 1 << sb->s_blocksize_bits;\n\tsb->s_magic = V9FS_MAGIC;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tsb->s_op = &v9fs_super_ops_dotl;\n\t\tsb->s_xattr = v9fs_xattr_handlers;\n\t} else\n\t\tsb->s_op = &v9fs_super_ops;\n\tsb->s_bdi = &v9ses->bdi;\n\tif (v9ses->cache)\n\t\tsb->s_bdi->ra_pages = (VM_MAX_READAHEAD * 1024)/PAGE_CACHE_SIZE;\n\n\tsb->s_flags |= MS_ACTIVE | MS_DIRSYNC | MS_NOATIME;\n\tif (!v9ses->cache)\n\t\tsb->s_flags |= MS_SYNCHRONOUS;\n\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\tif ((v9ses->flags & V9FS_ACL_MASK) == V9FS_POSIX_ACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n#endif\n\n\tsave_mount_options(sb, data);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations v9fs_super_ops, v9fs_super_ops_dotl;",
      "static const struct super_operations v9fs_super_ops = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = simple_statfs,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode,\n};",
      "static const struct super_operations v9fs_super_ops_dotl = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = v9fs_statfs,\n\t.drop_inode = v9fs_drop_inode,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode_dotl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "v9ses->maxdata - 1"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic const struct super_operations v9fs_super_ops, v9fs_super_ops_dotl;\nstatic const struct super_operations v9fs_super_ops = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = simple_statfs,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode,\n};\nstatic const struct super_operations v9fs_super_ops_dotl = {\n\t.alloc_inode = v9fs_alloc_inode,\n\t.destroy_inode = v9fs_destroy_inode,\n\t.statfs = v9fs_statfs,\n\t.drop_inode = v9fs_drop_inode,\n\t.evict_inode = v9fs_evict_inode,\n\t.show_options = generic_show_options,\n\t.umount_begin = v9fs_umount_begin,\n\t.write_inode = v9fs_write_inode_dotl,\n};\n\nstatic void\nv9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,\n\t\tint flags, void *data)\n{\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize_bits = fls(v9ses->maxdata - 1);\n\tsb->s_blocksize = 1 << sb->s_blocksize_bits;\n\tsb->s_magic = V9FS_MAGIC;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tsb->s_op = &v9fs_super_ops_dotl;\n\t\tsb->s_xattr = v9fs_xattr_handlers;\n\t} else\n\t\tsb->s_op = &v9fs_super_ops;\n\tsb->s_bdi = &v9ses->bdi;\n\tif (v9ses->cache)\n\t\tsb->s_bdi->ra_pages = (VM_MAX_READAHEAD * 1024)/PAGE_CACHE_SIZE;\n\n\tsb->s_flags |= MS_ACTIVE | MS_DIRSYNC | MS_NOATIME;\n\tif (!v9ses->cache)\n\t\tsb->s_flags |= MS_SYNCHRONOUS;\n\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\tif ((v9ses->flags & V9FS_ACL_MASK) == V9FS_POSIX_ACL)\n\t\tsb->s_flags |= MS_POSIXACL;\n#endif\n\n\tsave_mount_options(sb, data);\n}"
  },
  {
    "function_name": "v9fs_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_super.c",
    "lines": "61-65",
    "snippet": "static int v9fs_set_super(struct super_block *s, void *data)\n{\n\ts->s_fs_info = data;\n\treturn set_anon_super(s, data);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/magic.h>",
      "#include <linux/statfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "s",
            "data"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int v9fs_set_super(struct super_block *s, void *data)\n{\n\ts->s_fs_info = data;\n\treturn set_anon_super(s, data);\n}"
  }
]