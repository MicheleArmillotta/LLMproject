[
  {
    "function_name": "jfs_ci_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1569-1599",
    "snippet": "static int jfs_ci_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\t/*\n\t * This is not negative dentry. Always valid.\n\t *\n\t * Note, rename() to existing directory entry will have ->d_inode,\n\t * and will use existing name which isn't specified name by user.\n\t *\n\t * We may be able to drop this positive dentry here. But dropping\n\t * positive dentry isn't good idea. So it's unsupported like\n\t * rename(\"filename\", \"FILENAME\") for now.\n\t */\n\tif (dentry->d_inode)\n\t\treturn 1;\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!flags)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int jfs_ci_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\t/*\n\t * This is not negative dentry. Always valid.\n\t *\n\t * Note, rename() to existing directory entry will have ->d_inode,\n\t * and will use existing name which isn't specified name by user.\n\t *\n\t * We may be able to drop this positive dentry here. But dropping\n\t * positive dentry isn't good idea. So it's unsupported like\n\t * rename(\"filename\", \"FILENAME\") for now.\n\t */\n\tif (dentry->d_inode)\n\t\treturn 1;\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!flags)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "jfs_ci_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1553-1567",
    "snippet": "static int jfs_ci_compare(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tint i, result = 1;\n\n\tif (len != name->len)\n\t\tgoto out;\n\tfor (i=0; i < len; i++) {\n\t\tif (tolower(str[i]) != tolower(name->name[i]))\n\t\t\tgoto out;\n\t}\n\tresult = 0;\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "name->name[i]"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "fat_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "38-41",
          "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int jfs_ci_compare(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tint i, result = 1;\n\n\tif (len != name->len)\n\t\tgoto out;\n\tfor (i=0; i < len; i++) {\n\t\tif (tolower(str[i]) != tolower(name->name[i]))\n\t\t\tgoto out;\n\t}\n\tresult = 0;\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "jfs_ci_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1540-1551",
    "snippet": "static int jfs_ci_hash(const struct dentry *dir, struct qstr *this)\n{\n\tunsigned long hash;\n\tint i;\n\n\thash = init_name_hash();\n\tfor (i=0; i < this->len; i++)\n\t\thash = partial_name_hash(tolower(this->name[i]), hash);\n\tthis->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "tolower(this->name[i])",
            "hash"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "this->name[i]"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "fat_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "38-41",
          "snippet": "static inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic inline unsigned char fat_tolower(unsigned char c)\n{\n\treturn ((c >= 'A') && (c <= 'Z')) ? c+32 : c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int jfs_ci_hash(const struct dentry *dir, struct qstr *this)\n{\n\tunsigned long hash;\n\tint i;\n\n\thash = init_name_hash();\n\tfor (i=0; i < this->len; i++)\n\t\thash = partial_name_hash(tolower(this->name[i]), hash);\n\tthis->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1498-1506",
    "snippet": "struct dentry *jfs_get_parent(struct dentry *dentry)\n{\n\tunsigned long parent_ino;\n\n\tparent_ino =\n\t\tle32_to_cpu(JFS_IP(dentry->d_inode)->i_dtroot.header.idotdot);\n\n\treturn d_obtain_alias(jfs_iget(dentry->d_inode->i_sb, parent_ino));\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "jfs_iget(dentry->d_inode->i_sb, parent_ino)"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_iget",
          "args": [
            "dentry->d_inode->i_sb",
            "parent_ino"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "36-78",
          "snippet": "struct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nconst struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "JFS_IP(dentry->d_inode)->i_dtroot.header.idotdot"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *jfs_get_parent(struct dentry *dentry)\n{\n\tunsigned long parent_ino;\n\n\tparent_ino =\n\t\tle32_to_cpu(JFS_IP(dentry->d_inode)->i_dtroot.header.idotdot);\n\n\treturn d_obtain_alias(jfs_iget(dentry->d_inode->i_sb, parent_ino));\n}"
  },
  {
    "function_name": "jfs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1491-1496",
    "snippet": "struct dentry *jfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    jfs_nfs_get_inode);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "jfs_nfs_get_inode"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *jfs_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    jfs_nfs_get_inode);\n}"
  },
  {
    "function_name": "jfs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1484-1489",
    "snippet": "struct dentry *jfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    jfs_nfs_get_inode);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "jfs_nfs_get_inode"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *jfs_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    jfs_nfs_get_inode);\n}"
  },
  {
    "function_name": "jfs_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1465-1482",
    "snippet": "static struct inode *jfs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = jfs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "36-78",
          "snippet": "struct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nconst struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic struct inode *jfs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino == 0)\n\t\treturn ERR_PTR(-ESTALE);\n\tinode = jfs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tif (generation && inode->i_generation != generation) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "jfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1437-1463",
    "snippet": "static struct dentry *jfs_lookup(struct inode *dip, struct dentry *dentry, unsigned int flags)\n{\n\tstruct btstack btstack;\n\tino_t inum;\n\tstruct inode *ip;\n\tstruct component_name key;\n\tint rc;\n\n\tjfs_info(\"jfs_lookup: name = %pd\", dentry);\n\n\tif ((rc = get_UCSname(&key, dentry)))\n\t\treturn ERR_PTR(rc);\n\trc = dtSearch(dip, &key, &inum, &btstack, JFS_LOOKUP);\n\tfree_UCSname(&key);\n\tif (rc == -ENOENT) {\n\t\tip = NULL;\n\t} else if (rc) {\n\t\tjfs_err(\"jfs_lookup: dtSearch returned %d\", rc);\n\t\tip = ERR_PTR(rc);\n\t} else {\n\t\tip = jfs_iget(dip->i_sb, inum);\n\t\tif (IS_ERR(ip))\n\t\t\tjfs_err(\"jfs_lookup: iget failed on inum %d\", (uint)inum);\n\t}\n\n\treturn d_splice_alias(ip, dentry);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "ip",
            "dentry"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_lookup: iget failed on inum %d\"",
            "(uint)inum"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ip"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_iget",
          "args": [
            "dip->i_sb",
            "inum"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "36-78",
          "snippet": "struct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nconst struct address_space_operations jfs_aops = {\n\t.readpage\t= jfs_readpage,\n\t.readpages\t= jfs_readpages,\n\t.writepage\t= jfs_writepage,\n\t.writepages\t= jfs_writepages,\n\t.write_begin\t= jfs_write_begin,\n\t.write_end\t= nobh_write_end,\n\t.bmap\t\t= jfs_bmap,\n\t.direct_IO\t= jfs_direct_IO,\n};\n\nstruct inode *jfs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tret = diRead(inode);\n\tif (ret < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinode->i_fop = &jfs_file_operations;\n\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &jfs_dir_inode_operations;\n\t\tinode->i_fop = &jfs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (inode->i_size >= IDATASIZE) {\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &jfs_aops;\n\t\t} else {\n\t\t\tinode->i_op = &jfs_fast_symlink_inode_operations;\n\t\t\t/*\n\t\t\t * The inline data should be null-terminated, but\n\t\t\t * don't let on-disk corruption crash the kernel\n\t\t\t */\n\t\t\tJFS_IP(inode)->i_inline[inode->i_size] = '\\0';\n\t\t}\n\t} else {\n\t\tinode->i_op = &jfs_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t}\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&key"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "dip",
            "&key",
            "&inum",
            "&btstack",
            "JFS_LOOKUP"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&key",
            "dentry"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_lookup: name = %pd\"",
            "dentry"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic struct dentry *jfs_lookup(struct inode *dip, struct dentry *dentry, unsigned int flags)\n{\n\tstruct btstack btstack;\n\tino_t inum;\n\tstruct inode *ip;\n\tstruct component_name key;\n\tint rc;\n\n\tjfs_info(\"jfs_lookup: name = %pd\", dentry);\n\n\tif ((rc = get_UCSname(&key, dentry)))\n\t\treturn ERR_PTR(rc);\n\trc = dtSearch(dip, &key, &inum, &btstack, JFS_LOOKUP);\n\tfree_UCSname(&key);\n\tif (rc == -ENOENT) {\n\t\tip = NULL;\n\t} else if (rc) {\n\t\tjfs_err(\"jfs_lookup: dtSearch returned %d\", rc);\n\t\tip = ERR_PTR(rc);\n\t} else {\n\t\tip = jfs_iget(dip->i_sb, inum);\n\t\tif (IS_ERR(ip))\n\t\t\tjfs_err(\"jfs_lookup: iget failed on inum %d\", (uint)inum);\n\t}\n\n\treturn d_splice_alias(ip, dentry);\n}"
  },
  {
    "function_name": "jfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1340-1435",
    "snippet": "static int jfs_mknod(struct inode *dir, struct dentry *dentry,\n\t\tumode_t mode, dev_t rdev)\n{\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct btstack btstack;\n\tstruct component_name dname;\n\tino_t ino;\n\tstruct inode *ip;\n\tstruct inode *iplist[2];\n\tint rc;\n\ttid_t tid;\n\tstruct tblock *tblk;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tjfs_info(\"jfs_mknod: %pd\", dentry);\n\n\tdquot_initialize(dir);\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tip = ialloc(dir, mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out1;\n\t}\n\tjfs_ip = JFS_IP(ip);\n\n\ttid = txBegin(dir->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dir);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dir, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dir, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dir, &dname, &ino, &btstack))) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tip->i_op = &jfs_file_inode_operations;\n\tjfs_ip->dev = new_encode_dev(rdev);\n\tinit_special_inode(ip, ip->i_mode, rdev);\n\n\tmark_inode_dirty(ip);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tmark_inode_dirty(dir);\n\n\tiplist[0] = dir;\n\tiplist[1] = ip;\n\trc = txCommit(tid, 2, iplist, 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dir)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out1:\n\tfree_UCSname(&dname);\n\n      out:\n\tjfs_info(\"jfs_mknod: returning %d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mknod: returning %d\"",
            "rc"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&dname"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "ip"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "ip"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "ip"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ea_wmap",
          "args": [
            "ip"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "free_ea_wmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
          "lines": "49-59",
          "snippet": "static inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static s64 commitZeroLink(tid_t, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dir)->commit_mutex"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "dir"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "2",
            "iplist",
            "0"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "ip",
            "ip->i_mode",
            "rdev"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "rdev"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "0"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtInsert",
          "args": [
            "tid",
            "dir",
            "&dname",
            "&ino",
            "&btstack"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "dir",
            "&dname",
            "&ino",
            "&btstack",
            "JFS_CREATE"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_init_security",
          "args": [
            "tid",
            "ip",
            "dir",
            "&dentry->d_name"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xattr.h",
          "lines": "70-74",
          "snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_init_acl",
          "args": [
            "tid",
            "ip",
            "dir"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_init_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_acl.h",
          "lines": "29-33",
          "snippet": "static inline int jfs_init_acl(tid_t tid, struct inode *inode,\n\t\t\t       struct inode *dir)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int jfs_init_acl(tid_t tid, struct inode *inode,\n\t\t\t       struct inode *dir)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(dir)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "dir->i_sb",
            "0"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ip"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ip"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ialloc",
          "args": [
            "dir",
            "mode"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "72-165",
          "snippet": "struct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstruct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&dname",
            "dentry"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mknod: %pd\"",
            "dentry"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic int jfs_mknod(struct inode *dir, struct dentry *dentry,\n\t\tumode_t mode, dev_t rdev)\n{\n\tstruct jfs_inode_info *jfs_ip;\n\tstruct btstack btstack;\n\tstruct component_name dname;\n\tino_t ino;\n\tstruct inode *ip;\n\tstruct inode *iplist[2];\n\tint rc;\n\ttid_t tid;\n\tstruct tblock *tblk;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tjfs_info(\"jfs_mknod: %pd\", dentry);\n\n\tdquot_initialize(dir);\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tip = ialloc(dir, mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out1;\n\t}\n\tjfs_ip = JFS_IP(ip);\n\n\ttid = txBegin(dir->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dir);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dir, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dir, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dir, &dname, &ino, &btstack))) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tip->i_op = &jfs_file_inode_operations;\n\tjfs_ip->dev = new_encode_dev(rdev);\n\tinit_special_inode(ip, ip->i_mode, rdev);\n\n\tmark_inode_dirty(ip);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tmark_inode_dirty(dir);\n\n\tiplist[0] = dir;\n\tiplist[1] = ip;\n\trc = txCommit(tid, 2, iplist, 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dir)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out1:\n\tfree_UCSname(&dname);\n\n      out:\n\tjfs_info(\"jfs_mknod: returning %d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "1063-1332",
    "snippet": "static int jfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct btstack btstack;\n\tino_t ino;\n\tstruct component_name new_dname;\n\tstruct inode *new_ip;\n\tstruct component_name old_dname;\n\tstruct inode *old_ip;\n\tint rc;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tint ipcount;\n\tstruct inode *iplist[4];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\n\tjfs_info(\"jfs_rename: %pd %pd\", old_dentry, new_dentry);\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_ip = old_dentry->d_inode;\n\tnew_ip = new_dentry->d_inode;\n\n\tif ((rc = get_UCSname(&old_dname, old_dentry)))\n\t\tgoto out1;\n\n\tif ((rc = get_UCSname(&new_dname, new_dentry)))\n\t\tgoto out2;\n\n\t/*\n\t * Make sure source inode number is what we think it is\n\t */\n\trc = dtSearch(old_dir, &old_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (rc || (ino != old_ip->i_ino)) {\n\t\trc = -ENOENT;\n\t\tgoto out3;\n\t}\n\n\t/*\n\t * Make sure dest inode number (if any) is what we think it is\n\t */\n\trc = dtSearch(new_dir, &new_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (!rc) {\n\t\tif ((!new_ip) || (ino != new_ip->i_ino)) {\n\t\t\trc = -ESTALE;\n\t\t\tgoto out3;\n\t\t}\n\t} else if (rc != -ENOENT)\n\t\tgoto out3;\n\telse if (new_ip) {\n\t\t/* no entry exists, but one was expected */\n\t\trc = -ESTALE;\n\t\tgoto out3;\n\t}\n\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tif (new_ip) {\n\t\t\tif (!dtEmpty(new_ip)) {\n\t\t\t\trc = -ENOTEMPTY;\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t}\n\t} else if (new_ip) {\n\t\tIWRITE_LOCK(new_ip, RDWRLOCK_NORMAL);\n\t\t/* Init inode for quota operations. */\n\t\tdquot_initialize(new_ip);\n\t}\n\n\t/*\n\t * The real work starts here\n\t */\n\ttid = txBegin(new_dir->i_sb, 0);\n\n\t/*\n\t * How do we know the locking is safe from deadlocks?\n\t * The vfs does the hard part for us.  Any time we are taking nested\n\t * commit_mutexes, the vfs already has i_mutex held on the parent.\n\t * Here, the vfs has already taken i_mutex on both old_dir and new_dir.\n\t */\n\tmutex_lock_nested(&JFS_IP(new_dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(old_ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\tif (old_dir != new_dir)\n\t\tmutex_lock_nested(&JFS_IP(old_dir)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_SECOND_PARENT);\n\n\tif (new_ip) {\n\t\tmutex_lock_nested(&JFS_IP(new_ip)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_VICTIM);\n\t\t/*\n\t\t * Change existing directory entry to new inode number\n\t\t */\n\t\tino = new_ip->i_ino;\n\t\trc = dtModify(tid, new_dir, &new_dname, &ino,\n\t\t\t      old_ip->i_ino, JFS_RENAME);\n\t\tif (rc)\n\t\t\tgoto out4;\n\t\tdrop_nlink(new_ip);\n\t\tif (S_ISDIR(new_ip->i_mode)) {\n\t\t\tdrop_nlink(new_ip);\n\t\t\tif (new_ip->i_nlink) {\n\t\t\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t\t\t\tif (old_dir != new_dir)\n\t\t\t\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\t\t\t\tif (!S_ISDIR(old_ip->i_mode) && new_ip)\n\t\t\t\t\tIWRITE_UNLOCK(new_ip);\n\t\t\t\tjfs_error(new_ip->i_sb,\n\t\t\t\t\t  \"new_ip->i_nlink != 0\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else if (new_ip->i_nlink == 0) {\n\t\t\tassert(!test_cflag(COMMIT_Nolink, new_ip));\n\t\t\t/* free block resources */\n\t\t\tif ((new_size = commitZeroLink(tid, new_ip)) < 0) {\n\t\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\t\trc = new_size;\n\t\t\t\tgoto out4;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else {\n\t\t\tnew_ip->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(new_ip);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Add new directory entry\n\t\t */\n\t\trc = dtSearch(new_dir, &new_dname, &ino, &btstack,\n\t\t\t      JFS_CREATE);\n\t\tif (rc) {\n\t\t\tjfs_err(\"jfs_rename didn't expect dtSearch to fail \"\n\t\t\t\t\"w/rc = %d\", rc);\n\t\t\tgoto out4;\n\t\t}\n\n\t\tino = old_ip->i_ino;\n\t\trc = dtInsert(tid, new_dir, &new_dname, &ino, &btstack);\n\t\tif (rc) {\n\t\t\tif (rc == -EIO)\n\t\t\t\tjfs_err(\"jfs_rename: dtInsert returned -EIO\");\n\t\t\tgoto out4;\n\t\t}\n\t\tif (S_ISDIR(old_ip->i_mode))\n\t\t\tinc_nlink(new_dir);\n\t}\n\t/*\n\t * Remove old directory entry\n\t */\n\n\tino = old_ip->i_ino;\n\trc = dtDelete(tid, old_dir, &old_dname, &ino, JFS_REMOVE);\n\tif (rc) {\n\t\tjfs_err(\"jfs_rename did not expect dtDelete to return rc = %d\",\n\t\t\trc);\n\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\tgoto out4;\n\t}\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tdrop_nlink(old_dir);\n\t\tif (old_dir != new_dir) {\n\t\t\t/*\n\t\t\t * Change inode number of parent for moved directory\n\t\t\t */\n\n\t\t\tJFS_IP(old_ip)->i_dtroot.header.idotdot =\n\t\t\t\tcpu_to_le32(new_dir->i_ino);\n\n\t\t\t/* Linelock header of dtree */\n\t\t\ttlck = txLock(tid, old_ip,\n\t\t\t\t    (struct metapage *) &JFS_IP(old_ip)->bxflag,\n\t\t\t\t      tlckDTREE | tlckBTROOT | tlckRELINK);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\t/*\n\t * Update ctime on changed/moved inodes & mark dirty\n\t */\n\told_ip->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_ip);\n\n\tnew_dir->i_ctime = new_dir->i_mtime = current_fs_time(new_dir->i_sb);\n\tmark_inode_dirty(new_dir);\n\n\t/* Build list of inodes modified by this transaction */\n\tipcount = 0;\n\tiplist[ipcount++] = old_ip;\n\tif (new_ip)\n\t\tiplist[ipcount++] = new_ip;\n\tiplist[ipcount++] = old_dir;\n\n\tif (old_dir != new_dir) {\n\t\tiplist[ipcount++] = new_dir;\n\t\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;\n\t\tmark_inode_dirty(old_dir);\n\t}\n\n\t/*\n\t * Incomplete truncate of file data can\n\t * result in timing problems unless we synchronously commit the\n\t * transaction.\n\t */\n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\trc = txCommit(tid, ipcount, iplist, commit_flag);\n\n      out4:\n\ttxEnd(tid);\n\tif (new_ip)\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\tif (old_dir != new_dir)\n\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(new_ip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(new_ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, new_ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 1, &new_ip, COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t}\n\tif (new_ip && (new_ip->i_nlink == 0))\n\t\tset_cflag(COMMIT_Nolink, new_ip);\n      out3:\n\tfree_UCSname(&new_dname);\n      out2:\n\tfree_UCSname(&old_dname);\n      out1:\n\tif (new_ip && !S_ISDIR(new_ip->i_mode))\n\t\tIWRITE_UNLOCK(new_ip);\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, old_dir)) {\n\t\tif (old_dir->i_size > 1)\n\t\t\tjfs_truncate_nolock(old_dir, 0);\n\n\t\tclear_cflag(COMMIT_Stale, old_dir);\n\t}\n\n\tjfs_info(\"jfs_rename: returning %d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_rename: returning %d\"",
            "rc"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_cflag",
          "args": [
            "COMMIT_Stale",
            "old_dir"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_truncate_nolock",
          "args": [
            "old_dir",
            "0"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_truncate_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "374-412",
          "snippet": "void jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Stale",
            "old_dir"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "new_ip"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_ip->i_mode"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&old_dname"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&new_dname"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Nolink",
            "new_ip"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(new_ip)->commit_mutex"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "new_ip"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&new_ip",
            "COMMIT_SYNC"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "1"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtTruncate_pmap",
          "args": [
            "tid",
            "new_ip",
            "new_size"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate_pmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3718-3874",
          "snippet": "s64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(new_ip)->commit_mutex"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "new_ip->i_sb",
            "0"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(new_dir)->commit_mutex"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(old_ip)->commit_mutex"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(old_dir)->commit_mutex"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(new_ip)->commit_mutex"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_dir"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "new_dir->i_sb"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "old_ip",
            "(struct metapage *) &JFS_IP(old_ip)->bxflag",
            "tlckDTREE | tlckBTROOT | tlckRELINK"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_dir->i_ino"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "old_dir"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_ip->i_mode"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_rename did not expect dtDelete to return rc = %d\"",
            "rc"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtDelete",
          "args": [
            "tid",
            "old_dir",
            "&old_dname",
            "&ino",
            "JFS_REMOVE"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "dtDeleteUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2237-2436",
          "snippet": "static int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_ip->i_mode"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_rename: dtInsert returned -EIO\""
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtInsert",
          "args": [
            "tid",
            "new_dir",
            "&new_dname",
            "&ino",
            "&btstack"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "new_dir",
            "&new_dname",
            "&ino",
            "&btstack",
            "JFS_CREATE"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commitZeroLink",
          "args": [
            "tid",
            "new_ip"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "commitZeroLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
          "lines": "626-679",
          "snippet": "static s64 commitZeroLink(tid_t tid, struct inode *ip)\n{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* fast symbolic link */\n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t/* mark transaction of block map update type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache if COMMIT_PWMAP,\n\t * free xtree/data blocks from persistent block map, and\n\t * free xtree/data blocks from working block map if COMMIT_PWMAP;\n\t */\n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static s64 commitZeroLink(tid_t, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic s64 commitZeroLink(tid_t tid, struct inode *ip)\n{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* fast symbolic link */\n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t/* mark transaction of block map update type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache if COMMIT_PWMAP,\n\t * free xtree/data blocks from persistent block map, and\n\t * free xtree/data blocks from working block map if COMMIT_PWMAP;\n\t */\n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!test_cflag(COMMIT_Nolink, new_ip)"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "new_ip"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "new_ip"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_ip->i_mode"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(new_dir)->commit_mutex"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(old_ip)->commit_mutex"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(old_dir)->commit_mutex"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(new_ip)->commit_mutex"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_ip->i_mode"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtModify",
          "args": [
            "tid",
            "new_dir",
            "&new_dname",
            "&ino",
            "old_ip->i_ino",
            "JFS_RENAME"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "dtModify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "4521-4576",
          "snippet": "int dtModify(tid_t tid, struct inode *ip,\n\t struct component_name * key, ino_t * orig_ino, ino_t new_ino, int flag)\n{\n\tint rc;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\ts8 *stbl;\n\tint entry_si;\t\t/* entry slot index */\n\tstruct ldtentry *entry;\n\n\t/*\n\t *\tsearch for the entry to modify:\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to modify).\n\t */\n\tif ((rc = dtSearch(ip, key, orig_ino, &btstack, flag)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page of named entry\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* get slot index of the entry */\n\tstbl = DT_GETSTBL(p);\n\tentry_si = stbl[index];\n\n\t/* linelock entry */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = entry_si;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* get the head/only segment */\n\tentry = (struct ldtentry *) & p->slot[entry_si];\n\n\t/* substitute the inode number of the entry */\n\tentry->inumber = cpu_to_le32(new_ino);\n\n\t/* unpin the leaf page */\n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nint dtModify(tid_t tid, struct inode *ip,\n\t struct component_name * key, ino_t * orig_ino, ino_t new_ino, int flag)\n{\n\tint rc;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\ts8 *stbl;\n\tint entry_si;\t\t/* entry slot index */\n\tstruct ldtentry *entry;\n\n\t/*\n\t *\tsearch for the entry to modify:\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to modify).\n\t */\n\tif ((rc = dtSearch(ip, key, orig_ino, &btstack, flag)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page of named entry\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* get slot index of the entry */\n\tstbl = DT_GETSTBL(p);\n\tentry_si = stbl[index];\n\n\t/* linelock entry */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = entry_si;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* get the head/only segment */\n\tentry = (struct ldtentry *) & p->slot[entry_si];\n\n\t/* substitute the inode number of the entry */\n\tentry->inumber = cpu_to_le32(new_ino);\n\n\t/* unpin the leaf page */\n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(new_ip)->commit_mutex",
            "COMMIT_MUTEX_VICTIM"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(old_dir)->commit_mutex",
            "COMMIT_MUTEX_SECOND_PARENT"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(old_ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(new_dir)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "new_ip"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "new_ip",
            "RDWRLOCK_NORMAL"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtEmpty",
          "args": [
            "new_ip"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_ip->i_mode"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&new_dname",
            "new_dentry"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_rename: %pd %pd\"",
            "old_dentry",
            "new_dentry"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic int jfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct btstack btstack;\n\tino_t ino;\n\tstruct component_name new_dname;\n\tstruct inode *new_ip;\n\tstruct component_name old_dname;\n\tstruct inode *old_ip;\n\tint rc;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tint ipcount;\n\tstruct inode *iplist[4];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\n\tjfs_info(\"jfs_rename: %pd %pd\", old_dentry, new_dentry);\n\n\tdquot_initialize(old_dir);\n\tdquot_initialize(new_dir);\n\n\told_ip = old_dentry->d_inode;\n\tnew_ip = new_dentry->d_inode;\n\n\tif ((rc = get_UCSname(&old_dname, old_dentry)))\n\t\tgoto out1;\n\n\tif ((rc = get_UCSname(&new_dname, new_dentry)))\n\t\tgoto out2;\n\n\t/*\n\t * Make sure source inode number is what we think it is\n\t */\n\trc = dtSearch(old_dir, &old_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (rc || (ino != old_ip->i_ino)) {\n\t\trc = -ENOENT;\n\t\tgoto out3;\n\t}\n\n\t/*\n\t * Make sure dest inode number (if any) is what we think it is\n\t */\n\trc = dtSearch(new_dir, &new_dname, &ino, &btstack, JFS_LOOKUP);\n\tif (!rc) {\n\t\tif ((!new_ip) || (ino != new_ip->i_ino)) {\n\t\t\trc = -ESTALE;\n\t\t\tgoto out3;\n\t\t}\n\t} else if (rc != -ENOENT)\n\t\tgoto out3;\n\telse if (new_ip) {\n\t\t/* no entry exists, but one was expected */\n\t\trc = -ESTALE;\n\t\tgoto out3;\n\t}\n\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tif (new_ip) {\n\t\t\tif (!dtEmpty(new_ip)) {\n\t\t\t\trc = -ENOTEMPTY;\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t}\n\t} else if (new_ip) {\n\t\tIWRITE_LOCK(new_ip, RDWRLOCK_NORMAL);\n\t\t/* Init inode for quota operations. */\n\t\tdquot_initialize(new_ip);\n\t}\n\n\t/*\n\t * The real work starts here\n\t */\n\ttid = txBegin(new_dir->i_sb, 0);\n\n\t/*\n\t * How do we know the locking is safe from deadlocks?\n\t * The vfs does the hard part for us.  Any time we are taking nested\n\t * commit_mutexes, the vfs already has i_mutex held on the parent.\n\t * Here, the vfs has already taken i_mutex on both old_dir and new_dir.\n\t */\n\tmutex_lock_nested(&JFS_IP(new_dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(old_ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\tif (old_dir != new_dir)\n\t\tmutex_lock_nested(&JFS_IP(old_dir)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_SECOND_PARENT);\n\n\tif (new_ip) {\n\t\tmutex_lock_nested(&JFS_IP(new_ip)->commit_mutex,\n\t\t\t\t  COMMIT_MUTEX_VICTIM);\n\t\t/*\n\t\t * Change existing directory entry to new inode number\n\t\t */\n\t\tino = new_ip->i_ino;\n\t\trc = dtModify(tid, new_dir, &new_dname, &ino,\n\t\t\t      old_ip->i_ino, JFS_RENAME);\n\t\tif (rc)\n\t\t\tgoto out4;\n\t\tdrop_nlink(new_ip);\n\t\tif (S_ISDIR(new_ip->i_mode)) {\n\t\t\tdrop_nlink(new_ip);\n\t\t\tif (new_ip->i_nlink) {\n\t\t\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t\t\t\tif (old_dir != new_dir)\n\t\t\t\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\t\t\t\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\t\t\t\tif (!S_ISDIR(old_ip->i_mode) && new_ip)\n\t\t\t\t\tIWRITE_UNLOCK(new_ip);\n\t\t\t\tjfs_error(new_ip->i_sb,\n\t\t\t\t\t  \"new_ip->i_nlink != 0\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else if (new_ip->i_nlink == 0) {\n\t\t\tassert(!test_cflag(COMMIT_Nolink, new_ip));\n\t\t\t/* free block resources */\n\t\t\tif ((new_size = commitZeroLink(tid, new_ip)) < 0) {\n\t\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\t\trc = new_size;\n\t\t\t\tgoto out4;\n\t\t\t}\n\t\t\ttblk = tid_to_tblock(tid);\n\t\t\ttblk->xflag |= COMMIT_DELETE;\n\t\t\ttblk->u.ip = new_ip;\n\t\t} else {\n\t\t\tnew_ip->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(new_ip);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Add new directory entry\n\t\t */\n\t\trc = dtSearch(new_dir, &new_dname, &ino, &btstack,\n\t\t\t      JFS_CREATE);\n\t\tif (rc) {\n\t\t\tjfs_err(\"jfs_rename didn't expect dtSearch to fail \"\n\t\t\t\t\"w/rc = %d\", rc);\n\t\t\tgoto out4;\n\t\t}\n\n\t\tino = old_ip->i_ino;\n\t\trc = dtInsert(tid, new_dir, &new_dname, &ino, &btstack);\n\t\tif (rc) {\n\t\t\tif (rc == -EIO)\n\t\t\t\tjfs_err(\"jfs_rename: dtInsert returned -EIO\");\n\t\t\tgoto out4;\n\t\t}\n\t\tif (S_ISDIR(old_ip->i_mode))\n\t\t\tinc_nlink(new_dir);\n\t}\n\t/*\n\t * Remove old directory entry\n\t */\n\n\tino = old_ip->i_ino;\n\trc = dtDelete(tid, old_dir, &old_dname, &ino, JFS_REMOVE);\n\tif (rc) {\n\t\tjfs_err(\"jfs_rename did not expect dtDelete to return rc = %d\",\n\t\t\trc);\n\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\tgoto out4;\n\t}\n\tif (S_ISDIR(old_ip->i_mode)) {\n\t\tdrop_nlink(old_dir);\n\t\tif (old_dir != new_dir) {\n\t\t\t/*\n\t\t\t * Change inode number of parent for moved directory\n\t\t\t */\n\n\t\t\tJFS_IP(old_ip)->i_dtroot.header.idotdot =\n\t\t\t\tcpu_to_le32(new_dir->i_ino);\n\n\t\t\t/* Linelock header of dtree */\n\t\t\ttlck = txLock(tid, old_ip,\n\t\t\t\t    (struct metapage *) &JFS_IP(old_ip)->bxflag,\n\t\t\t\t      tlckDTREE | tlckBTROOT | tlckRELINK);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\t/*\n\t * Update ctime on changed/moved inodes & mark dirty\n\t */\n\told_ip->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_ip);\n\n\tnew_dir->i_ctime = new_dir->i_mtime = current_fs_time(new_dir->i_sb);\n\tmark_inode_dirty(new_dir);\n\n\t/* Build list of inodes modified by this transaction */\n\tipcount = 0;\n\tiplist[ipcount++] = old_ip;\n\tif (new_ip)\n\t\tiplist[ipcount++] = new_ip;\n\tiplist[ipcount++] = old_dir;\n\n\tif (old_dir != new_dir) {\n\t\tiplist[ipcount++] = new_dir;\n\t\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME;\n\t\tmark_inode_dirty(old_dir);\n\t}\n\n\t/*\n\t * Incomplete truncate of file data can\n\t * result in timing problems unless we synchronously commit the\n\t * transaction.\n\t */\n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\trc = txCommit(tid, ipcount, iplist, commit_flag);\n\n      out4:\n\ttxEnd(tid);\n\tif (new_ip)\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\tif (old_dir != new_dir)\n\t\tmutex_unlock(&JFS_IP(old_dir)->commit_mutex);\n\tmutex_unlock(&JFS_IP(old_ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(new_dir)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(new_ip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(new_ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, new_ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 1, &new_ip, COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(new_ip)->commit_mutex);\n\t}\n\tif (new_ip && (new_ip->i_nlink == 0))\n\t\tset_cflag(COMMIT_Nolink, new_ip);\n      out3:\n\tfree_UCSname(&new_dname);\n      out2:\n\tfree_UCSname(&old_dname);\n      out1:\n\tif (new_ip && !S_ISDIR(new_ip->i_mode))\n\t\tIWRITE_UNLOCK(new_ip);\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, old_dir)) {\n\t\tif (old_dir->i_size > 1)\n\t\t\tjfs_truncate_nolock(old_dir, 0);\n\n\t\tclear_cflag(COMMIT_Stale, old_dir);\n\t}\n\n\tjfs_info(\"jfs_rename: returning %d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "873-1055",
    "snippet": "static int jfs_symlink(struct inode *dip, struct dentry *dentry,\n\t\tconst char *name)\n{\n\tint rc;\n\ttid_t tid;\n\tino_t ino = 0;\n\tstruct component_name dname;\n\tint ssize;\t\t/* source pathname size */\n\tstruct btstack btstack;\n\tstruct inode *ip = dentry->d_inode;\n\tunchar *i_fastsymlink;\n\ts64 xlen = 0;\n\tint bmask = 0, xsize;\n\ts64 xaddr;\n\tstruct metapage *mp;\n\tstruct super_block *sb;\n\tstruct tblock *tblk;\n\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_symlink: dip:0x%p name:%s\", dip, name);\n\n\tdquot_initialize(dip);\n\n\tssize = strlen(name) + 1;\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * allocate on-disk/in-memory inode for symbolic link:\n\t * (iAlloc() returns new, locked inode)\n\t */\n\tip = ialloc(dip, S_IFLNK | 0777);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc)\n\t\tgoto out3;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\t/* fix symlink access permission\n\t * (dir_create() ANDs in the u.u_cmask,\n\t * but symlinks really need to be 777 access)\n\t */\n\tip->i_mode |= 0777;\n\n\t/*\n\t * write symbolic link target path name\n\t */\n\txtInitRoot(tid, ip);\n\n\t/*\n\t * write source path name inline in on-disk inode (fast symbolic link)\n\t */\n\n\tif (ssize <= IDATASIZE) {\n\t\tip->i_op = &jfs_fast_symlink_inode_operations;\n\n\t\ti_fastsymlink = JFS_IP(ip)->i_inline;\n\t\tmemcpy(i_fastsymlink, name, ssize);\n\t\tip->i_size = ssize - 1;\n\n\t\t/*\n\t\t * if symlink is > 128 bytes, we don't have the space to\n\t\t * store inline extended attributes\n\t\t */\n\t\tif (ssize > sizeof (JFS_IP(ip)->i_inline))\n\t\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tjfs_info(\"jfs_symlink: fast symlink added  ssize:%d name:%s \",\n\t\t\t ssize, name);\n\t}\n\t/*\n\t * write source path name in a single extent\n\t */\n\telse {\n\t\tjfs_info(\"jfs_symlink: allocate extent ip:0x%p\", ip);\n\n\t\tip->i_op = &jfs_symlink_inode_operations;\n\t\tip->i_mapping->a_ops = &jfs_aops;\n\n\t\t/*\n\t\t * even though the data of symlink object (source\n\t\t * path name) is treated as non-journaled user data,\n\t\t * it is read/written thru buffer cache for performance.\n\t\t */\n\t\tsb = ip->i_sb;\n\t\tbmask = JFS_SBI(sb)->bsize - 1;\n\t\txsize = (ssize + bmask) & ~bmask;\n\t\txaddr = 0;\n\t\txlen = xsize >> JFS_SBI(sb)->l2bsize;\n\t\tif ((rc = xtInsert(tid, ip, 0, 0, xlen, &xaddr, 0))) {\n\t\t\ttxAbort(tid, 0);\n\t\t\tgoto out3;\n\t\t}\n\t\tip->i_size = ssize - 1;\n\t\twhile (ssize) {\n\t\t\t/* This is kind of silly since PATH_MAX == 4K */\n\t\t\tint copy_size = min(ssize, PSIZE);\n\n\t\t\tmp = get_metapage(ip, xaddr, PSIZE, 1);\n\n\t\t\tif (mp == NULL) {\n\t\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\t\trc = -EIO;\n\t\t\t\ttxAbort(tid, 0);\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t\tmemcpy(mp->data, name, copy_size);\n\t\t\tflush_metapage(mp);\n\t\t\tssize -= copy_size;\n\t\t\tname += copy_size;\n\t\t\txaddr += JFS_SBI(sb)->nbperpage;\n\t\t}\n\t}\n\n\t/*\n\t * create entry for symbolic link in parent directory\n\t */\n\trc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE);\n\tif (rc == 0) {\n\t\tino = ip->i_ino;\n\t\trc = dtInsert(tid, dip, &dname, &ino, &btstack);\n\t}\n\tif (rc) {\n\t\tif (xlen)\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\ttxAbort(tid, 0);\n\t\t/* discard new inode */\n\t\tgoto out3;\n\t}\n\n\tmark_inode_dirty(ip);\n\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\t/*\n\t * commit update of parent directory and link object\n\t */\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\tjfs_info(\"jfs_symlink: rc:%d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_symlink: rc:%d\"",
            "rc"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&dname"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "ip"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "ip"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "ip"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ea_wmap",
          "args": [
            "ip"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "free_ea_wmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
          "lines": "49-59",
          "snippet": "static inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static s64 commitZeroLink(tid_t, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "dip"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "2",
            "&iplist[0]",
            "0"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dip"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "0"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtTruncate",
          "args": [
            "tid",
            "ip",
            "0",
            "COMMIT_PWMAP"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3162-3692",
          "snippet": "s64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtInsert",
          "args": [
            "tid",
            "dip",
            "&dname",
            "&ino",
            "&btstack"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "dip",
            "&dname",
            "&ino",
            "&btstack",
            "JFS_CREATE"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_metapage",
          "args": [
            "mp"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "flush_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "91-95",
          "snippet": "static inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_sync\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_sync\t3\n\nstatic inline void flush_metapage(struct metapage *mp)\n{\n\tset_bit(META_sync, &mp->flag);\n\twrite_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mp->data",
            "name",
            "copy_size"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ip",
            "xaddr",
            "PSIZE",
            "1"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ssize",
            "PSIZE"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "minix_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "172-185",
          "snippet": "static int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtInsert",
          "args": [
            "tid",
            "ip",
            "0",
            "0",
            "xlen",
            "&xaddr",
            "0"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "xtInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "537-670",
          "snippet": "int xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_symlink: allocate extent ip:0x%p\"",
            "ip"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_symlink: fast symlink added  ssize:%d name:%s \"",
            "ssize",
            "name"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "i_fastsymlink",
            "name",
            "ssize"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtInitRoot",
          "args": [
            "tid",
            "ip"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "xtInitRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3073-3098",
          "snippet": "void xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\n\nvoid xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_init_security",
          "args": [
            "tid",
            "ip",
            "dip",
            "&dentry->d_name"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xattr.h",
          "lines": "70-74",
          "snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(dip)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "dip->i_sb",
            "0"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ip"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ip"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ialloc",
          "args": [
            "dip",
            "S_IFLNK | 0777"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "72-165",
          "snippet": "struct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstruct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&dname",
            "dentry"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dip"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_symlink: dip:0x%p name:%s\"",
            "dip",
            "name"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic int jfs_symlink(struct inode *dip, struct dentry *dentry,\n\t\tconst char *name)\n{\n\tint rc;\n\ttid_t tid;\n\tino_t ino = 0;\n\tstruct component_name dname;\n\tint ssize;\t\t/* source pathname size */\n\tstruct btstack btstack;\n\tstruct inode *ip = dentry->d_inode;\n\tunchar *i_fastsymlink;\n\ts64 xlen = 0;\n\tint bmask = 0, xsize;\n\ts64 xaddr;\n\tstruct metapage *mp;\n\tstruct super_block *sb;\n\tstruct tblock *tblk;\n\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_symlink: dip:0x%p name:%s\", dip, name);\n\n\tdquot_initialize(dip);\n\n\tssize = strlen(name) + 1;\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * allocate on-disk/in-memory inode for symbolic link:\n\t * (iAlloc() returns new, locked inode)\n\t */\n\tip = ialloc(dip, S_IFLNK | 0777);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc)\n\t\tgoto out3;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\t/* fix symlink access permission\n\t * (dir_create() ANDs in the u.u_cmask,\n\t * but symlinks really need to be 777 access)\n\t */\n\tip->i_mode |= 0777;\n\n\t/*\n\t * write symbolic link target path name\n\t */\n\txtInitRoot(tid, ip);\n\n\t/*\n\t * write source path name inline in on-disk inode (fast symbolic link)\n\t */\n\n\tif (ssize <= IDATASIZE) {\n\t\tip->i_op = &jfs_fast_symlink_inode_operations;\n\n\t\ti_fastsymlink = JFS_IP(ip)->i_inline;\n\t\tmemcpy(i_fastsymlink, name, ssize);\n\t\tip->i_size = ssize - 1;\n\n\t\t/*\n\t\t * if symlink is > 128 bytes, we don't have the space to\n\t\t * store inline extended attributes\n\t\t */\n\t\tif (ssize > sizeof (JFS_IP(ip)->i_inline))\n\t\t\tJFS_IP(ip)->mode2 &= ~INLINEEA;\n\n\t\tjfs_info(\"jfs_symlink: fast symlink added  ssize:%d name:%s \",\n\t\t\t ssize, name);\n\t}\n\t/*\n\t * write source path name in a single extent\n\t */\n\telse {\n\t\tjfs_info(\"jfs_symlink: allocate extent ip:0x%p\", ip);\n\n\t\tip->i_op = &jfs_symlink_inode_operations;\n\t\tip->i_mapping->a_ops = &jfs_aops;\n\n\t\t/*\n\t\t * even though the data of symlink object (source\n\t\t * path name) is treated as non-journaled user data,\n\t\t * it is read/written thru buffer cache for performance.\n\t\t */\n\t\tsb = ip->i_sb;\n\t\tbmask = JFS_SBI(sb)->bsize - 1;\n\t\txsize = (ssize + bmask) & ~bmask;\n\t\txaddr = 0;\n\t\txlen = xsize >> JFS_SBI(sb)->l2bsize;\n\t\tif ((rc = xtInsert(tid, ip, 0, 0, xlen, &xaddr, 0))) {\n\t\t\ttxAbort(tid, 0);\n\t\t\tgoto out3;\n\t\t}\n\t\tip->i_size = ssize - 1;\n\t\twhile (ssize) {\n\t\t\t/* This is kind of silly since PATH_MAX == 4K */\n\t\t\tint copy_size = min(ssize, PSIZE);\n\n\t\t\tmp = get_metapage(ip, xaddr, PSIZE, 1);\n\n\t\t\tif (mp == NULL) {\n\t\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\t\trc = -EIO;\n\t\t\t\ttxAbort(tid, 0);\n\t\t\t\tgoto out3;\n\t\t\t}\n\t\t\tmemcpy(mp->data, name, copy_size);\n\t\t\tflush_metapage(mp);\n\t\t\tssize -= copy_size;\n\t\t\tname += copy_size;\n\t\t\txaddr += JFS_SBI(sb)->nbperpage;\n\t\t}\n\t}\n\n\t/*\n\t * create entry for symbolic link in parent directory\n\t */\n\trc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE);\n\tif (rc == 0) {\n\t\tino = ip->i_ino;\n\t\trc = dtInsert(tid, dip, &dname, &ino, &btstack);\n\t}\n\tif (rc) {\n\t\tif (xlen)\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\ttxAbort(tid, 0);\n\t\t/* discard new inode */\n\t\tgoto out3;\n\t}\n\n\tmark_inode_dirty(ip);\n\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\t/*\n\t * commit update of parent directory and link object\n\t */\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\tjfs_info(\"jfs_symlink: rc:%d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "789-853",
    "snippet": "static int jfs_link(struct dentry *old_dentry,\n\t     struct inode *dir, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\n\tstruct inode *ip = old_dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_link: %pd %pd\", old_dentry, dentry);\n\n\tdquot_initialize(dir);\n\n\ttid = txBegin(ip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\t/*\n\t * scan parent directory for entry/freespace\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tif ((rc = dtSearch(dir, &dname, &ino, &btstack, JFS_CREATE)))\n\t\tgoto free_dname;\n\n\t/*\n\t * create entry for new link in parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dir, &dname, &ino, &btstack)))\n\t\tgoto free_dname;\n\n\t/* update object inode */\n\tinc_nlink(ip);\t\t/* for new link */\n\tip->i_ctime = CURRENT_TIME;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\tihold(ip);\n\n\tiplist[0] = ip;\n\tiplist[1] = dir;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\tif (rc) {\n\t\tdrop_nlink(ip); /* never instantiated */\n\t\tiput(ip);\n\t} else\n\t\td_instantiate(dentry, ip);\n\n      free_dname:\n\tfree_UCSname(&dname);\n\n      out:\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dir)->commit_mutex);\n\n\tjfs_info(\"jfs_link: rc:%d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_link: rc:%d\"",
            "rc"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dir)->commit_mutex"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "dir"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&dname"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "ip"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "ip"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "2",
            "&iplist[0]",
            "0"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "ip"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "ip"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtInsert",
          "args": [
            "tid",
            "dir",
            "&dname",
            "&ino",
            "&btstack"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "dir",
            "&dname",
            "&ino",
            "&btstack",
            "JFS_CREATE"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&dname",
            "dentry"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(dir)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "ip->i_sb",
            "0"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_link: %pd %pd\"",
            "old_dentry",
            "dentry"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic int jfs_link(struct dentry *old_dentry,\n\t     struct inode *dir, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\n\tstruct inode *ip = old_dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\n\tjfs_info(\"jfs_link: %pd %pd\", old_dentry, dentry);\n\n\tdquot_initialize(dir);\n\n\ttid = txBegin(ip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dir)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\t/*\n\t * scan parent directory for entry/freespace\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tif ((rc = dtSearch(dir, &dname, &ino, &btstack, JFS_CREATE)))\n\t\tgoto free_dname;\n\n\t/*\n\t * create entry for new link in parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dir, &dname, &ino, &btstack)))\n\t\tgoto free_dname;\n\n\t/* update object inode */\n\tinc_nlink(ip);\t\t/* for new link */\n\tip->i_ctime = CURRENT_TIME;\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\tihold(ip);\n\n\tiplist[0] = ip;\n\tiplist[1] = dir;\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\tif (rc) {\n\t\tdrop_nlink(ip); /* never instantiated */\n\t\tiput(ip);\n\t} else\n\t\td_instantiate(dentry, ip);\n\n      free_dname:\n\tfree_UCSname(&dname);\n\n      out:\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dir)->commit_mutex);\n\n\tjfs_info(\"jfs_link: rc:%d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_free_zero_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "692-763",
    "snippet": "void jfs_free_zero_link(struct inode *ip)\n{\n\tint type;\n\n\tjfs_info(\"jfs_free_zero_link: ip = 0x%p\", ip);\n\n\t/* return if not reg or symbolic link or if size is\n\t * already ok.\n\t */\n\ttype = ip->i_mode & S_IFMT;\n\n\tswitch (type) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* if its contained in inode nothing to do */\n\t\tif (ip->i_size < IDATASIZE)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->ea);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->ea);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->ea);\n\n\t\t/* free EA extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->acl);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->acl);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->acl);\n\n\t\t/* free ACL extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache, and\n\t * free xtree/data blocks from working block map;\n\t */\n\tif (ip->i_size)\n\t\txtTruncate(0, ip, 0, COMMIT_WMAP);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xtTruncate",
          "args": [
            "0",
            "ip",
            "0",
            "COMMIT_WMAP"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3162-3692",
          "snippet": "s64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txFreeMap",
          "args": [
            "ip",
            "pxdlock",
            "NULL",
            "COMMIT_WMAP"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "txFreeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2497-2589",
          "snippet": "void txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txFreeMap(struct inode *ip,\n\t       struct maplock * maplock, struct tblock * tblk, int maptype)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct xdlistlock *xadlistlock;\n\txad_t *xad;\n\ts64 xaddr;\n\tint xlen;\n\tstruct pxd_lock *pxdlock;\n\tstruct xdlistlock *pxdlistlock;\n\tpxd_t *pxd;\n\tint n;\n\n\tjfs_info(\"txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x\",\n\t\t tblk, maplock, maptype);\n\n\t/*\n\t * free from persistent map;\n\t */\n\tif (maptype == COMMIT_PMAP || maptype == COMMIT_PWMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\tif (!(xad->flag & XAD_NEW)) {\n\t\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx \"\n\t\t\t\t\t\t \"xlen:%d\",\n\t\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbUpdatePMap(ipbmap, true, xaddr, (s64) xlen,\n\t\t\t\t     tblk);\n\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckALLOCPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbUpdatePMap(ipbmap, true, xaddr,\n\t\t\t\t\t     (s64) xlen, tblk);\n\t\t\t\tjfs_info(\"freePMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * free from working map;\n\t */\n\tif (maptype == COMMIT_PWMAP || maptype == COMMIT_WMAP) {\n\t\tif (maplock->flag & mlckFREEXADLIST) {\n\t\t\txadlistlock = (struct xdlistlock *) maplock;\n\t\t\txad = xadlistlock->xdlist;\n\t\t\tfor (n = 0; n < xadlistlock->count; n++, xad++) {\n\t\t\t\txaddr = addressXAD(xad);\n\t\t\t\txlen = lengthXAD(xad);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\txad->flag = 0;\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t} else if (maplock->flag & mlckFREEPXD) {\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\txaddr = addressPXD(&pxdlock->pxd);\n\t\t\txlen = lengthPXD(&pxdlock->pxd);\n\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t (ulong) xaddr, xlen);\n\t\t} else {\t/* (maplock->flag & mlckFREEPXDLIST) */\n\n\t\t\tpxdlistlock = (struct xdlistlock *) maplock;\n\t\t\tpxd = pxdlistlock->xdlist;\n\t\t\tfor (n = 0; n < pxdlistlock->count; n++, pxd++) {\n\t\t\t\txaddr = addressPXD(pxd);\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tjfs_info(\"freeWMap: xaddr:0x%lx xlen:%d\",\n\t\t\t\t\t (ulong) xaddr, xlen);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&pxdlock->pxd",
            "xlen"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "&pxdlock->pxd",
            "xaddr"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_dxd_metapages",
          "args": [
            "ip",
            "JFS_IP(ip)->acl"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "&JFS_IP(ip)->acl"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "&JFS_IP(ip)->acl"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_dxd_metapages",
          "args": [
            "ip",
            "JFS_IP(ip)->ea"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "&JFS_IP(ip)->ea"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "&JFS_IP(ip)->ea"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_free_zero_link: ip = 0x%p\"",
            "ip"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nvoid jfs_free_zero_link(struct inode *ip)\n{\n\tint type;\n\n\tjfs_info(\"jfs_free_zero_link: ip = 0x%p\", ip);\n\n\t/* return if not reg or symbolic link or if size is\n\t * already ok.\n\t */\n\ttype = ip->i_mode & S_IFMT;\n\n\tswitch (type) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* if its contained in inode nothing to do */\n\t\tif (ip->i_size < IDATASIZE)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->ea);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->ea);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->ea);\n\n\t\t/* free EA extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\ts64 xaddr = addressDXD(&JFS_IP(ip)->acl);\n\t\tint xlen = lengthDXD(&JFS_IP(ip)->acl);\n\t\tstruct maplock maplock;\t/* maplock for COMMIT_WMAP */\n\t\tstruct pxd_lock *pxdlock;\t/* maplock for COMMIT_WMAP */\n\n\t\tinvalidate_dxd_metapages(ip, JFS_IP(ip)->acl);\n\n\t\t/* free ACL extent from working block map */\n\t\tmaplock.index = 1;\n\t\tpxdlock = (struct pxd_lock *) & maplock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\tPXDlength(&pxdlock->pxd, xlen);\n\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\t}\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache, and\n\t * free xtree/data blocks from working block map;\n\t */\n\tif (ip->i_size)\n\t\txtTruncate(0, ip, 0, COMMIT_WMAP);\n}"
  },
  {
    "function_name": "commitZeroLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "626-679",
    "snippet": "static s64 commitZeroLink(tid_t tid, struct inode *ip)\n{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* fast symbolic link */\n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t/* mark transaction of block map update type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache if COMMIT_PWMAP,\n\t * free xtree/data blocks from persistent block map, and\n\t * free xtree/data blocks from working block map if COMMIT_PWMAP;\n\t */\n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xtTruncate_pmap",
          "args": [
            "tid",
            "ip",
            "0"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate_pmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3718-3874",
          "snippet": "s64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEA",
          "args": [
            "tid",
            "ip",
            "&JFS_IP(ip)->acl",
            "NULL"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "txEA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2173-2217",
          "snippet": "void txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nvoid txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Freewmap",
            "ip"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "filetype != S_IFDIR"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"commitZeroLink: tid = %d, ip = 0x%p\"",
            "tid",
            "ip"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic s64 commitZeroLink(tid_t tid, struct inode *ip)\n{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* fast symbolic link */\n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t/* mark transaction of block map update type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache if COMMIT_PWMAP,\n\t * free xtree/data blocks from persistent block map, and\n\t * free xtree/data blocks from working block map if COMMIT_PWMAP;\n\t */\n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "471-600",
    "snippet": "static int jfs_unlink(struct inode *dip, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\t/* object name */\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\tjfs_info(\"jfs_unlink: dip:0x%p name:%pd\", dip, dentry);\n\n\t/* Init inode for quota operations. */\n\tdquot_initialize(dip);\n\tdquot_initialize(ip);\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * delete the entry of target file from parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_unlink: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\tIWRITE_UNLOCK(ip);\n\t\tgoto out1;\n\t}\n\n\tASSERT(ip->i_nlink);\n\n\tip->i_ctime = dip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\n\t/* update target's inode */\n\tinode_dec_link_count(ip);\n\n\t/*\n\t *\tcommit zero link count object\n\t */\n\tif (ip->i_nlink == 0) {\n\t\tassert(!test_cflag(COMMIT_Nolink, ip));\n\t\t/* free block resources */\n\t\tif ((new_size = commitZeroLink(tid, ip)) < 0) {\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\t\tIWRITE_UNLOCK(ip);\n\t\t\trc = new_size;\n\t\t\tgoto out1;\n\t\t}\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= COMMIT_DELETE;\n\t\ttblk->u.ip = ip;\n\t}\n\n\t/*\n\t * Incomplete truncate of file data can\n\t * result in timing problems unless we synchronously commit the\n\t * transaction.\n\t */\n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\t/*\n\t * If xtTruncate was incomplete, commit synchronously to avoid\n\t * timing complications\n\t */\n\trc = txCommit(tid, 2, &iplist[0], commit_flag);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(dip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 2, &iplist[0], COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t}\n\n\tif (ip->i_nlink == 0)\n\t\tset_cflag(COMMIT_Nolink, ip);\n\n\tIWRITE_UNLOCK(ip);\n\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out1:\n\tfree_UCSname(&dname);\n      out:\n\tjfs_info(\"jfs_unlink: rc:%d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_unlink: rc:%d\"",
            "rc"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&dname"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_cflag",
          "args": [
            "COMMIT_Stale",
            "dip"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_truncate_nolock",
          "args": [
            "dip",
            "0"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_truncate_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "374-412",
          "snippet": "void jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Stale",
            "dip"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ip"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "2",
            "&iplist[0]",
            "COMMIT_SYNC"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "1"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtTruncate_pmap",
          "args": [
            "tid",
            "ip",
            "new_size"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate_pmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3718-3874",
          "snippet": "s64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate_pmap(tid_t tid, struct inode *ip, s64 committed_size)\n{\n\ts64 bn;\n\tstruct btstack btstack;\n\tint cmp;\n\tint index;\n\tint locked_leaves = 0;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tstruct btframe *parent;\n\tint rc;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck = NULL;\n\txad_t *xad;\n\tint xlen;\n\ts64 xoff;\n\tstruct xtlock *xtlck = NULL;\n\n\t/* save object truncation type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\tif (committed_size) {\n\t\txoff = (committed_size >> JFS_SBI(ip->i_sb)->l2bsize) - 1;\n\t\trc = xtSearch(ip, xoff, NULL, &cmp, &btstack, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\tif (cmp != 0) {\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"did not find extent\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * start with root\n\t\t *\n\t\t * root resides in the inode\n\t\t */\n\t\tbn = 0;\n\n\t\t/*\n\t\t * first access of each page:\n\t\t */\n      getPage:\n\t\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* process entries backward from last index */\n\t\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\t\tif (p->header.flag & BT_INTERNAL)\n\t\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tleaf page\n\t */\n\n\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t/*\n\t\t * We need to limit the size of the transaction\n\t\t * to avoid exhausting pagecache & tlocks\n\t\t */\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\tXT_PUTPAGE(mp);\n\t\treturn (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t}\n\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\ttlck->type = tlckXTREE | tlckFREE;\n\txtlck = (struct xtlock *) & tlck->lock;\n\txtlck->hwm.offset = index;\n\n\n\tXT_PUTPAGE(mp);\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\t/* txCommit() with tlckFREE:\n\t\t * free child extents covered by parent;\n\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\n\t\tXT_PUTPAGE(mp);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse\n\t\tindex--;\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "dip->i_sb",
            "0"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ip"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commitZeroLink",
          "args": [
            "tid",
            "ip"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "commitZeroLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
          "lines": "626-679",
          "snippet": "static s64 commitZeroLink(tid_t tid, struct inode *ip)\n{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* fast symbolic link */\n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t/* mark transaction of block map update type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache if COMMIT_PWMAP,\n\t * free xtree/data blocks from persistent block map, and\n\t * free xtree/data blocks from working block map if COMMIT_PWMAP;\n\t */\n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static s64 commitZeroLink(tid_t, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic s64 commitZeroLink(tid_t tid, struct inode *ip)\n{\n\tint filetype;\n\tstruct tblock *tblk;\n\n\tjfs_info(\"commitZeroLink: tid = %d, ip = 0x%p\", tid, ip);\n\n\tfiletype = ip->i_mode & S_IFMT;\n\tswitch (filetype) {\n\tcase S_IFREG:\n\t\tbreak;\n\tcase S_IFLNK:\n\t\t/* fast symbolic link */\n\t\tif (ip->i_size < IDATASIZE) {\n\t\t\tip->i_size = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tassert(filetype != S_IFDIR);\n\t\treturn 0;\n\t}\n\n\tset_cflag(COMMIT_Freewmap, ip);\n\n\t/* mark transaction of block map update type */\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_PMAP;\n\n\t/*\n\t * free EA\n\t */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\n\t/*\n\t * free ACL\n\t */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT)\n\t\t/* acquire maplock on EA to be freed from block map */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\n\t/*\n\t * free xtree/data (truncate to zero length):\n\t * free xtree/data pages from cache if COMMIT_PWMAP,\n\t * free xtree/data blocks from persistent block map, and\n\t * free xtree/data blocks from working block map if COMMIT_PWMAP;\n\t */\n\tif (ip->i_size)\n\t\treturn xtTruncate_pmap(tid, ip, 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!test_cflag(COMMIT_Nolink, ip)"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Nolink",
            "ip"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "ip"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dip"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_nlink"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_UNLOCK",
          "args": [
            "ip"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_unlink: dtDelete returned %d\"",
            "rc"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtDelete",
          "args": [
            "tid",
            "dip",
            "&dname",
            "&ino",
            "JFS_REMOVE"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "dtDeleteUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2237-2436",
          "snippet": "static int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(dip)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IWRITE_LOCK",
          "args": [
            "ip",
            "RDWRLOCK_NORMAL"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&dname",
            "dentry"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "ip"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_unlink: dip:0x%p name:%pd\"",
            "dip",
            "dentry"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic int jfs_unlink(struct inode *dip, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\t/* object name */\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\ts64 new_size = 0;\n\tint commit_flag;\n\n\tjfs_info(\"jfs_unlink: dip:0x%p name:%pd\", dip, dentry);\n\n\t/* Init inode for quota operations. */\n\tdquot_initialize(dip);\n\tdquot_initialize(ip);\n\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out;\n\n\tIWRITE_LOCK(ip, RDWRLOCK_NORMAL);\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * delete the entry of target file from parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_unlink: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\tIWRITE_UNLOCK(ip);\n\t\tgoto out1;\n\t}\n\n\tASSERT(ip->i_nlink);\n\n\tip->i_ctime = dip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\n\t/* update target's inode */\n\tinode_dec_link_count(ip);\n\n\t/*\n\t *\tcommit zero link count object\n\t */\n\tif (ip->i_nlink == 0) {\n\t\tassert(!test_cflag(COMMIT_Nolink, ip));\n\t\t/* free block resources */\n\t\tif ((new_size = commitZeroLink(tid, ip)) < 0) {\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\t\t\tIWRITE_UNLOCK(ip);\n\t\t\trc = new_size;\n\t\t\tgoto out1;\n\t\t}\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= COMMIT_DELETE;\n\t\ttblk->u.ip = ip;\n\t}\n\n\t/*\n\t * Incomplete truncate of file data can\n\t * result in timing problems unless we synchronously commit the\n\t * transaction.\n\t */\n\tif (new_size)\n\t\tcommit_flag = COMMIT_SYNC;\n\telse\n\t\tcommit_flag = 0;\n\n\t/*\n\t * If xtTruncate was incomplete, commit synchronously to avoid\n\t * timing complications\n\t */\n\trc = txCommit(tid, 2, &iplist[0], commit_flag);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\twhile (new_size && (rc == 0)) {\n\t\ttid = txBegin(dip->i_sb, 0);\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\t\tnew_size = xtTruncate_pmap(tid, ip, new_size);\n\t\tif (new_size < 0) {\n\t\t\ttxAbort(tid, 1);\t/* Marks FS Dirty */\n\t\t\trc = new_size;\n\t\t} else\n\t\t\trc = txCommit(tid, 2, &iplist[0], COMMIT_SYNC);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t}\n\n\tif (ip->i_nlink == 0)\n\t\tset_cflag(COMMIT_Nolink, ip);\n\n\tIWRITE_UNLOCK(ip);\n\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out1:\n\tfree_UCSname(&dname);\n      out:\n\tjfs_info(\"jfs_unlink: rc:%d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "345-449",
    "snippet": "static int jfs_rmdir(struct inode *dip, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_rmdir: dip:0x%p name:%pd\", dip, dentry);\n\n\t/* Init inode for quota operations. */\n\tdquot_initialize(dip);\n\tdquot_initialize(ip);\n\n\t/* directory must be empty to be removed */\n\tif (!dtEmpty(ip)) {\n\t\trc = -ENOTEMPTY;\n\t\tgoto out;\n\t}\n\n\tif ((rc = get_UCSname(&dname, dentry))) {\n\t\tgoto out;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_DELETE;\n\ttblk->u.ip = ip;\n\n\t/*\n\t * delete the entry of target directory from parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_rmdir: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t\tgoto out2;\n\t}\n\n\t/* update parent directory's link count corresponding\n\t * to \"..\" entry of the target directory deleted\n\t */\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tinode_dec_link_count(dip);\n\n\t/*\n\t * OS/2 could have created EA and/or ACL\n\t */\n\t/* free EA from both persistent and working map */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\t/* free EA pages */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\t}\n\tJFS_IP(ip)->ea.flag = 0;\n\n\t/* free ACL from both persistent and working map */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\t/* free ACL pages */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\t}\n\tJFS_IP(ip)->acl.flag = 0;\n\n\t/* mark the target directory as deleted */\n\tclear_nlink(ip);\n\tmark_inode_dirty(ip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out:\n\tjfs_info(\"jfs_rmdir: rc:%d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_rmdir: rc:%d\"",
            "rc"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&dname"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_cflag",
          "args": [
            "COMMIT_Stale",
            "dip"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_truncate_nolock",
          "args": [
            "dip",
            "0"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_truncate_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/inode.c",
          "lines": "374-412",
          "snippet": "void jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_extent.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_extent.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/fs.h>\n\nvoid jfs_truncate_nolock(struct inode *ip, loff_t length)\n{\n\tloff_t newsize;\n\ttid_t tid;\n\n\tASSERT(length >= 0);\n\n\tif (test_cflag(COMMIT_Nolink, ip)) {\n\t\txtTruncate(0, ip, length, COMMIT_WMAP);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ttid = txBegin(ip->i_sb, 0);\n\n\t\t/*\n\t\t * The commit_mutex cannot be taken before txBegin.\n\t\t * txBegin may block and there is a chance the inode\n\t\t * could be marked dirty and need to be committed\n\t\t * before txBegin unblocks\n\t\t */\n\t\tmutex_lock(&JFS_IP(ip)->commit_mutex);\n\n\t\tnewsize = xtTruncate(tid, ip, length,\n\t\t\t\t     COMMIT_TRUNCATE | COMMIT_PWMAP);\n\t\tif (newsize < 0) {\n\t\t\ttxEnd(tid);\n\t\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\tip->i_mtime = ip->i_ctime = CURRENT_TIME;\n\t\tmark_inode_dirty(ip);\n\n\t\ttxCommit(tid, 1, &ip, 0);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t} while (newsize > length);\t/* Truncate isn't always atomic */\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_cflag",
          "args": [
            "COMMIT_Stale",
            "dip"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "dip"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "2",
            "&iplist[0]",
            "0"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "ip"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "ip"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txEA",
          "args": [
            "tid",
            "ip",
            "&JFS_IP(ip)->acl",
            "NULL"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "txEA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2173-2217",
          "snippet": "void txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nvoid txEA(tid_t tid, struct inode *ip, dxd_t * oldea, dxd_t * newea)\n{\n\tstruct tlock *tlck = NULL;\n\tstruct pxd_lock *maplock = NULL, *pxdlock = NULL;\n\n\t/*\n\t * format maplock for alloc of new EA extent\n\t */\n\tif (newea) {\n\t\t/* Since the newea could be a completely zeroed entry we need to\n\t\t * check for the two flags which indicate we should actually\n\t\t * commit new EA data\n\t\t */\n\t\tif (newea->flag & DXD_EXTENT) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tpxdlock->flag = mlckALLOCPXD;\n\t\t\tPXDaddress(&pxdlock->pxd, addressDXD(newea));\n\t\t\tPXDlength(&pxdlock->pxd, lengthDXD(newea));\n\t\t\tpxdlock++;\n\t\t\tmaplock->index = 1;\n\t\t} else if (newea->flag & DXD_INLINE) {\n\t\t\ttlck = NULL;\n\n\t\t\tset_cflag(COMMIT_Inlineea, ip);\n\t\t}\n\t}\n\n\t/*\n\t * format maplock for free of old EA extent\n\t */\n\tif (!test_cflag(COMMIT_Nolink, ip) && oldea->flag & DXD_EXTENT) {\n\t\tif (tlck == NULL) {\n\t\t\ttlck = txMaplock(tid, ip, tlckMAP);\n\t\t\tmaplock = (struct pxd_lock *) & tlck->lock;\n\t\t\tpxdlock = (struct pxd_lock *) maplock;\n\t\t\tmaplock->index = 0;\n\t\t}\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tPXDaddress(&pxdlock->pxd, addressDXD(oldea));\n\t\tPXDlength(&pxdlock->pxd, lengthDXD(oldea));\n\t\tmaplock->index++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "dip"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "1"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_rmdir: dtDelete returned %d\"",
            "rc"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtDelete",
          "args": [
            "tid",
            "dip",
            "&dname",
            "&ino",
            "JFS_REMOVE"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "dtDeleteUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2237-2436",
          "snippet": "static int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(dip)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "dip->i_sb",
            "0"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&dname",
            "dentry"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtEmpty",
          "args": [
            "ip"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "ip"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_rmdir: dip:0x%p name:%pd\"",
            "dip",
            "dentry"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic int jfs_rmdir(struct inode *dip, struct dentry *dentry)\n{\n\tint rc;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = dentry->d_inode;\n\tino_t ino;\n\tstruct component_name dname;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_rmdir: dip:0x%p name:%pd\", dip, dentry);\n\n\t/* Init inode for quota operations. */\n\tdquot_initialize(dip);\n\tdquot_initialize(ip);\n\n\t/* directory must be empty to be removed */\n\tif (!dtEmpty(ip)) {\n\t\trc = -ENOTEMPTY;\n\t\tgoto out;\n\t}\n\n\tif ((rc = get_UCSname(&dname, dentry))) {\n\t\tgoto out;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_DELETE;\n\ttblk->u.ip = ip;\n\n\t/*\n\t * delete the entry of target directory from parent directory\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtDelete(tid, dip, &dname, &ino, JFS_REMOVE))) {\n\t\tjfs_err(\"jfs_rmdir: dtDelete returned %d\", rc);\n\t\tif (rc == -EIO)\n\t\t\ttxAbort(tid, 1);\n\t\ttxEnd(tid);\n\t\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\t\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t\tgoto out2;\n\t}\n\n\t/* update parent directory's link count corresponding\n\t * to \"..\" entry of the target directory deleted\n\t */\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tinode_dec_link_count(dip);\n\n\t/*\n\t * OS/2 could have created EA and/or ACL\n\t */\n\t/* free EA from both persistent and working map */\n\tif (JFS_IP(ip)->ea.flag & DXD_EXTENT) {\n\t\t/* free EA pages */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->ea, NULL);\n\t}\n\tJFS_IP(ip)->ea.flag = 0;\n\n\t/* free ACL from both persistent and working map */\n\tif (JFS_IP(ip)->acl.flag & DXD_EXTENT) {\n\t\t/* free ACL pages */\n\t\ttxEA(tid, ip, &JFS_IP(ip)->acl, NULL);\n\t}\n\tJFS_IP(ip)->acl.flag = 0;\n\n\t/* mark the target directory as deleted */\n\tclear_nlink(ip);\n\tmark_inode_dirty(ip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n\ttxEnd(tid);\n\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\n\t/*\n\t * Truncating the directory index table is not guaranteed.  It\n\t * may need to be done iteratively\n\t */\n\tif (test_cflag(COMMIT_Stale, dip)) {\n\t\tif (dip->i_size > 1)\n\t\t\tjfs_truncate_nolock(dip, 0);\n\n\t\tclear_cflag(COMMIT_Stale, dip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out:\n\tjfs_info(\"jfs_rmdir: rc:%d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "208-324",
    "snippet": "static int jfs_mkdir(struct inode *dip, struct dentry *dentry, umode_t mode)\n{\n\tint rc = 0;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = NULL;\t/* child directory inode */\n\tino_t ino;\n\tstruct component_name dname;\t/* child directory name */\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_mkdir: dip:0x%p name:%pd\", dip, dentry);\n\n\tdquot_initialize(dip);\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we\n\t * block there while holding dtree page, so we allocate the inode &\n\t * begin the transaction before we search the directory.\n\t */\n\tip = ialloc(dip, S_IFDIR | mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\tjfs_err(\"jfs_mkdir: dtSearch returned %d\", rc);\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * initialize the child directory in-line in inode\n\t */\n\tdtInitRoot(tid, ip, dip->i_ino);\n\n\t/*\n\t * create entry in parent directory for child directory\n\t * (dtInsert() releases parent directory page)\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {\n\t\tif (rc == -EIO) {\n\t\t\tjfs_err(\"jfs_mkdir: dtInsert returned -EIO\");\n\t\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\t} else\n\t\t\ttxAbort(tid, 0);\t/* Filesystem full */\n\t\tgoto out3;\n\t}\n\n\tset_nlink(ip, 2);\t/* for '.' */\n\tip->i_op = &jfs_dir_inode_operations;\n\tip->i_fop = &jfs_dir_operations;\n\n\tmark_inode_dirty(ip);\n\n\t/* update parent directory inode */\n\tinc_nlink(dip);\t\t/* for '..' from child directory */\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n\n      out1:\n\n\tjfs_info(\"jfs_mkdir: rc:%d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);",
      "const struct inode_operations jfs_dir_inode_operations = {\n\t.create\t\t= jfs_create,\n\t.lookup\t\t= jfs_lookup,\n\t.link\t\t= jfs_link,\n\t.unlink\t\t= jfs_unlink,\n\t.symlink\t= jfs_symlink,\n\t.mkdir\t\t= jfs_mkdir,\n\t.rmdir\t\t= jfs_rmdir,\n\t.mknod\t\t= jfs_mknod,\n\t.rename\t\t= jfs_rename,\n\t.setxattr\t= jfs_setxattr,\n\t.getxattr\t= jfs_getxattr,\n\t.listxattr\t= jfs_listxattr,\n\t.removexattr\t= jfs_removexattr,\n\t.setattr\t= jfs_setattr,\n#ifdef CONFIG_JFS_POSIX_ACL\n\t.get_acl\t= jfs_get_acl,\n\t.set_acl\t= jfs_set_acl,\n#endif\n};",
      "const struct file_operations jfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= jfs_readdir,\n\t.fsync\t\t= jfs_fsync,\n\t.unlocked_ioctl = jfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= jfs_compat_ioctl,\n#endif\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mkdir: rc:%d\"",
            "rc"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&dname"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "ip"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "ip"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "ip"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ea_wmap",
          "args": [
            "ip"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "free_ea_wmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
          "lines": "49-59",
          "snippet": "static inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static s64 commitZeroLink(tid_t, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "dip"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "2",
            "&iplist[0]",
            "0"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dip"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dip"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "ip",
            "2"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "0"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mkdir: dtInsert returned -EIO\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtInsert",
          "args": [
            "tid",
            "dip",
            "&dname",
            "&ino",
            "&btstack"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtInitRoot",
          "args": [
            "tid",
            "ip",
            "dip->i_ino"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "dtInitRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2826-2909",
          "snippet": "void dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tdtroot_t *p;\n\tint fsi;\n\tstruct dtslot *f;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tu16 xflag_save;\n\n\t/*\n\t * If this was previously an non-empty directory, we need to remove\n\t * the old directory table.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (!jfs_dirtable_inline(ip)) {\n\t\t\tstruct tblock *tblk = tid_to_tblock(tid);\n\t\t\t/*\n\t\t\t * We're playing games with the tid's xflag.  If\n\t\t\t * we're removing a regular file, the file's xtree\n\t\t\t * is committed with COMMIT_PMAP, but we always\n\t\t\t * commit the directories xtree with COMMIT_PWMAP.\n\t\t\t */\n\t\t\txflag_save = tblk->xflag;\n\t\t\ttblk->xflag = 0;\n\t\t\t/*\n\t\t\t * xtTruncate isn't guaranteed to fully truncate\n\t\t\t * the xtree.  The caller needs to check i_size\n\t\t\t * after committing the transaction to see if\n\t\t\t * additional truncation is needed.  The\n\t\t\t * COMMIT_Stale flag tells caller that we\n\t\t\t * initiated the truncation.\n\t\t\t */\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tset_cflag(COMMIT_Stale, ip);\n\n\t\t\ttblk->xflag = xflag_save;\n\t\t} else\n\t\t\tip->i_size = 1;\n\n\t\tjfs_ip->next_index = 2;\n\t} else\n\t\tip->i_size = IDATASIZE;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action: directory initialization;\n\t */\n\ttlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\n\t\t      tlckDTREE | tlckENTRY | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\tp = &jfs_ip->i_dtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\n\tp->header.nextindex = 0;\n\n\t/* init freelist */\n\tfsi = 1;\n\tf = &p->slot[fsi];\n\n\t/* init data area of root */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tp->header.freelist = 1;\n\tp->header.freecnt = 8;\n\n\t/* init '..' entry */\n\tp->header.idotdot = cpu_to_le32(idotdot);\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nvoid dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tdtroot_t *p;\n\tint fsi;\n\tstruct dtslot *f;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tu16 xflag_save;\n\n\t/*\n\t * If this was previously an non-empty directory, we need to remove\n\t * the old directory table.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (!jfs_dirtable_inline(ip)) {\n\t\t\tstruct tblock *tblk = tid_to_tblock(tid);\n\t\t\t/*\n\t\t\t * We're playing games with the tid's xflag.  If\n\t\t\t * we're removing a regular file, the file's xtree\n\t\t\t * is committed with COMMIT_PMAP, but we always\n\t\t\t * commit the directories xtree with COMMIT_PWMAP.\n\t\t\t */\n\t\t\txflag_save = tblk->xflag;\n\t\t\ttblk->xflag = 0;\n\t\t\t/*\n\t\t\t * xtTruncate isn't guaranteed to fully truncate\n\t\t\t * the xtree.  The caller needs to check i_size\n\t\t\t * after committing the transaction to see if\n\t\t\t * additional truncation is needed.  The\n\t\t\t * COMMIT_Stale flag tells caller that we\n\t\t\t * initiated the truncation.\n\t\t\t */\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tset_cflag(COMMIT_Stale, ip);\n\n\t\t\ttblk->xflag = xflag_save;\n\t\t} else\n\t\t\tip->i_size = 1;\n\n\t\tjfs_ip->next_index = 2;\n\t} else\n\t\tip->i_size = IDATASIZE;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action: directory initialization;\n\t */\n\ttlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\n\t\t      tlckDTREE | tlckENTRY | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\tp = &jfs_ip->i_dtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\n\tp->header.nextindex = 0;\n\n\t/* init freelist */\n\tfsi = 1;\n\tf = &p->slot[fsi];\n\n\t/* init data area of root */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tp->header.freelist = 1;\n\tp->header.freecnt = 8;\n\n\t/* init '..' entry */\n\tp->header.idotdot = cpu_to_le32(idotdot);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_mkdir: dtSearch returned %d\"",
            "rc"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "dip",
            "&dname",
            "&ino",
            "&btstack",
            "JFS_CREATE"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_init_security",
          "args": [
            "tid",
            "ip",
            "dip",
            "&dentry->d_name"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xattr.h",
          "lines": "70-74",
          "snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_init_acl",
          "args": [
            "tid",
            "ip",
            "dip"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_init_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_acl.h",
          "lines": "29-33",
          "snippet": "static inline int jfs_init_acl(tid_t tid, struct inode *inode,\n\t\t\t       struct inode *dir)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int jfs_init_acl(tid_t tid, struct inode *inode,\n\t\t\t       struct inode *dir)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(dip)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "dip->i_sb",
            "0"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ip"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ip"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ialloc",
          "args": [
            "dip",
            "S_IFDIR | mode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "72-165",
          "snippet": "struct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstruct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&dname",
            "dentry"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dip"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_mkdir: dip:0x%p name:%pd\"",
            "dip",
            "dentry"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\nconst struct inode_operations jfs_dir_inode_operations = {\n\t.create\t\t= jfs_create,\n\t.lookup\t\t= jfs_lookup,\n\t.link\t\t= jfs_link,\n\t.unlink\t\t= jfs_unlink,\n\t.symlink\t= jfs_symlink,\n\t.mkdir\t\t= jfs_mkdir,\n\t.rmdir\t\t= jfs_rmdir,\n\t.mknod\t\t= jfs_mknod,\n\t.rename\t\t= jfs_rename,\n\t.setxattr\t= jfs_setxattr,\n\t.getxattr\t= jfs_getxattr,\n\t.listxattr\t= jfs_listxattr,\n\t.removexattr\t= jfs_removexattr,\n\t.setattr\t= jfs_setattr,\n#ifdef CONFIG_JFS_POSIX_ACL\n\t.get_acl\t= jfs_get_acl,\n\t.set_acl\t= jfs_set_acl,\n#endif\n};\nconst struct file_operations jfs_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= jfs_readdir,\n\t.fsync\t\t= jfs_fsync,\n\t.unlocked_ioctl = jfs_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= jfs_compat_ioctl,\n#endif\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int jfs_mkdir(struct inode *dip, struct dentry *dentry, umode_t mode)\n{\n\tint rc = 0;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = NULL;\t/* child directory inode */\n\tino_t ino;\n\tstruct component_name dname;\t/* child directory name */\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_mkdir: dip:0x%p name:%pd\", dip, dentry);\n\n\tdquot_initialize(dip);\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we\n\t * block there while holding dtree page, so we allocate the inode &\n\t * begin the transaction before we search the directory.\n\t */\n\tip = ialloc(dip, S_IFDIR | mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\tjfs_err(\"jfs_mkdir: dtSearch returned %d\", rc);\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * initialize the child directory in-line in inode\n\t */\n\tdtInitRoot(tid, ip, dip->i_ino);\n\n\t/*\n\t * create entry in parent directory for child directory\n\t * (dtInsert() releases parent directory page)\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {\n\t\tif (rc == -EIO) {\n\t\t\tjfs_err(\"jfs_mkdir: dtInsert returned -EIO\");\n\t\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\t} else\n\t\t\ttxAbort(tid, 0);\t/* Filesystem full */\n\t\tgoto out3;\n\t}\n\n\tset_nlink(ip, 2);\t/* for '.' */\n\tip->i_op = &jfs_dir_inode_operations;\n\tip->i_fop = &jfs_dir_operations;\n\n\tmark_inode_dirty(ip);\n\n\t/* update parent directory inode */\n\tinc_nlink(dip);\t\t/* for '..' from child directory */\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(dip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n\n      out1:\n\n\tjfs_info(\"jfs_mkdir: rc:%d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "jfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "75-190",
    "snippet": "static int jfs_create(struct inode *dip, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\tint rc = 0;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = NULL;\t/* child directory inode */\n\tino_t ino;\n\tstruct component_name dname;\t/* child directory name */\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_create: dip:0x%p name:%pd\", dip, dentry);\n\n\tdquot_initialize(dip);\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we\n\t * block there while holding dtree page, so we allocate the inode &\n\t * begin the transaction before we search the directory.\n\t */\n\tip = ialloc(dip, mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\tjfs_err(\"jfs_create: dtSearch returned %d\", rc);\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * initialize the child XAD tree root in-line in inode\n\t */\n\txtInitRoot(tid, ip);\n\n\t/*\n\t * create entry in parent directory for child directory\n\t * (dtInsert() releases parent directory page)\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {\n\t\tif (rc == -EIO) {\n\t\t\tjfs_err(\"jfs_create: dtInsert returned -EIO\");\n\t\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\t} else\n\t\t\ttxAbort(tid, 0);\t/* Filesystem full */\n\t\tgoto out3;\n\t}\n\n\tip->i_op = &jfs_file_inode_operations;\n\tip->i_fop = &jfs_file_operations;\n\tip->i_mapping->a_ops = &jfs_aops;\n\n\tmark_inode_dirty(ip);\n\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\n\tmark_inode_dirty(dip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\n\tjfs_info(\"jfs_create: rc:%d\", rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_create: rc:%d\"",
            "rc"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_UCSname",
          "args": [
            "&dname"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "ip"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "ip"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "ip"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "ip"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ea_wmap",
          "args": [
            "ip"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "free_ea_wmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
          "lines": "49-59",
          "snippet": "static inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/exportfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static s64 commitZeroLink(tid_t, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(dip)->commit_mutex"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "dip"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&JFS_IP(ip)->commit_mutex"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "2",
            "&iplist[0]",
            "0"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dip"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txAbort",
          "args": [
            "tid",
            "0"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "txAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "2642-2689",
          "snippet": "void txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nvoid txAbort(tid_t tid, int dirty)\n{\n\tlid_t lid, next;\n\tstruct metapage *mp;\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct tlock *tlck;\n\n\t/*\n\t * free tlocks of the transaction\n\t */\n\tfor (lid = tblk->next; lid; lid = next) {\n\t\ttlck = lid_to_tlock(lid);\n\t\tnext = tlck->next;\n\t\tmp = tlck->mp;\n\t\tJFS_IP(tlck->ip)->xtlid = 0;\n\n\t\tif (mp) {\n\t\t\tmp->lid = 0;\n\n\t\t\t/*\n\t\t\t * reset lsn of page to avoid logwarap:\n\t\t\t *\n\t\t\t * (page may have been previously committed by another\n\t\t\t * transaction(s) but has not been paged, i.e.,\n\t\t\t * it may be on logsync list even though it has not\n\t\t\t * been logged for the current tx.)\n\t\t\t */\n\t\t\tif (mp->xflag & COMMIT_PAGE && mp->lsn)\n\t\t\t\tLogSyncRelease(mp);\n\t\t}\n\t\t/* insert tlock at head of freelist */\n\t\tTXN_LOCK();\n\t\ttxLockFree(lid);\n\t\tTXN_UNLOCK();\n\t}\n\n\t/* caller will free the transaction block */\n\n\ttblk->next = tblk->last = 0;\n\n\t/*\n\t * mark filesystem dirty\n\t */\n\tif (dirty)\n\t\tjfs_error(tblk->sb, \"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_create: dtInsert returned -EIO\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtInsert",
          "args": [
            "tid",
            "dip",
            "&dname",
            "&ino",
            "&btstack"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtInitRoot",
          "args": [
            "tid",
            "ip"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "xtInitRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3073-3098",
          "snippet": "void xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\n\nvoid xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_create: dtSearch returned %d\"",
            "rc"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "dip",
            "&dname",
            "&ino",
            "&btstack",
            "JFS_CREATE"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_init_security",
          "args": [
            "tid",
            "ip",
            "dip",
            "&dentry->d_name"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xattr.h",
          "lines": "70-74",
          "snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int jfs_init_security(tid_t tid, struct inode *inode,\n\t\t\t\t    struct inode *dir, const struct qstr *qstr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_init_acl",
          "args": [
            "tid",
            "ip",
            "dip"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_init_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_acl.h",
          "lines": "29-33",
          "snippet": "static inline int jfs_init_acl(tid_t tid, struct inode *inode,\n\t\t\t       struct inode *dir)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int jfs_init_acl(tid_t tid, struct inode *inode,\n\t\t\t       struct inode *dir)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(ip)->commit_mutex",
            "COMMIT_MUTEX_CHILD"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&JFS_IP(dip)->commit_mutex",
            "COMMIT_MUTEX_PARENT"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "dip->i_sb",
            "0"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ip"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ip"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ialloc",
          "args": [
            "dip",
            "mode"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_inode.c",
          "lines": "72-165",
          "snippet": "struct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstruct inode *ialloc(struct inode *parent, umode_t mode)\n{\n\tstruct super_block *sb = parent->i_sb;\n\tstruct inode *inode;\n\tstruct jfs_inode_info *jfs_inode;\n\tint rc;\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tjfs_warn(\"ialloc: new_inode returned NULL!\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjfs_inode = JFS_IP(inode);\n\n\trc = diAlloc(parent, S_ISDIR(mode), inode);\n\tif (rc) {\n\t\tjfs_warn(\"ialloc: diAlloc returned %d!\", rc);\n\t\tif (rc == -EIO)\n\t\t\tmake_bad_inode(inode);\n\t\tgoto fail_put;\n\t}\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\trc = -EINVAL;\n\t\tgoto fail_put;\n\t}\n\n\tinode_init_owner(inode, parent, mode);\n\t/*\n\t * New inodes need to save sane values on disk when\n\t * uid & gid mount options are used\n\t */\n\tjfs_inode->saved_uid = inode->i_uid;\n\tjfs_inode->saved_gid = inode->i_gid;\n\n\t/*\n\t * Allocate inode to quota.\n\t */\n\tdquot_initialize(inode);\n\trc = dquot_alloc_inode(inode);\n\tif (rc)\n\t\tgoto fail_drop;\n\n\t/* inherit flags from parent */\n\tjfs_inode->mode2 = JFS_IP(parent)->mode2 & JFS_FL_INHERIT;\n\n\tif (S_ISDIR(mode)) {\n\t\tjfs_inode->mode2 |= IDIRECTORY;\n\t\tjfs_inode->mode2 &= ~JFS_DIRSYNC_FL;\n\t}\n\telse {\n\t\tjfs_inode->mode2 |= INLINEEA | ISPARSE;\n\t\tif (S_ISLNK(mode))\n\t\t\tjfs_inode->mode2 &= ~(JFS_IMMUTABLE_FL|JFS_APPEND_FL);\n\t}\n\tjfs_inode->mode2 |= inode->i_mode;\n\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tjfs_inode->otime = inode->i_ctime.tv_sec;\n\tinode->i_generation = JFS_SBI(sb)->gengen++;\n\n\tjfs_inode->cflag = 0;\n\n\t/* Zero remaining fields */\n\tmemset(&jfs_inode->acl, 0, sizeof(dxd_t));\n\tmemset(&jfs_inode->ea, 0, sizeof(dxd_t));\n\tjfs_inode->next_index = 0;\n\tjfs_inode->acltype = 0;\n\tjfs_inode->btorder = 0;\n\tjfs_inode->btindex = 0;\n\tjfs_inode->bxflag = 0;\n\tjfs_inode->blid = 0;\n\tjfs_inode->atlhead = 0;\n\tjfs_inode->atltail = 0;\n\tjfs_inode->xtlid = 0;\n\tjfs_set_inode_flags(inode);\n\n\tjfs_info(\"ialloc returns inode = 0x%p\\n\", inode);\n\n\treturn inode;\n\nfail_drop:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail_put:\n\tiput(inode);\nfail:\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_UCSname",
          "args": [
            "&dname",
            "dentry"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "get_UCSname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "115-138",
          "snippet": "int get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\n{\n\tstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\n\tint length = dentry->d_name.len;\n\n\tif (length > JFS_NAME_MAX)\n\t\treturn -ENAMETOOLONG;\n\n\tuniName->name =\n\t    kmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\n\n\tif (uniName->name == NULL)\n\t\treturn -ENOMEM;\n\n\tuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\n\t\t\t\t       length, nls_tab);\n\n\tif (uniName->namlen < 0) {\n\t\tkfree(uniName->name);\n\t\treturn uniName->namlen;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dip"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"jfs_create: dip:0x%p name:%pd\"",
            "dip",
            "dentry"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic int jfs_create(struct inode *dip, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\tint rc = 0;\n\ttid_t tid;\t\t/* transaction id */\n\tstruct inode *ip = NULL;\t/* child directory inode */\n\tino_t ino;\n\tstruct component_name dname;\t/* child directory name */\n\tstruct btstack btstack;\n\tstruct inode *iplist[2];\n\tstruct tblock *tblk;\n\n\tjfs_info(\"jfs_create: dip:0x%p name:%pd\", dip, dentry);\n\n\tdquot_initialize(dip);\n\n\t/*\n\t * search parent directory for entry/freespace\n\t * (dtSearch() returns parent directory page pinned)\n\t */\n\tif ((rc = get_UCSname(&dname, dentry)))\n\t\tgoto out1;\n\n\t/*\n\t * Either iAlloc() or txBegin() may block.  Deadlock can occur if we\n\t * block there while holding dtree page, so we allocate the inode &\n\t * begin the transaction before we search the directory.\n\t */\n\tip = ialloc(dip, mode);\n\tif (IS_ERR(ip)) {\n\t\trc = PTR_ERR(ip);\n\t\tgoto out2;\n\t}\n\n\ttid = txBegin(dip->i_sb, 0);\n\n\tmutex_lock_nested(&JFS_IP(dip)->commit_mutex, COMMIT_MUTEX_PARENT);\n\tmutex_lock_nested(&JFS_IP(ip)->commit_mutex, COMMIT_MUTEX_CHILD);\n\n\trc = jfs_init_acl(tid, ip, dip);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = jfs_init_security(tid, ip, dip, &dentry->d_name);\n\tif (rc) {\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\tif ((rc = dtSearch(dip, &dname, &ino, &btstack, JFS_CREATE))) {\n\t\tjfs_err(\"jfs_create: dtSearch returned %d\", rc);\n\t\ttxAbort(tid, 0);\n\t\tgoto out3;\n\t}\n\n\ttblk = tid_to_tblock(tid);\n\ttblk->xflag |= COMMIT_CREATE;\n\ttblk->ino = ip->i_ino;\n\ttblk->u.ixpxd = JFS_IP(ip)->ixpxd;\n\n\tiplist[0] = dip;\n\tiplist[1] = ip;\n\n\t/*\n\t * initialize the child XAD tree root in-line in inode\n\t */\n\txtInitRoot(tid, ip);\n\n\t/*\n\t * create entry in parent directory for child directory\n\t * (dtInsert() releases parent directory page)\n\t */\n\tino = ip->i_ino;\n\tif ((rc = dtInsert(tid, dip, &dname, &ino, &btstack))) {\n\t\tif (rc == -EIO) {\n\t\t\tjfs_err(\"jfs_create: dtInsert returned -EIO\");\n\t\t\ttxAbort(tid, 1);\t/* Marks Filesystem dirty */\n\t\t} else\n\t\t\ttxAbort(tid, 0);\t/* Filesystem full */\n\t\tgoto out3;\n\t}\n\n\tip->i_op = &jfs_file_inode_operations;\n\tip->i_fop = &jfs_file_operations;\n\tip->i_mapping->a_ops = &jfs_aops;\n\n\tmark_inode_dirty(ip);\n\n\tdip->i_ctime = dip->i_mtime = CURRENT_TIME;\n\n\tmark_inode_dirty(dip);\n\n\trc = txCommit(tid, 2, &iplist[0], 0);\n\n      out3:\n\ttxEnd(tid);\n\tmutex_unlock(&JFS_IP(ip)->commit_mutex);\n\tmutex_unlock(&JFS_IP(dip)->commit_mutex);\n\tif (rc) {\n\t\tfree_ea_wmap(ip);\n\t\tclear_nlink(ip);\n\t\tunlock_new_inode(ip);\n\t\tiput(ip);\n\t} else {\n\t\tunlock_new_inode(ip);\n\t\td_instantiate(dentry, ip);\n\t}\n\n      out2:\n\tfree_UCSname(&dname);\n\n      out1:\n\n\tjfs_info(\"jfs_create: rc:%d\", rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "free_ea_wmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/namei.c",
    "lines": "49-59",
    "snippet": "static inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_acl.h\"",
      "#include \"jfs_xattr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_dinode.h\"",
      "#include \"jfs_inode.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/exportfs.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64 commitZeroLink(tid_t, struct inode *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "inode",
            "addressDXD(ea)",
            "lengthDXD(ea)"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthDXD",
          "args": [
            "ea"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressDXD",
          "args": [
            "ea"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_dxd_metapages",
          "args": [
            "inode",
            "*ea"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_xattr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/exportfs.h>\n#include <linux/quotaops.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic s64 commitZeroLink(tid_t, struct inode *);\n\nstatic inline void free_ea_wmap(struct inode *inode)\n{\n\tdxd_t *ea = &JFS_IP(inode)->ea;\n\n\tif (ea->flag & DXD_EXTENT) {\n\t\t/* free EA pages from cache */\n\t\tinvalidate_dxd_metapages(inode, *ea);\n\t\tdbFree(inode, addressDXD(ea), lengthDXD(ea));\n\t}\n\tea->flag = 0;\n}"
  }
]