[
  {
    "function_name": "cifs_crypto_shash_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "783-814",
    "snippet": "void\ncifs_crypto_shash_release(struct TCP_Server_Info *server)\n{\n\tif (server->secmech.cmacaes) {\n\t\tcrypto_free_shash(server->secmech.cmacaes);\n\t\tserver->secmech.cmacaes = NULL;\n\t}\n\n\tif (server->secmech.hmacsha256) {\n\t\tcrypto_free_shash(server->secmech.hmacsha256);\n\t\tserver->secmech.hmacsha256 = NULL;\n\t}\n\n\tif (server->secmech.md5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t}\n\n\tif (server->secmech.hmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t}\n\n\tkfree(server->secmech.sdesccmacaes);\n\tserver->secmech.sdesccmacaes = NULL;\n\tkfree(server->secmech.sdeschmacsha256);\n\tserver->secmech.sdeschmacsha256 = NULL;\n\tkfree(server->secmech.sdeschmacmd5);\n\tserver->secmech.sdeschmacmd5 = NULL;\n\tkfree(server->secmech.sdescmd5);\n\tserver->secmech.sdescmd5 = NULL;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->secmech.sdescmd5"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->secmech.sdeschmacmd5"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->secmech.sdeschmacsha256"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server->secmech.sdesccmacaes"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "server->secmech.hmacmd5"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "server->secmech.md5"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "server->secmech.hmacsha256"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "server->secmech.cmacaes"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid\ncifs_crypto_shash_release(struct TCP_Server_Info *server)\n{\n\tif (server->secmech.cmacaes) {\n\t\tcrypto_free_shash(server->secmech.cmacaes);\n\t\tserver->secmech.cmacaes = NULL;\n\t}\n\n\tif (server->secmech.hmacsha256) {\n\t\tcrypto_free_shash(server->secmech.hmacsha256);\n\t\tserver->secmech.hmacsha256 = NULL;\n\t}\n\n\tif (server->secmech.md5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t}\n\n\tif (server->secmech.hmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t}\n\n\tkfree(server->secmech.sdesccmacaes);\n\tserver->secmech.sdesccmacaes = NULL;\n\tkfree(server->secmech.sdeschmacsha256);\n\tserver->secmech.sdeschmacsha256 = NULL;\n\tkfree(server->secmech.sdeschmacmd5);\n\tserver->secmech.sdeschmacmd5 = NULL;\n\tkfree(server->secmech.sdescmd5);\n\tserver->secmech.sdescmd5 = NULL;\n}"
  },
  {
    "function_name": "calc_seckey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "735-781",
    "snippet": "int\ncalc_seckey(struct cifs_ses *ses)\n{\n\tint rc;\n\tstruct crypto_blkcipher *tfm_arc4;\n\tstruct scatterlist sgin, sgout;\n\tstruct blkcipher_desc desc;\n\tunsigned char sec_key[CIFS_SESS_KEY_SIZE]; /* a nonce */\n\n\tget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\n\n\ttfm_arc4 = crypto_alloc_blkcipher(\"ecb(arc4)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_arc4)) {\n\t\trc = PTR_ERR(tfm_arc4);\n\t\tcifs_dbg(VFS, \"could not allocate crypto API arc4\\n\");\n\t\treturn rc;\n\t}\n\n\tdesc.tfm = tfm_arc4;\n\n\trc = crypto_blkcipher_setkey(tfm_arc4, ses->auth_key.response,\n\t\t\t\t\tCIFS_SESS_KEY_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set response as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\tsg_init_one(&sgin, sec_key, CIFS_SESS_KEY_SIZE);\n\tsg_init_one(&sgout, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\n\trc = crypto_blkcipher_encrypt(&desc, &sgout, &sgin, CIFS_CPHTXT_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not encrypt session key rc: %d\\n\", rc);\n\t\tcrypto_free_blkcipher(tfm_arc4);\n\t\treturn rc;\n\t}\n\n\t/* make secondary_key/nonce as session key */\n\tmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\n\t/* and make len as that of session key only */\n\tses->auth_key.len = CIFS_SESS_KEY_SIZE;\n\n\tcrypto_free_blkcipher(tfm_arc4);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_blkcipher",
          "args": [
            "tfm_arc4"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ses->auth_key.response",
            "sec_key",
            "CIFS_SESS_KEY_SIZE"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_blkcipher",
          "args": [
            "tfm_arc4"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"could not encrypt session key rc: %d\\n\"",
            "rc"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_encrypt",
          "args": [
            "&desc",
            "&sgout",
            "&sgin",
            "CIFS_CPHTXT_SIZE"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&sgout",
            "ses->ntlmssp->ciphertext",
            "CIFS_CPHTXT_SIZE"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&sgin",
            "sec_key",
            "CIFS_SESS_KEY_SIZE"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not set response as a key\\n\"",
            "__func__"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_setkey",
          "args": [
            "tfm_arc4",
            "ses->auth_key.response",
            "CIFS_SESS_KEY_SIZE"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"could not allocate crypto API arc4\\n\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm_arc4"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm_arc4"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_blkcipher",
          "args": [
            "\"ecb(arc4)\"",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "sec_key",
            "CIFS_SESS_KEY_SIZE"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncalc_seckey(struct cifs_ses *ses)\n{\n\tint rc;\n\tstruct crypto_blkcipher *tfm_arc4;\n\tstruct scatterlist sgin, sgout;\n\tstruct blkcipher_desc desc;\n\tunsigned char sec_key[CIFS_SESS_KEY_SIZE]; /* a nonce */\n\n\tget_random_bytes(sec_key, CIFS_SESS_KEY_SIZE);\n\n\ttfm_arc4 = crypto_alloc_blkcipher(\"ecb(arc4)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_arc4)) {\n\t\trc = PTR_ERR(tfm_arc4);\n\t\tcifs_dbg(VFS, \"could not allocate crypto API arc4\\n\");\n\t\treturn rc;\n\t}\n\n\tdesc.tfm = tfm_arc4;\n\n\trc = crypto_blkcipher_setkey(tfm_arc4, ses->auth_key.response,\n\t\t\t\t\tCIFS_SESS_KEY_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set response as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\tsg_init_one(&sgin, sec_key, CIFS_SESS_KEY_SIZE);\n\tsg_init_one(&sgout, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\n\trc = crypto_blkcipher_encrypt(&desc, &sgout, &sgin, CIFS_CPHTXT_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not encrypt session key rc: %d\\n\", rc);\n\t\tcrypto_free_blkcipher(tfm_arc4);\n\t\treturn rc;\n\t}\n\n\t/* make secondary_key/nonce as session key */\n\tmemcpy(ses->auth_key.response, sec_key, CIFS_SESS_KEY_SIZE);\n\t/* and make len as that of session key only */\n\tses->auth_key.len = CIFS_SESS_KEY_SIZE;\n\n\tcrypto_free_blkcipher(tfm_arc4);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "setup_ntlmv2_rsp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "631-733",
    "snippet": "int\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc;\n\tint baselen;\n\tunsigned int tilen;\n\tstruct ntlmv2_resp *ntlmv2;\n\tchar ntlmv2_hash[16];\n\tunsigned char *tiblob = NULL; /* target info blob */\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\n\t\tif (!ses->domainName) {\n\t\t\trc = find_domain_name(ses, nls_cp);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(VFS, \"error %d finding domain name\\n\",\n\t\t\t\t\t rc);\n\t\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = build_avpair_blob(ses, nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"error %d building av pair blob\\n\", rc);\n\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t}\n\t}\n\n\tbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\n\ttilen = ses->auth_key.len;\n\ttiblob = ses->auth_key.response;\n\n\tses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\trc = ENOMEM;\n\t\tses->auth_key.len = 0;\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\tses->auth_key.len += baselen;\n\n\tntlmv2 = (struct ntlmv2_resp *)\n\t\t\t(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tntlmv2->blob_signature = cpu_to_le32(0x00000101);\n\tntlmv2->reserved = 0;\n\t/* Must be within 5 minutes of the server */\n\tntlmv2->time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));\n\tget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\n\tntlmv2->reserved2 = 0;\n\n\tmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\n\n\trc = crypto_hmacmd5_alloc(ses->server);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not crypto alloc hmacmd5 rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate ntlmv2_hash */\n\trc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not get v2 hash rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate first part of the client response (CR1) */\n\trc = CalcNTLMv2_response(ses, ntlmv2_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not calculate CR1 rc: %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* now calculate the session key for NTLMv2 */\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\tntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tntlmv2->ntlmv2_hash,\n\t\tCIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tses->auth_key.response);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsetup_ntlmv2_rsp_ret:\n\tkfree(tiblob);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tiblob"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not generate md5 hash\\n\"",
            "__func__"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "ses->auth_key.response"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with response\\n\"",
            "__func__"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "ntlmv2->ntlmv2_hash",
            "CIFS_HMAC_MD5_HASH_SIZE"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not init hmacmd5\\n\"",
            "__func__"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not set NTLMV2 Hash as a key\\n\"",
            "__func__"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_setkey",
          "args": [
            "ses->server->secmech.hmacmd5",
            "ntlmv2_hash",
            "CIFS_HMAC_MD5_HASH_SIZE"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Could not calculate CR1 rc: %d\\n\"",
            "rc"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CalcNTLMv2_response",
          "args": [
            "ses",
            "ntlmv2_hash"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "CalcNTLMv2_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "547-598",
          "snippet": "static int\nCalcNTLMv2_response(const struct cifs_ses *ses, char *ntlmv2_hash)\n{\n\tint rc;\n\tstruct ntlmv2_resp *ntlmv2 = (struct ntlmv2_resp *)\n\t    (ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tunsigned int hash_len;\n\n\t/* The MD5 hash starts at challenge_key.key */\n\thash_len = ses->auth_key.len - (CIFS_SESS_KEY_SIZE +\n\t\toffsetof(struct ntlmv2_resp, challenge.key[0]));\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\t\t\t ntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED)\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->ntlmssp->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\telse\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->server->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t ntlmv2->challenge.key, hash_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* Note that the MD5 digest over writes anon.challenge_key.key */\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\tntlmv2->ntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nCalcNTLMv2_response(const struct cifs_ses *ses, char *ntlmv2_hash)\n{\n\tint rc;\n\tstruct ntlmv2_resp *ntlmv2 = (struct ntlmv2_resp *)\n\t    (ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tunsigned int hash_len;\n\n\t/* The MD5 hash starts at challenge_key.key */\n\thash_len = ses->auth_key.len - (CIFS_SESS_KEY_SIZE +\n\t\toffsetof(struct ntlmv2_resp, challenge.key[0]));\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\t\t\t ntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED)\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->ntlmssp->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\telse\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->server->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t ntlmv2->challenge.key, hash_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* Note that the MD5 digest over writes anon.challenge_key.key */\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\tntlmv2->ntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"could not get v2 hash rc %d\\n\"",
            "rc"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_ntlmv2_hash",
          "args": [
            "ses",
            "ntlmv2_hash",
            "nls_cp"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "calc_ntlmv2_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "444-545",
          "snippet": "static int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,\n\t\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tint len;\n\tchar nt_hash[CIFS_NTHASH_SIZE];\n\t__le16 *user;\n\twchar_t *domain;\n\twchar_t *server;\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t/* calculate md4 hash of password */\n\tE_md4hash(ses->password, nt_hash, nls_cp);\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5, nt_hash,\n\t\t\t\tCIFS_NTHASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NT Hash as a key\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->user_name to unicode */\n\tlen = ses->user_name ? strlen(ses->user_name) : 0;\n\tuser = kmalloc(2 + (len * 2), GFP_KERNEL);\n\tif (user == NULL) {\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\n\tif (len) {\n\t\tlen = cifs_strtoUTF16(user, ses->user_name, len, nls_cp);\n\t\tUniStrupr(user);\n\t} else {\n\t\tmemset(user, '\\0', 2);\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t(char *)user, 2 * len);\n\tkfree(user);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with user\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->domainName to unicode and uppercase */\n\tif (ses->domainName) {\n\t\tlen = strlen(ses->domainName);\n\n\t\tdomain = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (domain == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)domain, ses->domainName, len,\n\t\t\t\t      nls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)domain, 2 * len);\n\t\tkfree(domain);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with domain\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t} else if (ses->serverName) {\n\t\tlen = strlen(ses->serverName);\n\n\t\tserver = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (server == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)server, ses->serverName, len,\n\t\t\t\t\tnls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)server, 2 * len);\n\t\tkfree(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with server\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\tntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,\n\t\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tint len;\n\tchar nt_hash[CIFS_NTHASH_SIZE];\n\t__le16 *user;\n\twchar_t *domain;\n\twchar_t *server;\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t/* calculate md4 hash of password */\n\tE_md4hash(ses->password, nt_hash, nls_cp);\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5, nt_hash,\n\t\t\t\tCIFS_NTHASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NT Hash as a key\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->user_name to unicode */\n\tlen = ses->user_name ? strlen(ses->user_name) : 0;\n\tuser = kmalloc(2 + (len * 2), GFP_KERNEL);\n\tif (user == NULL) {\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\n\tif (len) {\n\t\tlen = cifs_strtoUTF16(user, ses->user_name, len, nls_cp);\n\t\tUniStrupr(user);\n\t} else {\n\t\tmemset(user, '\\0', 2);\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t(char *)user, 2 * len);\n\tkfree(user);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with user\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->domainName to unicode and uppercase */\n\tif (ses->domainName) {\n\t\tlen = strlen(ses->domainName);\n\n\t\tdomain = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (domain == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)domain, ses->domainName, len,\n\t\t\t\t      nls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)domain, 2 * len);\n\t\tkfree(domain);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with domain\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t} else if (ses->serverName) {\n\t\tlen = strlen(ses->serverName);\n\n\t\tserver = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (server == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)server, ses->serverName, len,\n\t\t\t\t\tnls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)server, 2 * len);\n\t\tkfree(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with server\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\tntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"could not crypto alloc hmacmd5 rc %d\\n\"",
            "rc"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hmacmd5_alloc",
          "args": [
            "ses->server"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "crypto_hmacmd5_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "600-629",
          "snippet": "static int crypto_hmacmd5_alloc(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\t/* check if already allocated */\n\tif (server->secmech.sdeschmacmd5)\n\t\treturn 0;\n\n\tserver->secmech.hmacmd5 = crypto_alloc_shash(\"hmac(md5)\", 0, 0);\n\tif (IS_ERR(server->secmech.hmacmd5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto hmacmd5\\n\");\n\t\trc = PTR_ERR(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.hmacmd5);\n\tserver->secmech.sdeschmacmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdeschmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdeschmacmd5->shash.tfm = server->secmech.hmacmd5;\n\tserver->secmech.sdeschmacmd5->shash.flags = 0x0;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int crypto_hmacmd5_alloc(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\t/* check if already allocated */\n\tif (server->secmech.sdeschmacmd5)\n\t\treturn 0;\n\n\tserver->secmech.hmacmd5 = crypto_alloc_shash(\"hmac(md5)\", 0, 0);\n\tif (IS_ERR(server->secmech.hmacmd5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto hmacmd5\\n\");\n\t\trc = PTR_ERR(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.hmacmd5);\n\tserver->secmech.sdeschmacmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdeschmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdeschmacmd5->shash.tfm = server->secmech.hmacmd5;\n\tserver->secmech.sdeschmacmd5->shash.flags = 0x0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ses->auth_key.response + baselen",
            "tiblob",
            "tilen"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&ntlmv2->client_chal",
            "sizeof(ntlmv2->client_chal)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cifs_UnixTimeToNT(CURRENT_TIME)"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_UnixTimeToNT",
          "args": [
            "CURRENT_TIME"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_UnixTimeToNT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/netmisc.c",
          "lines": "951-956",
          "snippet": "u64\ncifs_UnixTimeToNT(struct timespec t)\n{\n\t/* Convert to 100ns intervals and then add the NTFS time offset. */\n\treturn (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;\n}",
          "includes": [
            "#include \"nterr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smberr.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/inet.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/div64.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>"
          ],
          "macros_used": [
            "#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nterr.h\"\n#include \"cifs_debug.h\"\n#include \"smberr.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/inet.h>\n#include <asm/byteorder.h>\n#include <asm/div64.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/net.h>\n\n#define NTFS_TIME_OFFSET ((u64)(369*365 + 89) * 24 * 3600 * 10000000)\n\nu64\ncifs_UnixTimeToNT(struct timespec t)\n{\n\t/* Convert to 100ns intervals and then add the NTFS time offset. */\n\treturn (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0x00000101"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "baselen + tilen",
            "GFP_KERNEL"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"error %d building av pair blob\\n\"",
            "rc"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_avpair_blob",
          "args": [
            "ses",
            "nls_cp"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "build_avpair_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "343-386",
          "snippet": "static int\nbuild_avpair_blob(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int dlen;\n\tunsigned int size = 2 * sizeof(struct ntlmssp2_name);\n\tchar *defdmname = \"WORKGROUP\";\n\tunsigned char *blobptr;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->domainName) {\n\t\tses->domainName = kstrdup(defdmname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdlen = strlen(ses->domainName);\n\n\t/*\n\t * The length of this blob is two times the size of a\n\t * structure (av pair) which holds name/size\n\t * ( for NTLMSSP_AV_NB_DOMAIN_NAME followed by NTLMSSP_AV_EOL ) +\n\t * unicode length of a netbios domain name\n\t */\n\tses->auth_key.len = size + 2 * dlen;\n\tses->auth_key.response = kzalloc(ses->auth_key.len, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tses->auth_key.len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tblobptr = ses->auth_key.response;\n\tattrptr = (struct ntlmssp2_name *) blobptr;\n\n\t/*\n\t * As defined in MS-NTLM 3.3.2, just this av pair field\n\t * is sufficient as part of the temp\n\t */\n\tattrptr->type = cpu_to_le16(NTLMSSP_AV_NB_DOMAIN_NAME);\n\tattrptr->length = cpu_to_le16(2 * dlen);\n\tblobptr = (unsigned char *)attrptr + sizeof(struct ntlmssp2_name);\n\tcifs_strtoUTF16((__le16 *)blobptr, ses->domainName, dlen, nls_cp);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nbuild_avpair_blob(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int dlen;\n\tunsigned int size = 2 * sizeof(struct ntlmssp2_name);\n\tchar *defdmname = \"WORKGROUP\";\n\tunsigned char *blobptr;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->domainName) {\n\t\tses->domainName = kstrdup(defdmname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdlen = strlen(ses->domainName);\n\n\t/*\n\t * The length of this blob is two times the size of a\n\t * structure (av pair) which holds name/size\n\t * ( for NTLMSSP_AV_NB_DOMAIN_NAME followed by NTLMSSP_AV_EOL ) +\n\t * unicode length of a netbios domain name\n\t */\n\tses->auth_key.len = size + 2 * dlen;\n\tses->auth_key.response = kzalloc(ses->auth_key.len, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tses->auth_key.len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tblobptr = ses->auth_key.response;\n\tattrptr = (struct ntlmssp2_name *) blobptr;\n\n\t/*\n\t * As defined in MS-NTLM 3.3.2, just this av pair field\n\t * is sufficient as part of the temp\n\t */\n\tattrptr->type = cpu_to_le16(NTLMSSP_AV_NB_DOMAIN_NAME);\n\tattrptr->length = cpu_to_le16(2 * dlen);\n\tblobptr = (unsigned char *)attrptr + sizeof(struct ntlmssp2_name);\n\tcifs_strtoUTF16((__le16 *)blobptr, ses->domainName, dlen, nls_cp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"error %d finding domain name\\n\"",
            "rc"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_domain_name",
          "args": [
            "ses",
            "nls_cp"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "find_domain_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "398-442",
          "snippet": "static int\nfind_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int attrsize;\n\tunsigned int type;\n\tunsigned int onesize = sizeof(struct ntlmssp2_name);\n\tunsigned char *blobptr;\n\tunsigned char *blobend;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->auth_key.len || !ses->auth_key.response)\n\t\treturn 0;\n\n\tblobptr = ses->auth_key.response;\n\tblobend = blobptr + ses->auth_key.len;\n\n\twhile (blobptr + onesize < blobend) {\n\t\tattrptr = (struct ntlmssp2_name *) blobptr;\n\t\ttype = le16_to_cpu(attrptr->type);\n\t\tif (type == NTLMSSP_AV_EOL)\n\t\t\tbreak;\n\t\tblobptr += 2; /* advance attr type */\n\t\tattrsize = le16_to_cpu(attrptr->length);\n\t\tblobptr += 2; /* advance attr size */\n\t\tif (blobptr + attrsize > blobend)\n\t\t\tbreak;\n\t\tif (type == NTLMSSP_AV_NB_DOMAIN_NAME) {\n\t\t\tif (!attrsize || attrsize >= CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\tbreak;\n\t\t\tif (!ses->domainName) {\n\t\t\t\tses->domainName =\n\t\t\t\t\tkmalloc(attrsize + 1, GFP_KERNEL);\n\t\t\t\tif (!ses->domainName)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tcifs_from_utf16(ses->domainName,\n\t\t\t\t\t(__le16 *)blobptr, attrsize, attrsize,\n\t\t\t\t\tnls_cp, NO_MAP_UNI_RSVD);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tblobptr += attrsize; /* advance attr  value */\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nfind_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int attrsize;\n\tunsigned int type;\n\tunsigned int onesize = sizeof(struct ntlmssp2_name);\n\tunsigned char *blobptr;\n\tunsigned char *blobend;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->auth_key.len || !ses->auth_key.response)\n\t\treturn 0;\n\n\tblobptr = ses->auth_key.response;\n\tblobend = blobptr + ses->auth_key.len;\n\n\twhile (blobptr + onesize < blobend) {\n\t\tattrptr = (struct ntlmssp2_name *) blobptr;\n\t\ttype = le16_to_cpu(attrptr->type);\n\t\tif (type == NTLMSSP_AV_EOL)\n\t\t\tbreak;\n\t\tblobptr += 2; /* advance attr type */\n\t\tattrsize = le16_to_cpu(attrptr->length);\n\t\tblobptr += 2; /* advance attr size */\n\t\tif (blobptr + attrsize > blobend)\n\t\t\tbreak;\n\t\tif (type == NTLMSSP_AV_NB_DOMAIN_NAME) {\n\t\t\tif (!attrsize || attrsize >= CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\tbreak;\n\t\t\tif (!ses->domainName) {\n\t\t\t\tses->domainName =\n\t\t\t\t\tkmalloc(attrsize + 1, GFP_KERNEL);\n\t\t\t\tif (!ses->domainName)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tcifs_from_utf16(ses->domainName,\n\t\t\t\t\t(__le16 *)blobptr, attrsize, attrsize,\n\t\t\t\t\tnls_cp, NO_MAP_UNI_RSVD);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tblobptr += attrsize; /* advance attr  value */\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nsetup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc;\n\tint baselen;\n\tunsigned int tilen;\n\tstruct ntlmv2_resp *ntlmv2;\n\tchar ntlmv2_hash[16];\n\tunsigned char *tiblob = NULL; /* target info blob */\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED) {\n\t\tif (!ses->domainName) {\n\t\t\trc = find_domain_name(ses, nls_cp);\n\t\t\tif (rc) {\n\t\t\t\tcifs_dbg(VFS, \"error %d finding domain name\\n\",\n\t\t\t\t\t rc);\n\t\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = build_avpair_blob(ses, nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"error %d building av pair blob\\n\", rc);\n\t\t\tgoto setup_ntlmv2_rsp_ret;\n\t\t}\n\t}\n\n\tbaselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);\n\ttilen = ses->auth_key.len;\n\ttiblob = ses->auth_key.response;\n\n\tses->auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\trc = ENOMEM;\n\t\tses->auth_key.len = 0;\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\tses->auth_key.len += baselen;\n\n\tntlmv2 = (struct ntlmv2_resp *)\n\t\t\t(ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tntlmv2->blob_signature = cpu_to_le32(0x00000101);\n\tntlmv2->reserved = 0;\n\t/* Must be within 5 minutes of the server */\n\tntlmv2->time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));\n\tget_random_bytes(&ntlmv2->client_chal, sizeof(ntlmv2->client_chal));\n\tntlmv2->reserved2 = 0;\n\n\tmemcpy(ses->auth_key.response + baselen, tiblob, tilen);\n\n\trc = crypto_hmacmd5_alloc(ses->server);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not crypto alloc hmacmd5 rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate ntlmv2_hash */\n\trc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not get v2 hash rc %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* calculate first part of the client response (CR1) */\n\trc = CalcNTLMv2_response(ses, ntlmv2_hash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Could not calculate CR1 rc: %d\\n\", rc);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\t/* now calculate the session key for NTLMv2 */\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\tntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init hmacmd5\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tntlmv2->ntlmv2_hash,\n\t\tCIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\tgoto setup_ntlmv2_rsp_ret;\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\tses->auth_key.response);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\nsetup_ntlmv2_rsp_ret:\n\tkfree(tiblob);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "crypto_hmacmd5_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "600-629",
    "snippet": "static int crypto_hmacmd5_alloc(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\t/* check if already allocated */\n\tif (server->secmech.sdeschmacmd5)\n\t\treturn 0;\n\n\tserver->secmech.hmacmd5 = crypto_alloc_shash(\"hmac(md5)\", 0, 0);\n\tif (IS_ERR(server->secmech.hmacmd5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto hmacmd5\\n\");\n\t\trc = PTR_ERR(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.hmacmd5);\n\tserver->secmech.sdeschmacmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdeschmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdeschmacmd5->shash.tfm = server->secmech.hmacmd5;\n\tserver->secmech.sdeschmacmd5->shash.flags = 0x0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "server->secmech.hmacmd5"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "server->secmech.hmacmd5"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server->secmech.hmacmd5"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"could not allocate crypto hmacmd5\\n\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server->secmech.hmacmd5"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"hmac(md5)\"",
            "0",
            "0"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int crypto_hmacmd5_alloc(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\t/* check if already allocated */\n\tif (server->secmech.sdeschmacmd5)\n\t\treturn 0;\n\n\tserver->secmech.hmacmd5 = crypto_alloc_shash(\"hmac(md5)\", 0, 0);\n\tif (IS_ERR(server->secmech.hmacmd5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto hmacmd5\\n\");\n\t\trc = PTR_ERR(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.hmacmd5);\n\tserver->secmech.sdeschmacmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdeschmacmd5) {\n\t\tcrypto_free_shash(server->secmech.hmacmd5);\n\t\tserver->secmech.hmacmd5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdeschmacmd5->shash.tfm = server->secmech.hmacmd5;\n\tserver->secmech.sdeschmacmd5->shash.flags = 0x0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "CalcNTLMv2_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "547-598",
    "snippet": "static int\nCalcNTLMv2_response(const struct cifs_ses *ses, char *ntlmv2_hash)\n{\n\tint rc;\n\tstruct ntlmv2_resp *ntlmv2 = (struct ntlmv2_resp *)\n\t    (ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tunsigned int hash_len;\n\n\t/* The MD5 hash starts at challenge_key.key */\n\thash_len = ses->auth_key.len - (CIFS_SESS_KEY_SIZE +\n\t\toffsetof(struct ntlmv2_resp, challenge.key[0]));\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\t\t\t ntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED)\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->ntlmssp->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\telse\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->server->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t ntlmv2->challenge.key, hash_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* Note that the MD5 digest over writes anon.challenge_key.key */\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\tntlmv2->ntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not generate md5 hash\\n\"",
            "__func__"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "ntlmv2->ntlmv2_hash"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with response\\n\"",
            "__func__"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "ntlmv2->challenge.key",
            "hash_len"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ntlmv2->challenge.key",
            "ses->server->cryptkey",
            "CIFS_SERVER_CHALLENGE_SIZE"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ntlmv2->challenge.key",
            "ses->ntlmssp->cryptkey",
            "CIFS_SERVER_CHALLENGE_SIZE"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: could not init hmacmd5\\n\"",
            "__func__"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not set NTLMV2 Hash as a key\\n\"",
            "__func__"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_setkey",
          "args": [
            "ses->server->secmech.hmacmd5",
            "ntlmv2_hash",
            "CIFS_HMAC_MD5_HASH_SIZE"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: can't generate ntlmv2 hash\\n\"",
            "__func__"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nCalcNTLMv2_response(const struct cifs_ses *ses, char *ntlmv2_hash)\n{\n\tint rc;\n\tstruct ntlmv2_resp *ntlmv2 = (struct ntlmv2_resp *)\n\t    (ses->auth_key.response + CIFS_SESS_KEY_SIZE);\n\tunsigned int hash_len;\n\n\t/* The MD5 hash starts at challenge_key.key */\n\thash_len = ses->auth_key.len - (CIFS_SESS_KEY_SIZE +\n\t\toffsetof(struct ntlmv2_resp, challenge.key[0]));\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5,\n\t\t\t\t ntlmv2_hash, CIFS_HMAC_MD5_HASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NTLMV2 Hash as a key\\n\",\n\t\t\t __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tif (ses->server->negflavor == CIFS_NEGFLAVOR_EXTENDED)\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->ntlmssp->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\telse\n\t\tmemcpy(ntlmv2->challenge.key,\n\t\t       ses->server->cryptkey, CIFS_SERVER_CHALLENGE_SIZE);\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t ntlmv2->challenge.key, hash_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* Note that the MD5 digest over writes anon.challenge_key.key */\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\tntlmv2->ntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "calc_ntlmv2_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "444-545",
    "snippet": "static int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,\n\t\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tint len;\n\tchar nt_hash[CIFS_NTHASH_SIZE];\n\t__le16 *user;\n\twchar_t *domain;\n\twchar_t *server;\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t/* calculate md4 hash of password */\n\tE_md4hash(ses->password, nt_hash, nls_cp);\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5, nt_hash,\n\t\t\t\tCIFS_NTHASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NT Hash as a key\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->user_name to unicode */\n\tlen = ses->user_name ? strlen(ses->user_name) : 0;\n\tuser = kmalloc(2 + (len * 2), GFP_KERNEL);\n\tif (user == NULL) {\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\n\tif (len) {\n\t\tlen = cifs_strtoUTF16(user, ses->user_name, len, nls_cp);\n\t\tUniStrupr(user);\n\t} else {\n\t\tmemset(user, '\\0', 2);\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t(char *)user, 2 * len);\n\tkfree(user);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with user\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->domainName to unicode and uppercase */\n\tif (ses->domainName) {\n\t\tlen = strlen(ses->domainName);\n\n\t\tdomain = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (domain == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)domain, ses->domainName, len,\n\t\t\t\t      nls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)domain, 2 * len);\n\t\tkfree(domain);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with domain\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t} else if (ses->serverName) {\n\t\tlen = strlen(ses->serverName);\n\n\t\tserver = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (server == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)server, ses->serverName, len,\n\t\t\t\t\tnls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)server, 2 * len);\n\t\tkfree(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with server\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\tntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not generate md5 hash\\n\"",
            "__func__"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "ntlmv2_hash"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with server\\n\"",
            "__func__"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "server"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "(char *)server",
            "2 * len"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *)server",
            "ses->serverName",
            "len",
            "nls_cp"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2 + (len * 2)",
            "GFP_KERNEL"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ses->serverName"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with domain\\n\"",
            "__func__"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "domain"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "(char *)domain",
            "2 * len"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with user\\n\"",
            "__func__"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "user"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash",
            "(char *)user",
            "2 * len"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "user",
            "'\\0'",
            "2"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UniStrupr",
          "args": [
            "user"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrupr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.h",
          "lines": "361-372",
          "snippet": "static inline __le16 *\nUniStrupr(register __le16 *upin)\n{\n\tregister __le16 *up;\n\n\tup = upin;\n\twhile (*up) {\t\t/* For all characters */\n\t\t*up = cpu_to_le16(UniToupper(le16_to_cpu(*up)));\n\t\tup++;\n\t}\n\treturn upin;\t\t/* Return input pointer */\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n#include <asm/byteorder.h>\n\nstatic inline __le16 *\nUniStrupr(register __le16 *upin)\n{\n\tregister __le16 *up;\n\n\tup = upin;\n\twhile (*up) {\t\t/* For all characters */\n\t\t*up = cpu_to_le16(UniToupper(le16_to_cpu(*up)));\n\t\tup++;\n\t}\n\treturn upin;\t\t/* Return input pointer */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: could not init hmacmd5\\n\"",
            "__func__"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&ses->server->secmech.sdeschmacmd5->shash"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not set NT Hash as a key\\n\"",
            "__func__"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_setkey",
          "args": [
            "ses->server->secmech.hmacmd5",
            "nt_hash",
            "CIFS_NTHASH_SIZE"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_md4hash",
          "args": [
            "ses->password",
            "nt_hash",
            "nls_cp"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "E_md4hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smbencrypt.c",
          "lines": "207-227",
          "snippet": "int\nE_md4hash(const unsigned char *passwd, unsigned char *p16,\n\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tint len;\n\t__le16 wpwd[129];\n\n\t/* Password cannot be longer than 128 characters */\n\tif (passwd) /* Password must be converted to NT unicode */\n\t\tlen = cifs_strtoUTF16(wpwd, passwd, 128, codepage);\n\telse {\n\t\tlen = 0;\n\t\t*wpwd = 0; /* Ensure string is null terminated */\n\t}\n\n\trc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));\n\tmemzero_explicit(wpwd, sizeof(wpwd));\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/random.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint\nE_md4hash(const unsigned char *passwd, unsigned char *p16,\n\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tint len;\n\t__le16 wpwd[129];\n\n\t/* Password cannot be longer than 128 characters */\n\tif (passwd) /* Password must be converted to NT unicode */\n\t\tlen = cifs_strtoUTF16(wpwd, passwd, 128, codepage);\n\telse {\n\t\tlen = 0;\n\t\t*wpwd = 0; /* Ensure string is null terminated */\n\t}\n\n\trc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));\n\tmemzero_explicit(wpwd, sizeof(wpwd));\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: can't generate ntlmv2 hash\\n\"",
            "__func__"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,\n\t\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tint len;\n\tchar nt_hash[CIFS_NTHASH_SIZE];\n\t__le16 *user;\n\twchar_t *domain;\n\twchar_t *server;\n\n\tif (!ses->server->secmech.sdeschmacmd5) {\n\t\tcifs_dbg(VFS, \"%s: can't generate ntlmv2 hash\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t/* calculate md4 hash of password */\n\tE_md4hash(ses->password, nt_hash, nls_cp);\n\n\trc = crypto_shash_setkey(ses->server->secmech.hmacmd5, nt_hash,\n\t\t\t\tCIFS_NTHASH_SIZE);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not set NT Hash as a key\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_init(&ses->server->secmech.sdeschmacmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: could not init hmacmd5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->user_name to unicode */\n\tlen = ses->user_name ? strlen(ses->user_name) : 0;\n\tuser = kmalloc(2 + (len * 2), GFP_KERNEL);\n\tif (user == NULL) {\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\n\tif (len) {\n\t\tlen = cifs_strtoUTF16(user, ses->user_name, len, nls_cp);\n\t\tUniStrupr(user);\n\t} else {\n\t\tmemset(user, '\\0', 2);\n\t}\n\n\trc = crypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t(char *)user, 2 * len);\n\tkfree(user);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with user\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\t/* convert ses->domainName to unicode and uppercase */\n\tif (ses->domainName) {\n\t\tlen = strlen(ses->domainName);\n\n\t\tdomain = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (domain == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)domain, ses->domainName, len,\n\t\t\t\t      nls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)domain, 2 * len);\n\t\tkfree(domain);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with domain\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t} else if (ses->serverName) {\n\t\tlen = strlen(ses->serverName);\n\n\t\tserver = kmalloc(2 + (len * 2), GFP_KERNEL);\n\t\tif (server == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t\tlen = cifs_strtoUTF16((__le16 *)server, ses->serverName, len,\n\t\t\t\t\tnls_cp);\n\t\trc =\n\t\tcrypto_shash_update(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\t(char *)server, 2 * len);\n\t\tkfree(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with server\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,\n\t\t\t\t\tntlmv2_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "find_domain_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "398-442",
    "snippet": "static int\nfind_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int attrsize;\n\tunsigned int type;\n\tunsigned int onesize = sizeof(struct ntlmssp2_name);\n\tunsigned char *blobptr;\n\tunsigned char *blobend;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->auth_key.len || !ses->auth_key.response)\n\t\treturn 0;\n\n\tblobptr = ses->auth_key.response;\n\tblobend = blobptr + ses->auth_key.len;\n\n\twhile (blobptr + onesize < blobend) {\n\t\tattrptr = (struct ntlmssp2_name *) blobptr;\n\t\ttype = le16_to_cpu(attrptr->type);\n\t\tif (type == NTLMSSP_AV_EOL)\n\t\t\tbreak;\n\t\tblobptr += 2; /* advance attr type */\n\t\tattrsize = le16_to_cpu(attrptr->length);\n\t\tblobptr += 2; /* advance attr size */\n\t\tif (blobptr + attrsize > blobend)\n\t\t\tbreak;\n\t\tif (type == NTLMSSP_AV_NB_DOMAIN_NAME) {\n\t\t\tif (!attrsize || attrsize >= CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\tbreak;\n\t\t\tif (!ses->domainName) {\n\t\t\t\tses->domainName =\n\t\t\t\t\tkmalloc(attrsize + 1, GFP_KERNEL);\n\t\t\t\tif (!ses->domainName)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tcifs_from_utf16(ses->domainName,\n\t\t\t\t\t(__le16 *)blobptr, attrsize, attrsize,\n\t\t\t\t\tnls_cp, NO_MAP_UNI_RSVD);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tblobptr += attrsize; /* advance attr  value */\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_from_utf16",
          "args": [
            "ses->domainName",
            "(__le16 *)blobptr",
            "attrsize",
            "attrsize",
            "nls_cp",
            "NO_MAP_UNI_RSVD"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_from_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "200-244",
          "snippet": "int\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\n\t\tconst struct nls_table *codepage, int map_type)\n{\n\tint i, charlen, safelen;\n\tint outlen = 0;\n\tint nullsize = nls_nullsize(codepage);\n\tint fromwords = fromlen / 2;\n\tchar tmp[NLS_MAX_CHARSET_SIZE];\n\t__u16 ftmp;\n\n\t/*\n\t * because the chars can be of varying widths, we need to take care\n\t * not to overflow the destination buffer when we get close to the\n\t * end of it. Until we get to this offset, we don't need to check\n\t * for overflow however.\n\t */\n\tsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\n\n\tfor (i = 0; i < fromwords; i++) {\n\t\tftmp = get_unaligned_le16(&from[i]);\n\t\tif (ftmp == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * check to see if converting this character might make the\n\t\t * conversion bleed into the null terminator\n\t\t */\n\t\tif (outlen >= safelen) {\n\t\t\tcharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\n\t\t\tif ((outlen + charlen) > (tolen - nullsize))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* put converted char into 'to' buffer */\n\t\tcharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\n\t\toutlen += charlen;\n\t}\n\n\t/* properly null-terminate string */\n\tfor (i = 0; i < nullsize; i++)\n\t\tto[outlen++] = 0;\n\n\treturn outlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "attrsize + 1",
            "GFP_KERNEL"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "attrptr->length"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nfind_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int attrsize;\n\tunsigned int type;\n\tunsigned int onesize = sizeof(struct ntlmssp2_name);\n\tunsigned char *blobptr;\n\tunsigned char *blobend;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->auth_key.len || !ses->auth_key.response)\n\t\treturn 0;\n\n\tblobptr = ses->auth_key.response;\n\tblobend = blobptr + ses->auth_key.len;\n\n\twhile (blobptr + onesize < blobend) {\n\t\tattrptr = (struct ntlmssp2_name *) blobptr;\n\t\ttype = le16_to_cpu(attrptr->type);\n\t\tif (type == NTLMSSP_AV_EOL)\n\t\t\tbreak;\n\t\tblobptr += 2; /* advance attr type */\n\t\tattrsize = le16_to_cpu(attrptr->length);\n\t\tblobptr += 2; /* advance attr size */\n\t\tif (blobptr + attrsize > blobend)\n\t\t\tbreak;\n\t\tif (type == NTLMSSP_AV_NB_DOMAIN_NAME) {\n\t\t\tif (!attrsize || attrsize >= CIFS_MAX_DOMAINNAME_LEN)\n\t\t\t\tbreak;\n\t\t\tif (!ses->domainName) {\n\t\t\t\tses->domainName =\n\t\t\t\t\tkmalloc(attrsize + 1, GFP_KERNEL);\n\t\t\t\tif (!ses->domainName)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tcifs_from_utf16(ses->domainName,\n\t\t\t\t\t(__le16 *)blobptr, attrsize, attrsize,\n\t\t\t\t\tnls_cp, NO_MAP_UNI_RSVD);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tblobptr += attrsize; /* advance attr  value */\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "build_avpair_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "343-386",
    "snippet": "static int\nbuild_avpair_blob(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int dlen;\n\tunsigned int size = 2 * sizeof(struct ntlmssp2_name);\n\tchar *defdmname = \"WORKGROUP\";\n\tunsigned char *blobptr;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->domainName) {\n\t\tses->domainName = kstrdup(defdmname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdlen = strlen(ses->domainName);\n\n\t/*\n\t * The length of this blob is two times the size of a\n\t * structure (av pair) which holds name/size\n\t * ( for NTLMSSP_AV_NB_DOMAIN_NAME followed by NTLMSSP_AV_EOL ) +\n\t * unicode length of a netbios domain name\n\t */\n\tses->auth_key.len = size + 2 * dlen;\n\tses->auth_key.response = kzalloc(ses->auth_key.len, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tses->auth_key.len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tblobptr = ses->auth_key.response;\n\tattrptr = (struct ntlmssp2_name *) blobptr;\n\n\t/*\n\t * As defined in MS-NTLM 3.3.2, just this av pair field\n\t * is sufficient as part of the temp\n\t */\n\tattrptr->type = cpu_to_le16(NTLMSSP_AV_NB_DOMAIN_NAME);\n\tattrptr->length = cpu_to_le16(2 * dlen);\n\tblobptr = (unsigned char *)attrptr + sizeof(struct ntlmssp2_name);\n\tcifs_strtoUTF16((__le16 *)blobptr, ses->domainName, dlen, nls_cp);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_strtoUTF16",
          "args": [
            "(__le16 *)blobptr",
            "ses->domainName",
            "dlen",
            "nls_cp"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strtoUTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "252-296",
          "snippet": "int\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\n\t      const struct nls_table *codepage)\n{\n\tint charlen;\n\tint i;\n\twchar_t wchar_to; /* needed to quiet sparse */\n\n\t/* special case for utf8 to handle no plane0 chars */\n\tif (!strcmp(codepage->charset, \"utf8\")) {\n\t\t/*\n\t\t * convert utf8 -> utf16, we assume we have enough space\n\t\t * as caller should have assumed conversion does not overflow\n\t\t * in destination len is length in wchar_t units (16bits)\n\t\t */\n\t\ti  = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\n\t\t\t\t       (wchar_t *) to, len);\n\n\t\t/* if success terminate and exit */\n\t\tif (i >= 0)\n\t\t\tgoto success;\n\t\t/*\n\t\t * if fails fall back to UCS encoding as this\n\t\t * function should not return negative values\n\t\t * currently can fail only if source contains\n\t\t * invalid encoded characters\n\t\t */\n\t}\n\n\tfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\n\t\tcharlen = codepage->char2uni(from, len, &wchar_to);\n\t\tif (charlen < 1) {\n\t\t\tcifs_dbg(VFS, \"strtoUTF16: char2uni of 0x%x returned %d\\n\",\n\t\t\t\t *from, charlen);\n\t\t\t/* A question mark */\n\t\t\twchar_to = 0x003f;\n\t\t\tcharlen = 1;\n\t\t}\n\t\tput_unaligned_le16(wchar_to, &to[i]);\n\t}\n\nsuccess:\n\tput_unaligned_le16(0, &to[i]);\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "2 * dlen"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "NTLMSSP_AV_NB_DOMAIN_NAME"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "ses->auth_key.len",
            "GFP_KERNEL"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ses->domainName"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "defdmname",
            "GFP_KERNEL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nbuild_avpair_blob(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tunsigned int dlen;\n\tunsigned int size = 2 * sizeof(struct ntlmssp2_name);\n\tchar *defdmname = \"WORKGROUP\";\n\tunsigned char *blobptr;\n\tstruct ntlmssp2_name *attrptr;\n\n\tif (!ses->domainName) {\n\t\tses->domainName = kstrdup(defdmname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdlen = strlen(ses->domainName);\n\n\t/*\n\t * The length of this blob is two times the size of a\n\t * structure (av pair) which holds name/size\n\t * ( for NTLMSSP_AV_NB_DOMAIN_NAME followed by NTLMSSP_AV_EOL ) +\n\t * unicode length of a netbios domain name\n\t */\n\tses->auth_key.len = size + 2 * dlen;\n\tses->auth_key.response = kzalloc(ses->auth_key.len, GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tses->auth_key.len = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tblobptr = ses->auth_key.response;\n\tattrptr = (struct ntlmssp2_name *) blobptr;\n\n\t/*\n\t * As defined in MS-NTLM 3.3.2, just this av pair field\n\t * is sufficient as part of the temp\n\t */\n\tattrptr->type = cpu_to_le16(NTLMSSP_AV_NB_DOMAIN_NAME);\n\tattrptr->length = cpu_to_le16(2 * dlen);\n\tblobptr = (unsigned char *)attrptr + sizeof(struct ntlmssp2_name);\n\tcifs_strtoUTF16((__le16 *)blobptr, ses->domainName, dlen, nls_cp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "calc_lanman_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "301-335",
    "snippet": "int calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\n\t\t\tchar *lnm_session_key)\n{\n\tint i;\n\tint rc;\n\tchar password_with_pad[CIFS_ENCPWD_SIZE];\n\n\tmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\n\tif (password)\n\t\tstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\n\n\tif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\n\t\tmemcpy(lnm_session_key, password_with_pad,\n\t\t\tCIFS_ENCPWD_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* calculate old style session key */\n\t/* calling toupper is less broken than repeatedly\n\tcalling nls_toupper would be since that will never\n\twork for UTF8, but neither handles multibyte code pages\n\tbut the only alternative would be converting to UCS-16 (Unicode)\n\t(using a routine something like UniStrupr) then\n\tuppercasing and then converting back from Unicode - which\n\twould only worth doing it if we knew it were utf8. Basically\n\tutf8 and other multibyte codepages each need their own strupper\n\tfunction since a byte at a time will ont work. */\n\n\tfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\n\t\tpassword_with_pad[i] = toupper(password_with_pad[i]);\n\n\trc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMBencrypt",
          "args": [
            "password_with_pad",
            "cryptkey",
            "lnm_session_key"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "SMBencrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smbencrypt.c",
          "lines": "182-201",
          "snippet": "int\nSMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)\n{\n\tint rc;\n\tunsigned char p14[14], p16[16], p21[21];\n\n\tmemset(p14, '\\0', 14);\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\tmemcpy(p14, passwd, 14);\n\trc = E_P16(p14, p16);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/random.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint\nSMBencrypt(unsigned char *passwd, const unsigned char *c8, unsigned char *p24)\n{\n\tint rc;\n\tunsigned char p14[14], p16[16], p21[21];\n\n\tmemset(p14, '\\0', 14);\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\tmemcpy(p14, passwd, 14);\n\trc = E_P16(p14, p16);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "password_with_pad[i]"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/winucase.c",
          "lines": "639-663",
          "snippet": "wchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}",
          "includes": [
            "#include <linux/nls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wchar_t cifs_toupper(wchar_t in);",
            "static const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n\nwchar_t cifs_toupper(wchar_t in);\nstatic const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};\n\nwchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lnm_session_key",
            "password_with_pad",
            "CIFS_ENCPWD_SIZE"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "password_with_pad",
            "password",
            "CIFS_ENCPWD_SIZE"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "password_with_pad",
            "0",
            "CIFS_ENCPWD_SIZE"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,\n\t\t\tchar *lnm_session_key)\n{\n\tint i;\n\tint rc;\n\tchar password_with_pad[CIFS_ENCPWD_SIZE];\n\n\tmemset(password_with_pad, 0, CIFS_ENCPWD_SIZE);\n\tif (password)\n\t\tstrncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);\n\n\tif (!encrypt && global_secflags & CIFSSEC_MAY_PLNTXT) {\n\t\tmemcpy(lnm_session_key, password_with_pad,\n\t\t\tCIFS_ENCPWD_SIZE);\n\t\treturn 0;\n\t}\n\n\t/* calculate old style session key */\n\t/* calling toupper is less broken than repeatedly\n\tcalling nls_toupper would be since that will never\n\twork for UTF8, but neither handles multibyte code pages\n\tbut the only alternative would be converting to UCS-16 (Unicode)\n\t(using a routine something like UniStrupr) then\n\tuppercasing and then converting back from Unicode - which\n\twould only worth doing it if we knew it were utf8. Basically\n\tutf8 and other multibyte codepages each need their own strupper\n\tfunction since a byte at a time will ont work. */\n\n\tfor (i = 0; i < CIFS_ENCPWD_SIZE; i++)\n\t\tpassword_with_pad[i] = toupper(password_with_pad[i]);\n\n\trc = SMBencrypt(password_with_pad, cryptkey, lnm_session_key);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "setup_ntlm_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "262-298",
    "snippet": "int setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tunsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;\n\tchar temp_key[CIFS_SESS_KEY_SIZE];\n\n\tif (!ses)\n\t\treturn -EINVAL;\n\n\tses->auth_key.response = kmalloc(temp_len, GFP_KERNEL);\n\tif (!ses->auth_key.response)\n\t\treturn -ENOMEM;\n\n\tses->auth_key.len = temp_len;\n\n\trc = SMBNTencrypt(ses->password, ses->server->cryptkey,\n\t\t\tses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM response, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = E_md4hash(ses->password, temp_key, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = mdfour(ses->auth_key.response, temp_key, CIFS_SESS_KEY_SIZE);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM session key, error: %d\\n\",\n\t\t\t __func__, rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s Can't generate NTLM session key, error: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdfour",
          "args": [
            "ses->auth_key.response",
            "temp_key",
            "CIFS_SESS_KEY_SIZE"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "mdfour",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smbencrypt.c",
          "lines": "132-175",
          "snippet": "int\nmdfour(unsigned char *md4_hash, unsigned char *link_str, int link_len)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md4;\n\tstruct sdesc *sdescmd4;\n\n\tmd4 = crypto_alloc_shash(\"md4\", 0, 0);\n\tif (IS_ERR(md4)) {\n\t\trc = PTR_ERR(md4);\n\t\tcifs_dbg(VFS, \"%s: Crypto md4 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md4);\n\tsdescmd4 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd4) {\n\t\trc = -ENOMEM;\n\t\tgoto mdfour_err;\n\t}\n\tsdescmd4->shash.tfm = md4;\n\tsdescmd4->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd4->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md4 shash\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_update(&sdescmd4->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_final(&sdescmd4->shash, md4_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md4 hash\\n\", __func__);\n\nmdfour_err:\n\tcrypto_free_shash(md4);\n\tkfree(sdescmd4);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/random.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint\nmdfour(unsigned char *md4_hash, unsigned char *link_str, int link_len)\n{\n\tint rc;\n\tunsigned int size;\n\tstruct crypto_shash *md4;\n\tstruct sdesc *sdescmd4;\n\n\tmd4 = crypto_alloc_shash(\"md4\", 0, 0);\n\tif (IS_ERR(md4)) {\n\t\trc = PTR_ERR(md4);\n\t\tcifs_dbg(VFS, \"%s: Crypto md4 allocation error %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(md4);\n\tsdescmd4 = kmalloc(size, GFP_KERNEL);\n\tif (!sdescmd4) {\n\t\trc = -ENOMEM;\n\t\tgoto mdfour_err;\n\t}\n\tsdescmd4->shash.tfm = md4;\n\tsdescmd4->shash.flags = 0x0;\n\n\trc = crypto_shash_init(&sdescmd4->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md4 shash\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_update(&sdescmd4->shash, link_str, link_len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with link_str\\n\", __func__);\n\t\tgoto mdfour_err;\n\t}\n\trc = crypto_shash_final(&sdescmd4->shash, md4_hash);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md4 hash\\n\", __func__);\n\nmdfour_err:\n\tcrypto_free_shash(md4);\n\tkfree(sdescmd4);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s Can't generate NT hash, error: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E_md4hash",
          "args": [
            "ses->password",
            "temp_key",
            "nls_cp"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "E_md4hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smbencrypt.c",
          "lines": "207-227",
          "snippet": "int\nE_md4hash(const unsigned char *passwd, unsigned char *p16,\n\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tint len;\n\t__le16 wpwd[129];\n\n\t/* Password cannot be longer than 128 characters */\n\tif (passwd) /* Password must be converted to NT unicode */\n\t\tlen = cifs_strtoUTF16(wpwd, passwd, 128, codepage);\n\telse {\n\t\tlen = 0;\n\t\t*wpwd = 0; /* Ensure string is null terminated */\n\t}\n\n\trc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));\n\tmemzero_explicit(wpwd, sizeof(wpwd));\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/random.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint\nE_md4hash(const unsigned char *passwd, unsigned char *p16,\n\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tint len;\n\t__le16 wpwd[129];\n\n\t/* Password cannot be longer than 128 characters */\n\tif (passwd) /* Password must be converted to NT unicode */\n\t\tlen = cifs_strtoUTF16(wpwd, passwd, 128, codepage);\n\telse {\n\t\tlen = 0;\n\t\t*wpwd = 0; /* Ensure string is null terminated */\n\t}\n\n\trc = mdfour(p16, (unsigned char *) wpwd, len * sizeof(__le16));\n\tmemzero_explicit(wpwd, sizeof(wpwd));\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s Can't generate NTLM response, error: %d\\n\"",
            "__func__",
            "rc"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMBNTencrypt",
          "args": [
            "ses->password",
            "ses->server->cryptkey",
            "ses->auth_key.response + CIFS_SESS_KEY_SIZE",
            "nls_cp"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "SMBNTencrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smbencrypt.c",
          "lines": "230-249",
          "snippet": "int\nSMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,\n\t\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tunsigned char p16[16], p21[21];\n\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\trc = E_md4hash(passwd, p16, codepage);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifsproto.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/random.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsproto.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/random.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint\nSMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24,\n\t\tconst struct nls_table *codepage)\n{\n\tint rc;\n\tunsigned char p16[16], p21[21];\n\n\tmemset(p16, '\\0', 16);\n\tmemset(p21, '\\0', 21);\n\n\trc = E_md4hash(passwd, p16, codepage);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\tmemcpy(p21, p16, 16);\n\trc = E_P24(p21, c8, p24);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "temp_len",
            "GFP_KERNEL"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint setup_ntlm_response(struct cifs_ses *ses, const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tunsigned int temp_len = CIFS_SESS_KEY_SIZE + CIFS_AUTH_RESP_SIZE;\n\tchar temp_key[CIFS_SESS_KEY_SIZE];\n\n\tif (!ses)\n\t\treturn -EINVAL;\n\n\tses->auth_key.response = kmalloc(temp_len, GFP_KERNEL);\n\tif (!ses->auth_key.response)\n\t\treturn -ENOMEM;\n\n\tses->auth_key.len = temp_len;\n\n\trc = SMBNTencrypt(ses->password, ses->server->cryptkey,\n\t\t\tses->auth_key.response + CIFS_SESS_KEY_SIZE, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM response, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = E_md4hash(ses->password, temp_key, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"%s Can't generate NT hash, error: %d\\n\",\n\t\t\t __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = mdfour(ses->auth_key.response, temp_key, CIFS_SESS_KEY_SIZE);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"%s Can't generate NTLM session key, error: %d\\n\",\n\t\t\t __func__, rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_verify_signature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "206-259",
    "snippet": "int cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  __u32 expected_sequence_number)\n{\n\tunsigned int rc;\n\tchar server_response_sig[8];\n\tchar what_we_think_sig_should_be[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (cifs_pdu == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->session_estab)\n\t\treturn 0;\n\n\tif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\n\t\tstruct smb_com_lock_req *pSMB =\n\t\t\t(struct smb_com_lock_req *)cifs_pdu;\n\t    if (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\n\t\t\treturn 0;\n\t}\n\n\t/* BB what if signatures are supposed to be on for session but\n\t   server does not send one? BB */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \"  */\n\tif (memcmp(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t cifs_pdu->Command);\n\n\t/* save off the origiginal signature so we can modify the smb and check\n\t\tits signature against what the server sent */\n\tmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\t\tcpu_to_le32(expected_sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n/*\tcifs_dump_mem(\"what we think it should be: \",\n\t\t      what_we_think_sig_should_be, 16); */\n\n\tif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "server_response_sig",
            "what_we_think_sig_should_be",
            "8"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_calc_signature",
          "args": [
            "rqst",
            "server",
            "what_we_think_sig_should_be"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_calc_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "72-146",
          "snippet": "static int cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature)\n{\n\tint i;\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\n\tif (iov == NULL || signature == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->secmech.sdescmd5) {\n\t\trc = cifs_crypto_shash_md5_allocate(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Can't alloc md5 crypto\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trc = crypto_shash_init(&server->secmech.sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\tserver->session_key.response, server->session_key.len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\tif (iov[i].iov_len == 0)\n\t\t\tcontinue;\n\t\tif (iov[i].iov_base == NULL) {\n\t\t\tcifs_dbg(VFS, \"null iovec entry\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* The first entry includes a length field (which does not get\n\t\t   signed that occupies the first 4 bytes before the header */\n\t\tif (i == 0) {\n\t\t\tif (iov[0].iov_len <= 8) /* cmd field at offset 9 */\n\t\t\t\tbreak; /* nothing to sign or corrupt header */\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base + 4, iov[i].iov_len - 4);\n\t\t} else {\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base, iov[i].iov_len);\n\t\t}\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* now hash over the rq_pages array */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\t\tp_iov.iov_base, p_iov.iov_len);\n\t\tkunmap(rqst->rq_pages[i]);\n\t}\n\n\trc = crypto_shash_final(&server->secmech.sdescmd5->shash, signature);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature)\n{\n\tint i;\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\n\tif (iov == NULL || signature == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->secmech.sdescmd5) {\n\t\trc = cifs_crypto_shash_md5_allocate(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Can't alloc md5 crypto\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trc = crypto_shash_init(&server->secmech.sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\tserver->session_key.response, server->session_key.len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\tif (iov[i].iov_len == 0)\n\t\t\tcontinue;\n\t\tif (iov[i].iov_base == NULL) {\n\t\t\tcifs_dbg(VFS, \"null iovec entry\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* The first entry includes a length field (which does not get\n\t\t   signed that occupies the first 4 bytes before the header */\n\t\tif (i == 0) {\n\t\t\tif (iov[0].iov_len <= 8) /* cmd field at offset 9 */\n\t\t\t\tbreak; /* nothing to sign or corrupt header */\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base + 4, iov[i].iov_len - 4);\n\t\t} else {\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base, iov[i].iov_len);\n\t\t}\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* now hash over the rq_pages array */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\t\tp_iov.iov_base, p_iov.iov_len);\n\t\tkunmap(rqst->rq_pages[i]);\n\t}\n\n\trc = crypto_shash_final(&server->secmech.sdescmd5->shash, signature);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "expected_sequence_number"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "server_response_sig",
            "cifs_pdu->Signature.SecuritySignature",
            "8"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"dummy signature received for smb command 0x%x\\n\"",
            "cifs_pdu->Command"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cifs_pdu->Signature.SecuritySignature",
            "\"BSRSPYL \"",
            "8"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_verify_signature(struct smb_rqst *rqst,\n\t\t\t  struct TCP_Server_Info *server,\n\t\t\t  __u32 expected_sequence_number)\n{\n\tunsigned int rc;\n\tchar server_response_sig[8];\n\tchar what_we_think_sig_should_be[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif (cifs_pdu == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->session_estab)\n\t\treturn 0;\n\n\tif (cifs_pdu->Command == SMB_COM_LOCKING_ANDX) {\n\t\tstruct smb_com_lock_req *pSMB =\n\t\t\t(struct smb_com_lock_req *)cifs_pdu;\n\t    if (pSMB->LockType & LOCKING_ANDX_OPLOCK_RELEASE)\n\t\t\treturn 0;\n\t}\n\n\t/* BB what if signatures are supposed to be on for session but\n\t   server does not send one? BB */\n\n\t/* Do not need to verify session setups with signature \"BSRSPYL \"  */\n\tif (memcmp(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL \", 8) == 0)\n\t\tcifs_dbg(FYI, \"dummy signature received for smb command 0x%x\\n\",\n\t\t\t cifs_pdu->Command);\n\n\t/* save off the origiginal signature so we can modify the smb and check\n\t\tits signature against what the server sent */\n\tmemcpy(server_response_sig, cifs_pdu->Signature.SecuritySignature, 8);\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\t\tcpu_to_le32(expected_sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_calc_signature(rqst, server, what_we_think_sig_should_be);\n\tmutex_unlock(&server->srv_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n/*\tcifs_dump_mem(\"what we think it should be: \",\n\t\t      what_we_think_sig_should_be, 16); */\n\n\tif (memcmp(server_response_sig, what_we_think_sig_should_be, 8))\n\t\treturn -EACCES;\n\telse\n\t\treturn 0;\n\n}"
  },
  {
    "function_name": "cifs_sign_smb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "194-204",
    "snippet": "int cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_sign_smbv",
          "args": [
            "&iov",
            "1",
            "server",
            "pexpected_response_sequence_number"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sign_smbv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "184-191",
          "snippet": "int cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn cifs_sign_rqst(&rqst, server, pexpected_response_sequence);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn cifs_sign_rqst(&rqst, server, pexpected_response_sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "cifs_pdu->smb_buf_length"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}"
  },
  {
    "function_name": "cifs_sign_smbv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "184-191",
    "snippet": "int cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn cifs_sign_rqst(&rqst, server, pexpected_response_sequence);\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_sign_rqst",
          "args": [
            "&rqst",
            "server",
            "pexpected_response_sequence"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sign_rqst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "149-182",
          "snippet": "int cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_smbv(struct kvec *iov, int n_vec, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence)\n{\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = n_vec };\n\n\treturn cifs_sign_rqst(&rqst, server, pexpected_response_sequence);\n}"
  },
  {
    "function_name": "cifs_sign_rqst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "149-182",
    "snippet": "int cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cifs_pdu->Signature.SecuritySignature",
            "smb_signature",
            "8"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cifs_pdu->Signature.SecuritySignature",
            "0",
            "8"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_calc_signature",
          "args": [
            "rqst",
            "server",
            "smb_signature"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_calc_signature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "72-146",
          "snippet": "static int cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature)\n{\n\tint i;\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\n\tif (iov == NULL || signature == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->secmech.sdescmd5) {\n\t\trc = cifs_crypto_shash_md5_allocate(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Can't alloc md5 crypto\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trc = crypto_shash_init(&server->secmech.sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\tserver->session_key.response, server->session_key.len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\tif (iov[i].iov_len == 0)\n\t\t\tcontinue;\n\t\tif (iov[i].iov_base == NULL) {\n\t\t\tcifs_dbg(VFS, \"null iovec entry\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* The first entry includes a length field (which does not get\n\t\t   signed that occupies the first 4 bytes before the header */\n\t\tif (i == 0) {\n\t\t\tif (iov[0].iov_len <= 8) /* cmd field at offset 9 */\n\t\t\t\tbreak; /* nothing to sign or corrupt header */\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base + 4, iov[i].iov_len - 4);\n\t\t} else {\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base, iov[i].iov_len);\n\t\t}\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* now hash over the rq_pages array */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\t\tp_iov.iov_base, p_iov.iov_len);\n\t\tkunmap(rqst->rq_pages[i]);\n\t}\n\n\trc = crypto_shash_final(&server->secmech.sdescmd5->shash, signature);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature)\n{\n\tint i;\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\n\tif (iov == NULL || signature == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->secmech.sdescmd5) {\n\t\trc = cifs_crypto_shash_md5_allocate(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Can't alloc md5 crypto\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trc = crypto_shash_init(&server->secmech.sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\tserver->session_key.response, server->session_key.len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\tif (iov[i].iov_len == 0)\n\t\t\tcontinue;\n\t\tif (iov[i].iov_base == NULL) {\n\t\t\tcifs_dbg(VFS, \"null iovec entry\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* The first entry includes a length field (which does not get\n\t\t   signed that occupies the first 4 bytes before the header */\n\t\tif (i == 0) {\n\t\t\tif (iov[0].iov_len <= 8) /* cmd field at offset 9 */\n\t\t\t\tbreak; /* nothing to sign or corrupt header */\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base + 4, iov[i].iov_len - 4);\n\t\t} else {\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base, iov[i].iov_len);\n\t\t}\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* now hash over the rq_pages array */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\t\tp_iov.iov_base, p_iov.iov_len);\n\t\tkunmap(rqst->rq_pages[i]);\n\t}\n\n\trc = crypto_shash_final(&server->secmech.sdescmd5->shash, signature);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "server->sequence_number"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cifs_pdu->Signature.SecuritySignature",
            "\"BSRSPYL\"",
            "8"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server,\n\t\t   __u32 *pexpected_response_sequence_number)\n{\n\tint rc = 0;\n\tchar smb_signature[20];\n\tstruct smb_hdr *cifs_pdu = (struct smb_hdr *)rqst->rq_iov[0].iov_base;\n\n\tif ((cifs_pdu == NULL) || (server == NULL))\n\t\treturn -EINVAL;\n\n\tif (!(cifs_pdu->Flags2 & SMBFLG2_SECURITY_SIGNATURE) ||\n\t    server->tcpStatus == CifsNeedNegotiate)\n\t\treturn rc;\n\n\tif (!server->session_estab) {\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, \"BSRSPYL\", 8);\n\t\treturn rc;\n\t}\n\n\tcifs_pdu->Signature.Sequence.SequenceNumber =\n\t\t\t\tcpu_to_le32(server->sequence_number);\n\tcifs_pdu->Signature.Sequence.Reserved = 0;\n\n\t*pexpected_response_sequence_number = ++server->sequence_number;\n\t++server->sequence_number;\n\n\trc = cifs_calc_signature(rqst, server, smb_signature);\n\tif (rc)\n\t\tmemset(cifs_pdu->Signature.SecuritySignature, 0, 8);\n\telse\n\t\tmemcpy(cifs_pdu->Signature.SecuritySignature, smb_signature, 8);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_calc_signature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "72-146",
    "snippet": "static int cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature)\n{\n\tint i;\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\n\tif (iov == NULL || signature == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->secmech.sdescmd5) {\n\t\trc = cifs_crypto_shash_md5_allocate(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Can't alloc md5 crypto\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trc = crypto_shash_init(&server->secmech.sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\tserver->session_key.response, server->session_key.len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\tif (iov[i].iov_len == 0)\n\t\t\tcontinue;\n\t\tif (iov[i].iov_base == NULL) {\n\t\t\tcifs_dbg(VFS, \"null iovec entry\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* The first entry includes a length field (which does not get\n\t\t   signed that occupies the first 4 bytes before the header */\n\t\tif (i == 0) {\n\t\t\tif (iov[0].iov_len <= 8) /* cmd field at offset 9 */\n\t\t\t\tbreak; /* nothing to sign or corrupt header */\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base + 4, iov[i].iov_len - 4);\n\t\t} else {\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base, iov[i].iov_len);\n\t\t}\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* now hash over the rq_pages array */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\t\tp_iov.iov_base, p_iov.iov_len);\n\t\tkunmap(rqst->rq_pages[i]);\n\t}\n\n\trc = crypto_shash_final(&server->secmech.sdescmd5->shash, signature);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not generate md5 hash\\n\"",
            "__func__"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&server->secmech.sdescmd5->shash",
            "signature"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "rqst->rq_pages[i]"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&server->secmech.sdescmd5->shash",
            "p_iov.iov_base",
            "p_iov.iov_len"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_rqst_page_to_kvec",
          "args": [
            "rqst",
            "i",
            "&p_iov"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_rqst_page_to_kvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "251-271",
          "snippet": "void\ncifs_rqst_page_to_kvec(struct smb_rqst *rqst, unsigned int idx,\n\t\t\tstruct kvec *iov)\n{\n\t/*\n\t * FIXME: We could avoid this kmap altogether if we used\n\t * kernel_sendpage instead of kernel_sendmsg. That will only\n\t * work if signing is disabled though as sendpage inlines the\n\t * page directly into the fraglist. If userspace modifies the\n\t * page after we calculate the signature, then the server will\n\t * reject it and may break the connection. kernel_sendmsg does\n\t * an extra copy of the data and avoids that issue.\n\t */\n\tiov->iov_base = kmap(rqst->rq_pages[idx]);\n\n\t/* if last page, don't send beyond this offset into page */\n\tif (idx == (rqst->rq_npages - 1))\n\t\tiov->iov_len = rqst->rq_tailsz;\n\telse\n\t\tiov->iov_len = rqst->rq_pagesz;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_rqst_page_to_kvec(struct smb_rqst *rqst, unsigned int idx,\n\t\t\tstruct kvec *iov)\n{\n\t/*\n\t * FIXME: We could avoid this kmap altogether if we used\n\t * kernel_sendpage instead of kernel_sendmsg. That will only\n\t * work if signing is disabled though as sendpage inlines the\n\t * page directly into the fraglist. If userspace modifies the\n\t * page after we calculate the signature, then the server will\n\t * reject it and may break the connection. kernel_sendmsg does\n\t * an extra copy of the data and avoids that issue.\n\t */\n\tiov->iov_base = kmap(rqst->rq_pages[idx]);\n\n\t/* if last page, don't send beyond this offset into page */\n\tif (idx == (rqst->rq_npages - 1))\n\t\tiov->iov_len = rqst->rq_tailsz;\n\telse\n\t\tiov->iov_len = rqst->rq_pagesz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with payload\\n\"",
            "__func__"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&server->secmech.sdescmd5->shash",
            "iov[i].iov_base",
            "iov[i].iov_len"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&server->secmech.sdescmd5->shash",
            "iov[i].iov_base + 4",
            "iov[i].iov_len - 4"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"null iovec entry\\n\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not update with response\\n\"",
            "__func__"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&server->secmech.sdescmd5->shash",
            "server->session_key.response",
            "server->session_key.len"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Could not init md5\\n\"",
            "__func__"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&server->secmech.sdescmd5->shash"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Can't alloc md5 crypto\\n\"",
            "__func__"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_crypto_shash_md5_allocate",
          "args": [
            "server"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_crypto_shash_md5_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "34-63",
          "snippet": "static int\ncifs_crypto_shash_md5_allocate(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\tif (server->secmech.sdescmd5 != NULL)\n\t\treturn 0; /* already allocated */\n\n\tserver->secmech.md5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(server->secmech.md5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto md5\\n\");\n\t\trc = PTR_ERR(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.md5);\n\tserver->secmech.sdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdescmd5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdescmd5->shash.tfm = server->secmech.md5;\n\tserver->secmech.sdescmd5->shash.flags = 0x0;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_crypto_shash_md5_allocate(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\tif (server->secmech.sdescmd5 != NULL)\n\t\treturn 0; /* already allocated */\n\n\tserver->secmech.md5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(server->secmech.md5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto md5\\n\");\n\t\trc = PTR_ERR(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.md5);\n\tserver->secmech.sdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdescmd5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdescmd5->shash.tfm = server->secmech.md5;\n\tserver->secmech.sdescmd5->shash.flags = 0x0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int cifs_calc_signature(struct smb_rqst *rqst,\n\t\t\tstruct TCP_Server_Info *server, char *signature)\n{\n\tint i;\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\n\tif (iov == NULL || signature == NULL || server == NULL)\n\t\treturn -EINVAL;\n\n\tif (!server->secmech.sdescmd5) {\n\t\trc = cifs_crypto_shash_md5_allocate(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Can't alloc md5 crypto\\n\", __func__);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\trc = crypto_shash_init(&server->secmech.sdescmd5->shash);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not init md5\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\trc = crypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\tserver->session_key.response, server->session_key.len);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"%s: Could not update with response\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < n_vec; i++) {\n\t\tif (iov[i].iov_len == 0)\n\t\t\tcontinue;\n\t\tif (iov[i].iov_base == NULL) {\n\t\t\tcifs_dbg(VFS, \"null iovec entry\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* The first entry includes a length field (which does not get\n\t\t   signed that occupies the first 4 bytes before the header */\n\t\tif (i == 0) {\n\t\t\tif (iov[0].iov_len <= 8) /* cmd field at offset 9 */\n\t\t\t\tbreak; /* nothing to sign or corrupt header */\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base + 4, iov[i].iov_len - 4);\n\t\t} else {\n\t\t\trc =\n\t\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\tiov[i].iov_base, iov[i].iov_len);\n\t\t}\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"%s: Could not update with payload\\n\",\n\t\t\t\t __func__);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* now hash over the rq_pages array */\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\tcrypto_shash_update(&server->secmech.sdescmd5->shash,\n\t\t\t\t\tp_iov.iov_base, p_iov.iov_len);\n\t\tkunmap(rqst->rq_pages[i]);\n\t}\n\n\trc = crypto_shash_final(&server->secmech.sdescmd5->shash, signature);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"%s: Could not generate md5 hash\\n\", __func__);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_crypto_shash_md5_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
    "lines": "34-63",
    "snippet": "static int\ncifs_crypto_shash_md5_allocate(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\tif (server->secmech.sdescmd5 != NULL)\n\t\treturn 0; /* already allocated */\n\n\tserver->secmech.md5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(server->secmech.md5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto md5\\n\");\n\t\trc = PTR_ERR(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.md5);\n\tserver->secmech.sdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdescmd5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdescmd5->shash.tfm = server->secmech.md5;\n\tserver->secmech.sdescmd5->shash.flags = 0x0;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/highmem.h>",
      "#include <linux/random.h>",
      "#include <linux/ctype.h>",
      "#include \"ntlmssp.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "server->secmech.md5"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "server->secmech.md5"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "server->secmech.md5"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"could not allocate crypto md5\\n\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "server->secmech.md5"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"md5\"",
            "0",
            "0"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_crypto_shash_md5_allocate(struct TCP_Server_Info *server)\n{\n\tint rc;\n\tunsigned int size;\n\n\tif (server->secmech.sdescmd5 != NULL)\n\t\treturn 0; /* already allocated */\n\n\tserver->secmech.md5 = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(server->secmech.md5)) {\n\t\tcifs_dbg(VFS, \"could not allocate crypto md5\\n\");\n\t\trc = PTR_ERR(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn rc;\n\t}\n\n\tsize = sizeof(struct shash_desc) +\n\t\t\tcrypto_shash_descsize(server->secmech.md5);\n\tserver->secmech.sdescmd5 = kmalloc(size, GFP_KERNEL);\n\tif (!server->secmech.sdescmd5) {\n\t\tcrypto_free_shash(server->secmech.md5);\n\t\tserver->secmech.md5 = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tserver->secmech.sdescmd5->shash.tfm = server->secmech.md5;\n\tserver->secmech.sdescmd5->shash.flags = 0x0;\n\n\treturn 0;\n}"
  }
]