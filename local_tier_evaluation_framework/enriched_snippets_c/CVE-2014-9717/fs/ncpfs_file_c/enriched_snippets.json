[
  {
    "function_name": "ncp_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
    "lines": "270-275",
    "snippet": "static int ncp_release(struct inode *inode, struct file *file) {\n\tif (ncp_make_closed(inode)) {\n\t\tncp_dbg(1, \"failed to close\\n\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"failed to close\\n\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_closed",
          "args": [
            "inode"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_closed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "286-304",
          "snippet": "int\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nstatic int ncp_release(struct inode *inode, struct file *file) {\n\tif (ncp_make_closed(inode)) {\n\t\tncp_dbg(1, \"failed to close\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
    "lines": "175-268",
    "snippet": "static ssize_t\nncp_file_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tsize_t already_written = 0;\n\toff_t pos;\n\tsize_t bufsize;\n\tint errno;\n\tvoid* bouncebuffer;\n\n\tncp_dbg(1, \"enter %pD2\\n\", file);\n\tif ((ssize_t) count < 0)\n\t\treturn -EINVAL;\n\tpos = *ppos;\n\tif (file->f_flags & O_APPEND) {\n\t\tpos = i_size_read(inode);\n\t}\n\n\tif (pos + count > MAX_NON_LFS && !(file->f_flags&O_LARGEFILE)) {\n\t\tif (pos >= MAX_NON_LFS) {\n\t\t\treturn -EFBIG;\n\t\t}\n\t\tif (count > MAX_NON_LFS - (u32)pos) {\n\t\t\tcount = MAX_NON_LFS - (u32)pos;\n\t\t}\n\t}\n\tif (pos >= inode->i_sb->s_maxbytes) {\n\t\tif (count || pos > inode->i_sb->s_maxbytes) {\n\t\t\treturn -EFBIG;\n\t\t}\n\t}\n\tif (pos + count > inode->i_sb->s_maxbytes) {\n\t\tcount = inode->i_sb->s_maxbytes - pos;\n\t}\n\t\n\tif (!count)\n\t\treturn 0;\n\terrno = ncp_make_open(inode, O_WRONLY);\n\tif (errno) {\n\t\tncp_dbg(1, \"open failed, error=%d\\n\", errno);\n\t\treturn errno;\n\t}\n\tbufsize = NCP_SERVER(inode)->buffer_size;\n\n\talready_written = 0;\n\n\terrno = file_update_time(file);\n\tif (errno)\n\t\tgoto outrel;\n\n\tbouncebuffer = vmalloc(bufsize);\n\tif (!bouncebuffer) {\n\t\terrno = -EIO;\t/* -ENOMEM */\n\t\tgoto outrel;\n\t}\n\twhile (already_written < count) {\n\t\tint written_this_time;\n\t\tsize_t to_write = min_t(unsigned int,\n\t\t\t\t      bufsize - (pos % bufsize),\n\t\t\t\t      count - already_written);\n\n\t\tif (copy_from_user(bouncebuffer, buf, to_write)) {\n\t\t\terrno = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (ncp_write_kernel(NCP_SERVER(inode), \n\t\t    NCP_FINFO(inode)->file_handle,\n\t\t    pos, to_write, bouncebuffer, &written_this_time) != 0) {\n\t\t\terrno = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tpos += written_this_time;\n\t\tbuf += written_this_time;\n\t\talready_written += written_this_time;\n\n\t\tif (written_this_time != to_write) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvfree(bouncebuffer);\n\n\t*ppos = pos;\n\n\tif (pos > i_size_read(inode)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (pos > i_size_read(inode))\n\t\t\ti_size_write(inode, pos);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tncp_dbg(1, \"exit %pD2\\n\", file);\noutrel:\n\tncp_inode_close(inode);\t\t\n\treturn already_written ? already_written : errno;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_inode_close",
          "args": [
            "inode"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_inode_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "62-64",
          "snippet": "static inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"exit %pD2\\n\"",
            "file"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "pos"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "bouncebuffer"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_write_kernel",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "pos",
            "to_write",
            "bouncebuffer",
            "&written_this_time"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_write_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "1035-1053",
          "snippet": "int\nncp_write_kernel(struct ncp_server *server, const char *file_id,\n\t\t __u32 offset, __u16 to_write,\n\t\t const char *source, int *bytes_written)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_write);\n\tncp_add_mem(server, source, to_write);\n\t\n\tif ((result = ncp_request(server, 73)) == 0)\n\t\t*bytes_written = to_write;\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_write_kernel(struct ncp_server *server, const char *file_id,\n\t\t __u32 offset, __u16 to_write,\n\t\t const char *source, int *bytes_written)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_write);\n\tncp_add_mem(server, source, to_write);\n\t\n\tif ((result = ncp_request(server, 73)) == 0)\n\t\t*bytes_written = to_write;\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "bouncebuffer",
            "buf",
            "to_write"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "bufsize - (pos % bufsize)",
            "count - already_written"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "bufsize"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"open failed, error=%d\\n\"",
            "errno"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_open",
          "args": [
            "inode",
            "O_WRONLY"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
          "lines": "32-98",
          "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"enter %pD2\\n\"",
            "file"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t\nncp_file_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tsize_t already_written = 0;\n\toff_t pos;\n\tsize_t bufsize;\n\tint errno;\n\tvoid* bouncebuffer;\n\n\tncp_dbg(1, \"enter %pD2\\n\", file);\n\tif ((ssize_t) count < 0)\n\t\treturn -EINVAL;\n\tpos = *ppos;\n\tif (file->f_flags & O_APPEND) {\n\t\tpos = i_size_read(inode);\n\t}\n\n\tif (pos + count > MAX_NON_LFS && !(file->f_flags&O_LARGEFILE)) {\n\t\tif (pos >= MAX_NON_LFS) {\n\t\t\treturn -EFBIG;\n\t\t}\n\t\tif (count > MAX_NON_LFS - (u32)pos) {\n\t\t\tcount = MAX_NON_LFS - (u32)pos;\n\t\t}\n\t}\n\tif (pos >= inode->i_sb->s_maxbytes) {\n\t\tif (count || pos > inode->i_sb->s_maxbytes) {\n\t\t\treturn -EFBIG;\n\t\t}\n\t}\n\tif (pos + count > inode->i_sb->s_maxbytes) {\n\t\tcount = inode->i_sb->s_maxbytes - pos;\n\t}\n\t\n\tif (!count)\n\t\treturn 0;\n\terrno = ncp_make_open(inode, O_WRONLY);\n\tif (errno) {\n\t\tncp_dbg(1, \"open failed, error=%d\\n\", errno);\n\t\treturn errno;\n\t}\n\tbufsize = NCP_SERVER(inode)->buffer_size;\n\n\talready_written = 0;\n\n\terrno = file_update_time(file);\n\tif (errno)\n\t\tgoto outrel;\n\n\tbouncebuffer = vmalloc(bufsize);\n\tif (!bouncebuffer) {\n\t\terrno = -EIO;\t/* -ENOMEM */\n\t\tgoto outrel;\n\t}\n\twhile (already_written < count) {\n\t\tint written_this_time;\n\t\tsize_t to_write = min_t(unsigned int,\n\t\t\t\t      bufsize - (pos % bufsize),\n\t\t\t\t      count - already_written);\n\n\t\tif (copy_from_user(bouncebuffer, buf, to_write)) {\n\t\t\terrno = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (ncp_write_kernel(NCP_SERVER(inode), \n\t\t    NCP_FINFO(inode)->file_handle,\n\t\t    pos, to_write, bouncebuffer, &written_this_time) != 0) {\n\t\t\terrno = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tpos += written_this_time;\n\t\tbuf += written_this_time;\n\t\talready_written += written_this_time;\n\n\t\tif (written_this_time != to_write) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvfree(bouncebuffer);\n\n\t*ppos = pos;\n\n\tif (pos > i_size_read(inode)) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (pos > i_size_read(inode))\n\t\t\ti_size_write(inode, pos);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\tncp_dbg(1, \"exit %pD2\\n\", file);\noutrel:\n\tncp_inode_close(inode);\t\t\n\treturn already_written ? already_written : errno;\n}"
  },
  {
    "function_name": "ncp_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
    "lines": "100-173",
    "snippet": "static ssize_t\nncp_file_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tsize_t already_read = 0;\n\toff_t pos;\n\tsize_t bufsize;\n\tint error;\n\tvoid* freepage;\n\tsize_t freelen;\n\n\tncp_dbg(1, \"enter %pD2\\n\", file);\n\n\tpos = *ppos;\n\n\tif ((ssize_t) count < 0) {\n\t\treturn -EINVAL;\n\t}\n\tif (!count)\n\t\treturn 0;\n\tif (pos > inode->i_sb->s_maxbytes)\n\t\treturn 0;\n\tif (pos + count > inode->i_sb->s_maxbytes) {\n\t\tcount = inode->i_sb->s_maxbytes - pos;\n\t}\n\n\terror = ncp_make_open(inode, O_RDONLY);\n\tif (error) {\n\t\tncp_dbg(1, \"open failed, error=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\tbufsize = NCP_SERVER(inode)->buffer_size;\n\n\terror = -EIO;\n\tfreelen = ncp_read_bounce_size(bufsize);\n\tfreepage = vmalloc(freelen);\n\tif (!freepage)\n\t\tgoto outrel;\n\terror = 0;\n\t/* First read in as much as possible for each bufsize. */\n\twhile (already_read < count) {\n\t\tint read_this_time;\n\t\tsize_t to_read = min_t(unsigned int,\n\t\t\t\t     bufsize - (pos % bufsize),\n\t\t\t\t     count - already_read);\n\n\t\terror = ncp_read_bounce(NCP_SERVER(inode),\n\t\t\t \tNCP_FINFO(inode)->file_handle,\n\t\t\t\tpos, to_read, buf, &read_this_time, \n\t\t\t\tfreepage, freelen);\n\t\tif (error) {\n\t\t\terror = -EIO;\t/* NW errno -> Linux errno */\n\t\t\tbreak;\n\t\t}\n\t\tpos += read_this_time;\n\t\tbuf += read_this_time;\n\t\talready_read += read_this_time;\n\n\t\tif (read_this_time != to_read) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvfree(freepage);\n\n\t*ppos = pos;\n\n\tfile_accessed(file);\n\n\tncp_dbg(1, \"exit %pD2\\n\", file);\noutrel:\n\tncp_inode_close(inode);\t\t\n\treturn already_read ? already_read : error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_inode_close",
          "args": [
            "inode"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_inode_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "62-64",
          "snippet": "static inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"exit %pD2\\n\"",
            "file"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "freepage"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_read_bounce",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "pos",
            "to_read",
            "buf",
            "&read_this_time",
            "freepage",
            "freelen"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_read_bounce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "1002-1033",
          "snippet": "int\nncp_read_bounce(struct ncp_server *server, const char *file_id,\n\t __u32 offset, __u16 to_read, char __user *target, int *bytes_read,\n\t void* bounce, __u32 bufsize)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tresult = ncp_request2(server, 72, bounce, bufsize);\n\tncp_unlock_server(server);\n\tif (!result) {\n\t\tint len = get_unaligned_be16((char *)bounce +\n\t\t\t  sizeof(struct ncp_reply_header));\n\t\tresult = -EIO;\n\t\tif (len <= to_read) {\n\t\t\tchar* source;\n\n\t\t\tsource = (char*)bounce + \n\t\t\t         sizeof(struct ncp_reply_header) + 2 + \n\t\t\t         (offset & 1);\n\t\t\t*bytes_read = len;\n\t\t\tresult = 0;\n\t\t\tif (copy_to_user(target, source, len))\n\t\t\t\tresult = -EFAULT;\n\t\t}\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_read_bounce(struct ncp_server *server, const char *file_id,\n\t __u32 offset, __u16 to_read, char __user *target, int *bytes_read,\n\t void* bounce, __u32 bufsize)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tresult = ncp_request2(server, 72, bounce, bufsize);\n\tncp_unlock_server(server);\n\tif (!result) {\n\t\tint len = get_unaligned_be16((char *)bounce +\n\t\t\t  sizeof(struct ncp_reply_header));\n\t\tresult = -EIO;\n\t\tif (len <= to_read) {\n\t\t\tchar* source;\n\n\t\t\tsource = (char*)bounce + \n\t\t\t         sizeof(struct ncp_reply_header) + 2 + \n\t\t\t         (offset & 1);\n\t\t\t*bytes_read = len;\n\t\t\tresult = 0;\n\t\t\tif (copy_to_user(target, source, len))\n\t\t\t\tresult = -EFAULT;\n\t\t}\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "bufsize - (pos % bufsize)",
            "count - already_read"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "freelen"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_read_bounce_size",
          "args": [
            "bufsize"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_read_bounce_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "52-54",
          "snippet": "static inline int ncp_read_bounce_size(__u32 size) {\n\treturn sizeof(struct ncp_reply_header) + 2 + 2 + size + 8;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ncp_read_bounce_size(__u32 size) {\n\treturn sizeof(struct ncp_reply_header) + 2 + 2 + size + 8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"open failed, error=%d\\n\"",
            "error"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_open",
          "args": [
            "inode",
            "O_RDONLY"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
          "lines": "32-98",
          "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"enter %pD2\\n\"",
            "file"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t\nncp_file_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tsize_t already_read = 0;\n\toff_t pos;\n\tsize_t bufsize;\n\tint error;\n\tvoid* freepage;\n\tsize_t freelen;\n\n\tncp_dbg(1, \"enter %pD2\\n\", file);\n\n\tpos = *ppos;\n\n\tif ((ssize_t) count < 0) {\n\t\treturn -EINVAL;\n\t}\n\tif (!count)\n\t\treturn 0;\n\tif (pos > inode->i_sb->s_maxbytes)\n\t\treturn 0;\n\tif (pos + count > inode->i_sb->s_maxbytes) {\n\t\tcount = inode->i_sb->s_maxbytes - pos;\n\t}\n\n\terror = ncp_make_open(inode, O_RDONLY);\n\tif (error) {\n\t\tncp_dbg(1, \"open failed, error=%d\\n\", error);\n\t\treturn error;\n\t}\n\n\tbufsize = NCP_SERVER(inode)->buffer_size;\n\n\terror = -EIO;\n\tfreelen = ncp_read_bounce_size(bufsize);\n\tfreepage = vmalloc(freelen);\n\tif (!freepage)\n\t\tgoto outrel;\n\terror = 0;\n\t/* First read in as much as possible for each bufsize. */\n\twhile (already_read < count) {\n\t\tint read_this_time;\n\t\tsize_t to_read = min_t(unsigned int,\n\t\t\t\t     bufsize - (pos % bufsize),\n\t\t\t\t     count - already_read);\n\n\t\terror = ncp_read_bounce(NCP_SERVER(inode),\n\t\t\t \tNCP_FINFO(inode)->file_handle,\n\t\t\t\tpos, to_read, buf, &read_this_time, \n\t\t\t\tfreepage, freelen);\n\t\tif (error) {\n\t\t\terror = -EIO;\t/* NW errno -> Linux errno */\n\t\t\tbreak;\n\t\t}\n\t\tpos += read_this_time;\n\t\tbuf += read_this_time;\n\t\talready_read += read_this_time;\n\n\t\tif (read_this_time != to_read) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tvfree(freepage);\n\n\t*ppos = pos;\n\n\tfile_accessed(file);\n\n\tncp_dbg(1, \"exit %pD2\\n\", file);\noutrel:\n\tncp_inode_close(inode);\t\t\n\treturn already_read ? already_read : error;\n}"
  },
  {
    "function_name": "ncp_make_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
    "lines": "32-98",
    "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&NCP_FINFO(inode)->open_mutex"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&NCP_FINFO(inode)->opened"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"file open, access=%x\\n\"",
            "access"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&NCP_FINFO(inode)->opened",
            "1"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_update_inode",
          "args": [
            "inode",
            "&finfo"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_inode2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "211-221",
          "snippet": "void ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nvoid ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"failed, result=%d\\n\"",
            "result"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_open_create_file_or_subdir",
          "args": [
            "NCP_SERVER(inode)",
            "inode",
            "NULL",
            "OC_MODE_OPEN",
            "0",
            "AR_WRITE",
            "&finfo"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_open_create_file_or_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "776-826",
          "snippet": "int ncp_open_create_file_or_subdir(struct ncp_server *server,\n\t\t\t\t   struct inode *dir, const char *name,\n\t\t\t\t   int open_create_mode,\n\t\t\t\t   __le32 create_attributes,\n\t\t\t\t   __le16 desired_acc_rights,\n\t\t\t\t   struct ncp_entry_info *target)\n{\n\t__le16 search_attribs = cpu_to_le16(0x0006);\n\t__u8  volnum;\n\t__le32 dirent;\n\tint result;\n\n\tvolnum = NCP_FINFO(dir)->volNumber;\n\tdirent = NCP_FINFO(dir)->dirEntNum;\n\n\tif ((create_attributes & aDIR) != 0) {\n\t\tsearch_attribs |= cpu_to_le16(0x8000);\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 1);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, open_create_mode);\n\tncp_add_word(server, search_attribs);\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_dword(server, create_attributes);\n\t/* The desired acc rights seem to be the inherited rights mask\n\t   for directories */\n\tncp_add_word(server, desired_acc_rights);\n\tncp_add_handle_path(server, volnum, dirent, 1, name);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tif (!(create_attributes & aDIR))\n\t\ttarget->opened = 1;\n\n\t/* in target there's a new finfo to fill */\n\tncp_extract_file_info(ncp_reply_data(server, 6), &(target->i));\n\ttarget->volume = target->i.volNumber;\n\tConvertToNWfromDWORD(ncp_reply_le16(server, 0),\n\t\t\t     ncp_reply_le16(server, 2),\n\t\t\t     target->file_handle);\n\t\n\tncp_unlock_server(server);\n\n\t(void)ncp_obtain_nfs_info(server, &(target->i));\n\treturn 0;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_open_create_file_or_subdir(struct ncp_server *server,\n\t\t\t\t   struct inode *dir, const char *name,\n\t\t\t\t   int open_create_mode,\n\t\t\t\t   __le32 create_attributes,\n\t\t\t\t   __le16 desired_acc_rights,\n\t\t\t\t   struct ncp_entry_info *target)\n{\n\t__le16 search_attribs = cpu_to_le16(0x0006);\n\t__u8  volnum;\n\t__le32 dirent;\n\tint result;\n\n\tvolnum = NCP_FINFO(dir)->volNumber;\n\tdirent = NCP_FINFO(dir)->dirEntNum;\n\n\tif ((create_attributes & aDIR) != 0) {\n\t\tsearch_attribs |= cpu_to_le16(0x8000);\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 1);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, open_create_mode);\n\tncp_add_word(server, search_attribs);\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_dword(server, create_attributes);\n\t/* The desired acc rights seem to be the inherited rights mask\n\t   for directories */\n\tncp_add_word(server, desired_acc_rights);\n\tncp_add_handle_path(server, volnum, dirent, 1, name);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tif (!(create_attributes & aDIR))\n\t\ttarget->opened = 1;\n\n\t/* in target there's a new finfo to fill */\n\tncp_extract_file_info(ncp_reply_data(server, 6), &(target->i));\n\ttarget->volume = target->i.volNumber;\n\tConvertToNWfromDWORD(ncp_reply_le16(server, 0),\n\t\t\t     ncp_reply_le16(server, 2),\n\t\t\t     target->file_handle);\n\t\n\tncp_unlock_server(server);\n\n\t(void)ncp_obtain_nfs_info(server, &(target->i));\n\treturn 0;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&NCP_FINFO(inode)->opened"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&NCP_FINFO(inode)->open_mutex"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"opened=%d, volume # %u, dir entry # %u\\n\"",
            "atomic_read(&NCP_FINFO(inode)->opened)",
            "NCP_FINFO(inode)->volNumber",
            "NCP_FINFO(inode)->dirEntNum"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&NCP_FINFO(inode)->opened"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: got NULL inode\\n\"",
            "__func__"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "ncp_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
    "lines": "24-27",
    "snippet": "static int ncp_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\treturn filemap_write_and_wait_range(file->f_mapping, start, end);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <linux/sched.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "file->f_mapping",
            "start",
            "end"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nstatic int ncp_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\treturn filemap_write_and_wait_range(file->f_mapping, start, end);\n}"
  }
]