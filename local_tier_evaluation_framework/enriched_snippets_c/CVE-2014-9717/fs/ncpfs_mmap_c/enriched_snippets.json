[
  {
    "function_name": "ncp_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/mmap.c",
    "lines": "104-125",
    "snippet": "int ncp_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\t\n\tncp_dbg(1, \"called\\n\");\n\n\tif (!ncp_conn_valid(NCP_SERVER(inode)))\n\t\treturn -EIO;\n\n\t/* only PAGE_COW or read-only supported now */\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn -EINVAL;\n\t/* we do not support files bigger than 4GB... We eventually \n\t   supports just 4GB... */\n\tif (vma_pages(vma) + vma->vm_pgoff\n\t   > (1U << (32 - PAGE_SHIFT)))\n\t\treturn -EFBIG;\n\n\tvma->vm_ops = &ncp_file_mmap;\n\tfile_accessed(file);\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/string.h>",
      "#include <linux/mman.h>",
      "#include <linux/errno.h>",
      "#include <linux/shm.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct ncp_file_mmap =\n{\n\t.fault = ncp_file_mmap_fault,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "file"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_conn_valid",
          "args": [
            "NCP_SERVER(inode)"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_conn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs_sb.h",
          "lines": "164-167",
          "snippet": "static inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/net.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/ncp_mount.h>\n#include <linux/types.h>\n\nstatic inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"called\\n\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/shm.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n\nstatic const struct vm_operations_struct ncp_file_mmap =\n{\n\t.fault = ncp_file_mmap_fault,\n};\n\nint ncp_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *inode = file_inode(file);\n\t\n\tncp_dbg(1, \"called\\n\");\n\n\tif (!ncp_conn_valid(NCP_SERVER(inode)))\n\t\treturn -EIO;\n\n\t/* only PAGE_COW or read-only supported now */\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn -EINVAL;\n\t/* we do not support files bigger than 4GB... We eventually \n\t   supports just 4GB... */\n\tif (vma_pages(vma) + vma->vm_pgoff\n\t   > (1U << (32 - PAGE_SHIFT)))\n\t\treturn -EFBIG;\n\n\tvma->vm_ops = &ncp_file_mmap;\n\tfile_accessed(file);\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_file_mmap_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/mmap.c",
    "lines": "30-95",
    "snippet": "static int ncp_file_mmap_fault(struct vm_area_struct *area,\n\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(area->vm_file);\n\tchar *pg_addr;\n\tunsigned int already_read;\n\tunsigned int count;\n\tint bufsize;\n\tint pos; /* XXX: loff_t ? */\n\n\t/*\n\t * ncpfs has nothing against high pages as long\n\t * as recvmsg and memset works on it\n\t */\n\tvmf->page = alloc_page(GFP_HIGHUSER);\n\tif (!vmf->page)\n\t\treturn VM_FAULT_OOM;\n\tpg_addr = kmap(vmf->page);\n\tpos = vmf->pgoff << PAGE_SHIFT;\n\n\tcount = PAGE_SIZE;\n\t/* what we can read in one go */\n\tbufsize = NCP_SERVER(inode)->buffer_size;\n\n\talready_read = 0;\n\tif (ncp_make_open(inode, O_RDONLY) >= 0) {\n\t\twhile (already_read < count) {\n\t\t\tint read_this_time;\n\t\t\tint to_read;\n\n\t\t\tto_read = bufsize - (pos % bufsize);\n\n\t\t\tto_read = min_t(unsigned int, to_read, count - already_read);\n\n\t\t\tif (ncp_read_kernel(NCP_SERVER(inode),\n\t\t\t\t     NCP_FINFO(inode)->file_handle,\n\t\t\t\t     pos, to_read,\n\t\t\t\t     pg_addr + already_read,\n\t\t\t\t     &read_this_time) != 0) {\n\t\t\t\tread_this_time = 0;\n\t\t\t}\n\t\t\tpos += read_this_time;\n\t\t\talready_read += read_this_time;\n\n\t\t\tif (read_this_time < to_read) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tncp_inode_close(inode);\n\n\t}\n\n\tif (already_read < PAGE_SIZE)\n\t\tmemset(pg_addr + already_read, 0, PAGE_SIZE - already_read);\n\tflush_dcache_page(vmf->page);\n\tkunmap(vmf->page);\n\n\t/*\n\t * If I understand ncp_read_kernel() properly, the above always\n\t * fetches from the network, here the analogue of disk.\n\t * -- nyc\n\t */\n\tcount_vm_event(PGMAJFAULT);\n\tmem_cgroup_count_vm_event(area->vm_mm, PGMAJFAULT);\n\treturn VM_FAULT_MAJOR;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/string.h>",
      "#include <linux/mman.h>",
      "#include <linux/errno.h>",
      "#include <linux/shm.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_cgroup_count_vm_event",
          "args": [
            "area->vm_mm",
            "PGMAJFAULT"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGMAJFAULT"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "vmf->page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "vmf->page"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pg_addr + already_read",
            "0",
            "PAGE_SIZE - already_read"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_inode_close",
          "args": [
            "inode"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_inode_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "62-64",
          "snippet": "static inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_read_kernel",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "pos",
            "to_read",
            "pg_addr + already_read",
            "&read_this_time"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_read_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "966-989",
          "snippet": "int\nncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "to_read",
            "count - already_read"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_open",
          "args": [
            "inode",
            "O_RDONLY"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
          "lines": "32-98",
          "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "vmf->page"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "area->vm_file"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/shm.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n\nstatic int ncp_file_mmap_fault(struct vm_area_struct *area,\n\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(area->vm_file);\n\tchar *pg_addr;\n\tunsigned int already_read;\n\tunsigned int count;\n\tint bufsize;\n\tint pos; /* XXX: loff_t ? */\n\n\t/*\n\t * ncpfs has nothing against high pages as long\n\t * as recvmsg and memset works on it\n\t */\n\tvmf->page = alloc_page(GFP_HIGHUSER);\n\tif (!vmf->page)\n\t\treturn VM_FAULT_OOM;\n\tpg_addr = kmap(vmf->page);\n\tpos = vmf->pgoff << PAGE_SHIFT;\n\n\tcount = PAGE_SIZE;\n\t/* what we can read in one go */\n\tbufsize = NCP_SERVER(inode)->buffer_size;\n\n\talready_read = 0;\n\tif (ncp_make_open(inode, O_RDONLY) >= 0) {\n\t\twhile (already_read < count) {\n\t\t\tint read_this_time;\n\t\t\tint to_read;\n\n\t\t\tto_read = bufsize - (pos % bufsize);\n\n\t\t\tto_read = min_t(unsigned int, to_read, count - already_read);\n\n\t\t\tif (ncp_read_kernel(NCP_SERVER(inode),\n\t\t\t\t     NCP_FINFO(inode)->file_handle,\n\t\t\t\t     pos, to_read,\n\t\t\t\t     pg_addr + already_read,\n\t\t\t\t     &read_this_time) != 0) {\n\t\t\t\tread_this_time = 0;\n\t\t\t}\n\t\t\tpos += read_this_time;\n\t\t\talready_read += read_this_time;\n\n\t\t\tif (read_this_time < to_read) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tncp_inode_close(inode);\n\n\t}\n\n\tif (already_read < PAGE_SIZE)\n\t\tmemset(pg_addr + already_read, 0, PAGE_SIZE - already_read);\n\tflush_dcache_page(vmf->page);\n\tkunmap(vmf->page);\n\n\t/*\n\t * If I understand ncp_read_kernel() properly, the above always\n\t * fetches from the network, here the analogue of disk.\n\t * -- nyc\n\t */\n\tcount_vm_event(PGMAJFAULT);\n\tmem_cgroup_count_vm_event(area->vm_mm, PGMAJFAULT);\n\treturn VM_FAULT_MAJOR;\n}"
  }
]