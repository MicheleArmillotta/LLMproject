[
  {
    "function_name": "logfs_cleanup_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "886-894",
    "snippet": "void logfs_cleanup_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor32(&super->s_reserved_segments, 0, NULL);\n\n\tkfree(super->s_compressed_je);\n\tkfree(super->s_je);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "super->s_je"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "super->s_compressed_je"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_grim_visitor32",
          "args": [
            "&super->s_reserved_segments",
            "0",
            "NULL"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_cleanup_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tbtree_grim_visitor32(&super->s_reserved_segments, 0, NULL);\n\n\tkfree(super->s_compressed_je);\n\tkfree(super->s_je);\n}"
  },
  {
    "function_name": "logfs_init_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "853-884",
    "snippet": "int logfs_init_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tint ret = -ENOMEM;\n\n\tmutex_init(&super->s_journal_mutex);\n\tbtree_init_mempool32(&super->s_reserved_segments, super->s_btree_pool);\n\n\tsuper->s_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_je)\n\t\treturn ret;\n\n\tsuper->s_compressed_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_compressed_je)\n\t\treturn ret;\n\n\tsuper->s_master_inode = logfs_new_meta_inode(sb, LOGFS_INO_MASTER);\n\tif (IS_ERR(super->s_master_inode))\n\t\treturn PTR_ERR(super->s_master_inode);\n\n\tret = logfs_read_journal(sb);\n\tif (ret)\n\t\treturn -EIO;\n\n\treserve_sb_and_journal(sb);\n\tlogfs_calc_free(sb);\n\n\tsuper->s_journal_area->a_ops = &journal_area_ops;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct logfs_area_ops journal_area_ops = {\n\t.get_free_segment\t= journal_get_free_segment,\n\t.get_erase_count\t= journal_get_erase_count,\n\t.erase_segment\t\t= journal_erase_segment,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_calc_free",
          "args": [
            "sb"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_calc_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "11-48",
          "snippet": "static void logfs_calc_free(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 reserve, no_segs = super->s_no_segs;\n\ts64 free;\n\tint i;\n\n\t/* superblock segments */\n\tno_segs -= 2;\n\tsuper->s_no_journal_segs = 0;\n\t/* journal */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tno_segs--;\n\t\t\tsuper->s_no_journal_segs++;\n\t\t}\n\n\t/* open segments plus one extra per level for GC */\n\tno_segs -= 2 * super->s_total_levels;\n\n\tfree = no_segs * (super->s_segsize - LOGFS_SEGMENT_RESERVE);\n\tfree -= super->s_used_bytes;\n\t/* just a bit extra */\n\tfree -= super->s_total_levels * 4096;\n\n\t/* Bad blocks are 'paid' for with speed reserve - the filesystem\n\t * simply gets slower as bad blocks accumulate.  Until the bad blocks\n\t * exceed the speed reserve - then the filesystem gets smaller.\n\t */\n\treserve = super->s_bad_segments + super->s_bad_seg_reserve;\n\treserve *= super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\treserve = max(reserve, super->s_speed_reserve);\n\tfree -= reserve;\n\tif (free < 0)\n\t\tfree = 0;\n\n\tsuper->s_free_bytes = free;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_calc_free(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 reserve, no_segs = super->s_no_segs;\n\ts64 free;\n\tint i;\n\n\t/* superblock segments */\n\tno_segs -= 2;\n\tsuper->s_no_journal_segs = 0;\n\t/* journal */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tno_segs--;\n\t\t\tsuper->s_no_journal_segs++;\n\t\t}\n\n\t/* open segments plus one extra per level for GC */\n\tno_segs -= 2 * super->s_total_levels;\n\n\tfree = no_segs * (super->s_segsize - LOGFS_SEGMENT_RESERVE);\n\tfree -= super->s_used_bytes;\n\t/* just a bit extra */\n\tfree -= super->s_total_levels * 4096;\n\n\t/* Bad blocks are 'paid' for with speed reserve - the filesystem\n\t * simply gets slower as bad blocks accumulate.  Until the bad blocks\n\t * exceed the speed reserve - then the filesystem gets smaller.\n\t */\n\treserve = super->s_bad_segments + super->s_bad_seg_reserve;\n\treserve *= super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\treserve = max(reserve, super->s_speed_reserve);\n\tfree -= reserve;\n\tif (free < 0)\n\t\tfree = 0;\n\n\tsuper->s_free_bytes = free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_sb_and_journal",
          "args": [
            "sb"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_sb_and_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "50-71",
          "snippet": "static void reserve_sb_and_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint i, err;\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[0]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[1]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\tjournal_for_each(i) {\n\t\tif (!super->s_journal_seg[i])\n\t\t\tcontinue;\n\t\terr = btree_insert32(head, super->s_journal_seg[i], (void *)1,\n\t\t\t\tGFP_KERNEL);\n\t\tBUG_ON(err);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void reserve_sb_and_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint i, err;\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[0]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[1]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\tjournal_for_each(i) {\n\t\tif (!super->s_journal_seg[i])\n\t\t\tcontinue;\n\t\terr = btree_insert32(head, super->s_journal_seg[i], (void *)1,\n\t\t\t\tGFP_KERNEL);\n\t\tBUG_ON(err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_journal",
          "args": [
            "sb"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "331-352",
          "snippet": "static int logfs_read_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 gec[LOGFS_JOURNAL_SEGS], max;\n\tu32 segno;\n\tint i, max_i;\n\n\tmax = 0;\n\tmax_i = -1;\n\tjournal_for_each(i) {\n\t\tsegno = super->s_journal_seg[i];\n\t\tgec[i] = read_gec(sb, super->s_journal_seg[i]);\n\t\tif (gec[i] > max) {\n\t\t\tmax = gec[i];\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i == -1)\n\t\treturn -EIO;\n\t/* FIXME: Try older segments in case of error */\n\treturn logfs_read_segment(sb, super->s_journal_seg[max_i]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 gec[LOGFS_JOURNAL_SEGS], max;\n\tu32 segno;\n\tint i, max_i;\n\n\tmax = 0;\n\tmax_i = -1;\n\tjournal_for_each(i) {\n\t\tsegno = super->s_journal_seg[i];\n\t\tgec[i] = read_gec(sb, super->s_journal_seg[i]);\n\t\tif (gec[i] > max) {\n\t\t\tmax = gec[i];\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i == -1)\n\t\treturn -EIO;\n\t/* FIXME: Try older segments in case of error */\n\treturn logfs_read_segment(sb, super->s_journal_seg[max_i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "super->s_master_inode"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "super->s_master_inode"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_new_meta_inode",
          "args": [
            "sb",
            "LOGFS_INO_MASTER"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_new_meta_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "262-276",
          "snippet": "struct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bufsize",
            "GFP_KERNEL"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bufsize",
            "GFP_KERNEL"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_init_mempool32",
          "args": [
            "&super->s_reserved_segments",
            "super->s_btree_pool"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&super->s_journal_mutex"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "sb->s_blocksize",
            "super->s_writesize"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_area_ops journal_area_ops = {\n\t.get_free_segment\t= journal_get_free_segment,\n\t.get_erase_count\t= journal_get_erase_count,\n\t.erase_segment\t\t= journal_erase_segment,\n};\n\nint logfs_init_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tint ret = -ENOMEM;\n\n\tmutex_init(&super->s_journal_mutex);\n\tbtree_init_mempool32(&super->s_reserved_segments, super->s_btree_pool);\n\n\tsuper->s_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_je)\n\t\treturn ret;\n\n\tsuper->s_compressed_je = kzalloc(bufsize, GFP_KERNEL);\n\tif (!super->s_compressed_je)\n\t\treturn ret;\n\n\tsuper->s_master_inode = logfs_new_meta_inode(sb, LOGFS_INO_MASTER);\n\tif (IS_ERR(super->s_master_inode))\n\t\treturn PTR_ERR(super->s_master_inode);\n\n\tret = logfs_read_journal(sb);\n\tif (ret)\n\t\treturn -EIO;\n\n\treserve_sb_and_journal(sb);\n\tlogfs_calc_free(sb);\n\n\tsuper->s_journal_area->a_ops = &journal_area_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_logfs_journal_wl_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "805-845",
    "snippet": "void do_logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tu32 segno, ec;\n\tint i, err;\n\n\tlog_journal(\"Journal requires wear-leveling.\\n\");\n\t/* Drop old segments */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tbtree_remove32(head, super->s_journal_seg[i]);\n\t\t\tlogfs_set_segment_unreserved(sb,\n\t\t\t\t\tsuper->s_journal_seg[i],\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\t\t\tsuper->s_journal_seg[i] = 0;\n\t\t\tsuper->s_journal_ec[i] = 0;\n\t\t}\n\t/* Get new segments */\n\tfor (i = 0; i < super->s_no_journal_segs; i++) {\n\t\tsegno = get_best_cand(sb, &super->s_reserve_list, &ec);\n\t\tsuper->s_journal_seg[i] = segno;\n\t\tsuper->s_journal_ec[i] = ec;\n\t\tlogfs_set_segment_reserved(sb, segno);\n\t\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\t\tBUG_ON(err); /* mempool should prevent this */\n\t\terr = logfs_erase_segment(sb, segno, 1);\n\t\tBUG_ON(err); /* FIXME: remount-ro would be nicer */\n\t}\n\t/* Manually move journal_area */\n\tfreeseg(sb, area->a_segno);\n\tarea->a_segno = super->s_journal_seg[0];\n\tarea->a_is_open = 0;\n\tarea->a_used_bytes = 0;\n\t/* Write journal */\n\tlogfs_write_anchor(sb);\n\t/* Write superblocks */\n\terr = logfs_write_sb(sb);\n\tBUG_ON(err);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_write_sb",
          "args": [
            "sb"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/super.c",
          "lines": "213-228",
          "snippet": "int logfs_write_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\t/* First superblock */\n\terr = write_one_sb(sb, super->s_devops->find_first_sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Last superblock */\n\terr = write_one_sb(sb, super->s_devops->find_last_sb);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include \"logfs.h\"\n\nint logfs_write_sb(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\t/* First superblock */\n\terr = write_one_sb(sb, super->s_devops->find_first_sb);\n\tif (err)\n\t\treturn err;\n\n\t/* Last superblock */\n\terr = write_one_sb(sb, super->s_devops->find_last_sb);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_anchor",
          "args": [
            "sb"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "734-803",
          "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeseg",
          "args": [
            "sb",
            "area->a_segno"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "freeseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "711-730",
          "snippet": "void freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid freeseg(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tu64 ofs, start, end;\n\n\tstart = dev_ofs(sb, segno, 0);\n\tend = dev_ofs(sb, segno + 1, 0);\n\tfor (ofs = start; ofs < end; ofs += PAGE_SIZE) {\n\t\tpage = find_get_page(mapping, ofs >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (PagePrivate(page)) {\n\t\t\tClearPagePrivate(page);\n\t\t\tpage_cache_release(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_erase_segment",
          "args": [
            "sb",
            "segno",
            "1"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_erase_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "29-37",
          "snippet": "int logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "head",
            "segno",
            "(void *)1",
            "GFP_NOFS"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_set_segment_reserved",
          "args": [
            "sb",
            "segno"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_segment_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2112-2115",
          "snippet": "void logfs_set_segment_reserved(struct super_block *sb, u32 segno)\n{\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_reserved, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_reserved(struct super_block *sb, u32 segno)\n{\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_reserved, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_best_cand",
          "args": [
            "sb",
            "&super->s_reserve_list",
            "&ec"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "get_best_cand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/gc.c",
          "lines": "234-248",
          "snippet": "u32 get_best_cand(struct super_block *sb, struct candidate_list *list, u32 *ec)\n{\n\tstruct gc_candidate *cand;\n\tu32 segno;\n\n\tBUG_ON(list->count == 0);\n\n\tcand = rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n\tremove_from_list(cand);\n\tsegno = cand->segno;\n\tif (ec)\n\t\t*ec = cand->erase_count;\n\tfree_candidate(sb, cand);\n\treturn segno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu32 get_best_cand(struct super_block *sb, struct candidate_list *list, u32 *ec)\n{\n\tstruct gc_candidate *cand;\n\tu32 segno;\n\n\tBUG_ON(list->count == 0);\n\n\tcand = rb_entry(rb_first(&list->rb_tree), struct gc_candidate, rb_node);\n\tremove_from_list(cand);\n\tsegno = cand->segno;\n\tif (ec)\n\t\t*ec = cand->erase_count;\n\tfree_candidate(sb, cand);\n\treturn segno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_set_segment_unreserved",
          "args": [
            "sb",
            "super->s_journal_seg[i]",
            "super->s_journal_ec[i]"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_segment_unreserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2124-2130",
          "snippet": "void logfs_set_segment_unreserved(struct super_block *sb, u32 segno, u32 ec)\n{\n\tu32 ec_level = ec << 4;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_unreserved,\n\t\t\tec_level);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_unreserved(struct super_block *sb, u32 segno, u32 ec)\n{\n\tu32 ec_level = ec << 4;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_unreserved,\n\t\t\tec_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btree_remove32",
          "args": [
            "head",
            "super->s_journal_seg[i]"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_journal",
          "args": [
            "\"Journal requires wear-leveling.\\n\""
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid do_logfs_journal_wl_pass(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tu32 segno, ec;\n\tint i, err;\n\n\tlog_journal(\"Journal requires wear-leveling.\\n\");\n\t/* Drop old segments */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tbtree_remove32(head, super->s_journal_seg[i]);\n\t\t\tlogfs_set_segment_unreserved(sb,\n\t\t\t\t\tsuper->s_journal_seg[i],\n\t\t\t\t\tsuper->s_journal_ec[i]);\n\t\t\tsuper->s_journal_seg[i] = 0;\n\t\t\tsuper->s_journal_ec[i] = 0;\n\t\t}\n\t/* Get new segments */\n\tfor (i = 0; i < super->s_no_journal_segs; i++) {\n\t\tsegno = get_best_cand(sb, &super->s_reserve_list, &ec);\n\t\tsuper->s_journal_seg[i] = segno;\n\t\tsuper->s_journal_ec[i] = ec;\n\t\tlogfs_set_segment_reserved(sb, segno);\n\t\terr = btree_insert32(head, segno, (void *)1, GFP_NOFS);\n\t\tBUG_ON(err); /* mempool should prevent this */\n\t\terr = logfs_erase_segment(sb, segno, 1);\n\t\tBUG_ON(err); /* FIXME: remount-ro would be nicer */\n\t}\n\t/* Manually move journal_area */\n\tfreeseg(sb, area->a_segno);\n\tarea->a_segno = super->s_journal_seg[0];\n\tarea->a_is_open = 0;\n\tarea->a_used_bytes = 0;\n\t/* Write journal */\n\tlogfs_write_anchor(sb);\n\t/* Write superblocks */\n\terr = logfs_write_sb(sb);\n\tBUG_ON(err);\n}"
  },
  {
    "function_name": "logfs_write_anchor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "734-803",
    "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&super->s_journal_mutex"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "super->s_devops->sync",
          "args": [
            "sb"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "area->a_used_bytes != area->a_written_bytes"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_sync_area",
          "args": [
            "area"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_sync_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "770-784",
          "snippet": "void logfs_sync_area(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tu32 len = (area->a_used_bytes - area->a_written_bytes);\n\n\tif (super->s_writesize)\n\t\tlen &= ~(super->s_writesize - 1);\n\tif (len == 0)\n\t\treturn;\n\tpad_wbuf(area, 0);\n\tsuper->s_devops->writeseg(sb, ofs, len);\n\tarea->a_written_bytes += len;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_sync_area(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tu32 len = (area->a_used_bytes - area->a_written_bytes);\n\n\tif (super->s_writesize)\n\t\tlen &= ~(super->s_writesize - 1);\n\tif (len == 0)\n\t\treturn;\n\tpad_wbuf(area, 0);\n\tsuper->s_devops->writeseg(sb, ofs, len);\n\tarea->a_written_bytes += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_journal",
          "args": [
            "\"Write commit to %llx\\n\"",
            "be64_to_cpu(super->s_je_array[super->s_no_je - 1])"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "super->s_je_array[super->s_no_je - 1]"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_write_je",
          "args": [
            "sb",
            "logfs_write_commit"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_je",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "673-683",
          "snippet": "static int logfs_write_je(struct super_block *sb,\n\t\tvoid* (*write)(struct super_block *sb, void *scratch,\n\t\t\tu16 *type, size_t *len))\n{\n\tvoid *buf;\n\tsize_t len;\n\tu16 type;\n\n\tbuf = write(sb, logfs_super(sb)->s_je, &type, &len);\n\treturn logfs_write_je_buf(sb, buf, type, len);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_je(struct super_block *sb,\n\t\tvoid* (*write)(struct super_block *sb, void *scratch,\n\t\t\tu16 *type, size_t *len))\n{\n\tvoid *buf;\n\tsize_t len;\n\tu16 type;\n\n\tbuf = write(sb, logfs_super(sb)->s_je, &type, &len);\n\treturn logfs_write_je_buf(sb, buf, type, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "super->s_devops->sync",
          "args": [
            "sb"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_write_obj_aliases",
          "args": [
            "sb"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_obj_aliases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "709-726",
          "snippet": "static int logfs_write_obj_aliases(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\tlog_journal(\"logfs_write_obj_aliases: %d aliases to write\\n\",\n\t\t\tsuper->s_no_object_aliases);\n\tsuper->s_je_fill = 0;\n\terr = logfs_write_obj_aliases_pagecache(sb);\n\tif (err)\n\t\treturn err;\n\n\tif (super->s_je_fill)\n\t\terr = logfs_write_je_buf(sb, super->s_je, JE_OBJ_ALIAS,\n\t\t\t\tsuper->s_je_fill\n\t\t\t\t* sizeof(struct logfs_obj_alias));\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_obj_aliases(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\tlog_journal(\"logfs_write_obj_aliases: %d aliases to write\\n\",\n\t\t\tsuper->s_no_object_aliases);\n\tsuper->s_je_fill = 0;\n\terr = logfs_write_obj_aliases_pagecache(sb);\n\tif (err)\n\t\treturn err;\n\n\tif (super->s_je_fill)\n\t\terr = logfs_write_je_buf(sb, super->s_je, JE_OBJ_ALIAS,\n\t\t\t\tsuper->s_je_fill\n\t\t\t\t* sizeof(struct logfs_obj_alias));\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_shadows",
          "args": [
            "sb"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "account_shadows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "491-513",
          "snippet": "static void account_shadows(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tbtree_grim_visitor64(&tree->new, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor64(&tree->old, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor32(&tree->segment_map, 0, NULL);\n\ttree->no_shadowed_segments = 0;\n\n\tif (li->li_block) {\n\t\t/*\n\t\t * We never actually use the structure, when attached to the\n\t\t * master inode.  But it is easier to always free it here than\n\t\t * to have checks in several places elsewhere when allocating\n\t\t * it.\n\t\t */\n\t\tli->li_block->ops->free_block(sb, li->li_block);\n\t}\n\tBUG_ON((s64)li->li_used_bytes < 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void account_shadows(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tbtree_grim_visitor64(&tree->new, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor64(&tree->old, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor32(&tree->segment_map, 0, NULL);\n\ttree->no_shadowed_segments = 0;\n\n\tif (li->li_block) {\n\t\t/*\n\t\t * We never actually use the structure, when attached to the\n\t\t * master inode.  But it is easier to always free it here than\n\t\t * to have checks in several places elsewhere when allocating\n\t\t * it.\n\t\t */\n\t\tli->li_block->ops->free_block(sb, li->li_block);\n\t}\n\tBUG_ON((s64)li->li_used_bytes < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_sync_segments",
          "args": [
            "sb"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_sync_segments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "786-793",
          "snippet": "void logfs_sync_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tlogfs_sync_area(super->s_area[i]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_sync_segments(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tfor_each_area(i)\n\t\tlogfs_sync_area(super->s_area[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&super->s_journal_mutex"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_flags & LOGFS_SB_FLAG_SHUTDOWN"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
  },
  {
    "function_name": "logfs_write_obj_aliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "709-726",
    "snippet": "static int logfs_write_obj_aliases(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\tlog_journal(\"logfs_write_obj_aliases: %d aliases to write\\n\",\n\t\t\tsuper->s_no_object_aliases);\n\tsuper->s_je_fill = 0;\n\terr = logfs_write_obj_aliases_pagecache(sb);\n\tif (err)\n\t\treturn err;\n\n\tif (super->s_je_fill)\n\t\terr = logfs_write_je_buf(sb, super->s_je, JE_OBJ_ALIAS,\n\t\t\t\tsuper->s_je_fill\n\t\t\t\t* sizeof(struct logfs_obj_alias));\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_write_je_buf",
          "args": [
            "sb",
            "super->s_je",
            "JE_OBJ_ALIAS",
            "super->s_je_fill\n\t\t\t\t* sizeof(struct logfs_obj_alias)"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_je_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "650-671",
          "snippet": "static int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_obj_aliases_pagecache",
          "args": [
            "sb"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_obj_aliases_pagecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "529-541",
          "snippet": "int logfs_write_obj_aliases_pagecache(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint err;\n\n\tlist_for_each_entry(block, &super->s_object_alias, alias_list) {\n\t\terr = block->ops->write_alias(sb, block, write_alias_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_write_obj_aliases_pagecache(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tint err;\n\n\tlist_for_each_entry(block, &super->s_object_alias, alias_list) {\n\t\terr = block->ops->write_alias(sb, block, write_alias_journal);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_journal",
          "args": [
            "\"logfs_write_obj_aliases: %d aliases to write\\n\"",
            "super->s_no_object_aliases"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_obj_aliases(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err;\n\n\tlog_journal(\"logfs_write_obj_aliases: %d aliases to write\\n\",\n\t\t\tsuper->s_no_object_aliases);\n\tsuper->s_je_fill = 0;\n\terr = logfs_write_obj_aliases_pagecache(sb);\n\tif (err)\n\t\treturn err;\n\n\tif (super->s_je_fill)\n\t\terr = logfs_write_je_buf(sb, super->s_je, JE_OBJ_ALIAS,\n\t\t\t\tsuper->s_je_fill\n\t\t\t\t* sizeof(struct logfs_obj_alias));\n\treturn err;\n}"
  },
  {
    "function_name": "write_alias_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "685-707",
    "snippet": "int write_alias_journal(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, int child_no, __be64 val)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_obj_alias *oa = super->s_je;\n\tint err = 0, fill = super->s_je_fill;\n\n\tlog_aliases(\"logfs_write_obj_aliases #%x(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\tfill, ino, bix, level, child_no, be64_to_cpu(val));\n\toa[fill].ino = cpu_to_be64(ino);\n\toa[fill].bix = cpu_to_be64(bix);\n\toa[fill].val = val;\n\toa[fill].level = (__force u8)level;\n\toa[fill].child_no = cpu_to_be16(child_no);\n\tfill++;\n\tif (fill >= sb->s_blocksize / sizeof(*oa)) {\n\t\terr = logfs_write_je_buf(sb, oa, JE_OBJ_ALIAS, sb->s_blocksize);\n\t\tfill = 0;\n\t}\n\n\tsuper->s_je_fill = fill;\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_write_je_buf",
          "args": [
            "sb",
            "oa",
            "JE_OBJ_ALIAS",
            "sb->s_blocksize"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_je_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "650-671",
          "snippet": "static int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "child_no"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bix"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ino"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_aliases",
          "args": [
            "\"logfs_write_obj_aliases #%x(%llx, %llx, %x, %x) %llx\\n\"",
            "fill",
            "ino",
            "bix",
            "level",
            "child_no",
            "be64_to_cpu(val)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "val"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint write_alias_journal(struct super_block *sb, u64 ino, u64 bix,\n\t\tlevel_t level, int child_no, __be64 val)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_obj_alias *oa = super->s_je;\n\tint err = 0, fill = super->s_je_fill;\n\n\tlog_aliases(\"logfs_write_obj_aliases #%x(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\tfill, ino, bix, level, child_no, be64_to_cpu(val));\n\toa[fill].ino = cpu_to_be64(ino);\n\toa[fill].bix = cpu_to_be64(bix);\n\toa[fill].val = val;\n\toa[fill].level = (__force u8)level;\n\toa[fill].child_no = cpu_to_be16(child_no);\n\tfill++;\n\tif (fill >= sb->s_blocksize / sizeof(*oa)) {\n\t\terr = logfs_write_je_buf(sb, oa, JE_OBJ_ALIAS, sb->s_blocksize);\n\t\tfill = 0;\n\t}\n\n\tsuper->s_je_fill = fill;\n\treturn err;\n}"
  },
  {
    "function_name": "logfs_write_je",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "673-683",
    "snippet": "static int logfs_write_je(struct super_block *sb,\n\t\tvoid* (*write)(struct super_block *sb, void *scratch,\n\t\t\tu16 *type, size_t *len))\n{\n\tvoid *buf;\n\tsize_t len;\n\tu16 type;\n\n\tbuf = write(sb, logfs_super(sb)->s_je, &type, &len);\n\treturn logfs_write_je_buf(sb, buf, type, len);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_write_je_buf",
          "args": [
            "sb",
            "buf",
            "type",
            "len"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_je_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "650-671",
          "snippet": "static int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_je(struct super_block *sb,\n\t\tvoid* (*write)(struct super_block *sb, void *scratch,\n\t\t\tu16 *type, size_t *len))\n{\n\tvoid *buf;\n\tsize_t len;\n\tu16 type;\n\n\tbuf = write(sb, logfs_super(sb)->s_je, &type, &len);\n\treturn logfs_write_je_buf(sb, buf, type, len);\n}"
  },
  {
    "function_name": "logfs_write_je_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "650-671",
    "snippet": "static int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ofs"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "super->s_no_je >= MAX_JOURNAL_ENTRIES"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_buf_write",
          "args": [
            "area",
            "ofs",
            "super->s_compressed_je",
            "len"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_buf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "608-612",
          "snippet": "static inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_free_bytes",
          "args": [
            "area",
            "&len",
            "must_pad"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_free_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "628-648",
          "snippet": "static s64 logfs_get_free_bytes(struct logfs_area *area, size_t *bytes,\n\t\tint must_pad)\n{\n\tu32 writesize = logfs_super(area->a_sb)->s_writesize;\n\ts32 ofs;\n\tint ret;\n\n\tret = logfs_open_area(area, *bytes);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += *bytes;\n\n\tif (must_pad) {\n\t\tarea->a_used_bytes = ALIGN(area->a_used_bytes, writesize);\n\t\t*bytes = area->a_used_bytes - ofs;\n\t}\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 logfs_get_free_bytes(struct logfs_area *area, size_t *bytes,\n\t\tint must_pad)\n{\n\tu32 writesize = logfs_super(area->a_sb)->s_writesize;\n\ts32 ofs;\n\tint ret;\n\n\tret = logfs_open_area(area, *bytes);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += *bytes;\n\n\tif (must_pad) {\n\t\tarea->a_used_bytes = ALIGN(area->a_used_bytes, writesize);\n\t\t*bytes = area->a_used_bytes - ofs;\n\t}\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "JE_COMMIT"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__logfs_write_je",
          "args": [
            "sb",
            "buf",
            "type",
            "buf_len"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_je",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "603-626",
          "snippet": "static size_t __logfs_write_je(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tvoid *header = super->s_compressed_je;\n\tvoid *data = header + sizeof(struct logfs_journal_header);\n\tssize_t compr_len, pad_len;\n\tu8 compr = COMPR_ZLIB;\n\n\tif (len == 0)\n\t\treturn logfs_write_header(super, header, 0, type);\n\n\tcompr_len = logfs_compress(buf, data, len, sb->s_blocksize);\n\tif (compr_len < 0 || type == JE_ANCHOR) {\n\t\tmemcpy(data, buf, len);\n\t\tcompr_len = len;\n\t\tcompr = COMPR_NONE;\n\t}\n\n\tpad_len = ALIGN(compr_len, 16);\n\tmemset(data + compr_len, 0, pad_len - compr_len);\n\n\treturn __logfs_write_header(super, header, compr_len, len, type, compr);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic size_t __logfs_write_je(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tvoid *header = super->s_compressed_je;\n\tvoid *data = header + sizeof(struct logfs_journal_header);\n\tssize_t compr_len, pad_len;\n\tu8 compr = COMPR_ZLIB;\n\n\tif (len == 0)\n\t\treturn logfs_write_header(super, header, 0, type);\n\n\tcompr_len = logfs_compress(buf, data, len, sb->s_blocksize);\n\tif (compr_len < 0 || type == JE_ANCHOR) {\n\t\tmemcpy(data, buf, len);\n\t\tcompr_len = len;\n\t\tcompr = COMPR_NONE;\n\t}\n\n\tpad_len = ALIGN(compr_len, 16);\n\tmemset(data + compr_len, 0, pad_len - compr_len);\n\n\treturn __logfs_write_header(super, header, compr_len, len, type, compr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_je_buf(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t buf_len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tsize_t len;\n\tint must_pad = 0;\n\ts64 ofs;\n\n\tlen = __logfs_write_je(sb, buf, type, buf_len);\n\tif (jh->h_type == cpu_to_be16(JE_COMMIT))\n\t\tmust_pad = 1;\n\n\tofs = logfs_get_free_bytes(area, &len, must_pad);\n\tif (ofs < 0)\n\t\treturn ofs;\n\tlogfs_buf_write(area, ofs, super->s_compressed_je, len);\n\tBUG_ON(super->s_no_je >= MAX_JOURNAL_ENTRIES);\n\tsuper->s_je_array[super->s_no_je++] = cpu_to_be64(ofs);\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_get_free_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "628-648",
    "snippet": "static s64 logfs_get_free_bytes(struct logfs_area *area, size_t *bytes,\n\t\tint must_pad)\n{\n\tu32 writesize = logfs_super(area->a_sb)->s_writesize;\n\ts32 ofs;\n\tint ret;\n\n\tret = logfs_open_area(area, *bytes);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += *bytes;\n\n\tif (must_pad) {\n\t\tarea->a_used_bytes = ALIGN(area->a_used_bytes, writesize);\n\t\t*bytes = area->a_used_bytes - ofs;\n\t}\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "area->a_sb",
            "area->a_segno",
            "ofs"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "area->a_used_bytes",
            "writesize"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_open_area",
          "args": [
            "area",
            "*bytes"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_open_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "732-768",
          "snippet": "int logfs_open_area(struct logfs_area *area, size_t bytes)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err, closed = 0;\n\n\tif (area->a_is_open && area->a_used_bytes + bytes <= super->s_segsize)\n\t\treturn 0;\n\n\tif (area->a_is_open) {\n\t\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\t\tu32 len = super->s_segsize - area->a_written_bytes;\n\n\t\tlog_gc(\"logfs_close_area(%x)\\n\", area->a_segno);\n\t\tpad_wbuf(area, 1);\n\t\tsuper->s_devops->writeseg(area->a_sb, ofs, len);\n\t\tfreeseg(sb, area->a_segno);\n\t\tclosed = 1;\n\t}\n\n\tarea->a_used_bytes = 0;\n\tarea->a_written_bytes = 0;\nagain:\n\tarea->a_ops->get_free_segment(area);\n\tarea->a_ops->get_erase_count(area);\n\n\tlog_gc(\"logfs_open_area(%x, %x)\\n\", area->a_segno, area->a_level);\n\terr = area->a_ops->erase_segment(area);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"LogFS: Error erasing segment %x\\n\",\n\t\t\t\tarea->a_segno);\n\t\tlogfs_mark_segment_bad(sb, area->a_segno);\n\t\tgoto again;\n\t}\n\tarea->a_is_open = 1;\n\treturn closed;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_open_area(struct logfs_area *area, size_t bytes)\n{\n\tstruct super_block *sb = area->a_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tint err, closed = 0;\n\n\tif (area->a_is_open && area->a_used_bytes + bytes <= super->s_segsize)\n\t\treturn 0;\n\n\tif (area->a_is_open) {\n\t\tu64 ofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\t\tu32 len = super->s_segsize - area->a_written_bytes;\n\n\t\tlog_gc(\"logfs_close_area(%x)\\n\", area->a_segno);\n\t\tpad_wbuf(area, 1);\n\t\tsuper->s_devops->writeseg(area->a_sb, ofs, len);\n\t\tfreeseg(sb, area->a_segno);\n\t\tclosed = 1;\n\t}\n\n\tarea->a_used_bytes = 0;\n\tarea->a_written_bytes = 0;\nagain:\n\tarea->a_ops->get_free_segment(area);\n\tarea->a_ops->get_erase_count(area);\n\n\tlog_gc(\"logfs_open_area(%x, %x)\\n\", area->a_segno, area->a_level);\n\terr = area->a_ops->erase_segment(area);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"LogFS: Error erasing segment %x\\n\",\n\t\t\t\tarea->a_segno);\n\t\tlogfs_mark_segment_bad(sb, area->a_segno);\n\t\tgoto again;\n\t}\n\tarea->a_is_open = 1;\n\treturn closed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "area->a_sb"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic s64 logfs_get_free_bytes(struct logfs_area *area, size_t *bytes,\n\t\tint must_pad)\n{\n\tu32 writesize = logfs_super(area->a_sb)->s_writesize;\n\ts32 ofs;\n\tint ret;\n\n\tret = logfs_open_area(area, *bytes);\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\tofs = area->a_used_bytes;\n\tarea->a_used_bytes += *bytes;\n\n\tif (must_pad) {\n\t\tarea->a_used_bytes = ALIGN(area->a_used_bytes, writesize);\n\t\t*bytes = area->a_used_bytes - ofs;\n\t}\n\n\treturn dev_ofs(area->a_sb, area->a_segno, ofs);\n}"
  },
  {
    "function_name": "__logfs_write_je",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "603-626",
    "snippet": "static size_t __logfs_write_je(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tvoid *header = super->s_compressed_je;\n\tvoid *data = header + sizeof(struct logfs_journal_header);\n\tssize_t compr_len, pad_len;\n\tu8 compr = COMPR_ZLIB;\n\n\tif (len == 0)\n\t\treturn logfs_write_header(super, header, 0, type);\n\n\tcompr_len = logfs_compress(buf, data, len, sb->s_blocksize);\n\tif (compr_len < 0 || type == JE_ANCHOR) {\n\t\tmemcpy(data, buf, len);\n\t\tcompr_len = len;\n\t\tcompr = COMPR_NONE;\n\t}\n\n\tpad_len = ALIGN(compr_len, 16);\n\tmemset(data + compr_len, 0, pad_len - compr_len);\n\n\treturn __logfs_write_header(super, header, compr_len, len, type, compr);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_write_header",
          "args": [
            "super",
            "header",
            "compr_len",
            "len",
            "type",
            "compr"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "420-435",
          "snippet": "static size_t __logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t len, size_t datalen,\n\t\tu16 type, u8 compr)\n{\n\tjh->h_len\t= cpu_to_be16(len);\n\tjh->h_type\t= cpu_to_be16(type);\n\tjh->h_datalen\t= cpu_to_be16(datalen);\n\tjh->h_compr\t= compr;\n\tjh->h_pad[0]\t= 'H';\n\tjh->h_pad[1]\t= 'E';\n\tjh->h_pad[2]\t= 'A';\n\tjh->h_pad[3]\t= 'D';\n\tjh->h_pad[4]\t= 'R';\n\tjh->h_crc\t= logfs_crc32(jh, len + sizeof(*jh), 4);\n\treturn ALIGN(len, 16) + sizeof(*jh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic size_t __logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t len, size_t datalen,\n\t\tu16 type, u8 compr)\n{\n\tjh->h_len\t= cpu_to_be16(len);\n\tjh->h_type\t= cpu_to_be16(type);\n\tjh->h_datalen\t= cpu_to_be16(datalen);\n\tjh->h_compr\t= compr;\n\tjh->h_pad[0]\t= 'H';\n\tjh->h_pad[1]\t= 'E';\n\tjh->h_pad[2]\t= 'A';\n\tjh->h_pad[3]\t= 'D';\n\tjh->h_pad[4]\t= 'R';\n\tjh->h_crc\t= logfs_crc32(jh, len + sizeof(*jh), 4);\n\treturn ALIGN(len, 16) + sizeof(*jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data + compr_len",
            "0",
            "pad_len - compr_len"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "compr_len",
            "16"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "buf",
            "len"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_compress",
          "args": [
            "buf",
            "data",
            "len",
            "sb->s_blocksize"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/compr.c",
          "lines": "17-49",
          "snippet": "int logfs_compress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_deflateInit(&stream, COMPR_LEVEL);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define COMPR_LEVEL 3"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(compr_mutex);",
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include \"logfs.h\"\n\n#define COMPR_LEVEL 3\n\nstatic DEFINE_MUTEX(compr_mutex);\nstatic struct z_stream_s stream;\n\nint logfs_compress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_deflateInit(&stream, COMPR_LEVEL);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_header",
          "args": [
            "super",
            "header",
            "0",
            "type"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "437-443",
          "snippet": "static size_t logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t datalen, u16 type)\n{\n\tsize_t len = datalen;\n\n\treturn __logfs_write_header(super, jh, len, datalen, type, COMPR_NONE);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic size_t logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t datalen, u16 type)\n{\n\tsize_t len = datalen;\n\n\treturn __logfs_write_header(super, jh, len, datalen, type, COMPR_NONE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic size_t __logfs_write_je(struct super_block *sb, void *buf, u16 type,\n\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tvoid *header = super->s_compressed_je;\n\tvoid *data = header + sizeof(struct logfs_journal_header);\n\tssize_t compr_len, pad_len;\n\tu8 compr = COMPR_ZLIB;\n\n\tif (len == 0)\n\t\treturn logfs_write_header(super, header, 0, type);\n\n\tcompr_len = logfs_compress(buf, data, len, sb->s_blocksize);\n\tif (compr_len < 0 || type == JE_ANCHOR) {\n\t\tmemcpy(data, buf, len);\n\t\tcompr_len = len;\n\t\tcompr = COMPR_NONE;\n\t}\n\n\tpad_len = ALIGN(compr_len, 16);\n\tmemset(data + compr_len, 0, pad_len - compr_len);\n\n\treturn __logfs_write_header(super, header, compr_len, len, type, compr);\n}"
  },
  {
    "function_name": "logfs_write_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "593-601",
    "snippet": "static void *logfs_write_commit(struct super_block *sb, void *h,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t*type = JE_COMMIT;\n\t*len = super->s_no_je * sizeof(__be64);\n\treturn super->s_je_array;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *logfs_write_commit(struct super_block *sb, void *h,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t*type = JE_COMMIT;\n\t*len = super->s_no_je * sizeof(__be64);\n\treturn super->s_je_array;\n}"
  },
  {
    "function_name": "logfs_write_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "574-591",
    "snippet": "static void *logfs_write_area(struct super_block *sb, void *_a,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[super->s_sum_index];\n\tstruct logfs_je_area *a = _a;\n\n\ta->vim = VIM_DEFAULT;\n\ta->gc_level = super->s_sum_index;\n\ta->used_bytes = cpu_to_be32(area->a_used_bytes);\n\ta->segno = cpu_to_be32(area->a_segno);\n\tif (super->s_writesize > 1)\n\t\twrite_wbuf(sb, area, a + 1);\n\n\t*type = JE_AREA;\n\t*len = sizeof(*a) + super->s_writesize;\n\treturn a;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_wbuf",
          "args": [
            "sb",
            "area",
            "a + 1"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "write_wbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "553-572",
          "snippet": "static void write_wbuf(struct super_block *sb, struct logfs_area *area,\n\t\tvoid *wbuf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tu64 ofs;\n\tpgoff_t index;\n\tint page_ofs;\n\tstruct page *page;\n\n\tofs = dev_ofs(sb, area->a_segno,\n\t\t\tarea->a_used_bytes & ~(super->s_writesize - 1));\n\tindex = ofs >> PAGE_SHIFT;\n\tpage_ofs = ofs & (PAGE_SIZE - 1);\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tBUG_ON(!page);\n\tmemcpy(wbuf, page_address(page) + page_ofs, super->s_writesize);\n\tunlock_page(page);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void write_wbuf(struct super_block *sb, struct logfs_area *area,\n\t\tvoid *wbuf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tu64 ofs;\n\tpgoff_t index;\n\tint page_ofs;\n\tstruct page *page;\n\n\tofs = dev_ofs(sb, area->a_segno,\n\t\t\tarea->a_used_bytes & ~(super->s_writesize - 1));\n\tindex = ofs >> PAGE_SHIFT;\n\tpage_ofs = ofs & (PAGE_SIZE - 1);\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tBUG_ON(!page);\n\tmemcpy(wbuf, page_address(page) + page_ofs, super->s_writesize);\n\tunlock_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "area->a_segno"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "area->a_used_bytes"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *logfs_write_area(struct super_block *sb, void *_a,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[super->s_sum_index];\n\tstruct logfs_je_area *a = _a;\n\n\ta->vim = VIM_DEFAULT;\n\ta->gc_level = super->s_sum_index;\n\ta->used_bytes = cpu_to_be32(area->a_used_bytes);\n\ta->segno = cpu_to_be32(area->a_segno);\n\tif (super->s_writesize > 1)\n\t\twrite_wbuf(sb, area, a + 1);\n\n\t*type = JE_AREA;\n\t*len = sizeof(*a) + super->s_writesize;\n\treturn a;\n}"
  },
  {
    "function_name": "write_wbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "553-572",
    "snippet": "static void write_wbuf(struct super_block *sb, struct logfs_area *area,\n\t\tvoid *wbuf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tu64 ofs;\n\tpgoff_t index;\n\tint page_ofs;\n\tstruct page *page;\n\n\tofs = dev_ofs(sb, area->a_segno,\n\t\t\tarea->a_used_bytes & ~(super->s_writesize - 1));\n\tindex = ofs >> PAGE_SHIFT;\n\tpage_ofs = ofs & (PAGE_SIZE - 1);\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tBUG_ON(!page);\n\tmemcpy(wbuf, page_address(page) + page_ofs, super->s_writesize);\n\tunlock_page(page);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "wbuf",
            "page_address(page) + page_ofs",
            "super->s_writesize"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_used_bytes & ~(super->s_writesize - 1)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void write_wbuf(struct super_block *sb, struct logfs_area *area,\n\t\tvoid *wbuf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tu64 ofs;\n\tpgoff_t index;\n\tint page_ofs;\n\tstruct page *page;\n\n\tofs = dev_ofs(sb, area->a_segno,\n\t\t\tarea->a_used_bytes & ~(super->s_writesize - 1));\n\tindex = ofs >> PAGE_SHIFT;\n\tpage_ofs = ofs & (PAGE_SIZE - 1);\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tBUG_ON(!page);\n\tmemcpy(wbuf, page_address(page) + page_ofs, super->s_writesize);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "logfs_write_dynsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "535-551",
    "snippet": "static void *logfs_write_dynsb(struct super_block *sb, void *_dynsb,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_je_dynsb *dynsb = _dynsb;\n\n\tdynsb->ds_gec\t\t= cpu_to_be64(super->s_gec);\n\tdynsb->ds_sweeper\t= cpu_to_be64(super->s_sweeper);\n\tdynsb->ds_victim_ino\t= cpu_to_be64(super->s_victim_ino);\n\tdynsb->ds_rename_dir\t= cpu_to_be64(super->s_rename_dir);\n\tdynsb->ds_rename_pos\t= cpu_to_be64(super->s_rename_pos);\n\tdynsb->ds_used_bytes\t= cpu_to_be64(super->s_used_bytes);\n\tdynsb->ds_generation\t= cpu_to_be32(super->s_generation);\n\t*type = JE_DYNSB;\n\t*len = sizeof(*dynsb);\n\treturn dynsb;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "super->s_generation"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_used_bytes"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_rename_pos"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_rename_dir"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_victim_ino"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_sweeper"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_gec"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *logfs_write_dynsb(struct super_block *sb, void *_dynsb,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_je_dynsb *dynsb = _dynsb;\n\n\tdynsb->ds_gec\t\t= cpu_to_be64(super->s_gec);\n\tdynsb->ds_sweeper\t= cpu_to_be64(super->s_sweeper);\n\tdynsb->ds_victim_ino\t= cpu_to_be64(super->s_victim_ino);\n\tdynsb->ds_rename_dir\t= cpu_to_be64(super->s_rename_dir);\n\tdynsb->ds_rename_pos\t= cpu_to_be64(super->s_rename_pos);\n\tdynsb->ds_used_bytes\t= cpu_to_be64(super->s_used_bytes);\n\tdynsb->ds_generation\t= cpu_to_be32(super->s_generation);\n\t*type = JE_DYNSB;\n\t*len = sizeof(*dynsb);\n\treturn dynsb;\n}"
  },
  {
    "function_name": "__logfs_write_anchor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "515-533",
    "snippet": "static void *__logfs_write_anchor(struct super_block *sb, void *_da,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_je_anchor *da = _da;\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tda->da_height\t= li->li_height;\n\tda->da_last_ino = cpu_to_be64(super->s_last_ino);\n\tda->da_size\t= cpu_to_be64(i_size_read(inode));\n\tda->da_used_bytes = cpu_to_be64(li->li_used_bytes);\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tda->da_data[i] = cpu_to_be64(li->li_data[i]);\n\t*type = JE_ANCHOR;\n\t*len = sizeof(*da);\n\treturn da;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "li->li_data[i]"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "li->li_used_bytes"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "i_size_read(inode)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "super->s_last_ino"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *__logfs_write_anchor(struct super_block *sb, void *_da,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_je_anchor *da = _da;\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tda->da_height\t= li->li_height;\n\tda->da_last_ino = cpu_to_be64(super->s_last_ino);\n\tda->da_size\t= cpu_to_be64(i_size_read(inode));\n\tda->da_used_bytes = cpu_to_be64(li->li_used_bytes);\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tda->da_data[i] = cpu_to_be64(li->li_data[i]);\n\t*type = JE_ANCHOR;\n\t*len = sizeof(*da);\n\treturn da;\n}"
  },
  {
    "function_name": "account_shadows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "491-513",
    "snippet": "static void account_shadows(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tbtree_grim_visitor64(&tree->new, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor64(&tree->old, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor32(&tree->segment_map, 0, NULL);\n\ttree->no_shadowed_segments = 0;\n\n\tif (li->li_block) {\n\t\t/*\n\t\t * We never actually use the structure, when attached to the\n\t\t * master inode.  But it is easier to always free it here than\n\t\t * to have checks in several places elsewhere when allocating\n\t\t * it.\n\t\t */\n\t\tli->li_block->ops->free_block(sb, li->li_block);\n\t}\n\tBUG_ON((s64)li->li_used_bytes < 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(s64)li->li_used_bytes < 0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "li->li_block->ops->free_block",
          "args": [
            "sb",
            "li->li_block"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_grim_visitor32",
          "args": [
            "&tree->segment_map",
            "0",
            "NULL"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_grim_visitor64",
          "args": [
            "&tree->old",
            "(unsigned long)sb",
            "account_shadow"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_grim_visitor64",
          "args": [
            "&tree->new",
            "(unsigned long)sb",
            "account_shadow"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void account_shadows(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tstruct shadow_tree *tree = &super->s_shadow_tree;\n\n\tbtree_grim_visitor64(&tree->new, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor64(&tree->old, (unsigned long)sb, account_shadow);\n\tbtree_grim_visitor32(&tree->segment_map, 0, NULL);\n\ttree->no_shadowed_segments = 0;\n\n\tif (li->li_block) {\n\t\t/*\n\t\t * We never actually use the structure, when attached to the\n\t\t * master inode.  But it is easier to always free it here than\n\t\t * to have checks in several places elsewhere when allocating\n\t\t * it.\n\t\t */\n\t\tli->li_block->ops->free_block(sb, li->li_block);\n\t}\n\tBUG_ON((s64)li->li_used_bytes < 0);\n}"
  },
  {
    "function_name": "account_shadow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "464-489",
    "snippet": "static void account_shadow(void *_shadow, unsigned long _sb, u64 ignore,\n\t\tsize_t ignore2)\n{\n\tstruct logfs_shadow *shadow = _shadow;\n\tstruct super_block *sb = (void *)_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t/* consume new space */\n\tsuper->s_free_bytes\t  -= shadow->new_len;\n\tsuper->s_used_bytes\t  += shadow->new_len;\n\tsuper->s_dirty_used_bytes -= shadow->new_len;\n\n\t/* free up old space */\n\tsuper->s_free_bytes\t  += shadow->old_len;\n\tsuper->s_used_bytes\t  -= shadow->old_len;\n\tsuper->s_dirty_free_bytes -= shadow->old_len;\n\n\tlogfs_set_segment_used(sb, shadow->old_ofs, -shadow->old_len);\n\tlogfs_set_segment_used(sb, shadow->new_ofs, shadow->new_len);\n\n\tlog_journal(\"account_shadow(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\tmempool_free(shadow, super->s_shadow_pool);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "shadow",
            "super->s_shadow_pool"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_journal",
          "args": [
            "\"account_shadow(%llx, %llx, %x) %llx->%llx %x->%x\\n\"",
            "shadow->ino",
            "shadow->bix",
            "shadow->gc_level",
            "shadow->old_ofs",
            "shadow->new_ofs",
            "shadow->old_len",
            "shadow->new_len"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_set_segment_used",
          "args": [
            "sb",
            "shadow->new_ofs",
            "shadow->new_len"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_segment_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2083-2092",
          "snippet": "void logfs_set_segment_used(struct super_block *sb, u64 ofs, int increment)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno = ofs >> super->s_segshift;\n\n\tif (!increment)\n\t\treturn;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_used, increment);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_set_segment_used(struct super_block *sb, u64 ofs, int increment)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu32 segno = ofs >> super->s_segshift;\n\n\tif (!increment)\n\t\treturn;\n\n\tlogfs_mod_segment_entry(sb, segno, 1, __set_segment_used, increment);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void account_shadow(void *_shadow, unsigned long _sb, u64 ignore,\n\t\tsize_t ignore2)\n{\n\tstruct logfs_shadow *shadow = _shadow;\n\tstruct super_block *sb = (void *)_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\n\t/* consume new space */\n\tsuper->s_free_bytes\t  -= shadow->new_len;\n\tsuper->s_used_bytes\t  += shadow->new_len;\n\tsuper->s_dirty_used_bytes -= shadow->new_len;\n\n\t/* free up old space */\n\tsuper->s_free_bytes\t  += shadow->old_len;\n\tsuper->s_used_bytes\t  -= shadow->old_len;\n\tsuper->s_dirty_free_bytes -= shadow->old_len;\n\n\tlogfs_set_segment_used(sb, shadow->old_ofs, -shadow->old_len);\n\tlogfs_set_segment_used(sb, shadow->new_ofs, shadow->new_len);\n\n\tlog_journal(\"account_shadow(%llx, %llx, %x) %llx->%llx %x->%x\\n\",\n\t\t\tshadow->ino, shadow->bix, shadow->gc_level,\n\t\t\tshadow->old_ofs, shadow->new_ofs,\n\t\t\tshadow->old_len, shadow->new_len);\n\tmempool_free(shadow, super->s_shadow_pool);\n}"
  },
  {
    "function_name": "logfs_write_erasecount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "450-462",
    "snippet": "static void *logfs_write_erasecount(struct super_block *sb, void *_ec,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_je_journal_ec *ec = _ec;\n\tint i;\n\n\tjournal_for_each(i)\n\t\tec->ec[i] = cpu_to_be32(super->s_journal_ec[i]);\n\t*type = JE_ERASECOUNT;\n\t*len = logfs_journal_erasecount_size(super);\n\treturn ec;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_journal_erasecount_size",
          "args": [
            "super"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_journal_erasecount_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "445-448",
          "snippet": "static inline size_t logfs_journal_erasecount_size(struct logfs_super *super)\n{\n\treturn LOGFS_JOURNAL_SEGS * sizeof(__be32);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic inline size_t logfs_journal_erasecount_size(struct logfs_super *super)\n{\n\treturn LOGFS_JOURNAL_SEGS * sizeof(__be32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "super->s_journal_ec[i]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *logfs_write_erasecount(struct super_block *sb, void *_ec,\n\t\tu16 *type, size_t *len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_je_journal_ec *ec = _ec;\n\tint i;\n\n\tjournal_for_each(i)\n\t\tec->ec[i] = cpu_to_be32(super->s_journal_ec[i]);\n\t*type = JE_ERASECOUNT;\n\t*len = logfs_journal_erasecount_size(super);\n\treturn ec;\n}"
  },
  {
    "function_name": "logfs_journal_erasecount_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "445-448",
    "snippet": "static inline size_t logfs_journal_erasecount_size(struct logfs_super *super)\n{\n\treturn LOGFS_JOURNAL_SEGS * sizeof(__be32);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic inline size_t logfs_journal_erasecount_size(struct logfs_super *super)\n{\n\treturn LOGFS_JOURNAL_SEGS * sizeof(__be32);\n}"
  },
  {
    "function_name": "logfs_write_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "437-443",
    "snippet": "static size_t logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t datalen, u16 type)\n{\n\tsize_t len = datalen;\n\n\treturn __logfs_write_header(super, jh, len, datalen, type, COMPR_NONE);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_write_header",
          "args": [
            "super",
            "jh",
            "len",
            "datalen",
            "type",
            "COMPR_NONE"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "420-435",
          "snippet": "static size_t __logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t len, size_t datalen,\n\t\tu16 type, u8 compr)\n{\n\tjh->h_len\t= cpu_to_be16(len);\n\tjh->h_type\t= cpu_to_be16(type);\n\tjh->h_datalen\t= cpu_to_be16(datalen);\n\tjh->h_compr\t= compr;\n\tjh->h_pad[0]\t= 'H';\n\tjh->h_pad[1]\t= 'E';\n\tjh->h_pad[2]\t= 'A';\n\tjh->h_pad[3]\t= 'D';\n\tjh->h_pad[4]\t= 'R';\n\tjh->h_crc\t= logfs_crc32(jh, len + sizeof(*jh), 4);\n\treturn ALIGN(len, 16) + sizeof(*jh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic size_t __logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t len, size_t datalen,\n\t\tu16 type, u8 compr)\n{\n\tjh->h_len\t= cpu_to_be16(len);\n\tjh->h_type\t= cpu_to_be16(type);\n\tjh->h_datalen\t= cpu_to_be16(datalen);\n\tjh->h_compr\t= compr;\n\tjh->h_pad[0]\t= 'H';\n\tjh->h_pad[1]\t= 'E';\n\tjh->h_pad[2]\t= 'A';\n\tjh->h_pad[3]\t= 'D';\n\tjh->h_pad[4]\t= 'R';\n\tjh->h_crc\t= logfs_crc32(jh, len + sizeof(*jh), 4);\n\treturn ALIGN(len, 16) + sizeof(*jh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic size_t logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t datalen, u16 type)\n{\n\tsize_t len = datalen;\n\n\treturn __logfs_write_header(super, jh, len, datalen, type, COMPR_NONE);\n}"
  },
  {
    "function_name": "__logfs_write_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "420-435",
    "snippet": "static size_t __logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t len, size_t datalen,\n\t\tu16 type, u8 compr)\n{\n\tjh->h_len\t= cpu_to_be16(len);\n\tjh->h_type\t= cpu_to_be16(type);\n\tjh->h_datalen\t= cpu_to_be16(datalen);\n\tjh->h_compr\t= compr;\n\tjh->h_pad[0]\t= 'H';\n\tjh->h_pad[1]\t= 'E';\n\tjh->h_pad[2]\t= 'A';\n\tjh->h_pad[3]\t= 'D';\n\tjh->h_pad[4]\t= 'R';\n\tjh->h_crc\t= logfs_crc32(jh, len + sizeof(*jh), 4);\n\treturn ALIGN(len, 16) + sizeof(*jh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "16"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "jh",
            "len + sizeof(*jh)",
            "4"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "datalen"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "type"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "len"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic size_t __logfs_write_header(struct logfs_super *super,\n\t\tstruct logfs_journal_header *jh, size_t len, size_t datalen,\n\t\tu16 type, u8 compr)\n{\n\tjh->h_len\t= cpu_to_be16(len);\n\tjh->h_type\t= cpu_to_be16(type);\n\tjh->h_datalen\t= cpu_to_be16(datalen);\n\tjh->h_compr\t= compr;\n\tjh->h_pad[0]\t= 'H';\n\tjh->h_pad[1]\t= 'E';\n\tjh->h_pad[2]\t= 'A';\n\tjh->h_pad[3]\t= 'D';\n\tjh->h_pad[4]\t= 'R';\n\tjh->h_crc\t= logfs_crc32(jh, len + sizeof(*jh), 4);\n\treturn ALIGN(len, 16) + sizeof(*jh);\n}"
  },
  {
    "function_name": "journal_erase_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "388-418",
    "snippet": "static int journal_erase_segment(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tunion {\n\t\tstruct logfs_segment_header sh;\n\t\tunsigned char c[ALIGN(sizeof(struct logfs_segment_header), 16)];\n\t} u;\n\tu64 ofs;\n\tint err;\n\n\terr = logfs_erase_segment(sb, area->a_segno, 1);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&u, 0, sizeof(u));\n\tu.sh.pad = 0;\n\tu.sh.type = SEG_JOURNAL;\n\tu.sh.level = 0;\n\tu.sh.segno = cpu_to_be32(area->a_segno);\n\tu.sh.ec = cpu_to_be32(area->a_erase_count);\n\tu.sh.gec = cpu_to_be64(logfs_super(sb)->s_gec);\n\tu.sh.crc = logfs_crc32(&u.sh, sizeof(u.sh), 4);\n\n\t/* This causes a bug in segment.c.  Not yet. */\n\t//logfs_set_segment_erased(sb, area->a_segno, area->a_erase_count, 0);\n\n\tofs = dev_ofs(sb, area->a_segno, 0);\n\tarea->a_used_bytes = sizeof(u);\n\tlogfs_buf_write(area, ofs, &u, sizeof(u));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_buf_write",
          "args": [
            "area",
            "ofs",
            "&u",
            "sizeof(u)"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_buf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "608-612",
          "snippet": "static inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline int logfs_buf_write(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "0"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "&u.sh",
            "sizeof(u.sh)",
            "4"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "logfs_super(sb)->s_gec"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "area->a_erase_count"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "area->a_segno"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&u",
            "0",
            "sizeof(u)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_erase_segment",
          "args": [
            "sb",
            "area->a_segno",
            "1"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_erase_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "29-37",
          "snippet": "int logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint logfs_erase_segment(struct super_block *sb, u32 segno, int ensure_erase)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec++;\n\n\treturn super->s_devops->erase(sb, (u64)segno << super->s_segshift,\n\t\t\tsuper->s_segsize, ensure_erase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(struct logfs_segment_header)",
            "16"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int journal_erase_segment(struct logfs_area *area)\n{\n\tstruct super_block *sb = area->a_sb;\n\tunion {\n\t\tstruct logfs_segment_header sh;\n\t\tunsigned char c[ALIGN(sizeof(struct logfs_segment_header), 16)];\n\t} u;\n\tu64 ofs;\n\tint err;\n\n\terr = logfs_erase_segment(sb, area->a_segno, 1);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&u, 0, sizeof(u));\n\tu.sh.pad = 0;\n\tu.sh.type = SEG_JOURNAL;\n\tu.sh.level = 0;\n\tu.sh.segno = cpu_to_be32(area->a_segno);\n\tu.sh.ec = cpu_to_be32(area->a_erase_count);\n\tu.sh.gec = cpu_to_be64(logfs_super(sb)->s_gec);\n\tu.sh.crc = logfs_crc32(&u.sh, sizeof(u.sh), 4);\n\n\t/* This causes a bug in segment.c.  Not yet. */\n\t//logfs_set_segment_erased(sb, area->a_segno, area->a_erase_count, 0);\n\n\tofs = dev_ofs(sb, area->a_segno, 0);\n\tarea->a_used_bytes = sizeof(u);\n\tlogfs_buf_write(area, ofs, &u, sizeof(u));\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_get_erase_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "382-386",
    "snippet": "static void journal_get_erase_count(struct logfs_area *area)\n{\n\t/* erase count is stored globally and incremented in\n\t * journal_get_free_segment() - nothing to do here */\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void journal_get_erase_count(struct logfs_area *area)\n{\n\t/* erase count is stored globally and incremented in\n\t * journal_get_free_segment() - nothing to do here */\n}"
  },
  {
    "function_name": "journal_get_free_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "358-380",
    "snippet": "static void journal_get_free_segment(struct logfs_area *area)\n{\n\tstruct logfs_super *super = logfs_super(area->a_sb);\n\tint i;\n\n\tjournal_for_each(i) {\n\t\tif (area->a_segno != super->s_journal_seg[i])\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\ti++;\n\t\t\tif (i == LOGFS_JOURNAL_SEGS)\n\t\t\t\ti = 0;\n\t\t} while (!super->s_journal_seg[i]);\n\n\t\tarea->a_segno = super->s_journal_seg[i];\n\t\tarea->a_erase_count = ++(super->s_journal_ec[i]);\n\t\tlog_journal(\"Journal now at %x (ec %x)\\n\", area->a_segno,\n\t\t\t\tarea->a_erase_count);\n\t\treturn;\n\t}\n\tBUG();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_journal",
          "args": [
            "\"Journal now at %x (ec %x)\\n\"",
            "area->a_segno",
            "area->a_erase_count"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "area->a_sb"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void journal_get_free_segment(struct logfs_area *area)\n{\n\tstruct logfs_super *super = logfs_super(area->a_sb);\n\tint i;\n\n\tjournal_for_each(i) {\n\t\tif (area->a_segno != super->s_journal_seg[i])\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\ti++;\n\t\t\tif (i == LOGFS_JOURNAL_SEGS)\n\t\t\t\ti = 0;\n\t\t} while (!super->s_journal_seg[i]);\n\n\t\tarea->a_segno = super->s_journal_seg[i];\n\t\tarea->a_erase_count = ++(super->s_journal_ec[i]);\n\t\tlog_journal(\"Journal now at %x (ec %x)\\n\", area->a_segno,\n\t\t\t\tarea->a_erase_count);\n\t\treturn;\n\t}\n\tBUG();\n}"
  },
  {
    "function_name": "logfs_read_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "331-352",
    "snippet": "static int logfs_read_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 gec[LOGFS_JOURNAL_SEGS], max;\n\tu32 segno;\n\tint i, max_i;\n\n\tmax = 0;\n\tmax_i = -1;\n\tjournal_for_each(i) {\n\t\tsegno = super->s_journal_seg[i];\n\t\tgec[i] = read_gec(sb, super->s_journal_seg[i]);\n\t\tif (gec[i] > max) {\n\t\t\tmax = gec[i];\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i == -1)\n\t\treturn -EIO;\n\t/* FIXME: Try older segments in case of error */\n\treturn logfs_read_segment(sb, super->s_journal_seg[max_i]);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_read_segment",
          "args": [
            "sb",
            "super->s_journal_seg[max_i]"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_segment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "260-309",
          "snippet": "static int logfs_read_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tu64 ofs, seg_ofs = dev_ofs(sb, segno, 0);\n\tu32 h_ofs, last_ofs = 0;\n\tu16 len, datalen, last_len = 0;\n\tint i, err;\n\n\t/* search for most recent commit */\n\tfor (h_ofs = 0; h_ofs < super->s_segsize; h_ofs += sizeof(*jh)) {\n\t\tofs = seg_ofs + h_ofs;\n\t\terr = __read_je_header(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tif (jh->h_type != cpu_to_be16(JE_COMMIT))\n\t\t\tcontinue;\n\t\terr = __read_je_payload(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tlen = be16_to_cpu(jh->h_len);\n\t\tdatalen = be16_to_cpu(jh->h_datalen);\n\t\tif ((datalen > sizeof(super->s_je_array)) ||\n\t\t\t\t(datalen % sizeof(__be64)))\n\t\t\tcontinue;\n\t\tlast_ofs = h_ofs;\n\t\tlast_len = datalen;\n\t\th_ofs += ALIGN(len, sizeof(*jh)) - sizeof(*jh);\n\t}\n\t/* read commit */\n\tif (last_ofs == 0)\n\t\treturn -ENOENT;\n\tofs = seg_ofs + last_ofs;\n\tlog_journal(\"Read commit from %llx\\n\", ofs);\n\terr = __read_je(sb, ofs, jh);\n\tBUG_ON(err); /* We should have caught it in the scan loop already */\n\tif (err)\n\t\treturn err;\n\t/* uncompress */\n\tunpack(jh, super->s_je_array);\n\tsuper->s_no_je = last_len / sizeof(__be64);\n\t/* iterate over array */\n\tfor (i = 0; i < super->s_no_je; i++) {\n\t\terr = read_je(sb, be64_to_cpu(super->s_je_array[i]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tsuper->s_journal_area->a_segno = segno;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tu64 ofs, seg_ofs = dev_ofs(sb, segno, 0);\n\tu32 h_ofs, last_ofs = 0;\n\tu16 len, datalen, last_len = 0;\n\tint i, err;\n\n\t/* search for most recent commit */\n\tfor (h_ofs = 0; h_ofs < super->s_segsize; h_ofs += sizeof(*jh)) {\n\t\tofs = seg_ofs + h_ofs;\n\t\terr = __read_je_header(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tif (jh->h_type != cpu_to_be16(JE_COMMIT))\n\t\t\tcontinue;\n\t\terr = __read_je_payload(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tlen = be16_to_cpu(jh->h_len);\n\t\tdatalen = be16_to_cpu(jh->h_datalen);\n\t\tif ((datalen > sizeof(super->s_je_array)) ||\n\t\t\t\t(datalen % sizeof(__be64)))\n\t\t\tcontinue;\n\t\tlast_ofs = h_ofs;\n\t\tlast_len = datalen;\n\t\th_ofs += ALIGN(len, sizeof(*jh)) - sizeof(*jh);\n\t}\n\t/* read commit */\n\tif (last_ofs == 0)\n\t\treturn -ENOENT;\n\tofs = seg_ofs + last_ofs;\n\tlog_journal(\"Read commit from %llx\\n\", ofs);\n\terr = __read_je(sb, ofs, jh);\n\tBUG_ON(err); /* We should have caught it in the scan loop already */\n\tif (err)\n\t\treturn err;\n\t/* uncompress */\n\tunpack(jh, super->s_je_array);\n\tsuper->s_no_je = last_len / sizeof(__be64);\n\t/* iterate over array */\n\tfor (i = 0; i < super->s_no_je; i++) {\n\t\terr = read_je(sb, be64_to_cpu(super->s_je_array[i]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tsuper->s_journal_area->a_segno = segno;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_gec",
          "args": [
            "sb",
            "super->s_journal_seg[i]"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "read_gec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "311-329",
          "snippet": "static u64 read_gec(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_segment_header sh;\n\t__be32 crc;\n\tint err;\n\n\tif (!segno)\n\t\treturn 0;\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tif (err)\n\t\treturn 0;\n\tcrc = logfs_crc32(&sh, sizeof(sh), 4);\n\tif (crc != sh.crc) {\n\t\tWARN_ON(sh.gec != cpu_to_be64(0xffffffffffffffffull));\n\t\t/* Most likely it was just erased */\n\t\treturn 0;\n\t}\n\treturn be64_to_cpu(sh.gec);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic u64 read_gec(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_segment_header sh;\n\t__be32 crc;\n\tint err;\n\n\tif (!segno)\n\t\treturn 0;\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tif (err)\n\t\treturn 0;\n\tcrc = logfs_crc32(&sh, sizeof(sh), 4);\n\tif (crc != sh.crc) {\n\t\tWARN_ON(sh.gec != cpu_to_be64(0xffffffffffffffffull));\n\t\t/* Most likely it was just erased */\n\t\treturn 0;\n\t}\n\treturn be64_to_cpu(sh.gec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 gec[LOGFS_JOURNAL_SEGS], max;\n\tu32 segno;\n\tint i, max_i;\n\n\tmax = 0;\n\tmax_i = -1;\n\tjournal_for_each(i) {\n\t\tsegno = super->s_journal_seg[i];\n\t\tgec[i] = read_gec(sb, super->s_journal_seg[i]);\n\t\tif (gec[i] > max) {\n\t\t\tmax = gec[i];\n\t\t\tmax_i = i;\n\t\t}\n\t}\n\tif (max_i == -1)\n\t\treturn -EIO;\n\t/* FIXME: Try older segments in case of error */\n\treturn logfs_read_segment(sb, super->s_journal_seg[max_i]);\n}"
  },
  {
    "function_name": "read_gec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "311-329",
    "snippet": "static u64 read_gec(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_segment_header sh;\n\t__be32 crc;\n\tint err;\n\n\tif (!segno)\n\t\treturn 0;\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tif (err)\n\t\treturn 0;\n\tcrc = logfs_crc32(&sh, sizeof(sh), 4);\n\tif (crc != sh.crc) {\n\t\tWARN_ON(sh.gec != cpu_to_be64(0xffffffffffffffffull));\n\t\t/* Most likely it was just erased */\n\t\treturn 0;\n\t}\n\treturn be64_to_cpu(sh.gec);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "sh.gec"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sh.gec != cpu_to_be64(0xffffffffffffffffull)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "0xffffffffffffffffull"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "&sh",
            "sizeof(sh)",
            "4"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "dev_ofs(sb, segno, 0)",
            "sizeof(sh)",
            "&sh"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "segno",
            "0"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic u64 read_gec(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_segment_header sh;\n\t__be32 crc;\n\tint err;\n\n\tif (!segno)\n\t\treturn 0;\n\terr = wbuf_read(sb, dev_ofs(sb, segno, 0), sizeof(sh), &sh);\n\tif (err)\n\t\treturn 0;\n\tcrc = logfs_crc32(&sh, sizeof(sh), 4);\n\tif (crc != sh.crc) {\n\t\tWARN_ON(sh.gec != cpu_to_be64(0xffffffffffffffffull));\n\t\t/* Most likely it was just erased */\n\t\treturn 0;\n\t}\n\treturn be64_to_cpu(sh.gec);\n}"
  },
  {
    "function_name": "logfs_read_segment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "260-309",
    "snippet": "static int logfs_read_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tu64 ofs, seg_ofs = dev_ofs(sb, segno, 0);\n\tu32 h_ofs, last_ofs = 0;\n\tu16 len, datalen, last_len = 0;\n\tint i, err;\n\n\t/* search for most recent commit */\n\tfor (h_ofs = 0; h_ofs < super->s_segsize; h_ofs += sizeof(*jh)) {\n\t\tofs = seg_ofs + h_ofs;\n\t\terr = __read_je_header(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tif (jh->h_type != cpu_to_be16(JE_COMMIT))\n\t\t\tcontinue;\n\t\terr = __read_je_payload(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tlen = be16_to_cpu(jh->h_len);\n\t\tdatalen = be16_to_cpu(jh->h_datalen);\n\t\tif ((datalen > sizeof(super->s_je_array)) ||\n\t\t\t\t(datalen % sizeof(__be64)))\n\t\t\tcontinue;\n\t\tlast_ofs = h_ofs;\n\t\tlast_len = datalen;\n\t\th_ofs += ALIGN(len, sizeof(*jh)) - sizeof(*jh);\n\t}\n\t/* read commit */\n\tif (last_ofs == 0)\n\t\treturn -ENOENT;\n\tofs = seg_ofs + last_ofs;\n\tlog_journal(\"Read commit from %llx\\n\", ofs);\n\terr = __read_je(sb, ofs, jh);\n\tBUG_ON(err); /* We should have caught it in the scan loop already */\n\tif (err)\n\t\treturn err;\n\t/* uncompress */\n\tunpack(jh, super->s_je_array);\n\tsuper->s_no_je = last_len / sizeof(__be64);\n\t/* iterate over array */\n\tfor (i = 0; i < super->s_no_je; i++) {\n\t\terr = read_je(sb, be64_to_cpu(super->s_je_array[i]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tsuper->s_journal_area->a_segno = segno;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_je",
          "args": [
            "sb",
            "be64_to_cpu(super->s_je_array[i])"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "read_je",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "222-258",
          "snippet": "static int read_je(struct super_block *sb, u64 ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tvoid *scratch = super->s_je;\n\tu16 type, datalen;\n\tint err;\n\n\terr = __read_je(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\n\tswitch (type) {\n\tcase JE_DYNSB:\n\t\tread_dynsb(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ANCHOR:\n\t\tread_anchor(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ERASECOUNT:\n\t\tread_erasecount(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_AREA:\n\t\terr = read_area(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_OBJ_ALIAS:\n\t\terr = logfs_load_object_aliases(sb, unpack(jh, scratch),\n\t\t\t\tdatalen);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_je(struct super_block *sb, u64 ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tvoid *scratch = super->s_je;\n\tu16 type, datalen;\n\tint err;\n\n\terr = __read_je(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\n\tswitch (type) {\n\tcase JE_DYNSB:\n\t\tread_dynsb(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ANCHOR:\n\t\tread_anchor(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ERASECOUNT:\n\t\tread_erasecount(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_AREA:\n\t\terr = read_area(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_OBJ_ALIAS:\n\t\terr = logfs_load_object_aliases(sb, unpack(jh, scratch),\n\t\t\t\tdatalen);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "super->s_je_array[i]"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack",
          "args": [
            "jh",
            "super->s_je_array"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "140-157",
          "snippet": "static void *unpack(void *from, void *to)\n{\n\tstruct logfs_journal_header *jh = from;\n\tvoid *data = from + sizeof(struct logfs_journal_header);\n\tint err;\n\tsize_t inlen, outlen;\n\n\tinlen = be16_to_cpu(jh->h_len);\n\toutlen = be16_to_cpu(jh->h_datalen);\n\n\tif (jh->h_compr == COMPR_NONE)\n\t\tmemcpy(to, data, inlen);\n\telse {\n\t\terr = logfs_uncompress(data, to, inlen, outlen);\n\t\tBUG_ON(err);\n\t}\n\treturn to;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *unpack(void *from, void *to)\n{\n\tstruct logfs_journal_header *jh = from;\n\tvoid *data = from + sizeof(struct logfs_journal_header);\n\tint err;\n\tsize_t inlen, outlen;\n\n\tinlen = be16_to_cpu(jh->h_len);\n\toutlen = be16_to_cpu(jh->h_datalen);\n\n\tif (jh->h_compr == COMPR_NONE)\n\t\tmemcpy(to, data, inlen);\n\telse {\n\t\terr = logfs_uncompress(data, to, inlen, outlen);\n\t\tBUG_ON(err);\n\t}\n\treturn to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__read_je",
          "args": [
            "sb",
            "ofs",
            "jh"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__read_je",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "211-220",
          "snippet": "static int __read_je(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tint err;\n\n\terr = __read_je_header(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\treturn __read_je_payload(sb, ofs, jh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tint err;\n\n\terr = __read_je_header(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\treturn __read_je_payload(sb, ofs, jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_journal",
          "args": [
            "\"Read commit from %llx\\n\"",
            "ofs"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "sizeof(*jh)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_datalen"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_len"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__read_je_payload",
          "args": [
            "sb",
            "ofs",
            "jh"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__read_je_payload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "184-206",
          "snippet": "static int __read_je_payload(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tu16 len;\n\tint err;\n\n\tlen = be16_to_cpu(jh->h_len);\n\terr = wbuf_read(sb, ofs + sizeof(*jh), len, jh + 1);\n\tif (err)\n\t\treturn err;\n\tif (jh->h_crc != logfs_crc32(jh, len + sizeof(*jh), 4)) {\n\t\t/* Old code was confused.  It forgot about the header length\n\t\t * and stopped calculating the crc 16 bytes before the end\n\t\t * of data - ick!\n\t\t * FIXME: Remove this hack once the old code is fixed.\n\t\t */\n\t\tif (jh->h_crc == logfs_crc32(jh, len, 4))\n\t\t\tWARN_ON_ONCE(1);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je_payload(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tu16 len;\n\tint err;\n\n\tlen = be16_to_cpu(jh->h_len);\n\terr = wbuf_read(sb, ofs + sizeof(*jh), len, jh + 1);\n\tif (err)\n\t\treturn err;\n\tif (jh->h_crc != logfs_crc32(jh, len + sizeof(*jh), 4)) {\n\t\t/* Old code was confused.  It forgot about the header length\n\t\t * and stopped calculating the crc 16 bytes before the end\n\t\t * of data - ick!\n\t\t * FIXME: Remove this hack once the old code is fixed.\n\t\t */\n\t\tif (jh->h_crc == logfs_crc32(jh, len, 4))\n\t\t\tWARN_ON_ONCE(1);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "JE_COMMIT"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__read_je_header",
          "args": [
            "sb",
            "ofs",
            "jh"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__read_je_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "159-182",
          "snippet": "static int __read_je_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tu16 type, len, datalen;\n\tint err;\n\n\t/* read header only */\n\terr = wbuf_read(sb, ofs, sizeof(*jh), jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tlen = be16_to_cpu(jh->h_len);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\tif (len > sb->s_blocksize)\n\t\treturn -EIO;\n\tif ((type < JE_FIRST) || (type > JE_LAST))\n\t\treturn -EIO;\n\tif (datalen > bufsize)\n\t\treturn -EIO;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tu16 type, len, datalen;\n\tint err;\n\n\t/* read header only */\n\terr = wbuf_read(sb, ofs, sizeof(*jh), jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tlen = be16_to_cpu(jh->h_len);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\tif (len > sb->s_blocksize)\n\t\treturn -EIO;\n\tif ((type < JE_FIRST) || (type > JE_LAST))\n\t\treturn -EIO;\n\tif (datalen > bufsize)\n\t\treturn -EIO;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "segno",
            "0"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_read_segment(struct super_block *sb, u32 segno)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tu64 ofs, seg_ofs = dev_ofs(sb, segno, 0);\n\tu32 h_ofs, last_ofs = 0;\n\tu16 len, datalen, last_len = 0;\n\tint i, err;\n\n\t/* search for most recent commit */\n\tfor (h_ofs = 0; h_ofs < super->s_segsize; h_ofs += sizeof(*jh)) {\n\t\tofs = seg_ofs + h_ofs;\n\t\terr = __read_je_header(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tif (jh->h_type != cpu_to_be16(JE_COMMIT))\n\t\t\tcontinue;\n\t\terr = __read_je_payload(sb, ofs, jh);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tlen = be16_to_cpu(jh->h_len);\n\t\tdatalen = be16_to_cpu(jh->h_datalen);\n\t\tif ((datalen > sizeof(super->s_je_array)) ||\n\t\t\t\t(datalen % sizeof(__be64)))\n\t\t\tcontinue;\n\t\tlast_ofs = h_ofs;\n\t\tlast_len = datalen;\n\t\th_ofs += ALIGN(len, sizeof(*jh)) - sizeof(*jh);\n\t}\n\t/* read commit */\n\tif (last_ofs == 0)\n\t\treturn -ENOENT;\n\tofs = seg_ofs + last_ofs;\n\tlog_journal(\"Read commit from %llx\\n\", ofs);\n\terr = __read_je(sb, ofs, jh);\n\tBUG_ON(err); /* We should have caught it in the scan loop already */\n\tif (err)\n\t\treturn err;\n\t/* uncompress */\n\tunpack(jh, super->s_je_array);\n\tsuper->s_no_je = last_len / sizeof(__be64);\n\t/* iterate over array */\n\tfor (i = 0; i < super->s_no_je; i++) {\n\t\terr = read_je(sb, be64_to_cpu(super->s_je_array[i]));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tsuper->s_journal_area->a_segno = segno;\n\treturn 0;\n}"
  },
  {
    "function_name": "read_je",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "222-258",
    "snippet": "static int read_je(struct super_block *sb, u64 ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tvoid *scratch = super->s_je;\n\tu16 type, datalen;\n\tint err;\n\n\terr = __read_je(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\n\tswitch (type) {\n\tcase JE_DYNSB:\n\t\tread_dynsb(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ANCHOR:\n\t\tread_anchor(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ERASECOUNT:\n\t\tread_erasecount(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_AREA:\n\t\terr = read_area(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_OBJ_ALIAS:\n\t\terr = logfs_load_object_aliases(sb, unpack(jh, scratch),\n\t\t\t\tdatalen);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_load_object_aliases",
          "args": [
            "sb",
            "unpack(jh, scratch)",
            "datalen"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_load_object_aliases",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "206-250",
          "snippet": "int logfs_load_object_aliases(struct super_block *sb,\n\t\tstruct logfs_obj_alias *oa, int count)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item;\n\tu64 ino, bix;\n\tlevel_t level;\n\tint i, err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_OBJ_ALIAS;\n\tcount /= sizeof(*oa);\n\tfor (i = 0; i < count; i++) {\n\t\titem = mempool_alloc(super->s_alias_pool, GFP_NOFS);\n\t\tif (!item)\n\t\t\treturn -ENOMEM;\n\t\tmemset(item, 0, sizeof(*item));\n\n\t\tsuper->s_no_object_aliases++;\n\t\titem->val = oa[i].val;\n\t\titem->child_no = be16_to_cpu(oa[i].child_no);\n\n\t\tino = be64_to_cpu(oa[i].ino);\n\t\tbix = be64_to_cpu(oa[i].bix);\n\t\tlevel = LEVEL(oa[i].level);\n\n\t\tlog_aliases(\"logfs_load_object_aliases(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\t\tino, bix, level, item->child_no,\n\t\t\t\tbe64_to_cpu(item->val));\n\t\tblock = alias_tree_lookup(sb, ino, bix, level);\n\t\tif (!block) {\n\t\t\tblock = __alloc_block(sb, ino, bix, level);\n\t\t\tblock->ops = &btree_block_ops;\n\t\t\terr = alias_tree_insert(sb, ino, bix, level, block);\n\t\t\tBUG_ON(err); /* mempool empty */\n\t\t}\n\t\tif (test_and_set_bit(item->child_no, block->alias_map)) {\n\t\t\tprintk(KERN_ERR\"LogFS: Alias collision detected\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n\t\tlist_add(&item->list, &block->item_list);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct logfs_block_ops btree_block_ops = {\n\t.write_block\t= btree_write_block,\n\t.free_block\t= __free_block,\n\t.write_alias\t= btree_write_alias,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct logfs_block_ops btree_block_ops = {\n\t.write_block\t= btree_write_block,\n\t.free_block\t= __free_block,\n\t.write_alias\t= btree_write_alias,\n};\n\nint logfs_load_object_aliases(struct super_block *sb,\n\t\tstruct logfs_obj_alias *oa, int count)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_block *block;\n\tstruct object_alias_item *item;\n\tu64 ino, bix;\n\tlevel_t level;\n\tint i, err;\n\n\tsuper->s_flags |= LOGFS_SB_FLAG_OBJ_ALIAS;\n\tcount /= sizeof(*oa);\n\tfor (i = 0; i < count; i++) {\n\t\titem = mempool_alloc(super->s_alias_pool, GFP_NOFS);\n\t\tif (!item)\n\t\t\treturn -ENOMEM;\n\t\tmemset(item, 0, sizeof(*item));\n\n\t\tsuper->s_no_object_aliases++;\n\t\titem->val = oa[i].val;\n\t\titem->child_no = be16_to_cpu(oa[i].child_no);\n\n\t\tino = be64_to_cpu(oa[i].ino);\n\t\tbix = be64_to_cpu(oa[i].bix);\n\t\tlevel = LEVEL(oa[i].level);\n\n\t\tlog_aliases(\"logfs_load_object_aliases(%llx, %llx, %x, %x) %llx\\n\",\n\t\t\t\tino, bix, level, item->child_no,\n\t\t\t\tbe64_to_cpu(item->val));\n\t\tblock = alias_tree_lookup(sb, ino, bix, level);\n\t\tif (!block) {\n\t\t\tblock = __alloc_block(sb, ino, bix, level);\n\t\t\tblock->ops = &btree_block_ops;\n\t\t\terr = alias_tree_insert(sb, ino, bix, level, block);\n\t\t\tBUG_ON(err); /* mempool empty */\n\t\t}\n\t\tif (test_and_set_bit(item->child_no, block->alias_map)) {\n\t\t\tprintk(KERN_ERR\"LogFS: Alias collision detected\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tlist_move_tail(&block->alias_list, &super->s_object_alias);\n\t\tlist_add(&item->list, &block->item_list);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unpack",
          "args": [
            "jh",
            "scratch"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "unpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "140-157",
          "snippet": "static void *unpack(void *from, void *to)\n{\n\tstruct logfs_journal_header *jh = from;\n\tvoid *data = from + sizeof(struct logfs_journal_header);\n\tint err;\n\tsize_t inlen, outlen;\n\n\tinlen = be16_to_cpu(jh->h_len);\n\toutlen = be16_to_cpu(jh->h_datalen);\n\n\tif (jh->h_compr == COMPR_NONE)\n\t\tmemcpy(to, data, inlen);\n\telse {\n\t\terr = logfs_uncompress(data, to, inlen, outlen);\n\t\tBUG_ON(err);\n\t}\n\treturn to;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *unpack(void *from, void *to)\n{\n\tstruct logfs_journal_header *jh = from;\n\tvoid *data = from + sizeof(struct logfs_journal_header);\n\tint err;\n\tsize_t inlen, outlen;\n\n\tinlen = be16_to_cpu(jh->h_len);\n\toutlen = be16_to_cpu(jh->h_datalen);\n\n\tif (jh->h_compr == COMPR_NONE)\n\t\tmemcpy(to, data, inlen);\n\telse {\n\t\terr = logfs_uncompress(data, to, inlen, outlen);\n\t\tBUG_ON(err);\n\t}\n\treturn to;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_area",
          "args": [
            "sb",
            "unpack(jh, scratch)"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "read_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "115-138",
          "snippet": "static int read_area(struct super_block *sb, struct logfs_je_area *a)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[a->gc_level];\n\tu64 ofs;\n\tu32 writemask = ~(super->s_writesize - 1);\n\n\tif (a->gc_level >= LOGFS_NO_AREAS)\n\t\treturn -EIO;\n\tif (a->vim != VIM_DEFAULT)\n\t\treturn -EIO; /* TODO: close area and continue */\n\n\tarea->a_used_bytes = be32_to_cpu(a->used_bytes);\n\tarea->a_written_bytes = area->a_used_bytes & writemask;\n\tarea->a_segno = be32_to_cpu(a->segno);\n\tif (area->a_segno)\n\t\tarea->a_is_open = 1;\n\n\tofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tif (super->s_writesize > 1)\n\t\treturn logfs_buf_recover(area, ofs, a + 1, super->s_writesize);\n\telse\n\t\treturn logfs_buf_recover(area, ofs, NULL, 0);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_area(struct super_block *sb, struct logfs_je_area *a)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[a->gc_level];\n\tu64 ofs;\n\tu32 writemask = ~(super->s_writesize - 1);\n\n\tif (a->gc_level >= LOGFS_NO_AREAS)\n\t\treturn -EIO;\n\tif (a->vim != VIM_DEFAULT)\n\t\treturn -EIO; /* TODO: close area and continue */\n\n\tarea->a_used_bytes = be32_to_cpu(a->used_bytes);\n\tarea->a_written_bytes = area->a_used_bytes & writemask;\n\tarea->a_segno = be32_to_cpu(a->segno);\n\tif (area->a_segno)\n\t\tarea->a_is_open = 1;\n\n\tofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tif (super->s_writesize > 1)\n\t\treturn logfs_buf_recover(area, ofs, a + 1, super->s_writesize);\n\telse\n\t\treturn logfs_buf_recover(area, ofs, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_erasecount",
          "args": [
            "sb",
            "unpack(jh, scratch)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "read_erasecount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "105-113",
          "snippet": "static void read_erasecount(struct super_block *sb,\n\t\tstruct logfs_je_journal_ec *ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_ec[i] = be32_to_cpu(ec->ec[i]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void read_erasecount(struct super_block *sb,\n\t\tstruct logfs_je_journal_ec *ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_ec[i] = be32_to_cpu(ec->ec[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_anchor",
          "args": [
            "sb",
            "unpack(jh, scratch)"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "read_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "87-103",
          "snippet": "static void read_anchor(struct super_block *sb,\n\t\tstruct logfs_je_anchor *da)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tsuper->s_last_ino = be64_to_cpu(da->da_last_ino);\n\tli->li_flags\t= 0;\n\tli->li_height\t= da->da_height;\n\ti_size_write(inode, be64_to_cpu(da->da_size));\n\tli->li_used_bytes = be64_to_cpu(da->da_used_bytes);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = be64_to_cpu(da->da_data[i]);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void read_anchor(struct super_block *sb,\n\t\tstruct logfs_je_anchor *da)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tsuper->s_last_ino = be64_to_cpu(da->da_last_ino);\n\tli->li_flags\t= 0;\n\tli->li_height\t= da->da_height;\n\ti_size_write(inode, be64_to_cpu(da->da_size));\n\tli->li_used_bytes = be64_to_cpu(da->da_used_bytes);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = be64_to_cpu(da->da_data[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_dynsb",
          "args": [
            "sb",
            "unpack(jh, scratch)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "read_dynsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "73-85",
          "snippet": "static void read_dynsb(struct super_block *sb,\n\t\tstruct logfs_je_dynsb *dynsb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec\t\t= be64_to_cpu(dynsb->ds_gec);\n\tsuper->s_sweeper\t= be64_to_cpu(dynsb->ds_sweeper);\n\tsuper->s_victim_ino\t= be64_to_cpu(dynsb->ds_victim_ino);\n\tsuper->s_rename_dir\t= be64_to_cpu(dynsb->ds_rename_dir);\n\tsuper->s_rename_pos\t= be64_to_cpu(dynsb->ds_rename_pos);\n\tsuper->s_used_bytes\t= be64_to_cpu(dynsb->ds_used_bytes);\n\tsuper->s_generation\t= be32_to_cpu(dynsb->ds_generation);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void read_dynsb(struct super_block *sb,\n\t\tstruct logfs_je_dynsb *dynsb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec\t\t= be64_to_cpu(dynsb->ds_gec);\n\tsuper->s_sweeper\t= be64_to_cpu(dynsb->ds_sweeper);\n\tsuper->s_victim_ino\t= be64_to_cpu(dynsb->ds_victim_ino);\n\tsuper->s_rename_dir\t= be64_to_cpu(dynsb->ds_rename_dir);\n\tsuper->s_rename_pos\t= be64_to_cpu(dynsb->ds_rename_pos);\n\tsuper->s_used_bytes\t= be64_to_cpu(dynsb->ds_used_bytes);\n\tsuper->s_generation\t= be32_to_cpu(dynsb->ds_generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_datalen"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_type"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__read_je",
          "args": [
            "sb",
            "ofs",
            "jh"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__read_je",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "211-220",
          "snippet": "static int __read_je(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tint err;\n\n\terr = __read_je_header(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\treturn __read_je_payload(sb, ofs, jh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tint err;\n\n\terr = __read_je_header(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\treturn __read_je_payload(sb, ofs, jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_je(struct super_block *sb, u64 ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_journal_header *jh = super->s_compressed_je;\n\tvoid *scratch = super->s_je;\n\tu16 type, datalen;\n\tint err;\n\n\terr = __read_je(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\n\tswitch (type) {\n\tcase JE_DYNSB:\n\t\tread_dynsb(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ANCHOR:\n\t\tread_anchor(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_ERASECOUNT:\n\t\tread_erasecount(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_AREA:\n\t\terr = read_area(sb, unpack(jh, scratch));\n\t\tbreak;\n\tcase JE_OBJ_ALIAS:\n\t\terr = logfs_load_object_aliases(sb, unpack(jh, scratch),\n\t\t\t\tdatalen);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EIO;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "__read_je",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "211-220",
    "snippet": "static int __read_je(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tint err;\n\n\terr = __read_je_header(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\treturn __read_je_payload(sb, ofs, jh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__read_je_payload",
          "args": [
            "sb",
            "ofs",
            "jh"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__read_je_payload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "184-206",
          "snippet": "static int __read_je_payload(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tu16 len;\n\tint err;\n\n\tlen = be16_to_cpu(jh->h_len);\n\terr = wbuf_read(sb, ofs + sizeof(*jh), len, jh + 1);\n\tif (err)\n\t\treturn err;\n\tif (jh->h_crc != logfs_crc32(jh, len + sizeof(*jh), 4)) {\n\t\t/* Old code was confused.  It forgot about the header length\n\t\t * and stopped calculating the crc 16 bytes before the end\n\t\t * of data - ick!\n\t\t * FIXME: Remove this hack once the old code is fixed.\n\t\t */\n\t\tif (jh->h_crc == logfs_crc32(jh, len, 4))\n\t\t\tWARN_ON_ONCE(1);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je_payload(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tu16 len;\n\tint err;\n\n\tlen = be16_to_cpu(jh->h_len);\n\terr = wbuf_read(sb, ofs + sizeof(*jh), len, jh + 1);\n\tif (err)\n\t\treturn err;\n\tif (jh->h_crc != logfs_crc32(jh, len + sizeof(*jh), 4)) {\n\t\t/* Old code was confused.  It forgot about the header length\n\t\t * and stopped calculating the crc 16 bytes before the end\n\t\t * of data - ick!\n\t\t * FIXME: Remove this hack once the old code is fixed.\n\t\t */\n\t\tif (jh->h_crc == logfs_crc32(jh, len, 4))\n\t\t\tWARN_ON_ONCE(1);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__read_je_header",
          "args": [
            "sb",
            "ofs",
            "jh"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__read_je_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "159-182",
          "snippet": "static int __read_je_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tu16 type, len, datalen;\n\tint err;\n\n\t/* read header only */\n\terr = wbuf_read(sb, ofs, sizeof(*jh), jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tlen = be16_to_cpu(jh->h_len);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\tif (len > sb->s_blocksize)\n\t\treturn -EIO;\n\tif ((type < JE_FIRST) || (type > JE_LAST))\n\t\treturn -EIO;\n\tif (datalen > bufsize)\n\t\treturn -EIO;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tu16 type, len, datalen;\n\tint err;\n\n\t/* read header only */\n\terr = wbuf_read(sb, ofs, sizeof(*jh), jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tlen = be16_to_cpu(jh->h_len);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\tif (len > sb->s_blocksize)\n\t\treturn -EIO;\n\tif ((type < JE_FIRST) || (type > JE_LAST))\n\t\treturn -EIO;\n\tif (datalen > bufsize)\n\t\treturn -EIO;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tint err;\n\n\terr = __read_je_header(sb, ofs, jh);\n\tif (err)\n\t\treturn err;\n\treturn __read_je_payload(sb, ofs, jh);\n}"
  },
  {
    "function_name": "__read_je_payload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "184-206",
    "snippet": "static int __read_je_payload(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tu16 len;\n\tint err;\n\n\tlen = be16_to_cpu(jh->h_len);\n\terr = wbuf_read(sb, ofs + sizeof(*jh), len, jh + 1);\n\tif (err)\n\t\treturn err;\n\tif (jh->h_crc != logfs_crc32(jh, len + sizeof(*jh), 4)) {\n\t\t/* Old code was confused.  It forgot about the header length\n\t\t * and stopped calculating the crc 16 bytes before the end\n\t\t * of data - ick!\n\t\t * FIXME: Remove this hack once the old code is fixed.\n\t\t */\n\t\tif (jh->h_crc == logfs_crc32(jh, len, 4))\n\t\t\tWARN_ON_ONCE(1);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_crc32",
          "args": [
            "jh",
            "len",
            "4"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_crc32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "653-656",
          "snippet": "static inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline __be32 logfs_crc32(void *data, size_t len, size_t skip)\n{\n\treturn cpu_to_be32(crc32(~0, data+skip, len-skip));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "ofs + sizeof(*jh)",
            "len",
            "jh + 1"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_len"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je_payload(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tu16 len;\n\tint err;\n\n\tlen = be16_to_cpu(jh->h_len);\n\terr = wbuf_read(sb, ofs + sizeof(*jh), len, jh + 1);\n\tif (err)\n\t\treturn err;\n\tif (jh->h_crc != logfs_crc32(jh, len + sizeof(*jh), 4)) {\n\t\t/* Old code was confused.  It forgot about the header length\n\t\t * and stopped calculating the crc 16 bytes before the end\n\t\t * of data - ick!\n\t\t * FIXME: Remove this hack once the old code is fixed.\n\t\t */\n\t\tif (jh->h_crc == logfs_crc32(jh, len, 4))\n\t\t\tWARN_ON_ONCE(1);\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__read_je_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "159-182",
    "snippet": "static int __read_je_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tu16 type, len, datalen;\n\tint err;\n\n\t/* read header only */\n\terr = wbuf_read(sb, ofs, sizeof(*jh), jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tlen = be16_to_cpu(jh->h_len);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\tif (len > sb->s_blocksize)\n\t\treturn -EIO;\n\tif ((type < JE_FIRST) || (type > JE_LAST))\n\t\treturn -EIO;\n\tif (datalen > bufsize)\n\t\treturn -EIO;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_datalen"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_len"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_type"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf_read",
          "args": [
            "sb",
            "ofs",
            "sizeof(*jh)",
            "jh"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "wbuf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/segment.c",
          "lines": "400-422",
          "snippet": "int wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nint wbuf_read(struct super_block *sb, u64 ofs, size_t len, void *buf)\n{\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\tstruct page *page;\n\tlong offset = ofs & (PAGE_SIZE-1);\n\tlong copylen;\n\n\twhile (len) {\n\t\tcopylen = min((ulong)len, PAGE_SIZE - offset);\n\n\t\tpage = get_mapping_page(sb, index, 1);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\t\tmemcpy(buf, page_address(page) + offset, copylen);\n\t\tpage_cache_release(page);\n\n\t\tbuf += copylen;\n\t\tlen -= copylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "sb->s_blocksize",
            "super->s_writesize"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int __read_je_header(struct super_block *sb, u64 ofs,\n\t\tstruct logfs_journal_header *jh)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tsize_t bufsize = max_t(size_t, sb->s_blocksize, super->s_writesize)\n\t\t+ MAX_JOURNAL_HEADER;\n\tu16 type, len, datalen;\n\tint err;\n\n\t/* read header only */\n\terr = wbuf_read(sb, ofs, sizeof(*jh), jh);\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(jh->h_type);\n\tlen = be16_to_cpu(jh->h_len);\n\tdatalen = be16_to_cpu(jh->h_datalen);\n\tif (len > sb->s_blocksize)\n\t\treturn -EIO;\n\tif ((type < JE_FIRST) || (type > JE_LAST))\n\t\treturn -EIO;\n\tif (datalen > bufsize)\n\t\treturn -EIO;\n\treturn 0;\n}"
  },
  {
    "function_name": "unpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "140-157",
    "snippet": "static void *unpack(void *from, void *to)\n{\n\tstruct logfs_journal_header *jh = from;\n\tvoid *data = from + sizeof(struct logfs_journal_header);\n\tint err;\n\tsize_t inlen, outlen;\n\n\tinlen = be16_to_cpu(jh->h_len);\n\toutlen = be16_to_cpu(jh->h_datalen);\n\n\tif (jh->h_compr == COMPR_NONE)\n\t\tmemcpy(to, data, inlen);\n\telse {\n\t\terr = logfs_uncompress(data, to, inlen, outlen);\n\t\tBUG_ON(err);\n\t}\n\treturn to;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_uncompress",
          "args": [
            "data",
            "to",
            "inlen",
            "outlen"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_uncompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/compr.c",
          "lines": "51-80",
          "snippet": "int logfs_uncompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_inflateInit(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <linux/vmalloc.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(compr_mutex);",
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <linux/vmalloc.h>\n#include \"logfs.h\"\n\nstatic DEFINE_MUTEX(compr_mutex);\nstatic struct z_stream_s stream;\n\nint logfs_uncompress(void *in, void *out, size_t inlen, size_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\tmutex_lock(&compr_mutex);\n\terr = zlib_inflateInit(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_inflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_inflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tmutex_unlock(&compr_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "to",
            "data",
            "inlen"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_datalen"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "jh->h_len"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void *unpack(void *from, void *to)\n{\n\tstruct logfs_journal_header *jh = from;\n\tvoid *data = from + sizeof(struct logfs_journal_header);\n\tint err;\n\tsize_t inlen, outlen;\n\n\tinlen = be16_to_cpu(jh->h_len);\n\toutlen = be16_to_cpu(jh->h_datalen);\n\n\tif (jh->h_compr == COMPR_NONE)\n\t\tmemcpy(to, data, inlen);\n\telse {\n\t\terr = logfs_uncompress(data, to, inlen, outlen);\n\t\tBUG_ON(err);\n\t}\n\treturn to;\n}"
  },
  {
    "function_name": "read_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "115-138",
    "snippet": "static int read_area(struct super_block *sb, struct logfs_je_area *a)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[a->gc_level];\n\tu64 ofs;\n\tu32 writemask = ~(super->s_writesize - 1);\n\n\tif (a->gc_level >= LOGFS_NO_AREAS)\n\t\treturn -EIO;\n\tif (a->vim != VIM_DEFAULT)\n\t\treturn -EIO; /* TODO: close area and continue */\n\n\tarea->a_used_bytes = be32_to_cpu(a->used_bytes);\n\tarea->a_written_bytes = area->a_used_bytes & writemask;\n\tarea->a_segno = be32_to_cpu(a->segno);\n\tif (area->a_segno)\n\t\tarea->a_is_open = 1;\n\n\tofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tif (super->s_writesize > 1)\n\t\treturn logfs_buf_recover(area, ofs, a + 1, super->s_writesize);\n\telse\n\t\treturn logfs_buf_recover(area, ofs, NULL, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_buf_recover",
          "args": [
            "area",
            "ofs",
            "NULL",
            "0"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_buf_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "614-618",
          "snippet": "static inline int logfs_buf_recover(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 1);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline int logfs_buf_recover(struct logfs_area *area, u64 ofs,\n\t\tvoid *buf, size_t len)\n{\n\treturn __logfs_buf_write(area, ofs, buf, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_ofs",
          "args": [
            "sb",
            "area->a_segno",
            "area->a_written_bytes"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dev_ofs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "668-671",
          "snippet": "static inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u64 dev_ofs(struct super_block *sb, u32 segno, u32 ofs)\n{\n\treturn ((u64)segno << logfs_super(sb)->s_segshift) + ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "a->segno"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "a->used_bytes"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int read_area(struct super_block *sb, struct logfs_je_area *a)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_area[a->gc_level];\n\tu64 ofs;\n\tu32 writemask = ~(super->s_writesize - 1);\n\n\tif (a->gc_level >= LOGFS_NO_AREAS)\n\t\treturn -EIO;\n\tif (a->vim != VIM_DEFAULT)\n\t\treturn -EIO; /* TODO: close area and continue */\n\n\tarea->a_used_bytes = be32_to_cpu(a->used_bytes);\n\tarea->a_written_bytes = area->a_used_bytes & writemask;\n\tarea->a_segno = be32_to_cpu(a->segno);\n\tif (area->a_segno)\n\t\tarea->a_is_open = 1;\n\n\tofs = dev_ofs(sb, area->a_segno, area->a_written_bytes);\n\tif (super->s_writesize > 1)\n\t\treturn logfs_buf_recover(area, ofs, a + 1, super->s_writesize);\n\telse\n\t\treturn logfs_buf_recover(area, ofs, NULL, 0);\n}"
  },
  {
    "function_name": "read_erasecount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "105-113",
    "snippet": "static void read_erasecount(struct super_block *sb,\n\t\tstruct logfs_je_journal_ec *ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_ec[i] = be32_to_cpu(ec->ec[i]);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ec->ec[i]"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void read_erasecount(struct super_block *sb,\n\t\tstruct logfs_je_journal_ec *ec)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint i;\n\n\tjournal_for_each(i)\n\t\tsuper->s_journal_ec[i] = be32_to_cpu(ec->ec[i]);\n}"
  },
  {
    "function_name": "read_anchor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "87-103",
    "snippet": "static void read_anchor(struct super_block *sb,\n\t\tstruct logfs_je_anchor *da)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tsuper->s_last_ino = be64_to_cpu(da->da_last_ino);\n\tli->li_flags\t= 0;\n\tli->li_height\t= da->da_height;\n\ti_size_write(inode, be64_to_cpu(da->da_size));\n\tli->li_used_bytes = be64_to_cpu(da->da_used_bytes);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = be64_to_cpu(da->da_data[i]);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "da->da_data[i]"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "da->da_used_bytes"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "be64_to_cpu(da->da_size)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "da->da_size"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "da->da_last_ino"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void read_anchor(struct super_block *sb,\n\t\tstruct logfs_je_anchor *da)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *inode = super->s_master_inode;\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tsuper->s_last_ino = be64_to_cpu(da->da_last_ino);\n\tli->li_flags\t= 0;\n\tli->li_height\t= da->da_height;\n\ti_size_write(inode, be64_to_cpu(da->da_size));\n\tli->li_used_bytes = be64_to_cpu(da->da_used_bytes);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = be64_to_cpu(da->da_data[i]);\n}"
  },
  {
    "function_name": "read_dynsb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "73-85",
    "snippet": "static void read_dynsb(struct super_block *sb,\n\t\tstruct logfs_je_dynsb *dynsb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec\t\t= be64_to_cpu(dynsb->ds_gec);\n\tsuper->s_sweeper\t= be64_to_cpu(dynsb->ds_sweeper);\n\tsuper->s_victim_ino\t= be64_to_cpu(dynsb->ds_victim_ino);\n\tsuper->s_rename_dir\t= be64_to_cpu(dynsb->ds_rename_dir);\n\tsuper->s_rename_pos\t= be64_to_cpu(dynsb->ds_rename_pos);\n\tsuper->s_used_bytes\t= be64_to_cpu(dynsb->ds_used_bytes);\n\tsuper->s_generation\t= be32_to_cpu(dynsb->ds_generation);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dynsb->ds_generation"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dynsb->ds_used_bytes"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dynsb->ds_rename_pos"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dynsb->ds_rename_dir"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dynsb->ds_victim_ino"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dynsb->ds_sweeper"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dynsb->ds_gec"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void read_dynsb(struct super_block *sb,\n\t\tstruct logfs_je_dynsb *dynsb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tsuper->s_gec\t\t= be64_to_cpu(dynsb->ds_gec);\n\tsuper->s_sweeper\t= be64_to_cpu(dynsb->ds_sweeper);\n\tsuper->s_victim_ino\t= be64_to_cpu(dynsb->ds_victim_ino);\n\tsuper->s_rename_dir\t= be64_to_cpu(dynsb->ds_rename_dir);\n\tsuper->s_rename_pos\t= be64_to_cpu(dynsb->ds_rename_pos);\n\tsuper->s_used_bytes\t= be64_to_cpu(dynsb->ds_used_bytes);\n\tsuper->s_generation\t= be32_to_cpu(dynsb->ds_generation);\n}"
  },
  {
    "function_name": "reserve_sb_and_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "50-71",
    "snippet": "static void reserve_sb_and_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint i, err;\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[0]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[1]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\tjournal_for_each(i) {\n\t\tif (!super->s_journal_seg[i])\n\t\t\tcontinue;\n\t\terr = btree_insert32(head, super->s_journal_seg[i], (void *)1,\n\t\t\t\tGFP_KERNEL);\n\t\tBUG_ON(err);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "head",
            "super->s_journal_seg[i]",
            "(void *)1",
            "GFP_KERNEL"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "head",
            "seg_no(sb, super->s_sb_ofs[1])",
            "(void *)1",
            "GFP_KERNEL"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seg_no",
          "args": [
            "sb",
            "super->s_sb_ofs[1]"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "seg_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "673-676",
          "snippet": "static inline u32 seg_no(struct super_block *sb, u64 ofs)\n{\n\treturn ofs >> logfs_super(sb)->s_segshift;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline u32 seg_no(struct super_block *sb, u64 ofs)\n{\n\treturn ofs >> logfs_super(sb)->s_segshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btree_insert32",
          "args": [
            "head",
            "seg_no(sb, super->s_sb_ofs[0])",
            "(void *)1",
            "GFP_KERNEL"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void reserve_sb_and_journal(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct btree_head32 *head = &super->s_reserved_segments;\n\tint i, err;\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[0]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\terr = btree_insert32(head, seg_no(sb, super->s_sb_ofs[1]), (void *)1,\n\t\t\tGFP_KERNEL);\n\tBUG_ON(err);\n\n\tjournal_for_each(i) {\n\t\tif (!super->s_journal_seg[i])\n\t\t\tcontinue;\n\t\terr = btree_insert32(head, super->s_journal_seg[i], (void *)1,\n\t\t\t\tGFP_KERNEL);\n\t\tBUG_ON(err);\n\t}\n}"
  },
  {
    "function_name": "logfs_calc_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
    "lines": "11-48",
    "snippet": "static void logfs_calc_free(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 reserve, no_segs = super->s_no_segs;\n\ts64 free;\n\tint i;\n\n\t/* superblock segments */\n\tno_segs -= 2;\n\tsuper->s_no_journal_segs = 0;\n\t/* journal */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tno_segs--;\n\t\t\tsuper->s_no_journal_segs++;\n\t\t}\n\n\t/* open segments plus one extra per level for GC */\n\tno_segs -= 2 * super->s_total_levels;\n\n\tfree = no_segs * (super->s_segsize - LOGFS_SEGMENT_RESERVE);\n\tfree -= super->s_used_bytes;\n\t/* just a bit extra */\n\tfree -= super->s_total_levels * 4096;\n\n\t/* Bad blocks are 'paid' for with speed reserve - the filesystem\n\t * simply gets slower as bad blocks accumulate.  Until the bad blocks\n\t * exceed the speed reserve - then the filesystem gets smaller.\n\t */\n\treserve = super->s_bad_segments + super->s_bad_seg_reserve;\n\treserve *= super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\treserve = max(reserve, super->s_speed_reserve);\n\tfree -= reserve;\n\tif (free < 0)\n\t\tfree = 0;\n\n\tsuper->s_free_bytes = free;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "reserve",
            "super->s_speed_reserve"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 13
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_calc_free(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 reserve, no_segs = super->s_no_segs;\n\ts64 free;\n\tint i;\n\n\t/* superblock segments */\n\tno_segs -= 2;\n\tsuper->s_no_journal_segs = 0;\n\t/* journal */\n\tjournal_for_each(i)\n\t\tif (super->s_journal_seg[i]) {\n\t\t\tno_segs--;\n\t\t\tsuper->s_no_journal_segs++;\n\t\t}\n\n\t/* open segments plus one extra per level for GC */\n\tno_segs -= 2 * super->s_total_levels;\n\n\tfree = no_segs * (super->s_segsize - LOGFS_SEGMENT_RESERVE);\n\tfree -= super->s_used_bytes;\n\t/* just a bit extra */\n\tfree -= super->s_total_levels * 4096;\n\n\t/* Bad blocks are 'paid' for with speed reserve - the filesystem\n\t * simply gets slower as bad blocks accumulate.  Until the bad blocks\n\t * exceed the speed reserve - then the filesystem gets smaller.\n\t */\n\treserve = super->s_bad_segments + super->s_bad_seg_reserve;\n\treserve *= super->s_segsize - LOGFS_SEGMENT_RESERVE;\n\treserve = max(reserve, super->s_speed_reserve);\n\tfree -= reserve;\n\tif (free < 0)\n\t\tfree = 0;\n\n\tsuper->s_free_bytes = free;\n}"
  }
]