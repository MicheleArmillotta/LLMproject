[
  {
    "function_name": "journal(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "1008-1082",
    "snippet": "lay_journal(struct ubifs_info *c)\n{\n\tint err, lnum, free;\n\n\tBUILD_BUG_ON(UBIFS_TRUN_KEY > 5);\n\n\t/* Update the status of the index head in lprops to 'taken' */\n\tfree = take_ihead(c);\n\tif (free < 0)\n\t\treturn free; /* Error code */\n\n\tif (c->ihead_offs != c->leb_size - free) {\n\t\tubifs_err(\"bad index head LEB %d:%d\", c->ihead_lnum,\n\t\t\t  c->ihead_offs);\n\t\treturn -EINVAL;\n\t}\n\n\tdbg_mnt(\"start replaying the journal\");\n\tc->replaying = 1;\n\tlnum = c->ltail_lnum = c->lhead_lnum;\n\n\tdo {\n\t\terr = replay_log_leb(c, lnum, 0, c->sbuf);\n\t\tif (err == 1) {\n\t\t\tif (lnum != c->lhead_lnum)\n\t\t\t\t/* We hit the end of the log */\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * The head of the log must always start with the\n\t\t\t * \"commit start\" node on a properly formatted UBIFS.\n\t\t\t * But we found no nodes at all, which means that\n\t\t\t * someting went wrong and we cannot proceed mounting\n\t\t\t * the file-system.\n\t\t\t */\n\t\t\tubifs_err(\"no UBIFS nodes found at the log head LEB %d:%d, possibly corrupted\",\n\t\t\t\t  lnum, 0);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t} while (lnum != c->ltail_lnum);\n\n\terr = replay_buds(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = apply_replay_list(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = set_buds_lprops(c);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * UBIFS budgeting calculations use @c->bi.uncommitted_idx variable\n\t * to roughly estimate index growth. Things like @c->bi.min_idx_lebs\n\t * depend on it. This means we have to initialize it to make sure\n\t * budgeting works properly.\n\t */\n\tc->bi.uncommitted_idx = atomic_long_read(&c->dirty_zn_cnt);\n\tc->bi.uncommitted_idx *= c->max_idx_node_sz;\n\n\tubifs_assert(c->bud_bytes <= c->max_bud_bytes || c->need_recovery);\n\tdbg_mnt(\"finished, log head LEB %d:%d, max_sqnum %llu, highest_inum %lu\",\n\t\tc->lhead_lnum, c->lhead_offs, c->max_sqnum,\n\t\t(unsigned long)c->highest_inum);\nout:\n\tdestroy_replay_list(c);\n\tdestroy_bud_list(c);\n\tc->replaying = 0;\n\treturn err;\n}",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist(c);\n\tc->repl",
          "args": [
            "y"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y_list(c);\n\tdestroy",
          "args": [
            "b"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shed, l",
          "args": [
            "g head LEB %d:%d, max_sqnum %llu, highest_inum %lu\",\n\t\tc->lhead_",
            ", c->lhead_of",
            ", c->max_sqnu",
            "(unsigned",
            "g)c->highest_inum);\nout:\n\tdest"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bud_bytes",
          "args": [
            "<= c->max_bud_bytes || c->need_recovery);\n\tdbg_mnt(\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt);\n\tc->bi.unc"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ps(c);\n\tif (err",
          "args": [],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list(c);\n\tif (err",
          "args": [],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif (err",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, lnum);\n\t}",
          "args": [
            "w",
            "le ("
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS no",
          "args": [
            "es found at the log head LEB %d:%d, possibly corrupted\",\n\t\t\t\t  lnum,",
            "err",
            "-"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b(c, lnum, 0,",
          "args": [
            "-",
            "buf)",
            "f (err"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t repla",
          "args": [
            "ing the journal\");\n\tc->replay"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d index h",
          "args": [
            "ad LEB %d:%d\", c->ihead_ln",
            ",\n\t\t\t  c->ihe",
            ");\n\t\treturn -"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tif (fre",
          "args": [],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_TRUN_K",
          "args": [
            "Y > 5);\n\n\t/* Updat"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nlay_journal(struct ubifs_info *c)\n{\n\tint err, lnum, free;\n\n\tBUILD_BUG_ON(UBIFS_TRUN_KEY > 5);\n\n\t/* Update the status of the index head in lprops to 'taken' */\n\tfree = take_ihead(c);\n\tif (free < 0)\n\t\treturn free; /* Error code */\n\n\tif (c->ihead_offs != c->leb_size - free) {\n\t\tubifs_err(\"bad index head LEB %d:%d\", c->ihead_lnum,\n\t\t\t  c->ihead_offs);\n\t\treturn -EINVAL;\n\t}\n\n\tdbg_mnt(\"start replaying the journal\");\n\tc->replaying = 1;\n\tlnum = c->ltail_lnum = c->lhead_lnum;\n\n\tdo {\n\t\terr = replay_log_leb(c, lnum, 0, c->sbuf);\n\t\tif (err == 1) {\n\t\t\tif (lnum != c->lhead_lnum)\n\t\t\t\t/* We hit the end of the log */\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * The head of the log must always start with the\n\t\t\t * \"commit start\" node on a properly formatted UBIFS.\n\t\t\t * But we found no nodes at all, which means that\n\t\t\t * someting went wrong and we cannot proceed mounting\n\t\t\t * the file-system.\n\t\t\t */\n\t\t\tubifs_err(\"no UBIFS nodes found at the log head LEB %d:%d, possibly corrupted\",\n\t\t\t\t  lnum, 0);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t} while (lnum != c->ltail_lnum);\n\n\terr = replay_buds(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = apply_replay_list(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = set_buds_lprops(c);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * UBIFS budgeting calculations use @c->bi.uncommitted_idx variable\n\t * to roughly estimate index growth. Things like @c->bi.min_idx_lebs\n\t * depend on it. This means we have to initialize it to make sure\n\t * budgeting works properly.\n\t */\n\tc->bi.uncommitted_idx = atomic_long_read(&c->dirty_zn_cnt);\n\tc->bi.uncommitted_idx *= c->max_idx_node_sz;\n\n\tubifs_assert(c->bud_bytes <= c->max_bud_bytes || c->need_recovery);\n\tdbg_mnt(\"finished, log head LEB %d:%d, max_sqnum %llu, highest_inum %lu\",\n\t\tc->lhead_lnum, c->lhead_offs, c->max_sqnum,\n\t\t(unsigned long)c->highest_inum);\nout:\n\tdestroy_replay_list(c);\n\tdestroy_bud_list(c);\n\tc->replaying = 0;\n\treturn err;\n}"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "972-998",
    "snippet": "ke_ihead(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err, free;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, c->ihead_lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tfree = lp->free;\n\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\terr = free;\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "="
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lp(c, lp, LPROP",
          "args": [
            "_",
            ",",
            "ROPS_NC,",
            "lp-",
            "PROPS_TAKEN, 0);\n\tif (IS",
            "R"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, c->ihead_",
          "args": [
            "n",
            ");\n\tif (IS_ER"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\tlp = u",
          "args": [
            "i"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nke_ihead(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err, free;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, c->ihead_lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tfree = lp->free;\n\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\terr = free;\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "b(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "826-963",
    "snippet": "play_log_leb(struct ubifs_info *c, int lnum, int offs, void *sbuf)\n{\n\tint err;\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tconst struct ubifs_cs_node *node;\n\n\tdbg_mnt(\"replay log LEB %d:%d\", lnum, offs);\n\tsleb = ubifs_scan(c, lnum, offs, sbuf, c->need_recovery);\n\tif (IS_ERR(sleb)) {\n\t\tif (PTR_ERR(sleb) != -EUCLEAN || !c->need_recovery)\n\t\t\treturn PTR_ERR(sleb);\n\t\t/*\n\t\t * Note, the below function will recover this log LEB only if\n\t\t * it is the last, because unclean reboots can possibly corrupt\n\t\t * only the tail of the log.\n\t\t */\n\t\tsleb = ubifs_recover_log_leb(c, lnum, offs, sbuf);\n\t\tif (IS_ERR(sleb))\n\t\t\treturn PTR_ERR(sleb);\n\t}\n\n\tif (sleb->nodes_cnt == 0) {\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\tnode = sleb->buf;\n\tsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\n\tif (c->cs_sqnum == 0) {\n\t\t/*\n\t\t * This is the first log LEB we are looking at, make sure that\n\t\t * the first node is a commit start node. Also record its\n\t\t * sequence number so that UBIFS can determine where the log\n\t\t * ends, because all nodes which were have higher sequence\n\t\t * numbers.\n\t\t */\n\t\tif (snod->type != UBIFS_CS_NODE) {\n\t\t\tubifs_err(\"first log node at LEB %d:%d is not CS node\",\n\t\t\t\t  lnum, offs);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (le64_to_cpu(node->cmt_no) != c->cmt_no) {\n\t\t\tubifs_err(\"first CS node at LEB %d:%d has wrong commit number %llu expected %llu\",\n\t\t\t\t  lnum, offs,\n\t\t\t\t  (unsigned long long)le64_to_cpu(node->cmt_no),\n\t\t\t\t  c->cmt_no);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tc->cs_sqnum = le64_to_cpu(node->ch.sqnum);\n\t\tdbg_mnt(\"commit start sqnum %llu\", c->cs_sqnum);\n\t}\n\n\tif (snod->sqnum < c->cs_sqnum) {\n\t\t/*\n\t\t * This means that we reached end of log and now\n\t\t * look to the older log data, which was already\n\t\t * committed but the eraseblock was not erased (UBIFS\n\t\t * only un-maps it). So this basically means we have to\n\t\t * exit with \"end of log\" code.\n\t\t */\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\t/* Make sure the first node sits at offset zero of the LEB */\n\tif (snod->offs != 0) {\n\t\tubifs_err(\"first node is not at zero offset\");\n\t\tgoto out_dump;\n\t}\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\n\t\tif (snod->sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(\"file system's life ended\");\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum < c->cs_sqnum) {\n\t\t\tubifs_err(\"bad sqnum %llu, commit sqnum %llu\",\n\t\t\t\t  snod->sqnum, c->cs_sqnum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum > c->max_sqnum)\n\t\t\tc->max_sqnum = snod->sqnum;\n\n\t\tswitch (snod->type) {\n\t\tcase UBIFS_REF_NODE: {\n\t\t\tconst struct ubifs_ref_node *ref = snod->node;\n\n\t\t\terr = validate_ref(c, ref);\n\t\t\tif (err == 1)\n\t\t\t\tbreak; /* Already have this bud */\n\t\t\tif (err)\n\t\t\t\tgoto out_dump;\n\n\t\t\terr = add_replay_bud(c, le32_to_cpu(ref->lnum),\n\t\t\t\t\t     le32_to_cpu(ref->offs),\n\t\t\t\t\t     le32_to_cpu(ref->jhead),\n\t\t\t\t\t     snod->sqnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_CS_NODE:\n\t\t\t/* Make sure it sits at the beginning of LEB */\n\t\t\tif (snod->offs != 0) {\n\t\t\t\tubifs_err(\"unexpected node in log\");\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(\"unexpected node in log\");\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\tif (sleb->endpt || c->lhead_offs >= c->leb_size) {\n\t\tc->lhead_lnum = lnum;\n\t\tc->lhead_offs = sleb->endpt;\n\t}\n\n\terr = !sleb->endpt;\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_dump:\n\tubifs_err(\"log error detected while replaying the log at LEB %d:%d\",\n\t\t  lnum, offs + snod->offs);\n\tubifs_dump_node(c, snod->node);\n\tubifs_scan_destroy(sleb);\n\treturn -EINVAL;\n}\n\n/**\n * take",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n -E"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, snod->nod",
          "args": [
            ")",
            "ubifs_sca"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g error d",
          "args": [
            "tected while replaying the log at LEB %d:%d\",\n\t\t  lnum, o",
            "snod",
            "offs);\n\tubifs_dum"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n er"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected",
          "args": [
            "ode in log\");\n\t\t\tgoto ou"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected",
          "args": [
            "ode in log\");\n\t\t\t\tgoto o"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, le32_to_c",
          "args": [
            "u",
            "ef->lnum),\n\t\t\t\t\t     l",
            "ef->offs),\n\t\t\t\t\t     l",
            "ef->jhead),\n\t\t\t\t\t     s",
            "if (err"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->jhead),",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->offs),",
          "args": [],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->lnum),",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, ref);",
          "args": [
            "f",
            "err"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d sqnum %",
          "args": [
            "lu, commit sqnum %llu\",\n\t\t\t\t  snod-",
            "c->cs_sqnum",
            "goto ou"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le system",
          "args": [
            "s life ended\");\n\t\t\tgoto ou"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\tif (sn",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {\n\t\tc",
            "d_re"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rst node",
          "args": [
            "s not at zero offset\");\n\t\tgoto out"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it star",
          "args": [
            "sqnum %llu\", c->cs_sqnum",
            "}\n\n\tif (s"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode->ch.sqn",
          "args": [
            "m);\n\t\tdbg_mnt("
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rst CS no",
          "args": [
            "e at LEB %d:%d has wrong commit number %llu expected %llu\",\n\t\t\t\t  lnum,",
            "unsi",
            "g long)le64_to_cpu(node->cmt_no),\n\t\t\t\t  c->cm",
            "goto ou"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode->cmt_no",
          "args": [
            ",\n\t\t\t\t  c->c"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode->cmt_no",
          "args": [
            "!= c->cmt_n"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rst log n",
          "args": [
            "de at LEB %d:%d is not CS node\",\n\t\t\t\t  lnum,",
            "g",
            "o ou"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->nodes.",
          "args": [
            "ext, struct ubif",
            "scan_nde, list);\n\tif",
            "->cs"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t}",
          "args": [
            "f (s"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re",
          "args": [
            "urn"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "_tnc_subtree(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "228-257",
          "snippet": "stroy_tnc_subtree(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\n\tlong clean_freed = 0;\n\tint n;\n\n\tubifs_assert(zn);\n\twhile (1) {\n\t\tfor (n = 0; n < zn->child_cnt; n++) {\n\t\t\tif (!zn->zbranch[n].znode)\n\t\t\t\tcontinue;\n\n\t\t\tif (zn->level > 0 &&\n\t\t\t    !ubifs_zn_dirty(zn->zbranch[n].znode))\n\t\t\t\tclean_freed += 1;\n\n\t\t\tcond_resched();\n\t\t\tkfree(zn->zbranch[n].znode);\n\t\t}\n\n\t\tif (zn == znode) {\n\t\t\tif (!ubifs_zn_dirty(zn))\n\t\t\t\tclean_freed += 1;\n\t\t\tkfree(zn);\n\t\t\treturn clean_freed;\n\t\t}\n\n\t\tzn = ubifs_tnc_postorder_next(zn);\n\t}\n}\n\n/**\n * read",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nstroy_tnc_subtree(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\n\tlong clean_freed = 0;\n\tint n;\n\n\tubifs_assert(zn);\n\twhile (1) {\n\t\tfor (n = 0; n < zn->child_cnt; n++) {\n\t\t\tif (!zn->zbranch[n].znode)\n\t\t\t\tcontinue;\n\n\t\t\tif (zn->level > 0 &&\n\t\t\t    !ubifs_zn_dirty(zn->zbranch[n].znode))\n\t\t\t\tclean_freed += 1;\n\n\t\t\tcond_resched();\n\t\t\tkfree(zn->zbranch[n].znode);\n\t\t}\n\n\t\tif (zn == znode) {\n\t\t\tif (!ubifs_zn_dirty(zn))\n\t\t\t\tclean_freed += 1;\n\t\t\tkfree(zn);\n\t\t\treturn clean_freed;\n\t\t}\n\n\t\tzn = ubifs_tnc_postorder_next(zn);\n\t}\n}\n\n/**\n * read"
        }
      },
      {
        "call_info": {
          "callee": "_log_leb(c, lnum, off",
          "args": [
            ",",
            "buf)",
            "if",
            "IS_E"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t/*",
          "args": [
            "*"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!= -EU",
          "args": [
            "LEAN"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\t\ti",
          "args": [
            "(PT"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum, off",
          "args": [
            ",",
            "buf,",
            "->ne",
            "_rec",
            "ery);\n\tif (IS_ER"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ay log",
          "args": [
            "EB %d:%d\", lnum, offs)",
            "sle",
            "= ub"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nplay_log_leb(struct ubifs_info *c, int lnum, int offs, void *sbuf)\n{\n\tint err;\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tconst struct ubifs_cs_node *node;\n\n\tdbg_mnt(\"replay log LEB %d:%d\", lnum, offs);\n\tsleb = ubifs_scan(c, lnum, offs, sbuf, c->need_recovery);\n\tif (IS_ERR(sleb)) {\n\t\tif (PTR_ERR(sleb) != -EUCLEAN || !c->need_recovery)\n\t\t\treturn PTR_ERR(sleb);\n\t\t/*\n\t\t * Note, the below function will recover this log LEB only if\n\t\t * it is the last, because unclean reboots can possibly corrupt\n\t\t * only the tail of the log.\n\t\t */\n\t\tsleb = ubifs_recover_log_leb(c, lnum, offs, sbuf);\n\t\tif (IS_ERR(sleb))\n\t\t\treturn PTR_ERR(sleb);\n\t}\n\n\tif (sleb->nodes_cnt == 0) {\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\tnode = sleb->buf;\n\tsnod = list_entry(sleb->nodes.next, struct ubifs_scan_node, list);\n\tif (c->cs_sqnum == 0) {\n\t\t/*\n\t\t * This is the first log LEB we are looking at, make sure that\n\t\t * the first node is a commit start node. Also record its\n\t\t * sequence number so that UBIFS can determine where the log\n\t\t * ends, because all nodes which were have higher sequence\n\t\t * numbers.\n\t\t */\n\t\tif (snod->type != UBIFS_CS_NODE) {\n\t\t\tubifs_err(\"first log node at LEB %d:%d is not CS node\",\n\t\t\t\t  lnum, offs);\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (le64_to_cpu(node->cmt_no) != c->cmt_no) {\n\t\t\tubifs_err(\"first CS node at LEB %d:%d has wrong commit number %llu expected %llu\",\n\t\t\t\t  lnum, offs,\n\t\t\t\t  (unsigned long long)le64_to_cpu(node->cmt_no),\n\t\t\t\t  c->cmt_no);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tc->cs_sqnum = le64_to_cpu(node->ch.sqnum);\n\t\tdbg_mnt(\"commit start sqnum %llu\", c->cs_sqnum);\n\t}\n\n\tif (snod->sqnum < c->cs_sqnum) {\n\t\t/*\n\t\t * This means that we reached end of log and now\n\t\t * look to the older log data, which was already\n\t\t * committed but the eraseblock was not erased (UBIFS\n\t\t * only un-maps it). So this basically means we have to\n\t\t * exit with \"end of log\" code.\n\t\t */\n\t\terr = 1;\n\t\tgoto out;\n\t}\n\n\t/* Make sure the first node sits at offset zero of the LEB */\n\tif (snod->offs != 0) {\n\t\tubifs_err(\"first node is not at zero offset\");\n\t\tgoto out_dump;\n\t}\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tcond_resched();\n\n\t\tif (snod->sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(\"file system's life ended\");\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum < c->cs_sqnum) {\n\t\t\tubifs_err(\"bad sqnum %llu, commit sqnum %llu\",\n\t\t\t\t  snod->sqnum, c->cs_sqnum);\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum > c->max_sqnum)\n\t\t\tc->max_sqnum = snod->sqnum;\n\n\t\tswitch (snod->type) {\n\t\tcase UBIFS_REF_NODE: {\n\t\t\tconst struct ubifs_ref_node *ref = snod->node;\n\n\t\t\terr = validate_ref(c, ref);\n\t\t\tif (err == 1)\n\t\t\t\tbreak; /* Already have this bud */\n\t\t\tif (err)\n\t\t\t\tgoto out_dump;\n\n\t\t\terr = add_replay_bud(c, le32_to_cpu(ref->lnum),\n\t\t\t\t\t     le32_to_cpu(ref->offs),\n\t\t\t\t\t     le32_to_cpu(ref->jhead),\n\t\t\t\t\t     snod->sqnum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_CS_NODE:\n\t\t\t/* Make sure it sits at the beginning of LEB */\n\t\t\tif (snod->offs != 0) {\n\t\t\t\tubifs_err(\"unexpected node in log\");\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(\"unexpected node in log\");\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\tif (sleb->endpt || c->lhead_offs >= c->leb_size) {\n\t\tc->lhead_lnum = lnum;\n\t\tc->lhead_offs = sleb->endpt;\n\t}\n\n\terr = !sleb->endpt;\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_dump:\n\tubifs_err(\"log error detected while replaying the log at LEB %d:%d\",\n\t\t  lnum, offs + snod->offs);\n\tubifs_dump_node(c, snod->node);\n\tubifs_scan_destroy(sleb);\n\treturn -EINVAL;\n}\n\n/**\n * take"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "786-813",
    "snippet": "lidate_ref(struct ubifs_info *c, const struct ubifs_ref_node *ref)\n{\n\tstruct ubifs_bud *bud;\n\tint lnum = le32_to_cpu(ref->lnum);\n\tunsigned int offs = le32_to_cpu(ref->offs);\n\tunsigned int jhead = le32_to_cpu(ref->jhead);\n\n\t/*\n\t * ref->offs may point to the end of LEB when the journal head points\n\t * to the end of LEB and we write reference node for it during commit.\n\t * So this is why we require 'offs > c->leb_size'.\n\t */\n\tif (jhead >= c->jhead_cnt || lnum >= c->leb_cnt ||\n\t    lnum < c->main_first || offs > c->leb_size ||\n\t    offs & (c->min_io_size - 1))\n\t\treturn -EINVAL;\n\n\t/* Make sure we have not already looked at this bud */\n\tbud = ubifs_search_bud(c, lnum);\n\tif (bud) {\n\t\tif (bud->jhead == jhead && bud->start <= offs)\n\t\t\treturn 1;\n\t\tubifs_err(\"bud at LEB %d:%d was already referred\", lnum, offs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * repl",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d at LEB",
          "args": [
            "d:%d was already referred\", lnum, offs)",
            "re",
            "rn -"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bud(c, lnum);\n\ti",
          "args": [
            "ud)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->jhead);",
          "args": [
            "/*\n\t * r"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->offs);",
          "args": [
            "unsigned"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->lnum);",
          "args": [
            "unsigned"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nlidate_ref(struct ubifs_info *c, const struct ubifs_ref_node *ref)\n{\n\tstruct ubifs_bud *bud;\n\tint lnum = le32_to_cpu(ref->lnum);\n\tunsigned int offs = le32_to_cpu(ref->offs);\n\tunsigned int jhead = le32_to_cpu(ref->jhead);\n\n\t/*\n\t * ref->offs may point to the end of LEB when the journal head points\n\t * to the end of LEB and we write reference node for it during commit.\n\t * So this is why we require 'offs > c->leb_size'.\n\t */\n\tif (jhead >= c->jhead_cnt || lnum >= c->leb_cnt ||\n\t    lnum < c->main_first || offs > c->leb_size ||\n\t    offs & (c->min_io_size - 1))\n\t\treturn -EINVAL;\n\n\t/* Make sure we have not already looked at this bud */\n\tbud = ubifs_search_bud(c, lnum);\n\tif (bud) {\n\t\tif (bud->jhead == jhead && bud->start <= offs)\n\t\t\treturn 1;\n\t\tubifs_err(\"bud at LEB %d:%d was already referred\", lnum, offs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * repl"
  },
  {
    "function_name": "d(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "745-773",
    "snippet": "d_replay_bud(struct ubifs_info *c, int lnum, int offs, int jhead,\n\t\t\t  unsigned long long sqnum)\n{\n\tstruct ubifs_bud *bud;\n\tstruct bud_entry *b;\n\n\tdbg_mnt(\"add replay bud LEB %d:%d, head %d\", lnum, offs, jhead);\n\n\tbud = kmalloc(sizeof(struct ubifs_bud), GFP_KERNEL);\n\tif (!bud)\n\t\treturn -ENOMEM;\n\n\tb = kmalloc(sizeof(struct bud_entry), GFP_KERNEL);\n\tif (!b) {\n\t\tkfree(bud);\n\t\treturn -ENOMEM;\n\t}\n\n\tbud->lnum = lnum;\n\tbud->start = offs;\n\tbud->jhead = jhead;\n\tubifs_add_bud(c, bud);\n\n\tb->bud = bud;\n\tb->sqnum = sqnum;\n\tlist_add_tail(&b->list, &c->replay_buds);\n\n\treturn 0;\n}\n\n/**\n * vali",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(&b->list, &c",
          "args": [
            ">replay_",
            "ds);\n\n\treturn 0"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, bud);\n\n\tb",
          "args": [
            ">",
            "d ="
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n -"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "bud_entry), GFP_KERNEL)",
            "if (!b) {"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "replay",
          "args": [
            "ud LEB %d:%d, head %d\", lnum, offs,",
            "head",
            "b",
            "= km"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replay_truncate_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5884-5953",
          "snippet": "static int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t handle_t *handle,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\t/* TODO: Perhaps we can calculate the bulk of the\n\t\t * credits up front rather than extending like\n\t\t * this. */\n\t\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t\t    OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nstatic int ocfs2_replay_truncate_records(struct ocfs2_super *osb,\n\t\t\t\t\t handle_t *handle,\n\t\t\t\t\t struct inode *data_alloc_inode,\n\t\t\t\t\t struct buffer_head *data_alloc_bh)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int num_clusters;\n\tu64 start_blk;\n\tstruct ocfs2_truncate_rec rec;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct buffer_head *tl_bh = osb->osb_tl_bh;\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\ttl = &di->id2.i_dealloc;\n\ti = le16_to_cpu(tl->tl_used) - 1;\n\twhile (i >= 0) {\n\t\t/* Caller has given us at least enough credits to\n\t\t * update the truncate log dinode */\n\t\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(tl_inode), tl_bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttl->tl_used = cpu_to_le16(i);\n\n\t\tocfs2_journal_dirty(handle, tl_bh);\n\n\t\t/* TODO: Perhaps we can calculate the bulk of the\n\t\t * credits up front rather than extending like\n\t\t * this. */\n\t\tstatus = ocfs2_extend_trans(handle,\n\t\t\t\t\t    OCFS2_TRUNCATE_LOG_FLUSH_ONE_REC);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\trec = tl->tl_recs[i];\n\t\tstart_blk = ocfs2_clusters_to_blocks(data_alloc_inode->i_sb,\n\t\t\t\t\t\t    le32_to_cpu(rec.t_start));\n\t\tnum_clusters = le32_to_cpu(rec.t_clusters);\n\n\t\t/* if start_blk is not set, we ignore the record as\n\t\t * invalid. */\n\t\tif (start_blk) {\n\t\t\ttrace_ocfs2_replay_truncate_records(\n\t\t\t\t(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,\n\t\t\t\ti, le32_to_cpu(rec.t_start), num_clusters);\n\n\t\t\tstatus = ocfs2_free_clusters(handle, data_alloc_inode,\n\t\t\t\t\t\t     data_alloc_bh, start_blk,\n\t\t\t\t\t\t     num_clusters);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\ti--;\n\t}\n\n\tosb->truncated_clusters = 0;\n\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nd_replay_bud(struct ubifs_info *c, int lnum, int offs, int jhead,\n\t\t\t  unsigned long long sqnum)\n{\n\tstruct ubifs_bud *bud;\n\tstruct bud_entry *b;\n\n\tdbg_mnt(\"add replay bud LEB %d:%d, head %d\", lnum, offs, jhead);\n\n\tbud = kmalloc(sizeof(struct ubifs_bud), GFP_KERNEL);\n\tif (!bud)\n\t\treturn -ENOMEM;\n\n\tb = kmalloc(sizeof(struct bud_entry), GFP_KERNEL);\n\tif (!b) {\n\t\tkfree(bud);\n\t\treturn -ENOMEM;\n\t}\n\n\tbud->lnum = lnum;\n\tbud->start = offs;\n\tbud->jhead = jhead;\n\tubifs_add_bud(c, bud);\n\n\tb->bud = bud;\n\tb->sqnum = sqnum;\n\tlist_add_tail(&b->list, &c->replay_buds);\n\n\treturn 0;\n}\n\n/**\n * vali"
  },
  {
    "function_name": "ist(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "723-732",
    "snippet": "estroy_bud_list(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\n\twhile (!list_empty(&c->replay_buds)) {\n\t\tb = list_entry(c->replay_buds.next, struct bud_entry, list);\n\t\tlist_del(&b->list);\n\t\tkfree(b);\n\t}\n}\n\n/**\n * add_",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/*",
          "args": [],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list);",
          "args": [
            "kfree(b)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">replay_bu",
          "args": [
            "s.next, struct bud_",
            "try, lst);\n\t\tli",
            "_del"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->replay_b",
          "args": [
            "ds)) {\n\t\tb = li"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nestroy_bud_list(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\n\twhile (!list_empty(&c->replay_buds)) {\n\t\tb = list_entry(c->replay_buds.next, struct bud_entry, list);\n\t\tlist_del(&b->list);\n\t\tkfree(b);\n\t}\n}\n\n/**\n * add_"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "701-717",
    "snippet": "play_buds(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\tint err;\n\tunsigned long long prev_sqnum = 0;\n\n\tlist_for_each_entry(b, &c->replay_buds, list) {\n\t\terr = replay_bud(c, b);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tubifs_assert(b->sqnum > prev_sqnum);\n\t\tprev_sqnum = b->sqnum;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dest",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "b->sqnum > p",
          "args": [
            "ev_sqnum);\n\t\tprev_sqn"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b);\n\t\tif",
          "args": [
            "e",
            ")"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(b, &c->repla",
          "args": [
            "_",
            "ds, list) {\n\t\te",
            "= r"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nplay_buds(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\tint err;\n\tunsigned long long prev_sqnum = 0;\n\n\tlist_for_each_entry(b, &c->replay_buds, list) {\n\t\terr = replay_bud(c, b);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tubifs_assert(b->sqnum > prev_sqnum);\n\t\tprev_sqnum = b->sqnum;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dest"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "541-692",
    "snippet": "play_bud(struct ubifs_info *c, struct bud_entry *b)\n{\n\tint is_last = is_last_bud(c, b->bud);\n\tint err = 0, used = 0, lnum = b->bud->lnum, offs = b->bud->start;\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\n\tdbg_mnt(\"replay bud LEB %d, head %d, offs %d, is_last %d\",\n\t\tlnum, b->bud->jhead, offs, is_last);\n\n\tif (c->need_recovery && is_last)\n\t\t/*\n\t\t * Recover only last LEBs in the journal heads, because power\n\t\t * cuts may cause corruptions only in these LEBs, because only\n\t\t * these LEBs could possibly be written to at the power cut\n\t\t * time.\n\t\t */\n\t\tsleb = ubifs_recover_leb(c, lnum, offs, c->sbuf, b->bud->jhead);\n\telse\n\t\tsleb = ubifs_scan(c, lnum, offs, c->sbuf, 0);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\n\t/*\n\t * The bud does not have to start from offset zero - the beginning of\n\t * the 'lnum' LEB may contain previously committed data. One of the\n\t * things we have to do in replay is to correctly update lprops with\n\t * newer information about this LEB.\n\t *\n\t * At this point lprops thinks that this LEB has 'c->leb_size - offs'\n\t * bytes of free space because it only contain information about\n\t * committed data.\n\t *\n\t * But we know that real amount of free space is 'c->leb_size -\n\t * sleb->endpt', and the space in the 'lnum' LEB between 'offs' and\n\t * 'sleb->endpt' is used by bud data. We have to correctly calculate\n\t * how much of these data are dirty and update lprops with this\n\t * information.\n\t *\n\t * The dirt in that LEB region is comprised of padding nodes, deletion\n\t * nodes, truncation nodes and nodes which are obsoleted by subsequent\n\t * nodes in this LEB. So instead of calculating clean space, we\n\t * calculate used space ('used' variable).\n\t */\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tint deletion = 0;\n\n\t\tcond_resched();\n\n\t\tif (snod->sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(\"file system's life ended\");\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum > c->max_sqnum)\n\t\t\tc->max_sqnum = snod->sqnum;\n\n\t\tswitch (snod->type) {\n\t\tcase UBIFS_INO_NODE:\n\t\t{\n\t\t\tstruct ubifs_ino_node *ino = snod->node;\n\t\t\tloff_t new_size = le64_to_cpu(ino->size);\n\n\t\t\tif (le32_to_cpu(ino->nlink) == 0)\n\t\t\t\tdeletion = 1;\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &snod->key, snod->sqnum, deletion,\n\t\t\t\t\t  &used, 0, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_DATA_NODE:\n\t\t{\n\t\t\tstruct ubifs_data_node *dn = snod->node;\n\t\t\tloff_t new_size = le32_to_cpu(dn->size) +\n\t\t\t\t\t  key_block(c, &snod->key) *\n\t\t\t\t\t  UBIFS_BLOCK_SIZE;\n\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &snod->key, snod->sqnum, deletion,\n\t\t\t\t\t  &used, 0, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_DENT_NODE:\n\t\tcase UBIFS_XENT_NODE:\n\t\t{\n\t\t\tstruct ubifs_dent_node *dent = snod->node;\n\n\t\t\terr = ubifs_validate_entry(c, dent);\n\t\t\tif (err)\n\t\t\t\tgoto out_dump;\n\n\t\t\terr = insert_dent(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &snod->key, dent->name,\n\t\t\t\t\t  le16_to_cpu(dent->nlen), snod->sqnum,\n\t\t\t\t\t  !le64_to_cpu(dent->inum), &used);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_TRUN_NODE:\n\t\t{\n\t\t\tstruct ubifs_trun_node *trun = snod->node;\n\t\t\tloff_t old_size = le64_to_cpu(trun->old_size);\n\t\t\tloff_t new_size = le64_to_cpu(trun->new_size);\n\t\t\tunion ubifs_key key;\n\n\t\t\t/* Validate truncation node */\n\t\t\tif (old_size < 0 || old_size > c->max_inode_sz ||\n\t\t\t    new_size < 0 || new_size > c->max_inode_sz ||\n\t\t\t    old_size <= new_size) {\n\t\t\t\tubifs_err(\"bad truncation node\");\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Create a fake truncation key just to use the same\n\t\t\t * functions which expect nodes to have keys.\n\t\t\t */\n\t\t\ttrun_key_init(c, &key, le32_to_cpu(trun->inum));\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &key, snod->sqnum, 1, &used,\n\t\t\t\t\t  old_size, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tubifs_err(\"unexpected node type %d in bud LEB %d:%d\",\n\t\t\t\t  snod->type, lnum, snod->offs);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tubifs_assert(ubifs_search_bud(c, lnum));\n\tubifs_assert(sleb->endpt - offs >= used);\n\tubifs_assert(sleb->endpt % c->min_io_size == 0);\n\n\tb->dirty = sleb->endpt - offs - used;\n\tb->free = c->leb_size - sleb->endpt;\n\tdbg_mnt(\"bud LEB %d replied: dirty %d, free %d\",\n\t\tlnum, b->dirty, b->free);\n\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_dump:\n\tubifs_err(\"bad node is at LEB %d:%d\", lnum, snod->offs);\n\tubifs_dump_node(c, snod->node);\n\tubifs_scan_destroy(sleb);\n\treturn -EINVAL;\n}\n\n/**\n * repl",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n -E"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, snod->nod",
          "args": [
            ")",
            "ubifs_sca"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node is",
          "args": [
            "at LEB %d:%d\", lnum, snod-",
            "ffs)",
            "ubifs_dum"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n er"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %d",
          "args": [
            "eplied: dirty %d, free %d\",\n\t\tlnum, b->",
            "y, b",
            "free);",
            "t:\n\tubi"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleb->endpt",
          "args": [
            "c->min_io_size == 0);\n\n\tb->dirty"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleb->endpt",
          "args": [
            "offs >= used);\n\tubifs_ass"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_search",
          "args": [
            "bud(c, lnum));\n\tubifs_ass"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bud(c, lnum));",
          "args": [
            "b",
            "s_as"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected",
          "args": [
            "ode type %d in bud LEB %d:%d\",\n\t\t\t\t  snod-",
            "num, snod-",
            "ffs)",
            "err = -"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", lnum, sno",
          "args": [
            "-",
            "ffs,",
            "nod->len,",
            "&key",
            "qnum",
            "1, &used,",
            "old_",
            "_size);",
            "break;"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, le3",
          "args": [
            "_",
            "_cpu",
            "run->inum));\n\t\t\terr = i"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->inum))",
          "args": [
            "err ="
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d truncat",
          "args": [
            "on node\");\n\t\t\t\tgoto o"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->new_si",
          "args": [
            "e);\n\t\t\tunion u"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "run->old_si",
          "args": [
            "e);\n\t\t\tloff_t"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", lnum, sno",
          "args": [
            "-",
            "ffs,",
            "nod->len,",
            "&sno",
            "ent->name,",
            "le16",
            "ent->nlen), snod->sqnum",
            "!le6",
            "dent->inum), &used);",
            "eak;"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum),",
          "args": [
            "&used);"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen),",
          "args": [
            "snod->sqnu"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_entry(c, dent);",
          "args": [
            "i",
            "(err"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", lnum, sno",
          "args": [
            "-",
            "ffs,",
            "nod->len,",
            "&sno",
            "nod->sqnum",
            "deletion,",
            "&use",
            "_size",
            "break;"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&snod->ke",
          "args": [
            ")",
            "UB"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->size) +",
          "args": [
            "ke"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", lnum, sno",
          "args": [
            "-",
            "ffs,",
            "nod->len,",
            "&sno",
            "nod->sqnum",
            "deletion,",
            "&use",
            "_size",
            "break;"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->nlink)",
          "args": [
            "= 0)\n\t\t\t\td"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->size);",
          "args": [
            "if (le"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le system",
          "args": [
            "s life ended\");\n\t\t\tgoto ou"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\tif (sn",
          "args": [],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {\n\t\ti",
            "del"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\t/*",
          "args": [
            "* T"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn P"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lnum, off",
          "args": [
            ",",
            "->sb",
            ", 0)",
            "if (IS",
            "R"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leb(c, lnum, off",
          "args": [
            ",",
            "->sb",
            ", b-",
            "ud->jhe",
            ");\n\telse\n\t\tsl"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ay bud",
          "args": [
            "EB %d, head %d, offs %d, is_last %d\",\n\t\tlnum, b->",
            ">jhe",
            ", offs, is_la",
            ");",
            "f (c->n"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", b->bud);",
          "args": [
            "i",
            "err ="
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nplay_bud(struct ubifs_info *c, struct bud_entry *b)\n{\n\tint is_last = is_last_bud(c, b->bud);\n\tint err = 0, used = 0, lnum = b->bud->lnum, offs = b->bud->start;\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\n\tdbg_mnt(\"replay bud LEB %d, head %d, offs %d, is_last %d\",\n\t\tlnum, b->bud->jhead, offs, is_last);\n\n\tif (c->need_recovery && is_last)\n\t\t/*\n\t\t * Recover only last LEBs in the journal heads, because power\n\t\t * cuts may cause corruptions only in these LEBs, because only\n\t\t * these LEBs could possibly be written to at the power cut\n\t\t * time.\n\t\t */\n\t\tsleb = ubifs_recover_leb(c, lnum, offs, c->sbuf, b->bud->jhead);\n\telse\n\t\tsleb = ubifs_scan(c, lnum, offs, c->sbuf, 0);\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\n\t/*\n\t * The bud does not have to start from offset zero - the beginning of\n\t * the 'lnum' LEB may contain previously committed data. One of the\n\t * things we have to do in replay is to correctly update lprops with\n\t * newer information about this LEB.\n\t *\n\t * At this point lprops thinks that this LEB has 'c->leb_size - offs'\n\t * bytes of free space because it only contain information about\n\t * committed data.\n\t *\n\t * But we know that real amount of free space is 'c->leb_size -\n\t * sleb->endpt', and the space in the 'lnum' LEB between 'offs' and\n\t * 'sleb->endpt' is used by bud data. We have to correctly calculate\n\t * how much of these data are dirty and update lprops with this\n\t * information.\n\t *\n\t * The dirt in that LEB region is comprised of padding nodes, deletion\n\t * nodes, truncation nodes and nodes which are obsoleted by subsequent\n\t * nodes in this LEB. So instead of calculating clean space, we\n\t * calculate used space ('used' variable).\n\t */\n\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tint deletion = 0;\n\n\t\tcond_resched();\n\n\t\tif (snod->sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(\"file system's life ended\");\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (snod->sqnum > c->max_sqnum)\n\t\t\tc->max_sqnum = snod->sqnum;\n\n\t\tswitch (snod->type) {\n\t\tcase UBIFS_INO_NODE:\n\t\t{\n\t\t\tstruct ubifs_ino_node *ino = snod->node;\n\t\t\tloff_t new_size = le64_to_cpu(ino->size);\n\n\t\t\tif (le32_to_cpu(ino->nlink) == 0)\n\t\t\t\tdeletion = 1;\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &snod->key, snod->sqnum, deletion,\n\t\t\t\t\t  &used, 0, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_DATA_NODE:\n\t\t{\n\t\t\tstruct ubifs_data_node *dn = snod->node;\n\t\t\tloff_t new_size = le32_to_cpu(dn->size) +\n\t\t\t\t\t  key_block(c, &snod->key) *\n\t\t\t\t\t  UBIFS_BLOCK_SIZE;\n\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &snod->key, snod->sqnum, deletion,\n\t\t\t\t\t  &used, 0, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_DENT_NODE:\n\t\tcase UBIFS_XENT_NODE:\n\t\t{\n\t\t\tstruct ubifs_dent_node *dent = snod->node;\n\n\t\t\terr = ubifs_validate_entry(c, dent);\n\t\t\tif (err)\n\t\t\t\tgoto out_dump;\n\n\t\t\terr = insert_dent(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &snod->key, dent->name,\n\t\t\t\t\t  le16_to_cpu(dent->nlen), snod->sqnum,\n\t\t\t\t\t  !le64_to_cpu(dent->inum), &used);\n\t\t\tbreak;\n\t\t}\n\t\tcase UBIFS_TRUN_NODE:\n\t\t{\n\t\t\tstruct ubifs_trun_node *trun = snod->node;\n\t\t\tloff_t old_size = le64_to_cpu(trun->old_size);\n\t\t\tloff_t new_size = le64_to_cpu(trun->new_size);\n\t\t\tunion ubifs_key key;\n\n\t\t\t/* Validate truncation node */\n\t\t\tif (old_size < 0 || old_size > c->max_inode_sz ||\n\t\t\t    new_size < 0 || new_size > c->max_inode_sz ||\n\t\t\t    old_size <= new_size) {\n\t\t\t\tubifs_err(\"bad truncation node\");\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Create a fake truncation key just to use the same\n\t\t\t * functions which expect nodes to have keys.\n\t\t\t */\n\t\t\ttrun_key_init(c, &key, le32_to_cpu(trun->inum));\n\t\t\terr = insert_node(c, lnum, snod->offs, snod->len,\n\t\t\t\t\t  &key, snod->sqnum, 1, &used,\n\t\t\t\t\t  old_size, new_size);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tubifs_err(\"unexpected node type %d in bud LEB %d:%d\",\n\t\t\t\t  snod->type, lnum, snod->offs);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_dump;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tubifs_assert(ubifs_search_bud(c, lnum));\n\tubifs_assert(sleb->endpt - offs >= used);\n\tubifs_assert(sleb->endpt % c->min_io_size == 0);\n\n\tb->dirty = sleb->endpt - offs - used;\n\tb->free = c->leb_size - sleb->endpt;\n\tdbg_mnt(\"bud LEB %d replied: dirty %d, free %d\",\n\t\tlnum, b->dirty, b->free);\n\nout:\n\tubifs_scan_destroy(sleb);\n\treturn err;\n\nout_dump:\n\tubifs_err(\"bad node is at LEB %d:%d\", lnum, snod->offs);\n\tubifs_dump_node(c, snod->node);\n\tubifs_scan_destroy(sleb);\n\treturn -EINVAL;\n}\n\n/**\n * repl"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "484-530",
    "snippet": "_last_bud(struct ubifs_info *c, struct ubifs_bud *bud)\n{\n\tstruct ubifs_jhead *jh = &c->jheads[bud->jhead];\n\tstruct ubifs_bud *next;\n\tuint32_t data;\n\tint err;\n\n\tif (list_is_last(&bud->list, &jh->buds_list))\n\t\treturn 1;\n\n\t/*\n\t * The following is a quirk to make sure we work correctly with UBIFS\n\t * images used with older UBIFS.\n\t *\n\t * Normally, the last bud will be the last in the journal head's list\n\t * of bud. However, there is one exception if the UBIFS image belongs\n\t * to older UBIFS. This is fairly unlikely: one would need to use old\n\t * UBIFS, then have a power cut exactly at the right point, and then\n\t * try to mount this image with new UBIFS.\n\t *\n\t * The exception is: it is possible to have 2 buds A and B, A goes\n\t * before B, and B is the last, bud B is contains no data, and bud A is\n\t * corrupted at the end. The reason is that in older versions when the\n\t * journal code switched the next bud (from A to B), it first added a\n\t * log reference node for the new bud (B), and only after this it\n\t * synchronized the write-buffer of current bud (A). But later this was\n\t * changed and UBIFS started to always synchronize the write-buffer of\n\t * the bud (A) before writing the log reference for the new bud (B).\n\t *\n\t * But because older UBIFS always synchronized A's write-buffer before\n\t * writing to B, we can recognize this exceptional situation but\n\t * checking the contents of bud B - if it is empty, then A can be\n\t * treated as the last and we can recover it.\n\t *\n\t * TODO: remove this piece of code in a couple of years (today it is\n\t * 16.05.2011).\n\t */\n\tnext = list_entry(bud->list.next, struct ubifs_bud, list);\n\tif (!list_is_last(&next->list, &jh->buds_list))\n\t\treturn 0;\n\n\terr = ubifs_leb_read(c, next->lnum, (char *)&data, next->start, 4, 1);\n\tif (err)\n\t\treturn 0;\n\n\treturn data == 0xFFFFFFFF;\n}\n\n/**\n * repl",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d(c, next->lnu",
          "args": [
            ",",
            "char *)&da",
            ", next->start",
            "4, 1);\n\tif",
            "r"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&next->list,",
          "args": [
            "&jh->buds_l",
            "t))\n\t\treturn 0"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->list.ne",
          "args": [
            "t, struct ubif",
            "bud, lst);\n\tif",
            "list"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&bud->list,",
          "args": [
            "jh->buds_l",
            "t))\n\t\treturn 1"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\n_last_bud(struct ubifs_info *c, struct ubifs_bud *bud)\n{\n\tstruct ubifs_jhead *jh = &c->jheads[bud->jhead];\n\tstruct ubifs_bud *next;\n\tuint32_t data;\n\tint err;\n\n\tif (list_is_last(&bud->list, &jh->buds_list))\n\t\treturn 1;\n\n\t/*\n\t * The following is a quirk to make sure we work correctly with UBIFS\n\t * images used with older UBIFS.\n\t *\n\t * Normally, the last bud will be the last in the journal head's list\n\t * of bud. However, there is one exception if the UBIFS image belongs\n\t * to older UBIFS. This is fairly unlikely: one would need to use old\n\t * UBIFS, then have a power cut exactly at the right point, and then\n\t * try to mount this image with new UBIFS.\n\t *\n\t * The exception is: it is possible to have 2 buds A and B, A goes\n\t * before B, and B is the last, bud B is contains no data, and bud A is\n\t * corrupted at the end. The reason is that in older versions when the\n\t * journal code switched the next bud (from A to B), it first added a\n\t * log reference node for the new bud (B), and only after this it\n\t * synchronized the write-buffer of current bud (A). But later this was\n\t * changed and UBIFS started to always synchronize the write-buffer of\n\t * the bud (A) before writing the log reference for the new bud (B).\n\t *\n\t * But because older UBIFS always synchronized A's write-buffer before\n\t * writing to B, we can recognize this exceptional situation but\n\t * checking the contents of bud B - if it is empty, then A can be\n\t * treated as the last and we can recover it.\n\t *\n\t * TODO: remove this piece of code in a couple of years (today it is\n\t * 16.05.2011).\n\t */\n\tnext = list_entry(bud->list.next, struct ubifs_bud, list);\n\tif (!list_is_last(&next->list, &jh->buds_list))\n\t\treturn 0;\n\n\terr = ubifs_leb_read(c, next->lnum, (char *)&data, next->start, 4, 1);\n\tif (err)\n\t\treturn 0;\n\n\treturn data == 0xFFFFFFFF;\n}\n\n/**\n * repl"
  },
  {
    "function_name": "e_entry(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "450-472",
    "snippet": "idate_entry(struct ubifs_info *c,\n\t\t\t const struct ubifs_dent_node *dent)\n{\n\tint key_type = key_type_flash(c, dent->key);\n\tint nlen = le16_to_cpu(dent->nlen);\n\n\tif (le32_to_cpu(dent->ch.len) != nlen + UBIFS_DENT_NODE_SZ + 1 ||\n\t    dent->type >= UBIFS_ITYPES_CNT ||\n\t    nlen > UBIFS_MAX_NLEN || dent->name[nlen] != 0 ||\n\t    strnlen(dent->name, nlen) != nlen ||\n\t    le64_to_cpu(dent->inum) > MAX_INUM) {\n\t\tubifs_err(\"bad %s node\", key_type == UBIFS_DENT_KEY ?\n\t\t\t  \"directory entry\" : \"extended attribute entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (key_type != UBIFS_DENT_KEY && key_type != UBIFS_XENT_KEY) {\n\t\tubifs_err(\"bad key type %d\", key_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * is_l",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d key typ",
          "args": [
            "%d\", key_type);",
            "return -"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d %s node",
          "args": [
            ", key_type ==",
            "BIFS_DENT_KEY ?\n\t\t\t  \"directory entry\" : \"extended attribute entry\");\n\t\treturn -"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->inum)",
          "args": [
            "MAX_INUM)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">name,",
          "args": [
            "len) != nl",
            "||"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->ch.len",
          "args": [
            "!= nlen + U"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ent->nlen);",
          "args": [
            "if (le32"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, dent->key",
          "args": [
            ";",
            "int nlen"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nidate_entry(struct ubifs_info *c,\n\t\t\t const struct ubifs_dent_node *dent)\n{\n\tint key_type = key_type_flash(c, dent->key);\n\tint nlen = le16_to_cpu(dent->nlen);\n\n\tif (le32_to_cpu(dent->ch.len) != nlen + UBIFS_DENT_NODE_SZ + 1 ||\n\t    dent->type >= UBIFS_ITYPES_CNT ||\n\t    nlen > UBIFS_MAX_NLEN || dent->name[nlen] != 0 ||\n\t    strnlen(dent->name, nlen) != nlen ||\n\t    le64_to_cpu(dent->inum) > MAX_INUM) {\n\t\tubifs_err(\"bad %s node\", key_type == UBIFS_DENT_KEY ?\n\t\t\t  \"directory entry\" : \"extended attribute entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (key_type != UBIFS_DENT_KEY && key_type != UBIFS_XENT_KEY) {\n\t\tubifs_err(\"bad key type %d\", key_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/**\n * is_l"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "404-440",
    "snippet": "sert_dent(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t       union ubifs_key *key, const char *name, int nlen,\n\t\t       unsigned long long sqnum, int deletion, int *used)\n{\n\tstruct replay_entry *r;\n\tchar *nbuf;\n\n\tdbg_mntk(key, \"add LEB %d:%d, key \", lnum, offs);\n\tif (key_inum(c, key) >= c->highest_inum)\n\t\tc->highest_inum = key_inum(c, key);\n\n\tr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tnbuf = kmalloc(nlen + 1, GFP_KERNEL);\n\tif (!nbuf) {\n\t\tkfree(r);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!deletion)\n\t\t*used += ALIGN(len, 8);\n\tr->lnum = lnum;\n\tr->offs = offs;\n\tr->len = len;\n\tr->deletion = !!deletion;\n\tr->sqnum = sqnum;\n\tkey_copy(c, key, &r->key);\n\tr->nm.len = nlen;\n\tmemcpy(nbuf, name, nlen);\n\tnbuf[nlen] = '\\0';\n\tr->nm.name = nbuf;\n\n\tlist_add_tail(&r->list, &c->replay_list);\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(&r->list, &c",
          "args": [
            ">replay_",
            "st);\n\treturn 0;"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "len)",
            "nbu",
            "nlen"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &r->",
          "args": [
            "e",
            ";",
            ">nm.len"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tr-",
          "args": [
            "lnu",
            "="
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eturn",
          "args": [
            "-"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "+ 1, GF",
          "args": [
            "_KERNEL)",
            "if (!nbuf"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "replay_entry), GFP_KERNEL)",
            "if (!r)"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "ey);\n\n\tr",
          "args": [
            "=",
            "zal"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) >= c",
          "args": [
            ">",
            "ghe"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"add LE",
          "args": [
            "%d",
            "d, key \", lnum, offs)",
            "if",
            "ey_i"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nsert_dent(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t       union ubifs_key *key, const char *name, int nlen,\n\t\t       unsigned long long sqnum, int deletion, int *used)\n{\n\tstruct replay_entry *r;\n\tchar *nbuf;\n\n\tdbg_mntk(key, \"add LEB %d:%d, key \", lnum, offs);\n\tif (key_inum(c, key) >= c->highest_inum)\n\t\tc->highest_inum = key_inum(c, key);\n\n\tr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tnbuf = kmalloc(nlen + 1, GFP_KERNEL);\n\tif (!nbuf) {\n\t\tkfree(r);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!deletion)\n\t\t*used += ALIGN(len, 8);\n\tr->lnum = lnum;\n\tr->offs = offs;\n\tr->len = len;\n\tr->deletion = !!deletion;\n\tr->sqnum = sqnum;\n\tkey_copy(c, key, &r->key);\n\tr->nm.len = nlen;\n\tmemcpy(nbuf, name, nlen);\n\tnbuf[nlen] = '\\0';\n\tr->nm.name = nbuf;\n\n\tlist_add_tail(&r->list, &c->replay_list);\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "356-385",
    "snippet": "sert_node(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t       union ubifs_key *key, unsigned long long sqnum,\n\t\t       int deletion, int *used, loff_t old_size,\n\t\t       loff_t new_size)\n{\n\tstruct replay_entry *r;\n\n\tdbg_mntk(key, \"add LEB %d:%d, key \", lnum, offs);\n\n\tif (key_inum(c, key) >= c->highest_inum)\n\t\tc->highest_inum = key_inum(c, key);\n\n\tr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tif (!deletion)\n\t\t*used += ALIGN(len, 8);\n\tr->lnum = lnum;\n\tr->offs = offs;\n\tr->len = len;\n\tr->deletion = !!deletion;\n\tr->sqnum = sqnum;\n\tkey_copy(c, key, &r->key);\n\tr->old_size = old_size;\n\tr->new_size = new_size;\n\n\tlist_add_tail(&r->list, &c->replay_list);\n\treturn 0;\n}\n\n/**\n * inse",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(&r->list, &c",
          "args": [
            ">replay_",
            "st);\n\treturn 0;"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &r->",
          "args": [
            "e",
            ";",
            ">old_si"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tr-",
          "args": [
            "lnu",
            "="
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "replay_entry), GFP_KERNEL)",
            "if (!r)"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "ey);\n\n\tr",
          "args": [
            "=",
            "zal"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey) >= c",
          "args": [
            ">",
            "ghe"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"add LE",
          "args": [
            "%d",
            "d, key \", lnum, offs)",
            "if",
            "key_"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nsert_node(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t       union ubifs_key *key, unsigned long long sqnum,\n\t\t       int deletion, int *used, loff_t old_size,\n\t\t       loff_t new_size)\n{\n\tstruct replay_entry *r;\n\n\tdbg_mntk(key, \"add LEB %d:%d, key \", lnum, offs);\n\n\tif (key_inum(c, key) >= c->highest_inum)\n\t\tc->highest_inum = key_inum(c, key);\n\n\tr = kzalloc(sizeof(struct replay_entry), GFP_KERNEL);\n\tif (!r)\n\t\treturn -ENOMEM;\n\n\tif (!deletion)\n\t\t*used += ALIGN(len, 8);\n\tr->lnum = lnum;\n\tr->offs = offs;\n\tr->len = len;\n\tr->deletion = !!deletion;\n\tr->sqnum = sqnum;\n\tkey_copy(c, key, &r->key);\n\tr->old_size = old_size;\n\tr->new_size = new_size;\n\n\tlist_add_tail(&r->list, &c->replay_list);\n\treturn 0;\n}\n\n/**\n * inse"
  },
  {
    "function_name": "y_list(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "324-334",
    "snippet": "estroy_replay_list(struct ubifs_info *c)\n{\n\tstruct replay_entry *r, *tmp;\n\n\tlist_for_each_entry_safe(r, tmp, &c->replay_list, list) {\n\t\tif (is_hash_key(c, &r->key))\n\t\t\tkfree(r->nm.name);\n\t\tlist_del(&r->list);\n\t\tkfree(r);\n\t}\n}\n\n/**\n * inse",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/*",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list);",
          "args": [
            "kfree(r)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ame);",
          "args": [
            "list_del"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &r->key))",
          "args": [
            "kfree(r"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry_safe(r, tmp, &c->",
          "args": [
            "e",
            "ay_",
            "st, list) {\n\t\ti",
            "(is_"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nestroy_replay_list(struct ubifs_info *c)\n{\n\tstruct replay_entry *r, *tmp;\n\n\tlist_for_each_entry_safe(r, tmp, &c->replay_list, list) {\n\t\tif (is_hash_key(c, &r->key))\n\t\t\tkfree(r->nm.name);\n\t\tlist_del(&r->list);\n\t\tkfree(r);\n\t}\n}\n\n/**\n * inse"
  },
  {
    "function_name": "list(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "300-316",
    "snippet": "ply_replay_list(struct ubifs_info *c)\n{\n\tstruct replay_entry *r;\n\tint err;\n\n\tlist_sort(c, &c->replay_list, &replay_entries_cmp);\n\n\tlist_for_each_entry(r, &c->replay_list, list) {\n\t\tcond_resched();\n\n\t\terr = apply_replay_entry(c, r);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dest",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "entry(c, r);\n\t\tif",
          "args": [
            "e",
            ")"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\terr =",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(r, &c->repla",
          "args": [
            "_",
            "st, list) {\n\t\tc",
            "d_re"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->repla",
          "args": [
            "_",
            "st, &replay_ent",
            "es_cmp);\n\n\tlist_for"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nply_replay_list(struct ubifs_info *c)\n{\n\tstruct replay_entry *r;\n\tint err;\n\n\tlist_sort(c, &c->replay_list, &replay_entries_cmp);\n\n\tlist_for_each_entry(r, &c->replay_list, list) {\n\t\tcond_resched();\n\n\t\terr = apply_replay_entry(c, r);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dest"
  },
  {
    "function_name": "s_cmp(void *priv,",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "276-291",
    "snippet": "play_entries_cmp(void *priv, struct list_head *a,\n\t\t\t      struct list_head *b)\n{\n\tstruct replay_entry *ra, *rb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tra = list_entry(a, struct replay_entry, list);\n\trb = list_entry(b, struct replay_entry, list);\n\tubifs_assert(ra->sqnum != rb->sqnum);\n\tif (ra->sqnum > rb->sqnum)\n\t\treturn 1;\n\treturn -1;\n}\n\n/**\n * appl",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ra->sqnum !=",
          "args": [
            "rb->sqnum);\n\tif (ra->s"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct re",
          "args": [
            "l",
            "_entry list);\n\tubi",
            "_ass"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct re",
          "args": [
            "l",
            "_entry list);\n\trb",
            "list"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif (a ==",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nplay_entries_cmp(void *priv, struct list_head *a,\n\t\t\t      struct list_head *b)\n{\n\tstruct replay_entry *ra, *rb;\n\n\tcond_resched();\n\tif (a == b)\n\t\treturn 0;\n\n\tra = list_entry(a, struct replay_entry, list);\n\trb = list_entry(b, struct replay_entry, list);\n\tubifs_assert(ra->sqnum != rb->sqnum);\n\tif (ra->sqnum > rb->sqnum)\n\t\treturn 1;\n\treturn -1;\n}\n\n/**\n * appl"
  },
  {
    "function_name": "entry(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "219-264",
    "snippet": "ply_replay_entry(struct ubifs_info *c, struct replay_entry *r)\n{\n\tint err;\n\n\tdbg_mntk(&r->key, \"LEB %d:%d len %d deletion %d sqnum %llu key \",\n\t\t r->lnum, r->offs, r->len, r->deletion, r->sqnum);\n\n\t/* Set c->replay_sqnum to help deal with dangling branches. */\n\tc->replay_sqnum = r->sqnum;\n\n\tif (is_hash_key(c, &r->key)) {\n\t\tif (r->deletion)\n\t\t\terr = ubifs_tnc_remove_nm(c, &r->key, &r->nm);\n\t\telse\n\t\t\terr = ubifs_tnc_add_nm(c, &r->key, r->lnum, r->offs,\n\t\t\t\t\t       r->len, &r->nm);\n\t} else {\n\t\tif (r->deletion)\n\t\t\tswitch (key_type(c, &r->key)) {\n\t\t\tcase UBIFS_INO_KEY:\n\t\t\t{\n\t\t\t\tino_t inum = key_inum(c, &r->key);\n\n\t\t\t\terr = ubifs_tnc_remove_ino(c, inum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase UBIFS_TRUN_KEY:\n\t\t\t\terr = trun_remove_range(c, r);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = ubifs_tnc_remove(c, &r->key);\n\t\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\terr = ubifs_tnc_add(c, &r->key, r->lnum, r->offs,\n\t\t\t\t\t    r->len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (c->need_recovery)\n\t\t\terr = ubifs_recover_size_accum(c, &r->key, r->deletion,\n\t\t\t\t\t\t       r->new_size);\n\t}\n\n\treturn err;\n}\n\n/**\n * repl",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_size_accum(c, &r->key,",
          "args": [
            "-",
            "eletion",
            "}\n\n\tretur"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &r->key,",
          "args": [
            "-",
            "num, r-",
            "ffs,",
            "r-",
            "(err)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove(c, &r->key);",
          "args": [
            "break;"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ange(c, r);\n\t\t\t\tb",
          "args": [
            "e",
            ";"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_ino(c, inum);",
          "args": [
            "eak;"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->key);",
          "args": [
            "err ="
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->key))",
          "args": [
            "{",
            "case"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nm(c, &r->key,",
          "args": [
            "-",
            "num, r-",
            "ffs,",
            "m);\n\t}",
            "lse {"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_nm(c, &r->key,",
          "args": [
            "r",
            "nm);",
            "se"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", &r->key))",
          "args": [
            "{",
            "if (r-"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key, \"LE",
          "args": [
            "%d:%d",
            "n %d deletion %d sqnum %llu key \",\n\t\t r->lnum,",
            "ffs, r-",
            "en, r->",
            "letion",
            "r->sqnum);",
            "/* Set c"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nply_replay_entry(struct ubifs_info *c, struct replay_entry *r)\n{\n\tint err;\n\n\tdbg_mntk(&r->key, \"LEB %d:%d len %d deletion %d sqnum %llu key \",\n\t\t r->lnum, r->offs, r->len, r->deletion, r->sqnum);\n\n\t/* Set c->replay_sqnum to help deal with dangling branches. */\n\tc->replay_sqnum = r->sqnum;\n\n\tif (is_hash_key(c, &r->key)) {\n\t\tif (r->deletion)\n\t\t\terr = ubifs_tnc_remove_nm(c, &r->key, &r->nm);\n\t\telse\n\t\t\terr = ubifs_tnc_add_nm(c, &r->key, r->lnum, r->offs,\n\t\t\t\t\t       r->len, &r->nm);\n\t} else {\n\t\tif (r->deletion)\n\t\t\tswitch (key_type(c, &r->key)) {\n\t\t\tcase UBIFS_INO_KEY:\n\t\t\t{\n\t\t\t\tino_t inum = key_inum(c, &r->key);\n\n\t\t\t\terr = ubifs_tnc_remove_ino(c, inum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase UBIFS_TRUN_KEY:\n\t\t\t\terr = trun_remove_range(c, r);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = ubifs_tnc_remove(c, &r->key);\n\t\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\terr = ubifs_tnc_add(c, &r->key, r->lnum, r->offs,\n\t\t\t\t\t    r->len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (c->need_recovery)\n\t\t\terr = ubifs_recover_size_accum(c, &r->key, r->deletion,\n\t\t\t\t\t\t       r->new_size);\n\t}\n\n\treturn err;\n}\n\n/**\n * repl"
  },
  {
    "function_name": "ange(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "190-210",
    "snippet": "un_remove_range(struct ubifs_info *c, struct replay_entry *r)\n{\n\tunsigned min_blk, max_blk;\n\tunion ubifs_key min_key, max_key;\n\tino_t ino;\n\n\tmin_blk = r->new_size / UBIFS_BLOCK_SIZE;\n\tif (r->new_size & (UBIFS_BLOCK_SIZE - 1))\n\t\tmin_blk += 1;\n\n\tmax_blk = r->old_size / UBIFS_BLOCK_SIZE;\n\tif ((r->old_size & (UBIFS_BLOCK_SIZE - 1)) == 0)\n\t\tmax_blk -= 1;\n\n\tino = key_inum(c, &r->key);\n\n\tdata_key_init(c, &min_key, ino, min_blk);\n\tdata_key_init(c, &max_key, ino, max_blk);\n\n\treturn ubifs_tnc_remove_range(c, &min_key, &max_key);\n}\n\n/**\n * appl",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ove_range(c, &min_key,",
          "args": [
            "&",
            "x_key);",
            "/**\n *"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &max_key,",
          "args": [
            "i",
            ", max_bl",
            ";",
            "eturn u"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &min_key,",
          "args": [
            "i",
            ", min_bl",
            ";",
            "ta_key_"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->key);",
          "args": [
            "ata_key"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nun_remove_range(struct ubifs_info *c, struct replay_entry *r)\n{\n\tunsigned min_blk, max_blk;\n\tunion ubifs_key min_key, max_key;\n\tino_t ino;\n\n\tmin_blk = r->new_size / UBIFS_BLOCK_SIZE;\n\tif (r->new_size & (UBIFS_BLOCK_SIZE - 1))\n\t\tmin_blk += 1;\n\n\tmax_blk = r->old_size / UBIFS_BLOCK_SIZE;\n\tif ((r->old_size & (UBIFS_BLOCK_SIZE - 1)) == 0)\n\t\tmax_blk -= 1;\n\n\tino = key_inum(c, &r->key);\n\n\tdata_key_init(c, &min_key, ino, min_blk);\n\tdata_key_init(c, &max_key, ino, max_blk);\n\n\treturn ubifs_tnc_remove_range(c, &min_key, &max_key);\n}\n\n/**\n * appl"
  },
  {
    "function_name": "ps(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "171-183",
    "snippet": "t_buds_lprops(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\tint err;\n\n\tlist_for_each_entry(b, &c->replay_buds, list) {\n\t\terr = set_bud_lprops(c, b);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n/**\n * trun",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s(c, b);\n\t\tif",
          "args": [
            "e",
            ")"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(b, &c->repla",
          "args": [
            "_",
            "ds, list) {\n\t\te",
            "= s"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nt_buds_lprops(struct ubifs_info *c)\n{\n\tstruct bud_entry *b;\n\tint err;\n\n\tlist_for_each_entry(b, &c->replay_buds, list) {\n\t\terr = set_bud_lprops(c, b);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n/**\n * trun"
  },
  {
    "function_name": "s(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/replay.c",
    "lines": "97-162",
    "snippet": "t_bud_lprops(struct ubifs_info *c, struct bud_entry *b)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err = 0, dirty;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, b->bud->lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tdirty = lp->dirty;\n\tif (b->bud->start == 0 && (lp->free != c->leb_size || lp->dirty != 0)) {\n\t\t/*\n\t\t * The LEB was added to the journal with a starting offset of\n\t\t * zero which means the LEB must have been empty. The LEB\n\t\t * property values should be @lp->free == @c->leb_size and\n\t\t * @lp->dirty == 0, but that is not the case. The reason is that\n\t\t * the LEB had been garbage collected before it became the bud,\n\t\t * and there was not commit inbetween. The garbage collector\n\t\t * resets the free and dirty space without recording it\n\t\t * anywhere except lprops, so if there was no commit then\n\t\t * lprops does not have that information.\n\t\t *\n\t\t * We do not need to adjust free space because the scan has told\n\t\t * us the exact value which is recorded in the replay entry as\n\t\t * @b->free.\n\t\t *\n\t\t * However we do need to subtract from the dirty space the\n\t\t * amount of space that the garbage collector reclaimed, which\n\t\t * is the whole LEB minus the amount of space that was free.\n\t\t */\n\t\tdbg_mnt(\"bud LEB %d was GC'd (%d free, %d dirty)\", b->bud->lnum,\n\t\t\tlp->free, lp->dirty);\n\t\tdbg_gc(\"bud LEB %d was GC'd (%d free, %d dirty)\", b->bud->lnum,\n\t\t\tlp->free, lp->dirty);\n\t\tdirty -= c->leb_size - lp->free;\n\t\t/*\n\t\t * If the replay order was perfect the dirty space would now be\n\t\t * zero. The order is not perfect because the journal heads\n\t\t * race with each other. This is not a problem but is does mean\n\t\t * that the dirty space may temporarily exceed c->leb_size\n\t\t * during the replay.\n\t\t */\n\t\tif (dirty != 0)\n\t\t\tdbg_mnt(\"LEB %d lp: %d free %d dirty replay: %d free %d dirty\",\n\t\t\t\tb->bud->lnum, lp->free, lp->dirty, b->free,\n\t\t\t\tb->dirty);\n\t}\n\tlp = ubifs_change_lp(c, lp, b->free, dirty + b->dirty,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\t/* Make sure the journal head points to the latest bud */\n\terr = ubifs_wbuf_seek_nolock(&c->jheads[b->bud->jhead].wbuf,\n\t\t\t\t     b->bud->lnum, c->leb_size - b->free);\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * set_",
    "includes": [
      "ux/list_sort.h>\n\n/**\n * struc",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ek_nolock(&c->jheads[b",
          "args": [
            ">bud->jhead].wbuf,\n\t\t\t\t     b-",
            "c->leb_size",
            "b->free);\n\nout:\n\tubi"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "="
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lp(c, lp, b->fr",
          "args": [
            "e",
            "di",
            "y + b->",
            "rty,\n\t\t\t     lp-",
            "PROPS_TAKEN, 0);\n\tif (IS",
            "R"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d lp:",
          "args": [
            "d free %d dirty replay: %d free %d dirty\",\n\t\t\t\tb->bud-",
            "lp->free, l",
            ">dirty,",
            ">free,",
            "b->dirt",
            "lp = u"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EB %d",
          "args": [
            "as GC'd (%d free, %d dirty)\", b->bud->lnu",
            "lp->free",
            ">dirty);",
            "dirty -="
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %d",
          "args": [
            "as GC'd (%d free, %d dirty)\", b->bud->lnu",
            "lp->free",
            ">dirty);",
            "dbg_gc(\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, b->bud->l",
          "args": [
            "u",
            ";\n\tif (IS_ER"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\tlp = u",
          "args": [
            "i"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/list_sort.h>\n\n/**\n * struc\nfs.h\"\n#include <lin\n\nt_bud_lprops(struct ubifs_info *c, struct bud_entry *b)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err = 0, dirty;\n\n\tubifs_get_lprops(c);\n\n\tlp = ubifs_lpt_lookup_dirty(c, b->bud->lnum);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tdirty = lp->dirty;\n\tif (b->bud->start == 0 && (lp->free != c->leb_size || lp->dirty != 0)) {\n\t\t/*\n\t\t * The LEB was added to the journal with a starting offset of\n\t\t * zero which means the LEB must have been empty. The LEB\n\t\t * property values should be @lp->free == @c->leb_size and\n\t\t * @lp->dirty == 0, but that is not the case. The reason is that\n\t\t * the LEB had been garbage collected before it became the bud,\n\t\t * and there was not commit inbetween. The garbage collector\n\t\t * resets the free and dirty space without recording it\n\t\t * anywhere except lprops, so if there was no commit then\n\t\t * lprops does not have that information.\n\t\t *\n\t\t * We do not need to adjust free space because the scan has told\n\t\t * us the exact value which is recorded in the replay entry as\n\t\t * @b->free.\n\t\t *\n\t\t * However we do need to subtract from the dirty space the\n\t\t * amount of space that the garbage collector reclaimed, which\n\t\t * is the whole LEB minus the amount of space that was free.\n\t\t */\n\t\tdbg_mnt(\"bud LEB %d was GC'd (%d free, %d dirty)\", b->bud->lnum,\n\t\t\tlp->free, lp->dirty);\n\t\tdbg_gc(\"bud LEB %d was GC'd (%d free, %d dirty)\", b->bud->lnum,\n\t\t\tlp->free, lp->dirty);\n\t\tdirty -= c->leb_size - lp->free;\n\t\t/*\n\t\t * If the replay order was perfect the dirty space would now be\n\t\t * zero. The order is not perfect because the journal heads\n\t\t * race with each other. This is not a problem but is does mean\n\t\t * that the dirty space may temporarily exceed c->leb_size\n\t\t * during the replay.\n\t\t */\n\t\tif (dirty != 0)\n\t\t\tdbg_mnt(\"LEB %d lp: %d free %d dirty replay: %d free %d dirty\",\n\t\t\t\tb->bud->lnum, lp->free, lp->dirty, b->free,\n\t\t\t\tb->dirty);\n\t}\n\tlp = ubifs_change_lp(c, lp, b->free, dirty + b->dirty,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\t/* Make sure the journal head points to the latest bud */\n\terr = ubifs_wbuf_seek_nolock(&c->jheads[b->bud->jhead].wbuf,\n\t\t\t\t     b->bud->lnum, c->leb_size - b->free);\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * set_"
  }
]